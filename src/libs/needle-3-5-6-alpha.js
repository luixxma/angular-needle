var tz = Object.defineProperty, iz = (i, e, t) => e in i ? tz(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, u = (i, e, t) => (iz(i, typeof e != "symbol" ? e + "" : e, t), t); const Dv = () => i => i; function sz(i) { return Dv()(i) } function rz() { return !!oe("debug") } class To { constructor(e, t) { u(this, "_factory"), u(this, "_cache", []), u(this, "_maxSize"), u(this, "_index", 0), this._factory = e, this._maxSize = t } get() { const e = this._index % this._maxSize; return this._index++, this._cache.length <= e && (this._cache[e] = this._factory()), this._cache[e] } } let V_ = !1; const W_ = []; setTimeout(() => { V_ && console.log(W_.sort()) }, 100); function sf() { return new URLSearchParams(window.location.search) } function oe(i) { V_ && !W_.includes(i) && W_.push(i); const e = sf(); if (e.has(i)) { const t = e.get(i); if (t) { const s = Number(t); return isNaN(s) ? t : s } else return !0 } return !1 } V_ = oe("help") === !0; function nz(i, e) { const t = sf(); t.has(i) ? t.set(i, e) : t.append(i, e), document.location.search = t.toString() } function BI(i, e, t = !0) { const s = sf(); s.has(i) ? e === null ? s.delete(i) : s.set(i, e) : e !== null && s.append(i, e), t ? kI(i, s) : q_(i, s) } function rf(i, e, t) { i.has(e) ? i.set(e, t.toString()) : i.append(e, t.toString()) } function kI(i, e, t) { window.history.pushState(t, i, "?" + e.toString()) } function q_(i, e, t) { window.history.replaceState(t, i, "?" + e.toString()) } function oz(i) { for (var e = "", t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", s = t.length, r = 0; r < i; r++)e += t.charAt(Math.floor(Math.random() * s)); return e } function DI(i, e) { return Math.floor(Math.random() * (e - i + 1)) + i } const OI = ["smol", "tiny", "giant", "interesting", "smart", "bright", "dull", "extreme", "beautiful", "pretty", "dark", "epic", "salty", "silly", "funny", "lame", "lazy", "loud", "lucky", "mad", "mean", "mighty", "mysterious", "nasty", "odd", "old", "powerful", "quiet", "rapid", "scary", "shiny", "shy", "silly", "smooth", "sour", "spicy", "stupid", "sweet", "tasty", "terrible", "ugly", "unusual", "vast", "wet", "wild", "witty", "wrong", "zany", "zealous", "zippy", "zombie", "zorro"], LI = ["cat", "dog", "mouse", "pig", "cow", "horse", "sheep", "chicken", "duck", "goat", "panda", "tiger", "lion", "elephant", "monkey", "bird", "fish", "snake", "frog", "turtle", "hamster", "penguin", "kangaroo", "whale", "dolphin", "crocodile", "snail", "ant", "bee", "beetle", "butterfly", "dragon", "eagle", "fish", "giraffe", "lizard", "panda", "penguin", "rabbit", "snake", "spider", "tiger", "zebra"]; function FI() { const i = OI[Math.floor(Math.random() * OI.length)], e = LI[Math.floor(Math.random() * LI.length)]; return i + "_" + e } function UI(i) { return i = i.replace(/[^a-z0-9áéíóúñü \.,_-]/gim, ""), i.trim() } function Cu(i, e, t = !0, s = !1) { var r; if (e == null) return null; if (e.userData && e.userData.guid === i || e.guid == i) return e; if (s && (r = e.userData) != null && r.components) { for (const n of e.userData.components) if (n.guid === i) return n } if (t) { if (e.scenes) for (const n in e.scenes) { const o = e.scenes[n], a = Cu(i, o, t, s); if (a) return a } if (e.children) for (const n in e.children) { const o = e.children[n], a = Cu(i, o, t, s); if (a) return a } } } function Ov(i, e) { if (i != null && typeof i == "object") { let t; Array.isArray(i) ? t = [] : (t = Object.create(i), Object.assign(t, i)); for (const s of Object.keys(i)) { const r = i[s]; e && !e(i, s, r) ? t[s] = r : r?.clone !== void 0 && typeof r.clone == "function" ? t[s] = r.clone() : t[s] = Ov(r, e) } return t } return i } function nf(i) { return new Promise((e, t) => { setTimeout(e, i) }) } const Lv = oe("debugresolveurl"), NI = "rel:"; function az(i, e) { return Pl(i, e) } function Pl(i, e) {
  if (e === void 0) return Lv && console.warn("getPath: uri is undefined, returning uri", e), e; if (e.startsWith("./")) return e; if (e.startsWith("http")) return Lv && console.warn("getPath: uri is absolute, returning uri", e), e; if (i === void 0) return Lv && console.warn("getPath: source is undefined, returning uri", e), e; e.startsWith(NI) && (e = e.substring(4)); const t = i.lastIndexOf("/"); if (t >= 0) {
    const s = i.substring(0, t + 1); let r = s + e; return Lv && console.log("source:", i, `- changed uri 
from`, e, `
\u2192 `, r, `
`+ s), r
  } return e
} class lz { constructor(e, t) { u(this, "writeCallbacks", []), u(this, "_applied", !1), u(this, "_object"), u(this, "_prop"), u(this, "_wrapperProp"), this._object = e, this._prop = t, this._wrapperProp = Symbol("$" + t), this.apply() } subscribeWrite(e) { this.writeCallbacks.push(e) } apply() { if (this._applied || !this._object) return; const e = this._object, t = this._prop; if (e[t] === void 0) return; this._applied = !0, e[this._wrapperProp] !== void 0 && console.warn("Watcher is being applied to an object that already has a wrapper property. This is not (yet) supported"); const s = e[t]; e[this._wrapperProp] = s, Object.defineProperty(e, t, { get: () => e[this._wrapperProp], set: r => { e[this._wrapperProp] = r; for (const n of this.writeCallbacks) n(r, this._prop) } }) } revoke() { if (!this._applied || !this._object) return; this._applied = !1; const e = this._object, t = this._prop; Reflect.deleteProperty(e, t); const s = e[this._wrapperProp]; e[t] = s, Reflect.deleteProperty(e, this._wrapperProp) } dispose() { this.revoke(), this.writeCallbacks.length = 0, this._object = null } } class qp { constructor(e, t) { if (u(this, "_watches", []), Array.isArray(t)) for (const s of t) this._watches.push(new qp(e, s)); else this._watches.push(new lz(e, t)) } subscribeWrite(e) { for (const t of this._watches) t.subscribeWrite(e) } apply() { for (const e of this._watches) e.apply() } revoke() { for (const e of this._watches) e.revoke() } dispose() { for (const e of this._watches) e.dispose(); this._watches.length = 0 } } function Su() { return typeof window.orientation < "u" || navigator.userAgent.indexOf("IEMobile") !== -1 } function X_() { return /WebXRViewer\//i.test(navigator.userAgent) } const cz = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"]; function of() { return cz.includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document } function Sa() { return /^((?!chrome|android).)*safari/i.test(navigator.userAgent) } function hz() { return navigator.userAgent.includes("OculusBrowser") } const uz = /ip=(?<ip>.+?)\n/s; async function dz() { const i = await (await fetch("https://www.cloudflare.com/cdn-cgi/trace")).text(), e = uz.exec(i); return e ? e[1] : null } async function pz() { return (await (await fetch("https://api.db-ip.com/v2/free/self")).json()).ipAddress } async function fz() { return await (await fetch("https://api.db-ip.com/v2/free/self").catch(() => null)).json() } const Y_ = new Map; function dr(i = window.location.hostname) { if (Y_.has(i)) return Y_.get(i); const e = new RegExp("[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}|localhost", "gm").test(i); return Y_.set(i, e), e === !0 } function zI() { return window.location.hostname.includes("glitch.me") } var Jr = (i => (i.ContextRegistered = "ContextRegistered", i.ContextCreationStart = "ContextCreationStart", i.ContextCreated = "ContextCreated", i.ContextDestroyed = "ContextDestroyed", i.MissingCamera = "MissingCamera", i))(Jr || {}); class Zi { static get Current() { return globalThis["NeedleEngine.Context.Current"] } static set Current(e) { globalThis["NeedleEngine.Context.Current"] = e } static register(e) { this.Registered.push(e), this.dispatchCallback("ContextRegistered", e) } static unregister(e) { const t = this.Registered.indexOf(e); t !== -1 && this.Registered.splice(t, 1) } static registerCallback(e, t) { this._callbacks[e] || (this._callbacks[e] = []), this._callbacks[e].push(t) } static unregisterCallback(e, t) { if (!this._callbacks[e]) return; const s = this._callbacks[e].indexOf(t); s !== -1 && this._callbacks[e].splice(s, 1) } static dispatchCallback(e, t) { if (!this._callbacks[e]) return !0; const s = { event: e, context: t }, r = new Array; return this._callbacks[e].forEach(n => { const o = n(s); o instanceof Promise && r.push(o) }), Promise.all(r) } static addContextCreatedCallback(e) { this.registerCallback("ContextCreated", e) } static addContextDestroyedCallback(e) { this.registerCallback("ContextDestroyed", e) } } u(Zi, "Registered", []), u(Zi, "_callbacks", {}); const jI = oe("debugdebug"), QI = oe("noerrors"), gz = "ar", J_ = new Map; var Ro = (i => (i[i.Log = 0] = "Log", i[i.Warn = 1] = "Warn", i[i.Error = 2] = "Error", i))(Ro || {}); function GI() { return HI } function mz() { if (QI) return; const i = dr(); if (jI && console.log("Is this a local network?", i), i) { jI && console.log(window.location.hostname); const e = console.error; console.error = (...t) => { e.apply(console, t), vz(t), Ea(2, t), K_() }, window.addEventListener("error", t => { if (!t) return; let s = t.error; if (s === void 0) { dr() && console.warn("Received unknown error", t, t.target); return } Ea(2, s, t.filename, t.lineno), K_() }, !0), window.addEventListener("unhandledrejection", t => { t && (t.reason ? Ea(2, t.reason.message, t.reason.stack) : Ea(2, "unhandled rejection"), K_()) }) } } let HI = 0; function K_() { HI += 1 } function vz(i) { if (Array.isArray(i)) for (let e = 0; e < i.length; e++) { const t = i[e]; typeof t == "string" && t.startsWith("THREE.PropertyBinding: Trying to update node for track:") && (i[e] = "Some animated objects couldn't be found: see console for details") } } function Ea(i, e, t, s) { if (QI) return; const r = Zi.Current, n = r?.domElement ?? document.querySelector("needle-engine"); if (n) { if (Array.isArray(e)) { let o = ""; for (let a = 0; a < e.length; a++)typeof e[a] != "object" && (a > 0 && (o += " "), o += e[a]); e = o } Az(i, n, e) } } const Z_ = new Set; function Az(i, e, t) { const s = bz(e); if (s.childElementCount >= 20) { const n = s.lastElementChild; WI(n) } if (t.length > 300 && (t = t.substring(0, 300) + "..."), Z_.has(t)) return; Z_.add(t); const r = _z(i, t); s.prepend(r), setTimeout(() => { Z_.delete(t), WI(r) }, 1e4) } const yz = `

@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

div[data-needle_engine_debug_overlay] {
    font-family: 'Roboto', sans-serif;
    font-weight: 400;
}

div[data-needle_engine_debug_overlay] strong {
    font-weight: 700;
}

div[data-needle_engine_debug_overlay] a {
    color: white;
    text-decoration: none;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

div[data-needle_engine_debug_overlay] a:hover {
    text-decoration: none;
    border: none;
}

div[data-needle_engine_debug_overlay] .log strong {
    color: rgba(200,200,200,.9);
}

div[data-needle_engine_debug_overlay] .warn strong {
    color: rgba(255,255,230, 1);
}

div[data-needle_engine_debug_overlay] .error strong {
    color: rgba(255,100,120, 1);
}
`; function bz(i) { if (J_.has(i)) return J_.get(i); { const e = document.createElement("div"); e.setAttribute("data-needle_engine_debug_overlay", ""), e.classList.add(gz), e.classList.add("desktop"), e.classList.add("debug-container"), e.style.position = "absolute", e.style.top = "0", e.style.right = "5px", e.style.paddingTop = "0px", e.style.maxWidth = "70%", e.style.maxHeight = "calc(100% - 5px)", e.style.zIndex = "1000", e.style.pointerEvents = "scroll", e.style.display = "flex", e.style.alignItems = "end", e.style.flexDirection = "column", e.style.color = "white", e.style.overflow = "auto", i.appendChild(e), J_.set(i, e); const t = document.createElement("style"); return t.innerHTML = yz, e.appendChild(t), e } } const VI = Symbol("logtype"), Fv = new Map; function WI(i) { i.remove(); const e = i[VI], t = Fv.get(e) ?? []; t.push(i), Fv.set(e, t) } function _z(i, e) { if (Fv.has(i)) { const s = Fv.get(i); if (s.length > 0) { const r = s.pop(); return r.innerHTML = e, r } } const t = document.createElement("div"); switch (t.setAttribute("data-id", "__needle_engine_debug_overlay"), t.style.marginRight = "5px", t.style.padding = ".5em", t.style.backgroundColor = "rgba(0,0,0,.9)", t.style.marginTop = "5px", t.style.marginBottom = "3px", t.style.borderRadius = "8px", t.style.pointerEvents = "all", t.style.userSelect = "text", t.style.maxWidth = "250px", t.style.whiteSpace = "pre-wrap", t.style["backdrop-filter"] = "blur(10px)", t.style.backgroundColor = "rgba(20,20,20,.8)", t.style.boxShadow = "inset 0 0 80px rgba(0,0,0,.2), 0 0 5px rgba(0,0,0,.2)", t.style.border = "1px solid rgba(160,160,160,.2)", t[VI] = i, i) { case 0: t.classList.add("log"), t.style.color = "rgba(200,200,200,.7)", t.style.backgroundColor = "rgba(40,40,40,.7)"; break; case 1: t.classList.add("warn"), t.style.color = "rgb(255, 255, 150)", t.style.backgroundColor = "rgba(50,50,20,.8)"; break; case 2: t.classList.add("error"), t.style.color = "rgb(255, 50, 50", t.style.backgroundColor = "rgba(50,20,20,.8)"; break }return t.title = "Open the browser console (F12) for more information", t.innerHTML = e, t } const $_ = null, qI = { version: null }.generator, Ma = "needle_isActiveInHierarchy", eh = "builtin_components", af = "needle_editor_guid";/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const th = "147dev", ih = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, sh = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, XI = 0, ex = 1, YI = 2, xz = 3, wz = 0, tx = 1, ix = 2, Eu = 3, pr = 0, fs = 1, yi = 2, Ri = 0, Ia = 1, rh = 2, sx = 3, rx = 4, JI = 5, nh = 100, KI = 101, ZI = 102, nx = 103, ox = 104, $I = 200, eT = 201, tT = 202, iT = 203, ax = 204, lx = 205, sT = 206, rT = 207, nT = 208, oT = 209, aT = 210, cx = 0, Uv = 1, lf = 2, Mu = 3, Iu = 4, Nv = 5, zv = 6, cf = 7, hf = 0, lT = 1, cT = 2, fr = 0, uf = 1, hx = 2, hT = 3, ux = 4, uT = 5, jv = 300, Bl = 301, kl = 302, An = 303, Tu = 304, Ru = 306, yn = 1e3, Ss = 1001, Ta = 1002, Zt = 1003, Pu = 1004, Cz = 1004, Bu = 1005, Sz = 1005, Qt = 1006, df = 1007, Ez = 1007, eo = 1008, Mz = 1008, ui = 1009, dT = 1010, pT = 1011, dx = 1012, fT = 1013, Ra = 1014, $i = 1015, gs = 1016, gT = 1017, mT = 1018, Dl = 1020, vT = 1021, AT = 1022, _i = 1023, Qv = 1024, yT = 1025, Ol = 1026, Ll = 1027, Fl = 1028, bT = 1029, oh = 1030, _T = 1031, xT = 1033, pf = 33776, Gv = 33777, Hv = 33778, ff = 33779, Vv = 35840, px = 35841, Wv = 35842, fx = 35843, gx = 36196, qv = 37492, Xv = 37496, Yv = 37808, mx = 37809, vx = 37810, Ax = 37811, yx = 37812, bx = 37813, _x = 37814, xx = 37815, wx = 37816, Cx = 37817, Sx = 37818, Ex = 37819, Mx = 37820, Ix = 37821, Jv = 36492, gf = 2200, Tx = 2201, wT = 2202, ah = 2300, Pa = 2301, Kv = 2302, lh = 2400, ch = 2401, mf = 2402, Zv = 2500, Rx = 2501, Iz = 0, CT = 1, Px = 2, Qi = 3e3, Xe = 3001, Os = 3200, $v = 3201, Ul = 0, ST = 1, Tz = "", to = "srgb", vf = "srgb-linear", ET = 0, Af = 7680, MT = 7681, IT = 7682, TT = 7683, RT = 34055, PT = 34056, BT = 5386, kT = 512, DT = 513, OT = 514, LT = 515, FT = 516, UT = 517, NT = 518, Bx = 519, yf = 35044, Ks = 35048, Rz = 35040, Pz = 35045, Bz = 35049, kz = 35041, Dz = 35046, Oz = 35050, Lz = 35042, Fz = "100", kx = "300 es", eA = 1035; class ms { addEventListener(e, t) { this._listeners === void 0 && (this._listeners = {}); const s = this._listeners; s[e] === void 0 && (s[e] = []), s[e].indexOf(t) === -1 && s[e].push(t) } hasEventListener(e, t) { if (this._listeners === void 0) return !1; const s = this._listeners; return s[e] !== void 0 && s[e].indexOf(t) !== -1 } removeEventListener(e, t) { if (this._listeners === void 0) return; const s = this._listeners[e]; if (s !== void 0) { const r = s.indexOf(t); r !== -1 && s.splice(r, 1) } } dispatchEvent(e) { if (this._listeners === void 0) return; const t = this._listeners[e.type]; if (t !== void 0) { e.target = this; const s = t.slice(0); for (let r = 0, n = s.length; r < n; r++)s[r].call(this, e); e.target = null } } } const Zs = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let zT = 1234567; const hh = Math.PI / 180, ku = 180 / Math.PI; function Kr() { const i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0; return (Zs[i & 255] + Zs[i >> 8 & 255] + Zs[i >> 16 & 255] + Zs[i >> 24 & 255] + "-" + Zs[e & 255] + Zs[e >> 8 & 255] + "-" + Zs[e >> 16 & 15 | 64] + Zs[e >> 24 & 255] + "-" + Zs[t & 63 | 128] + Zs[t >> 8 & 255] + "-" + Zs[t >> 16 & 255] + Zs[t >> 24 & 255] + Zs[s & 255] + Zs[s >> 8 & 255] + Zs[s >> 16 & 255] + Zs[s >> 24 & 255]).toLowerCase() } function Gi(i, e, t) { return Math.max(e, Math.min(t, i)) } function Dx(i, e) { return (i % e + e) % e } function Uz(i, e, t, s, r) { return s + (i - e) * (r - s) / (t - e) } function Nz(i, e, t) { return i !== e ? (t - i) / (e - i) : 0 } function bf(i, e, t) { return (1 - t) * i + t * e } function zz(i, e, t, s) { return bf(i, e, 1 - Math.exp(-t * s)) } function jz(i, e = 1) { return e - Math.abs(Dx(i, e * 2) - e) } function Qz(i, e, t) { return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * (3 - 2 * i)) } function Gz(i, e, t) { return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * i * (i * (i * 6 - 15) + 10)) } function Hz(i, e) { return i + Math.floor(Math.random() * (e - i + 1)) } function Vz(i, e) { return i + Math.random() * (e - i) } function Wz(i) { return i * (.5 - Math.random()) } function qz(i) { i !== void 0 && (zT = i); let e = zT += 1831565813; return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296 } function Xz(i) { return i * hh } function Yz(i) { return i * ku } function Ox(i) { return (i & i - 1) === 0 && i !== 0 } function jT(i) { return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2)) } function tA(i) { return Math.pow(2, Math.floor(Math.log(i) / Math.LN2)) } function Jz(i, e, t, s, r) { const n = Math.cos, o = Math.sin, a = n(t / 2), l = o(t / 2), c = n((e + s) / 2), h = o((e + s) / 2), d = n((e - s) / 2), p = o((e - s) / 2), f = n((s - e) / 2), g = o((s - e) / 2); switch (r) { case "XYX": i.set(a * h, l * d, l * p, a * c); break; case "YZY": i.set(l * p, a * h, l * d, a * c); break; case "ZXZ": i.set(l * d, l * p, a * h, a * c); break; case "XZX": i.set(a * h, l * g, l * f, a * c); break; case "YXY": i.set(l * f, a * h, l * g, a * c); break; case "ZYZ": i.set(l * g, l * f, a * h, a * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } function Ba(i, e) { switch (e.constructor) { case Float32Array: return i; case Uint16Array: return i / 65535; case Uint8Array: return i / 255; case Int16Array: return Math.max(i / 32767, -1); case Int8Array: return Math.max(i / 127, -1); default: throw new Error("Invalid component type.") } } function gi(i, e) { switch (e.constructor) { case Float32Array: return i; case Uint16Array: return Math.round(i * 65535); case Uint8Array: return Math.round(i * 255); case Int16Array: return Math.round(i * 32767); case Int8Array: return Math.round(i * 127); default: throw new Error("Invalid component type.") } } var kr = Object.freeze({ __proto__: null, DEG2RAD: hh, RAD2DEG: ku, generateUUID: Kr, clamp: Gi, euclideanModulo: Dx, mapLinear: Uz, inverseLerp: Nz, lerp: bf, damp: zz, pingpong: jz, smoothstep: Qz, smootherstep: Gz, randInt: Hz, randFloat: Vz, randFloatSpread: Wz, seededRandom: qz, degToRad: Xz, radToDeg: Yz, isPowerOfTwo: Ox, ceilPowerOfTwo: jT, floorPowerOfTwo: tA, setQuaternionFromProperEuler: Jz, normalize: gi, denormalize: Ba }); class W { constructor(e = 0, t = 0) { W.prototype.isVector2 = !0, this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, s = this.y, r = e.elements; return this.x = r[0] * t + r[3] * s + r[6], this.y = r[1] * t + r[4] * s + r[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const s = this.length(); return this.divideScalar(s || 1).multiplyScalar(Math.max(e, Math.min(t, s))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, s = this.y - e.y; return t * t + s * s } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, s) { return this.x = e.x + (t.x - e.x) * s, this.y = e.y + (t.y - e.y) * s, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const s = Math.cos(t), r = Math.sin(t), n = this.x - e.x, o = this.y - e.y; return this.x = n * s - o * r + e.x, this.y = n * r + o * s + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class ds { constructor() { ds.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1] } set(e, t, s, r, n, o, a, l, c) { const h = this.elements; return h[0] = e, h[1] = r, h[2] = a, h[3] = t, h[4] = n, h[5] = l, h[6] = s, h[7] = o, h[8] = c, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, s = e.elements; return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], t[5] = s[5], t[6] = s[6], t[7] = s[7], t[8] = s[8], this } extractBasis(e, t, s) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), s.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const s = e.elements, r = t.elements, n = this.elements, o = s[0], a = s[3], l = s[6], c = s[1], h = s[4], d = s[7], p = s[2], f = s[5], g = s[8], m = r[0], v = r[3], A = r[6], b = r[1], y = r[4], _ = r[7], w = r[2], E = r[5], P = r[8]; return n[0] = o * m + a * b + l * w, n[3] = o * v + a * y + l * E, n[6] = o * A + a * _ + l * P, n[1] = c * m + h * b + d * w, n[4] = c * v + h * y + d * E, n[7] = c * A + h * _ + d * P, n[2] = p * m + f * b + g * w, n[5] = p * v + f * y + g * E, n[8] = p * A + f * _ + g * P, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], s = e[1], r = e[2], n = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8]; return t * o * h - t * a * c - s * n * h + s * a * l + r * n * c - r * o * l } invert() { const e = this.elements, t = e[0], s = e[1], r = e[2], n = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8], d = h * o - a * c, p = a * l - h * n, f = c * n - o * l, g = t * d + s * p + r * f; if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const m = 1 / g; return e[0] = d * m, e[1] = (r * c - h * s) * m, e[2] = (a * s - r * o) * m, e[3] = p * m, e[4] = (h * t - r * l) * m, e[5] = (r * n - a * t) * m, e[6] = f * m, e[7] = (s * l - c * t) * m, e[8] = (o * t - s * n) * m, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, s, r, n, o, a) { const l = Math.cos(n), c = Math.sin(n); return this.set(s * l, s * c, -s * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + t, 0, 0, 1), this } scale(e, t) { return this.premultiply(Lx.makeScale(e, t)), this } rotate(e) { return this.premultiply(Lx.makeRotation(-e)), this } translate(e, t) { return this.premultiply(Lx.makeTranslation(e, t)), this } makeTranslation(e, t) { return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this } makeRotation(e) { const t = Math.cos(e), s = Math.sin(e); return this.set(t, -s, 0, s, t, 0, 0, 0, 1), this } makeScale(e, t) { return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this } equals(e) { const t = this.elements, s = e.elements; for (let r = 0; r < 9; r++)if (t[r] !== s[r]) return !1; return !0 } fromArray(e, t = 0) { for (let s = 0; s < 9; s++)this.elements[s] = e[s + t]; return this } toArray(e = [], t = 0) { const s = this.elements; return e[t] = s[0], e[t + 1] = s[1], e[t + 2] = s[2], e[t + 3] = s[3], e[t + 4] = s[4], e[t + 5] = s[5], e[t + 6] = s[6], e[t + 7] = s[7], e[t + 8] = s[8], e } clone() { return new this.constructor().fromArray(this.elements) } } const Lx = new ds; function QT(i) { for (let e = i.length - 1; e >= 0; --e)if (i[e] >= 65535) return !0; return !1 } const Kz = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function Du(i, e) { return new Kz[i](e) } function _f(i) { return document.createElementNS("http://www.w3.org/1999/xhtml", i) } function uh(i) { return i < .04045 ? i * .0773993808 : Math.pow(i * .9478672986 + .0521327014, 2.4) } function iA(i) { return i < .0031308 ? i * 12.92 : 1.055 * Math.pow(i, .41666) - .055 } const Fx = { [to]: { [vf]: uh }, [vf]: { [to]: iA } }, $s = { legacyMode: !0, get workingColorSpace() { return vf }, set workingColorSpace(i) { console.warn("THREE.ColorManagement: .workingColorSpace is readonly.") }, convert: function (i, e, t) { if (this.legacyMode || e === t || !e || !t) return i; if (Fx[e] && Fx[e][t] !== void 0) { const s = Fx[e][t]; return i.r = s(i.r), i.g = s(i.g), i.b = s(i.b), i } throw new Error("Unsupported color space conversion.") }, fromWorkingColorSpace: function (i, e) { return this.convert(i, this.workingColorSpace, e) }, toWorkingColorSpace: function (i, e) { return this.convert(i, e, this.workingColorSpace) } }, GT = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, vs = { r: 0, g: 0, b: 0 }, io = { h: 0, s: 0, l: 0 }, sA = { h: 0, s: 0, l: 0 }; function Ux(i, e, t) { return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i } function rA(i, e) { return e.r = i.r, e.g = i.g, e.b = i.b, e } class xe { constructor(e, t, s) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && s === void 0 ? this.set(e) : this.setRGB(e, t, s) } set(e) { return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, t = to) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, $s.toWorkingColorSpace(this, t), this } setRGB(e, t, s, r = $s.workingColorSpace) { return this.r = e, this.g = t, this.b = s, $s.toWorkingColorSpace(this, r), this } setHSL(e, t, s, r = $s.workingColorSpace) { if (e = Dx(e, 1), t = Gi(t, 0, 1), s = Gi(s, 0, 1), t === 0) this.r = this.g = this.b = s; else { const n = s <= .5 ? s * (1 + t) : s + t - s * t, o = 2 * s - n; this.r = Ux(o, n, e + 1 / 3), this.g = Ux(o, n, e), this.b = Ux(o, n, e - 1 / 3) } return $s.toWorkingColorSpace(this, r), this } setStyle(e, t = to) { function s(n) { n !== void 0 && parseFloat(n) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let r; if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) { let n; const o = r[1], a = r[2]; switch (o) { case "rgb": case "rgba": if (n = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, $s.toWorkingColorSpace(this, t), s(n[4]), this; if (n = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, $s.toWorkingColorSpace(this, t), s(n[4]), this; break; case "hsl": case "hsla": if (n = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) { const l = parseFloat(n[1]) / 360, c = parseFloat(n[2]) / 100, h = parseFloat(n[3]) / 100; return s(n[4]), this.setHSL(l, c, h, t) } break } } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) { const n = r[1], o = n.length; if (o === 3) return this.r = parseInt(n.charAt(0) + n.charAt(0), 16) / 255, this.g = parseInt(n.charAt(1) + n.charAt(1), 16) / 255, this.b = parseInt(n.charAt(2) + n.charAt(2), 16) / 255, $s.toWorkingColorSpace(this, t), this; if (o === 6) return this.r = parseInt(n.charAt(0) + n.charAt(1), 16) / 255, this.g = parseInt(n.charAt(2) + n.charAt(3), 16) / 255, this.b = parseInt(n.charAt(4) + n.charAt(5), 16) / 255, $s.toWorkingColorSpace(this, t), this } return e && e.length > 0 ? this.setColorName(e, t) : this } setColorName(e, t = to) { const s = GT[e.toLowerCase()]; return s !== void 0 ? this.setHex(s, t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = uh(e.r), this.g = uh(e.g), this.b = uh(e.b), this } copyLinearToSRGB(e) { return this.r = iA(e.r), this.g = iA(e.g), this.b = iA(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = to) { return $s.fromWorkingColorSpace(rA(this, vs), e), Gi(vs.r * 255, 0, 255) << 16 ^ Gi(vs.g * 255, 0, 255) << 8 ^ Gi(vs.b * 255, 0, 255) << 0 } getHexString(e = to) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, t = $s.workingColorSpace) { $s.fromWorkingColorSpace(rA(this, vs), t); const s = vs.r, r = vs.g, n = vs.b, o = Math.max(s, r, n), a = Math.min(s, r, n); let l, c; const h = (a + o) / 2; if (a === o) l = 0, c = 0; else { const d = o - a; switch (c = h <= .5 ? d / (o + a) : d / (2 - o - a), o) { case s: l = (r - n) / d + (r < n ? 6 : 0); break; case r: l = (n - s) / d + 2; break; case n: l = (s - r) / d + 4; break }l /= 6 } return e.h = l, e.s = c, e.l = h, e } getRGB(e, t = $s.workingColorSpace) { return $s.fromWorkingColorSpace(rA(this, vs), t), e.r = vs.r, e.g = vs.g, e.b = vs.b, e } getStyle(e = to) { return $s.fromWorkingColorSpace(rA(this, vs), e), e !== to ? `color(${e} ${vs.r} ${vs.g} ${vs.b})` : `rgb(${vs.r * 255 | 0},${vs.g * 255 | 0},${vs.b * 255 | 0})` } offsetHSL(e, t, s) { return this.getHSL(io), io.h += e, io.s += t, io.l += s, this.setHSL(io.h, io.s, io.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, s) { return this.r = e.r + (t.r - e.r) * s, this.g = e.g + (t.g - e.g) * s, this.b = e.b + (t.b - e.b) * s, this } lerpHSL(e, t) { this.getHSL(io), e.getHSL(sA); const s = bf(io.h, sA.h, t), r = bf(io.s, sA.s, t), n = bf(io.l, sA.l, t); return this.setHSL(s, r, n), this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } xe.NAMES = GT; let Ou; class Nx { static getDataURL(e) { if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { Ou === void 0 && (Ou = _f("canvas")), Ou.width = e.width, Ou.height = e.height; const s = Ou.getContext("2d"); e instanceof ImageData ? s.putImageData(e, 0, 0) : s.drawImage(e, 0, 0, e.width, e.height), t = Ou } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } static sRGBToLinear(e) { if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) { const t = _f("canvas"); t.width = e.width, t.height = e.height; const s = t.getContext("2d"); s.drawImage(e, 0, 0, e.width, e.height); const r = s.getImageData(0, 0, e.width, e.height), n = r.data; for (let o = 0; o < n.length; o++)n[o] = uh(n[o] / 255) * 255; return s.putImageData(r, 0, 0), t } else if (e.data) { const t = e.data.slice(0); for (let s = 0; s < t.length; s++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[s] = Math.floor(uh(t[s] / 255) * 255) : t[s] = uh(t[s]); return { data: t, width: e.width, height: e.height } } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } class Nl { constructor(e = null) { this.isSource = !0, this.uuid = Kr(), this.data = e, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid]; const s = { uuid: this.uuid, url: "" }, r = this.data; if (r !== null) { let n; if (Array.isArray(r)) { n = []; for (let o = 0, a = r.length; o < a; o++)r[o].isDataTexture ? n.push(zx(r[o].image)) : n.push(zx(r[o])) } else n = zx(r); s.url = n } return t || (e.images[this.uuid] = s), s } } function zx(i) { return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? Nx.getDataURL(i) : i.data ? { data: Array.from(i.data), width: i.width, height: i.height, type: i.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let Zz = 0; class Nt extends ms { constructor(e = Nt.DEFAULT_IMAGE, t = Nt.DEFAULT_MAPPING, s = Ss, r = Ss, n = Qt, o = eo, a = _i, l = ui, c = 1, h = Qi) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Zz++ }), this.uuid = Kr(), this.name = "", this.source = new Nl(e), this.mipmaps = [], this.mapping = t, this.wrapS = s, this.wrapT = r, this.magFilter = n, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new W(0, 0), this.repeat = new W(1, 1), this.center = new W(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ds, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image() { return this.source.data } set image(e) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return new this.constructor().copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]; const s = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return JSON.stringify(this.userData) !== "{}" && (s.userData = this.userData), t || (e.textures[this.uuid] = s), s } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== jv) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case yn: e.x = e.x - Math.floor(e.x); break; case Ss: e.x = e.x < 0 ? 0 : 1; break; case Ta: Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x); break }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case yn: e.y = e.y - Math.floor(e.y); break; case Ss: e.y = e.y < 0 ? 0 : 1; break; case Ta: Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y); break }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { e === !0 && (this.version++, this.source.needsUpdate = !0) } } Nt.DEFAULT_IMAGE = null, Nt.DEFAULT_MAPPING = jv; class st { constructor(e = 0, t = 0, s = 0, r = 1) { st.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = s, this.w = r } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, s, r) { return this.x = e, this.y = t, this.z = s, this.w = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, s = this.y, r = this.z, n = this.w, o = e.elements; return this.x = o[0] * t + o[4] * s + o[8] * r + o[12] * n, this.y = o[1] * t + o[5] * s + o[9] * r + o[13] * n, this.z = o[2] * t + o[6] * s + o[10] * r + o[14] * n, this.w = o[3] * t + o[7] * s + o[11] * r + o[15] * n, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, s, r, n; const o = e.elements, a = o[0], l = o[4], c = o[8], h = o[1], d = o[5], p = o[9], f = o[2], g = o[6], m = o[10]; if (Math.abs(l - h) < .01 && Math.abs(c - f) < .01 && Math.abs(p - g) < .01) { if (Math.abs(l + h) < .1 && Math.abs(c + f) < .1 && Math.abs(p + g) < .1 && Math.abs(a + d + m - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; const A = (a + 1) / 2, b = (d + 1) / 2, y = (m + 1) / 2, _ = (l + h) / 4, w = (c + f) / 4, E = (p + g) / 4; return A > b && A > y ? A < .01 ? (s = 0, r = .707106781, n = .707106781) : (s = Math.sqrt(A), r = _ / s, n = w / s) : b > y ? b < .01 ? (s = .707106781, r = 0, n = .707106781) : (r = Math.sqrt(b), s = _ / r, n = E / r) : y < .01 ? (s = .707106781, r = .707106781, n = 0) : (n = Math.sqrt(y), s = w / n, r = E / n), this.set(s, r, n, t), this } let v = Math.sqrt((g - p) * (g - p) + (c - f) * (c - f) + (h - l) * (h - l)); return Math.abs(v) < .001 && (v = 1), this.x = (g - p) / v, this.y = (c - f) / v, this.z = (h - l) / v, this.w = Math.acos((a + d + m - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const s = this.length(); return this.divideScalar(s || 1).multiplyScalar(Math.max(e, Math.min(t, s))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, s) { return this.x = e.x + (t.x - e.x) * s, this.y = e.y + (t.y - e.y) * s, this.z = e.z + (t.z - e.z) * s, this.w = e.w + (t.w - e.w) * s, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class ri extends ms { constructor(e = 1, t = 1, s = {}) { super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new st(0, 0, e, t), this.scissorTest = !1, this.viewport = new st(0, 0, e, t); const r = { width: e, height: t, depth: 1 }; this.texture = new Nt(r, s.mapping, s.wrapS, s.wrapT, s.magFilter, s.minFilter, s.format, s.type, s.anisotropy, s.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = s.generateMipmaps !== void 0 ? s.generateMipmaps : !1, this.texture.internalFormat = s.internalFormat !== void 0 ? s.internalFormat : null, this.texture.minFilter = s.minFilter !== void 0 ? s.minFilter : Qt, this.depthBuffer = s.depthBuffer !== void 0 ? s.depthBuffer : !0, this.stencilBuffer = s.stencilBuffer !== void 0 ? s.stencilBuffer : !1, this.depthTexture = s.depthTexture !== void 0 ? s.depthTexture : null, this.samples = s.samples !== void 0 ? s.samples : 0 } setSize(e, t, s = 1) { (this.width !== e || this.height !== t || this.depth !== s) && (this.width = e, this.height = t, this.depth = s, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = s, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return new this.constructor().copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0; const t = Object.assign({}, e.texture.image); return this.texture.source = new Nl(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class xf extends Nt { constructor(e = null, t = 1, s = 1, r = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: s, depth: r }, this.magFilter = Zt, this.minFilter = Zt, this.wrapR = Ss, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class $z extends ri { constructor(e = 1, t = 1, s = 1) { super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = s, this.texture = new xf(null, e, t, s), this.texture.isRenderTargetTexture = !0 } } class wf extends Nt { constructor(e = null, t = 1, s = 1, r = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: s, depth: r }, this.magFilter = Zt, this.minFilter = Zt, this.wrapR = Ss, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class e4 extends ri { constructor(e = 1, t = 1, s = 1) { super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = s, this.texture = new wf(null, e, t, s), this.texture.isRenderTargetTexture = !0 } } class t4 extends ri { constructor(e = 1, t = 1, s = 1, r = {}) { super(e, t, r), this.isWebGLMultipleRenderTargets = !0; const n = this.texture; this.texture = []; for (let o = 0; o < s; o++)this.texture[o] = n.clone(), this.texture[o].isRenderTargetTexture = !0 } setSize(e, t, s = 1) { if (this.width !== e || this.height !== t || this.depth !== s) { this.width = e, this.height = t, this.depth = s; for (let r = 0, n = this.texture.length; r < n; r++)this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = s; this.dispose() } return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this } copy(e) { this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0; for (let t = 0, s = e.texture.length; t < s; t++)this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0; return this } } class we { constructor(e = 0, t = 0, s = 0, r = 1) { this.isQuaternion = !0, this._x = e, this._y = t, this._z = s, this._w = r } static slerpFlat(e, t, s, r, n, o, a) { let l = s[r + 0], c = s[r + 1], h = s[r + 2], d = s[r + 3]; const p = n[o + 0], f = n[o + 1], g = n[o + 2], m = n[o + 3]; if (a === 0) { e[t + 0] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = d; return } if (a === 1) { e[t + 0] = p, e[t + 1] = f, e[t + 2] = g, e[t + 3] = m; return } if (d !== m || l !== p || c !== f || h !== g) { let v = 1 - a; const A = l * p + c * f + h * g + d * m, b = A >= 0 ? 1 : -1, y = 1 - A * A; if (y > Number.EPSILON) { const w = Math.sqrt(y), E = Math.atan2(w, A * b); v = Math.sin(v * E) / w, a = Math.sin(a * E) / w } const _ = a * b; if (l = l * v + p * _, c = c * v + f * _, h = h * v + g * _, d = d * v + m * _, v === 1 - a) { const w = 1 / Math.sqrt(l * l + c * c + h * h + d * d); l *= w, c *= w, h *= w, d *= w } } e[t] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = d } static multiplyQuaternionsFlat(e, t, s, r, n, o) { const a = s[r], l = s[r + 1], c = s[r + 2], h = s[r + 3], d = n[o], p = n[o + 1], f = n[o + 2], g = n[o + 3]; return e[t] = a * g + h * d + l * f - c * p, e[t + 1] = l * g + h * p + c * d - a * f, e[t + 2] = c * g + h * f + a * p - l * d, e[t + 3] = h * g - a * d - l * p - c * f, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, s, r) { return this._x = e, this._y = t, this._z = s, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { const s = e._x, r = e._y, n = e._z, o = e._order, a = Math.cos, l = Math.sin, c = a(s / 2), h = a(r / 2), d = a(n / 2), p = l(s / 2), f = l(r / 2), g = l(n / 2); switch (o) { case "XYZ": this._x = p * h * d + c * f * g, this._y = c * f * d - p * h * g, this._z = c * h * g + p * f * d, this._w = c * h * d - p * f * g; break; case "YXZ": this._x = p * h * d + c * f * g, this._y = c * f * d - p * h * g, this._z = c * h * g - p * f * d, this._w = c * h * d + p * f * g; break; case "ZXY": this._x = p * h * d - c * f * g, this._y = c * f * d + p * h * g, this._z = c * h * g + p * f * d, this._w = c * h * d - p * f * g; break; case "ZYX": this._x = p * h * d - c * f * g, this._y = c * f * d + p * h * g, this._z = c * h * g - p * f * d, this._w = c * h * d + p * f * g; break; case "YZX": this._x = p * h * d + c * f * g, this._y = c * f * d + p * h * g, this._z = c * h * g - p * f * d, this._w = c * h * d - p * f * g; break; case "XZY": this._x = p * h * d - c * f * g, this._y = c * f * d - p * h * g, this._z = c * h * g + p * f * d, this._w = c * h * d + p * f * g; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o) }return t !== !1 && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const s = t / 2, r = Math.sin(s); return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(s), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, s = t[0], r = t[4], n = t[8], o = t[1], a = t[5], l = t[9], c = t[2], h = t[6], d = t[10], p = s + a + d; if (p > 0) { const f = .5 / Math.sqrt(p + 1); this._w = .25 / f, this._x = (h - l) * f, this._y = (n - c) * f, this._z = (o - r) * f } else if (s > a && s > d) { const f = 2 * Math.sqrt(1 + s - a - d); this._w = (h - l) / f, this._x = .25 * f, this._y = (r + o) / f, this._z = (n + c) / f } else if (a > d) { const f = 2 * Math.sqrt(1 + a - s - d); this._w = (n - c) / f, this._x = (r + o) / f, this._y = .25 * f, this._z = (l + h) / f } else { const f = 2 * Math.sqrt(1 + d - s - a); this._w = (o - r) / f, this._x = (n + c) / f, this._y = (l + h) / f, this._z = .25 * f } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let s = e.dot(t) + 1; return s < Number.EPSILON ? (s = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = s) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = s)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = s), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(Gi(this.dot(e), -1, 1))) } rotateTowards(e, t) { const s = this.angleTo(e); if (s === 0) return this; const r = Math.min(1, t / s); return this.slerp(e, r), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const s = e._x, r = e._y, n = e._z, o = e._w, a = t._x, l = t._y, c = t._z, h = t._w; return this._x = s * h + o * a + r * c - n * l, this._y = r * h + o * l + n * a - s * c, this._z = n * h + o * c + s * l - r * a, this._w = o * h - s * a - r * l - n * c, this._onChangeCallback(), this } slerp(e, t) { if (t === 0) return this; if (t === 1) return this.copy(e); const s = this._x, r = this._y, n = this._z, o = this._w; let a = o * e._w + s * e._x + r * e._y + n * e._z; if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = s, this._y = r, this._z = n, this; const l = 1 - a * a; if (l <= Number.EPSILON) { const f = 1 - t; return this._w = f * o + t * this._w, this._x = f * s + t * this._x, this._y = f * r + t * this._y, this._z = f * n + t * this._z, this.normalize(), this._onChangeCallback(), this } const c = Math.sqrt(l), h = Math.atan2(c, a), d = Math.sin((1 - t) * h) / c, p = Math.sin(t * h) / c; return this._w = o * d + this._w * p, this._x = s * d + this._x * p, this._y = r * d + this._y * p, this._z = n * d + this._z * p, this._onChangeCallback(), this } slerpQuaternions(e, t, s) { return this.copy(e).slerp(t, s) } random() { const e = Math.random(), t = Math.sqrt(1 - e), s = Math.sqrt(e), r = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(); return this.set(t * Math.cos(r), s * Math.sin(n), s * Math.cos(n), t * Math.sin(r)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class S { constructor(e = 0, t = 0, s = 0) { S.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = s } set(e, t, s) { return s === void 0 && (s = this.z), this.x = e, this.y = t, this.z = s, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return this.applyQuaternion(HT.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(HT.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, s = this.y, r = this.z, n = e.elements; return this.x = n[0] * t + n[3] * s + n[6] * r, this.y = n[1] * t + n[4] * s + n[7] * r, this.z = n[2] * t + n[5] * s + n[8] * r, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, s = this.y, r = this.z, n = e.elements, o = 1 / (n[3] * t + n[7] * s + n[11] * r + n[15]); return this.x = (n[0] * t + n[4] * s + n[8] * r + n[12]) * o, this.y = (n[1] * t + n[5] * s + n[9] * r + n[13]) * o, this.z = (n[2] * t + n[6] * s + n[10] * r + n[14]) * o, this } applyQuaternion(e) { const t = this.x, s = this.y, r = this.z, n = e.x, o = e.y, a = e.z, l = e.w, c = l * t + o * r - a * s, h = l * s + a * t - n * r, d = l * r + n * s - o * t, p = -n * t - o * s - a * r; return this.x = c * l + p * -n + h * -a - d * -o, this.y = h * l + p * -o + d * -n - c * -a, this.z = d * l + p * -a + c * -o - h * -n, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, s = this.y, r = this.z, n = e.elements; return this.x = n[0] * t + n[4] * s + n[8] * r, this.y = n[1] * t + n[5] * s + n[9] * r, this.z = n[2] * t + n[6] * s + n[10] * r, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const s = this.length(); return this.divideScalar(s || 1).multiplyScalar(Math.max(e, Math.min(t, s))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, s) { return this.x = e.x + (t.x - e.x) * s, this.y = e.y + (t.y - e.y) * s, this.z = e.z + (t.z - e.z) * s, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, t) { const s = e.x, r = e.y, n = e.z, o = t.x, a = t.y, l = t.z; return this.x = r * l - n * a, this.y = n * o - s * l, this.z = s * a - r * o, this } projectOnVector(e) { const t = e.lengthSq(); if (t === 0) return this.set(0, 0, 0); const s = e.dot(this) / t; return this.copy(e).multiplyScalar(s) } projectOnPlane(e) { return jx.copy(this).projectOnVector(e), this.sub(jx) } reflect(e) { return this.sub(jx.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (t === 0) return Math.PI / 2; const s = this.dot(e) / t; return Math.acos(Gi(s, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, s = this.y - e.y, r = this.z - e.z; return t * t + s * s + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, s) { const r = Math.sin(t) * e; return this.x = r * Math.sin(s), this.y = Math.cos(t) * e, this.z = r * Math.cos(s), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, s) { return this.x = e * Math.sin(t), this.y = s, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), s = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = s, this.z = r, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, t * 4) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, t * 3) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = (Math.random() - .5) * 2, t = Math.random() * Math.PI * 2, s = Math.sqrt(1 - e ** 2); return this.x = s * Math.cos(t), this.y = s * Math.sin(t), this.z = e, this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const jx = new S, HT = new we; class er { constructor(e = new S(1 / 0, 1 / 0, 1 / 0), t = new S(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { let t = 1 / 0, s = 1 / 0, r = 1 / 0, n = -1 / 0, o = -1 / 0, a = -1 / 0; for (let l = 0, c = e.length; l < c; l += 3) { const h = e[l], d = e[l + 1], p = e[l + 2]; h < t && (t = h), d < s && (s = d), p < r && (r = p), h > n && (n = h), d > o && (o = d), p > a && (a = p) } return this.min.set(t, s, r), this.max.set(n, o, a), this } setFromBufferAttribute(e) { let t = 1 / 0, s = 1 / 0, r = 1 / 0, n = -1 / 0, o = -1 / 0, a = -1 / 0; for (let l = 0, c = e.count; l < c; l++) { const h = e.getX(l), d = e.getY(l), p = e.getZ(l); h < t && (t = h), d < s && (s = d), p < r && (r = p), h > n && (n = h), d > o && (o = d), p > a && (a = p) } return this.min.set(t, s, r), this.max.set(n, o, a), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, s = e.length; t < s; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const s = dh.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(s), this.max.copy(e).add(s), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { e.updateWorldMatrix(!1, !1); const s = e.geometry; if (s !== void 0) if (t && s.attributes != null && s.attributes.position !== void 0) { const n = s.attributes.position; for (let o = 0, a = n.count; o < a; o++)dh.fromBufferAttribute(n, o).applyMatrix4(e.matrixWorld), this.expandByPoint(dh) } else s.boundingBox === null && s.computeBoundingBox(), Qx.copy(s.boundingBox), Qx.applyMatrix4(e.matrixWorld), this.union(Qx); const r = e.children; for (let n = 0, o = r.length; n < o; n++)this.expandByObject(r[n], t); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, dh), dh.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, s; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, s = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, s = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, s += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, s += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, s += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, s += e.normal.z * this.min.z), t <= -e.constant && s >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(Cf), nA.subVectors(this.max, Cf), Lu.subVectors(e.a, Cf), Fu.subVectors(e.b, Cf), Uu.subVectors(e.c, Cf), zl.subVectors(Fu, Lu), jl.subVectors(Uu, Fu), ph.subVectors(Lu, Uu); let t = [0, -zl.z, zl.y, 0, -jl.z, jl.y, 0, -ph.z, ph.y, zl.z, 0, -zl.x, jl.z, 0, -jl.x, ph.z, 0, -ph.x, -zl.y, zl.x, 0, -jl.y, jl.x, 0, -ph.y, ph.x, 0]; return !Gx(t, Lu, Fu, Uu, nA) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Gx(t, Lu, Fu, Uu, nA)) ? !1 : (oA.crossVectors(zl, jl), t = [oA.x, oA.y, oA.z], Gx(t, Lu, Fu, Uu, nA)) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return dh.copy(e).clamp(this.min, this.max).sub(e).length() } getBoundingSphere(e) { return this.getCenter(e.center), e.radius = this.getSize(dh).length() * .5, e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() ? this : (ka[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), ka[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), ka[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), ka[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), ka[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), ka[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), ka[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), ka[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(ka), this) } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const ka = [new S, new S, new S, new S, new S, new S, new S, new S], dh = new S, Qx = new er, Lu = new S, Fu = new S, Uu = new S, zl = new S, jl = new S, ph = new S, Cf = new S, nA = new S, oA = new S, fh = new S; function Gx(i, e, t, s, r) { for (let n = 0, o = i.length - 3; n <= o; n += 3) { fh.fromArray(i, n); const a = r.x * Math.abs(fh.x) + r.y * Math.abs(fh.y) + r.z * Math.abs(fh.z), l = e.dot(fh), c = t.dot(fh), h = s.dot(fh); if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1 } return !0 } const i4 = new er, Sf = new S, Hx = new S; class Po { constructor(e = new S, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const s = this.center; t !== void 0 ? s.copy(t) : i4.setFromPoints(e).getCenter(s); let r = 0; for (let n = 0, o = e.length; n < o; n++)r = Math.max(r, s.distanceToSquared(e[n])); return this.radius = Math.sqrt(r), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const s = this.center.distanceToSquared(e); return t.copy(e), s > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; Sf.subVectors(e, this.center); const t = Sf.lengthSq(); if (t > this.radius * this.radius) { const s = Math.sqrt(t), r = (s - this.radius) * .5; this.center.addScaledVector(Sf, r / s), this.radius += r } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Hx.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Sf.copy(e.center).add(Hx)), this.expandByPoint(Sf.copy(e.center).sub(Hx))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return new this.constructor().copy(this) } } const Da = new S, Vx = new S, aA = new S, Ql = new S, Wx = new S, lA = new S, qx = new S; class Oa { constructor(e = new S, t = new S(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.direction).multiplyScalar(e).add(this.origin) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, Da)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const s = t.dot(this.direction); return s < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(s).add(this.origin) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = Da.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (Da.copy(this.direction).multiplyScalar(t).add(this.origin), Da.distanceToSquared(e)) } distanceSqToSegment(e, t, s, r) { Vx.copy(e).add(t).multiplyScalar(.5), aA.copy(t).sub(e).normalize(), Ql.copy(this.origin).sub(Vx); const n = e.distanceTo(t) * .5, o = -this.direction.dot(aA), a = Ql.dot(this.direction), l = -Ql.dot(aA), c = Ql.lengthSq(), h = Math.abs(1 - o * o); let d, p, f, g; if (h > 0) if (d = o * l - a, p = o * a - l, g = n * h, d >= 0) if (p >= -g) if (p <= g) { const m = 1 / h; d *= m, p *= m, f = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + c } else p = n, d = Math.max(0, -(o * p + a)), f = -d * d + p * (p + 2 * l) + c; else p = -n, d = Math.max(0, -(o * p + a)), f = -d * d + p * (p + 2 * l) + c; else p <= -g ? (d = Math.max(0, -(-o * n + a)), p = d > 0 ? -n : Math.min(Math.max(-n, -l), n), f = -d * d + p * (p + 2 * l) + c) : p <= g ? (d = 0, p = Math.min(Math.max(-n, -l), n), f = p * (p + 2 * l) + c) : (d = Math.max(0, -(o * n + a)), p = d > 0 ? n : Math.min(Math.max(-n, -l), n), f = -d * d + p * (p + 2 * l) + c); else p = o > 0 ? -n : n, d = Math.max(0, -(o * p + a)), f = -d * d + p * (p + 2 * l) + c; return s && s.copy(this.direction).multiplyScalar(d).add(this.origin), r && r.copy(aA).multiplyScalar(p).add(Vx), f } intersectSphere(e, t) { Da.subVectors(e.center, this.origin); const s = Da.dot(this.direction), r = Da.dot(Da) - s * s, n = e.radius * e.radius; if (r > n) return null; const o = Math.sqrt(n - r), a = s - o, l = s + o; return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null; const s = -(this.origin.dot(e.normal) + e.constant) / t; return s >= 0 ? s : null } intersectPlane(e, t) { const s = this.distanceToPlane(e); return s === null ? null : this.at(s, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); return t === 0 || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let s, r, n, o, a, l; const c = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin; return c >= 0 ? (s = (e.min.x - p.x) * c, r = (e.max.x - p.x) * c) : (s = (e.max.x - p.x) * c, r = (e.min.x - p.x) * c), h >= 0 ? (n = (e.min.y - p.y) * h, o = (e.max.y - p.y) * h) : (n = (e.max.y - p.y) * h, o = (e.min.y - p.y) * h), s > o || n > r || ((n > s || isNaN(s)) && (s = n), (o < r || isNaN(r)) && (r = o), d >= 0 ? (a = (e.min.z - p.z) * d, l = (e.max.z - p.z) * d) : (a = (e.max.z - p.z) * d, l = (e.min.z - p.z) * d), s > l || a > r) || ((a > s || s !== s) && (s = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(s >= 0 ? s : r, t) } intersectsBox(e) { return this.intersectBox(e, Da) !== null } intersectTriangle(e, t, s, r, n) { Wx.subVectors(t, e), lA.subVectors(s, e), qx.crossVectors(Wx, lA); let o = this.direction.dot(qx), a; if (o > 0) { if (r) return null; a = 1 } else if (o < 0) a = -1, o = -o; else return null; Ql.subVectors(this.origin, e); const l = a * this.direction.dot(lA.crossVectors(Ql, lA)); if (l < 0) return null; const c = a * this.direction.dot(Wx.cross(Ql)); if (c < 0 || l + c > o) return null; const h = -a * Ql.dot(qx); return h < 0 ? null : this.at(h / o, n) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return new this.constructor().copy(this) } } class He { constructor() { He.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } set(e, t, s, r, n, o, a, l, c, h, d, p, f, g, m, v) { const A = this.elements; return A[0] = e, A[4] = t, A[8] = s, A[12] = r, A[1] = n, A[5] = o, A[9] = a, A[13] = l, A[2] = c, A[6] = h, A[10] = d, A[14] = p, A[3] = f, A[7] = g, A[11] = m, A[15] = v, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return new He().fromArray(this.elements) } copy(e) { const t = this.elements, s = e.elements; return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], t[5] = s[5], t[6] = s[6], t[7] = s[7], t[8] = s[8], t[9] = s[9], t[10] = s[10], t[11] = s[11], t[12] = s[12], t[13] = s[13], t[14] = s[14], t[15] = s[15], this } copyPosition(e) { const t = this.elements, s = e.elements; return t[12] = s[12], t[13] = s[13], t[14] = s[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, s) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), s.setFromMatrixColumn(this, 2), this } makeBasis(e, t, s) { return this.set(e.x, t.x, s.x, 0, e.y, t.y, s.y, 0, e.z, t.z, s.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, s = e.elements, r = 1 / Nu.setFromMatrixColumn(e, 0).length(), n = 1 / Nu.setFromMatrixColumn(e, 1).length(), o = 1 / Nu.setFromMatrixColumn(e, 2).length(); return t[0] = s[0] * r, t[1] = s[1] * r, t[2] = s[2] * r, t[3] = 0, t[4] = s[4] * n, t[5] = s[5] * n, t[6] = s[6] * n, t[7] = 0, t[8] = s[8] * o, t[9] = s[9] * o, t[10] = s[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { const t = this.elements, s = e.x, r = e.y, n = e.z, o = Math.cos(s), a = Math.sin(s), l = Math.cos(r), c = Math.sin(r), h = Math.cos(n), d = Math.sin(n); if (e.order === "XYZ") { const p = o * h, f = o * d, g = a * h, m = a * d; t[0] = l * h, t[4] = -l * d, t[8] = c, t[1] = f + g * c, t[5] = p - m * c, t[9] = -a * l, t[2] = m - p * c, t[6] = g + f * c, t[10] = o * l } else if (e.order === "YXZ") { const p = l * h, f = l * d, g = c * h, m = c * d; t[0] = p + m * a, t[4] = g * a - f, t[8] = o * c, t[1] = o * d, t[5] = o * h, t[9] = -a, t[2] = f * a - g, t[6] = m + p * a, t[10] = o * l } else if (e.order === "ZXY") { const p = l * h, f = l * d, g = c * h, m = c * d; t[0] = p - m * a, t[4] = -o * d, t[8] = g + f * a, t[1] = f + g * a, t[5] = o * h, t[9] = m - p * a, t[2] = -o * c, t[6] = a, t[10] = o * l } else if (e.order === "ZYX") { const p = o * h, f = o * d, g = a * h, m = a * d; t[0] = l * h, t[4] = g * c - f, t[8] = p * c + m, t[1] = l * d, t[5] = m * c + p, t[9] = f * c - g, t[2] = -c, t[6] = a * l, t[10] = o * l } else if (e.order === "YZX") { const p = o * l, f = o * c, g = a * l, m = a * c; t[0] = l * h, t[4] = m - p * d, t[8] = g * d + f, t[1] = d, t[5] = o * h, t[9] = -a * h, t[2] = -c * h, t[6] = f * d + g, t[10] = p - m * d } else if (e.order === "XZY") { const p = o * l, f = o * c, g = a * l, m = a * c; t[0] = l * h, t[4] = -d, t[8] = c * h, t[1] = p * d + m, t[5] = o * h, t[9] = f * d - g, t[2] = g * d - f, t[6] = a * h, t[10] = m * d + p } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(s4, e, r4) } lookAt(e, t, s) { const r = this.elements; return Zr.subVectors(e, t), Zr.lengthSq() === 0 && (Zr.z = 1), Zr.normalize(), Gl.crossVectors(s, Zr), Gl.lengthSq() === 0 && (Math.abs(s.z) === 1 ? Zr.x += 1e-4 : Zr.z += 1e-4, Zr.normalize(), Gl.crossVectors(s, Zr)), Gl.normalize(), cA.crossVectors(Zr, Gl), r[0] = Gl.x, r[4] = cA.x, r[8] = Zr.x, r[1] = Gl.y, r[5] = cA.y, r[9] = Zr.y, r[2] = Gl.z, r[6] = cA.z, r[10] = Zr.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const s = e.elements, r = t.elements, n = this.elements, o = s[0], a = s[4], l = s[8], c = s[12], h = s[1], d = s[5], p = s[9], f = s[13], g = s[2], m = s[6], v = s[10], A = s[14], b = s[3], y = s[7], _ = s[11], w = s[15], E = r[0], P = r[4], C = r[8], R = r[12], T = r[1], z = r[5], H = r[9], N = r[13], F = r[2], X = r[6], te = r[10], re = r[14], Z = r[3], fe = r[7], ae = r[11], De = r[15]; return n[0] = o * E + a * T + l * F + c * Z, n[4] = o * P + a * z + l * X + c * fe, n[8] = o * C + a * H + l * te + c * ae, n[12] = o * R + a * N + l * re + c * De, n[1] = h * E + d * T + p * F + f * Z, n[5] = h * P + d * z + p * X + f * fe, n[9] = h * C + d * H + p * te + f * ae, n[13] = h * R + d * N + p * re + f * De, n[2] = g * E + m * T + v * F + A * Z, n[6] = g * P + m * z + v * X + A * fe, n[10] = g * C + m * H + v * te + A * ae, n[14] = g * R + m * N + v * re + A * De, n[3] = b * E + y * T + _ * F + w * Z, n[7] = b * P + y * z + _ * X + w * fe, n[11] = b * C + y * H + _ * te + w * ae, n[15] = b * R + y * N + _ * re + w * De, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], s = e[4], r = e[8], n = e[12], o = e[1], a = e[5], l = e[9], c = e[13], h = e[2], d = e[6], p = e[10], f = e[14], g = e[3], m = e[7], v = e[11], A = e[15]; return g * (+n * l * d - r * c * d - n * a * p + s * c * p + r * a * f - s * l * f) + m * (+t * l * f - t * c * p + n * o * p - r * o * f + r * c * h - n * l * h) + v * (+t * c * d - t * a * f - n * o * d + s * o * f + n * a * h - s * c * h) + A * (-r * a * h - t * l * d + t * a * p + r * o * d - s * o * p + s * l * h) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, s) { const r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = s), this } invert() { const e = this.elements, t = e[0], s = e[1], r = e[2], n = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8], d = e[9], p = e[10], f = e[11], g = e[12], m = e[13], v = e[14], A = e[15], b = d * v * c - m * p * c + m * l * f - a * v * f - d * l * A + a * p * A, y = g * p * c - h * v * c - g * l * f + o * v * f + h * l * A - o * p * A, _ = h * m * c - g * d * c + g * a * f - o * m * f - h * a * A + o * d * A, w = g * d * l - h * m * l - g * a * p + o * m * p + h * a * v - o * d * v, E = t * b + s * y + r * _ + n * w; if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const P = 1 / E; return e[0] = b * P, e[1] = (m * p * n - d * v * n - m * r * f + s * v * f + d * r * A - s * p * A) * P, e[2] = (a * v * n - m * l * n + m * r * c - s * v * c - a * r * A + s * l * A) * P, e[3] = (d * l * n - a * p * n - d * r * c + s * p * c + a * r * f - s * l * f) * P, e[4] = y * P, e[5] = (h * v * n - g * p * n + g * r * f - t * v * f - h * r * A + t * p * A) * P, e[6] = (g * l * n - o * v * n - g * r * c + t * v * c + o * r * A - t * l * A) * P, e[7] = (o * p * n - h * l * n + h * r * c - t * p * c - o * r * f + t * l * f) * P, e[8] = _ * P, e[9] = (g * d * n - h * m * n - g * s * f + t * m * f + h * s * A - t * d * A) * P, e[10] = (o * m * n - g * a * n + g * s * c - t * m * c - o * s * A + t * a * A) * P, e[11] = (h * a * n - o * d * n - h * s * c + t * d * c + o * s * f - t * a * f) * P, e[12] = w * P, e[13] = (h * m * r - g * d * r + g * s * p - t * m * p - h * s * v + t * d * v) * P, e[14] = (g * a * r - o * m * r - g * s * l + t * m * l + o * s * v - t * a * v) * P, e[15] = (o * d * r - h * a * r + h * s * l - t * d * l - o * s * p + t * a * p) * P, this } scale(e) { const t = this.elements, s = e.x, r = e.y, n = e.z; return t[0] *= s, t[4] *= r, t[8] *= n, t[1] *= s, t[5] *= r, t[9] *= n, t[2] *= s, t[6] *= r, t[10] *= n, t[3] *= s, t[7] *= r, t[11] *= n, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], s = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, s, r)) } makeTranslation(e, t, s) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, s, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), s = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -s, 0, 0, s, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), s = Math.sin(e); return this.set(t, 0, s, 0, 0, 1, 0, 0, -s, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), s = Math.sin(e); return this.set(t, -s, 0, 0, s, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const s = Math.cos(t), r = Math.sin(t), n = 1 - s, o = e.x, a = e.y, l = e.z, c = n * o, h = n * a; return this.set(c * o + s, c * a - r * l, c * l + r * a, 0, c * a + r * l, h * a + s, h * l - r * o, 0, c * l - r * a, h * l + r * o, n * l * l + s, 0, 0, 0, 0, 1), this } makeScale(e, t, s) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, s, 0, 0, 0, 0, 1), this } makeShear(e, t, s, r, n, o) { return this.set(1, s, n, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this } compose(e, t, s) { const r = this.elements, n = t._x, o = t._y, a = t._z, l = t._w, c = n + n, h = o + o, d = a + a, p = n * c, f = n * h, g = n * d, m = o * h, v = o * d, A = a * d, b = l * c, y = l * h, _ = l * d, w = s.x, E = s.y, P = s.z; return r[0] = (1 - (m + A)) * w, r[1] = (f + _) * w, r[2] = (g - y) * w, r[3] = 0, r[4] = (f - _) * E, r[5] = (1 - (p + A)) * E, r[6] = (v + b) * E, r[7] = 0, r[8] = (g + y) * P, r[9] = (v - b) * P, r[10] = (1 - (p + m)) * P, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } decompose(e, t, s) { const r = this.elements; let n = Nu.set(r[0], r[1], r[2]).length(); const o = Nu.set(r[4], r[5], r[6]).length(), a = Nu.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (n = -n), e.x = r[12], e.y = r[13], e.z = r[14], so.copy(this); const l = 1 / n, c = 1 / o, h = 1 / a; return so.elements[0] *= l, so.elements[1] *= l, so.elements[2] *= l, so.elements[4] *= c, so.elements[5] *= c, so.elements[6] *= c, so.elements[8] *= h, so.elements[9] *= h, so.elements[10] *= h, t.setFromRotationMatrix(so), s.x = n, s.y = o, s.z = a, this } makePerspective(e, t, s, r, n, o) { const a = this.elements, l = 2 * n / (t - e), c = 2 * n / (s - r), h = (t + e) / (t - e), d = (s + r) / (s - r), p = -(o + n) / (o - n), f = -2 * o * n / (o - n); return a[0] = l, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = c, a[9] = d, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = p, a[14] = f, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this } makeOrthographic(e, t, s, r, n, o) { const a = this.elements, l = 1 / (t - e), c = 1 / (s - r), h = 1 / (o - n), d = (t + e) * l, p = (s + r) * c, f = (o + n) * h; return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -d, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -p, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -f, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this } equals(e) { const t = this.elements, s = e.elements; for (let r = 0; r < 16; r++)if (t[r] !== s[r]) return !1; return !0 } fromArray(e, t = 0) { for (let s = 0; s < 16; s++)this.elements[s] = e[s + t]; return this } toArray(e = [], t = 0) { const s = this.elements; return e[t] = s[0], e[t + 1] = s[1], e[t + 2] = s[2], e[t + 3] = s[3], e[t + 4] = s[4], e[t + 5] = s[5], e[t + 6] = s[6], e[t + 7] = s[7], e[t + 8] = s[8], e[t + 9] = s[9], e[t + 10] = s[10], e[t + 11] = s[11], e[t + 12] = s[12], e[t + 13] = s[13], e[t + 14] = s[14], e[t + 15] = s[15], e } } const Nu = new S, so = new He, s4 = new S(0, 0, 0), r4 = new S(1, 1, 1), Gl = new S, cA = new S, Zr = new S, VT = new He, WT = new we; class ps { constructor(e = 0, t = 0, s = 0, r = ps.DefaultOrder) { this.isEuler = !0, this._x = e, this._y = t, this._z = s, this._order = r } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, s, r = this._order) { return this._x = e, this._y = t, this._z = s, this._order = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, s = !0) { const r = e.elements, n = r[0], o = r[4], a = r[8], l = r[1], c = r[5], h = r[9], d = r[2], p = r[6], f = r[10]; switch (t) { case "XYZ": this._y = Math.asin(Gi(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, n)) : (this._x = Math.atan2(p, c), this._z = 0); break; case "YXZ": this._x = Math.asin(-Gi(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, n), this._z = 0); break; case "ZXY": this._x = Math.asin(Gi(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, n)); break; case "ZYX": this._y = Math.asin(-Gi(d, -1, 1)), Math.abs(d) < .9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(l, n)) : (this._x = 0, this._z = Math.atan2(-o, c)); break; case "YZX": this._z = Math.asin(Gi(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-d, n)) : (this._x = 0, this._y = Math.atan2(a, f)); break; case "XZY": this._z = Math.asin(-Gi(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(a, n)) : (this._x = Math.atan2(-h, f), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, s === !0 && this._onChangeCallback(), this } setFromQuaternion(e, t, s) { return VT.makeRotationFromQuaternion(e), this.setFromRotationMatrix(VT, t, s) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return WT.setFromEuler(this), this.setFromQuaternion(WT, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } toVector3() { console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead") } } ps.DefaultOrder = "XYZ", ps.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; class bn { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return (this.mask & e.mask) !== 0 } isEnabled(e) { return (this.mask & (1 << e | 0)) !== 0 } } let n4 = 0; const qT = new S, zu = new we, La = new He, hA = new S, Ef = new S, o4 = new S, a4 = new we, XT = new S(1, 0, 0), YT = new S(0, 1, 0), JT = new S(0, 0, 1), l4 = { type: "added" }, KT = { type: "removed" }; class Me extends ms { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: n4++ }), this.uuid = Kr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Me.DefaultUp.clone(); const e = new S, t = new ps, s = new we, r = new S(1, 1, 1); function n() { s.setFromEuler(t, !1) } function o() { t.setFromQuaternion(s, void 0, !1) } t._onChange(n), s._onChange(o), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: s }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new He }, normalMatrix: { value: new ds } }), this.matrix = new He, this.matrixWorld = new He, this.matrixAutoUpdate = Me.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Me.DefaultMatrixWorldAutoUpdate, this.layers = new bn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return zu.setFromAxisAngle(e, t), this.quaternion.multiply(zu), this } rotateOnWorldAxis(e, t) { return zu.setFromAxisAngle(e, t), this.quaternion.premultiply(zu), this } rotateX(e) { return this.rotateOnAxis(XT, e) } rotateY(e) { return this.rotateOnAxis(YT, e) } rotateZ(e) { return this.rotateOnAxis(JT, e) } translateOnAxis(e, t) { return qT.copy(e).applyQuaternion(this.quaternion), this.position.add(qT.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(XT, e) } translateY(e) { return this.translateOnAxis(YT, e) } translateZ(e) { return this.translateOnAxis(JT, e) } localToWorld(e) { return e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return e.applyMatrix4(La.copy(this.matrixWorld).invert()) } lookAt(e, t, s) { e.isVector3 ? hA.copy(e) : hA.set(e, t, s); const r = this.parent; this.updateWorldMatrix(!0, !1), Ef.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? La.lookAt(Ef, hA, this.up) : La.lookAt(hA, Ef, this.up), this.quaternion.setFromRotationMatrix(La), r && (La.extractRotation(r.matrixWorld), zu.setFromRotationMatrix(La), this.quaternion.premultiply(zu.invert())) } add(e) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(l4)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let s = 0; s < arguments.length; s++)this.remove(arguments[s]); return this } const t = this.children.indexOf(e); return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(KT)), this } removeFromParent() { const e = this.parent; return e !== null && e.remove(this), this } clear() { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; t.parent = null, t.dispatchEvent(KT) } return this.children.length = 0, this } attach(e) { return this.updateWorldMatrix(!0, !1), La.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), La.multiply(e.parent.matrixWorld)), e.applyMatrix4(La), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let s = 0, r = this.children.length; s < r; s++) { const n = this.children[s].getObjectByProperty(e, t); if (n !== void 0) return n } } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ef, e, o4), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ef, a4, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let s = 0, r = t.length; s < r; s++)t[s].traverse(e) } traverseVisible(e) { if (this.visible === !1) return; e(this); const t = this.children; for (let s = 0, r = t.length; s < r; s++)t[s].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; t !== null && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let s = 0, r = t.length; s < r; s++) { const n = t[s]; (n.matrixWorldAutoUpdate === !0 || e === !0) && n.updateMatrixWorld(e) } } updateWorldMatrix(e, t) { const s = this.parent; if (e === !0 && s !== null && s.matrixWorldAutoUpdate === !0 && s.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) { const r = this.children; for (let n = 0, o = r.length; n < o; n++) { const a = r[n]; a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0) } } } toJSON(e) { const t = e === void 0 || typeof e == "string", s = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, s.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const r = {}; r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())); function n(a, l) { return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid } if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { r.geometry = n(e.geometries, this.geometry); const a = this.geometry.parameters; if (a !== void 0 && a.shapes !== void 0) { const l = a.shapes; if (Array.isArray(l)) for (let c = 0, h = l.length; c < h; c++) { const d = l[c]; n(e.shapes, d) } else n(e.shapes, l) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (n(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) { const a = []; for (let l = 0, c = this.material.length; l < c; l++)a.push(n(e.materials, this.material[l])); r.material = a } else r.material = n(e.materials, this.material); if (this.children.length > 0) { r.children = []; for (let a = 0; a < this.children.length; a++)r.children.push(this.children[a].toJSON(e).object) } if (this.animations.length > 0) { r.animations = []; for (let a = 0; a < this.animations.length; a++) { const l = this.animations[a]; r.animations.push(n(e.animations, l)) } } if (t) { const a = o(e.geometries), l = o(e.materials), c = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), f = o(e.animations), g = o(e.nodes); a.length > 0 && (s.geometries = a), l.length > 0 && (s.materials = l), c.length > 0 && (s.textures = c), h.length > 0 && (s.images = h), d.length > 0 && (s.shapes = d), p.length > 0 && (s.skeletons = p), f.length > 0 && (s.animations = f), g.length > 0 && (s.nodes = g) } return s.object = r, s; function o(a) { const l = []; for (const c in a) { const h = a[c]; delete h.metadata, l.push(h) } return l } } clone(e) { return new this.constructor().copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0) for (let s = 0; s < e.children.length; s++) { const r = e.children[s]; this.add(r.clone()) } return this } } Me.DefaultUp = new S(0, 1, 0), Me.DefaultMatrixAutoUpdate = !0, Me.DefaultMatrixWorldAutoUpdate = !0; const ro = new S, Fa = new S, Xx = new S, Ua = new S, ju = new S, Qu = new S, ZT = new S, Yx = new S, Jx = new S, Kx = new S; class vn { constructor(e = new S, t = new S, s = new S) { this.a = e, this.b = t, this.c = s } static getNormal(e, t, s, r) { r.subVectors(s, t), ro.subVectors(e, t), r.cross(ro); const n = r.lengthSq(); return n > 0 ? r.multiplyScalar(1 / Math.sqrt(n)) : r.set(0, 0, 0) } static getBarycoord(e, t, s, r, n) { ro.subVectors(r, t), Fa.subVectors(s, t), Xx.subVectors(e, t); const o = ro.dot(ro), a = ro.dot(Fa), l = ro.dot(Xx), c = Fa.dot(Fa), h = Fa.dot(Xx), d = o * c - a * a; if (d === 0) return n.set(-2, -1, -1); const p = 1 / d, f = (c * l - a * h) * p, g = (o * h - a * l) * p; return n.set(1 - f - g, g, f) } static containsPoint(e, t, s, r) { return this.getBarycoord(e, t, s, r, Ua), Ua.x >= 0 && Ua.y >= 0 && Ua.x + Ua.y <= 1 } static getUV(e, t, s, r, n, o, a, l) { return this.getBarycoord(e, t, s, r, Ua), l.set(0, 0), l.addScaledVector(n, Ua.x), l.addScaledVector(o, Ua.y), l.addScaledVector(a, Ua.z), l } static isFrontFacing(e, t, s, r) { return ro.subVectors(s, t), Fa.subVectors(e, t), ro.cross(Fa).dot(r) < 0 } set(e, t, s) { return this.a.copy(e), this.b.copy(t), this.c.copy(s), this } setFromPointsAndIndices(e, t, s, r) { return this.a.copy(e[t]), this.b.copy(e[s]), this.c.copy(e[r]), this } setFromAttributeAndIndices(e, t, s, r) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, s), this.c.fromBufferAttribute(e, r), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return ro.subVectors(this.c, this.b), Fa.subVectors(this.a, this.b), ro.cross(Fa).length() * .5 } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return vn.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return vn.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, s, r, n) { return vn.getUV(e, this.a, this.b, this.c, t, s, r, n) } containsPoint(e) { return vn.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return vn.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const s = this.a, r = this.b, n = this.c; let o, a; ju.subVectors(r, s), Qu.subVectors(n, s), Yx.subVectors(e, s); const l = ju.dot(Yx), c = Qu.dot(Yx); if (l <= 0 && c <= 0) return t.copy(s); Jx.subVectors(e, r); const h = ju.dot(Jx), d = Qu.dot(Jx); if (h >= 0 && d <= h) return t.copy(r); const p = l * d - h * c; if (p <= 0 && l >= 0 && h <= 0) return o = l / (l - h), t.copy(s).addScaledVector(ju, o); Kx.subVectors(e, n); const f = ju.dot(Kx), g = Qu.dot(Kx); if (g >= 0 && f <= g) return t.copy(n); const m = f * c - l * g; if (m <= 0 && c >= 0 && g <= 0) return a = c / (c - g), t.copy(s).addScaledVector(Qu, a); const v = h * g - f * d; if (v <= 0 && d - h >= 0 && f - g >= 0) return ZT.subVectors(n, r), a = (d - h) / (d - h + (f - g)), t.copy(r).addScaledVector(ZT, a); const A = 1 / (v + m + p); return o = m * A, a = p * A, t.copy(s).addScaledVector(ju, o).addScaledVector(Qu, a) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let c4 = 0; class Tt extends ms { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: c4++ }), this.uuid = Kr(), this.name = "", this.type = "Material", this.blending = Ia, this.side = pr, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = ax, this.blendDst = lx, this.blendEquation = nh, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Mu, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Bx, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Af, this.stencilZFail = Af, this.stencilZPass = Af, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBuild() { } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (e !== void 0) for (const t in e) { const s = e[t]; if (s === void 0) { console.warn("THREE.Material: '" + t + "' parameter is undefined."); continue } const r = this[t]; if (r === void 0) { console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material."); continue } r && r.isColor ? r.set(s) : r && r.isVector3 && s && s.isVector3 ? r.copy(s) : this[t] = s } } toJSON(e) { const t = e === void 0 || typeof e == "string"; t && (e = { textures: {}, images: {} }); const s = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.color && this.color.isColor && (s.color = this.color.getHex()), this.roughness !== void 0 && (s.roughness = this.roughness), this.metalness !== void 0 && (s.metalness = this.metalness), this.sheen !== void 0 && (s.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (s.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (s.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (s.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (s.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (s.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (s.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (s.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (s.shininess = this.shininess), this.clearcoat !== void 0 && (s.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (s.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (s.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (s.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, s.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (s.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (s.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (s.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (s.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (s.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (s.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (s.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (s.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (s.lightMap = this.lightMap.toJSON(e).uuid, s.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (s.aoMap = this.aoMap.toJSON(e).uuid, s.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (s.bumpMap = this.bumpMap.toJSON(e).uuid, s.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (s.normalMap = this.normalMap.toJSON(e).uuid, s.normalMapType = this.normalMapType, s.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (s.displacementMap = this.displacementMap.toJSON(e).uuid, s.displacementScale = this.displacementScale, s.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (s.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (s.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (s.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (s.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (s.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (s.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (s.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (s.combine = this.combine)), this.envMapIntensity !== void 0 && (s.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (s.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (s.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (s.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (s.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (s.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (s.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (s.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (s.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (s.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (s.size = this.size), this.shadowSide !== null && (s.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (s.sizeAttenuation = this.sizeAttenuation), this.blending !== Ia && (s.blending = this.blending), this.side !== pr && (s.side = this.side), this.vertexColors && (s.vertexColors = !0), this.opacity < 1 && (s.opacity = this.opacity), this.transparent === !0 && (s.transparent = this.transparent), s.depthFunc = this.depthFunc, s.depthTest = this.depthTest, s.depthWrite = this.depthWrite, s.colorWrite = this.colorWrite, s.stencilWrite = this.stencilWrite, s.stencilWriteMask = this.stencilWriteMask, s.stencilFunc = this.stencilFunc, s.stencilRef = this.stencilRef, s.stencilFuncMask = this.stencilFuncMask, s.stencilFail = this.stencilFail, s.stencilZFail = this.stencilZFail, s.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (s.rotation = this.rotation), this.polygonOffset === !0 && (s.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (s.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (s.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (s.linewidth = this.linewidth), this.dashSize !== void 0 && (s.dashSize = this.dashSize), this.gapSize !== void 0 && (s.gapSize = this.gapSize), this.scale !== void 0 && (s.scale = this.scale), this.dithering === !0 && (s.dithering = !0), this.alphaTest > 0 && (s.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (s.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (s.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (s.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (s.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (s.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (s.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (s.flatShading = this.flatShading), this.visible === !1 && (s.visible = !1), this.toneMapped === !1 && (s.toneMapped = !1), this.fog === !1 && (s.fog = !1), JSON.stringify(this.userData) !== "{}" && (s.userData = this.userData); function r(n) { const o = []; for (const a in n) { const l = n[a]; delete l.metadata, o.push(l) } return o } if (t) { const n = r(e.textures), o = r(e.images); n.length > 0 && (s.textures = n), o.length > 0 && (s.images = o) } return s } clone() { return new this.constructor().copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let s = null; if (t !== null) { const r = t.length; s = new Array(r); for (let n = 0; n !== r; ++n)s[n] = t[n].clone() } return this.clippingPlanes = s, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { e === !0 && this.version++ } } class di extends Tt { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new xe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = hf, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const es = new S, uA = new W; class nt { constructor(e, t, s) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = s === !0, this.usage = yf, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this } copyAt(e, t, s) { e *= this.itemSize, s *= t.itemSize; for (let r = 0, n = this.itemSize; r < n; r++)this.array[e + r] = t.array[s + r]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (this.itemSize === 2) for (let t = 0, s = this.count; t < s; t++)uA.fromBufferAttribute(this, t), uA.applyMatrix3(e), this.setXY(t, uA.x, uA.y); else if (this.itemSize === 3) for (let t = 0, s = this.count; t < s; t++)es.fromBufferAttribute(this, t), es.applyMatrix3(e), this.setXYZ(t, es.x, es.y, es.z); return this } applyMatrix4(e) { for (let t = 0, s = this.count; t < s; t++)es.fromBufferAttribute(this, t), es.applyMatrix4(e), this.setXYZ(t, es.x, es.y, es.z); return this } applyNormalMatrix(e) { for (let t = 0, s = this.count; t < s; t++)es.fromBufferAttribute(this, t), es.applyNormalMatrix(e), this.setXYZ(t, es.x, es.y, es.z); return this } transformDirection(e) { for (let t = 0, s = this.count; t < s; t++)es.fromBufferAttribute(this, t), es.transformDirection(e), this.setXYZ(t, es.x, es.y, es.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getX(e) { let t = this.array[e * this.itemSize]; return this.normalized && (t = Ba(t, this.array)), t } setX(e, t) { return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize] = t, this } getY(e) { let t = this.array[e * this.itemSize + 1]; return this.normalized && (t = Ba(t, this.array)), t } setY(e, t) { return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize + 1] = t, this } getZ(e) { let t = this.array[e * this.itemSize + 2]; return this.normalized && (t = Ba(t, this.array)), t } setZ(e, t) { return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize + 2] = t, this } getW(e) { let t = this.array[e * this.itemSize + 3]; return this.normalized && (t = Ba(t, this.array)), t } setW(e, t) { return this.normalized && (t = gi(t, this.array)), this.array[e * this.itemSize + 3] = t, this } setXY(e, t, s) { return e *= this.itemSize, this.normalized && (t = gi(t, this.array), s = gi(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = s, this } setXYZ(e, t, s, r) { return e *= this.itemSize, this.normalized && (t = gi(t, this.array), s = gi(s, this.array), r = gi(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = s, this.array[e + 2] = r, this } setXYZW(e, t, s, r, n) { return e *= this.itemSize, this.normalized && (t = gi(t, this.array), s = gi(s, this.array), r = gi(r, this.array), n = gi(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = s, this.array[e + 2] = r, this.array[e + 3] = n, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return this.name !== "" && (e.name = this.name), this.usage !== yf && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e } copyColorsArray() { console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.") } copyVector2sArray() { console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.") } copyVector3sArray() { console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.") } copyVector4sArray() { console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.") } } class h4 extends nt { constructor(e, t, s) { super(new Int8Array(e), t, s) } } class u4 extends nt { constructor(e, t, s) { super(new Uint8Array(e), t, s) } } class d4 extends nt { constructor(e, t, s) { super(new Uint8ClampedArray(e), t, s) } } class p4 extends nt { constructor(e, t, s) { super(new Int16Array(e), t, s) } } class Zx extends nt { constructor(e, t, s) { super(new Uint16Array(e), t, s) } } class f4 extends nt { constructor(e, t, s) { super(new Int32Array(e), t, s) } } class $x extends nt { constructor(e, t, s) { super(new Uint32Array(e), t, s) } } class g4 extends nt { constructor(e, t, s) { super(new Uint16Array(e), t, s), this.isFloat16BufferAttribute = !0 } } class et extends nt { constructor(e, t, s) { super(new Float32Array(e), t, s) } } class m4 extends nt { constructor(e, t, s) { super(new Float64Array(e), t, s) } } let v4 = 0; const _n = new He, ew = new Me, Gu = new S, $r = new er, Mf = new er, Es = new S; class yt extends ms { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: v4++ }), this.uuid = Kr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (QT(e) ? $x : Zx)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return this.attributes[e] !== void 0 } addGroup(e, t, s = 0) { this.groups.push({ start: e, count: t, materialIndex: s }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0); const s = this.attributes.normal; if (s !== void 0) { const n = new ds().getNormalMatrix(e); s.applyNormalMatrix(n), s.needsUpdate = !0 } const r = this.attributes.tangent; return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } applyQuaternion(e) { return _n.makeRotationFromQuaternion(e), this.applyMatrix4(_n), this } rotateX(e) { return _n.makeRotationX(e), this.applyMatrix4(_n), this } rotateY(e) { return _n.makeRotationY(e), this.applyMatrix4(_n), this } rotateZ(e) { return _n.makeRotationZ(e), this.applyMatrix4(_n), this } translate(e, t, s) { return _n.makeTranslation(e, t, s), this.applyMatrix4(_n), this } scale(e, t, s) { return _n.makeScale(e, t, s), this.applyMatrix4(_n), this } lookAt(e) { return ew.lookAt(e), ew.updateMatrix(), this.applyMatrix4(ew.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Gu).negate(), this.translate(Gu.x, Gu.y, Gu.z), this } setFromPoints(e) { const t = []; for (let s = 0, r = e.length; s < r; s++) { const n = e[s]; t.push(n.x, n.y, n.z || 0) } return this.setAttribute("position", new et(t, 3)), this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new er); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new S(-1 / 0, -1 / 0, -1 / 0), new S(1 / 0, 1 / 0, 1 / 0)); return } if (e !== void 0) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let s = 0, r = t.length; s < r; s++) { const n = t[s]; $r.setFromBufferAttribute(n), this.morphTargetsRelative ? (Es.addVectors(this.boundingBox.min, $r.min), this.boundingBox.expandByPoint(Es), Es.addVectors(this.boundingBox.max, $r.max), this.boundingBox.expandByPoint(Es)) : (this.boundingBox.expandByPoint($r.min), this.boundingBox.expandByPoint($r.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new Po); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new S, 1 / 0); return } if (e) { const s = this.boundingSphere.center; if ($r.setFromBufferAttribute(e), t) for (let n = 0, o = t.length; n < o; n++) { const a = t[n]; Mf.setFromBufferAttribute(a), this.morphTargetsRelative ? (Es.addVectors($r.min, Mf.min), $r.expandByPoint(Es), Es.addVectors($r.max, Mf.max), $r.expandByPoint(Es)) : ($r.expandByPoint(Mf.min), $r.expandByPoint(Mf.max)) } $r.getCenter(s); let r = 0; for (let n = 0, o = e.count; n < o; n++)Es.fromBufferAttribute(e, n), r = Math.max(r, s.distanceToSquared(Es)); if (t) for (let n = 0, o = t.length; n < o; n++) { const a = t[n], l = this.morphTargetsRelative; for (let c = 0, h = a.count; c < h; c++)Es.fromBufferAttribute(a, c), l && (Gu.fromBufferAttribute(e, c), Es.add(Gu)), r = Math.max(r, s.distanceToSquared(Es)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, t = this.attributes; if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } const s = e.array, r = t.position.array, n = t.normal.array, o = t.uv.array, a = r.length / 3; this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new nt(new Float32Array(4 * a), 4)); const l = this.getAttribute("tangent").array, c = [], h = []; for (let T = 0; T < a; T++)c[T] = new S, h[T] = new S; const d = new S, p = new S, f = new S, g = new W, m = new W, v = new W, A = new S, b = new S; function y(T, z, H) { d.fromArray(r, T * 3), p.fromArray(r, z * 3), f.fromArray(r, H * 3), g.fromArray(o, T * 2), m.fromArray(o, z * 2), v.fromArray(o, H * 2), p.sub(d), f.sub(d), m.sub(g), v.sub(g); const N = 1 / (m.x * v.y - v.x * m.y); isFinite(N) && (A.copy(p).multiplyScalar(v.y).addScaledVector(f, -m.y).multiplyScalar(N), b.copy(f).multiplyScalar(m.x).addScaledVector(p, -v.x).multiplyScalar(N), c[T].add(A), c[z].add(A), c[H].add(A), h[T].add(b), h[z].add(b), h[H].add(b)) } let _ = this.groups; _.length === 0 && (_ = [{ start: 0, count: s.length }]); for (let T = 0, z = _.length; T < z; ++T) { const H = _[T], N = H.start, F = H.count; for (let X = N, te = N + F; X < te; X += 3)y(s[X + 0], s[X + 1], s[X + 2]) } const w = new S, E = new S, P = new S, C = new S; function R(T) { P.fromArray(n, T * 3), C.copy(P); const z = c[T]; w.copy(z), w.sub(P.multiplyScalar(P.dot(z))).normalize(), E.crossVectors(C, z); const H = E.dot(h[T]) < 0 ? -1 : 1; l[T * 4] = w.x, l[T * 4 + 1] = w.y, l[T * 4 + 2] = w.z, l[T * 4 + 3] = H } for (let T = 0, z = _.length; T < z; ++T) { const H = _[T], N = H.start, F = H.count; for (let X = N, te = N + F; X < te; X += 3)R(s[X + 0]), R(s[X + 1]), R(s[X + 2]) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (t !== void 0) { let s = this.getAttribute("normal"); if (s === void 0) s = new nt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", s); else for (let p = 0, f = s.count; p < f; p++)s.setXYZ(p, 0, 0, 0); const r = new S, n = new S, o = new S, a = new S, l = new S, c = new S, h = new S, d = new S; if (e) for (let p = 0, f = e.count; p < f; p += 3) { const g = e.getX(p + 0), m = e.getX(p + 1), v = e.getX(p + 2); r.fromBufferAttribute(t, g), n.fromBufferAttribute(t, m), o.fromBufferAttribute(t, v), h.subVectors(o, n), d.subVectors(r, n), h.cross(d), a.fromBufferAttribute(s, g), l.fromBufferAttribute(s, m), c.fromBufferAttribute(s, v), a.add(h), l.add(h), c.add(h), s.setXYZ(g, a.x, a.y, a.z), s.setXYZ(m, l.x, l.y, l.z), s.setXYZ(v, c.x, c.y, c.z) } else for (let p = 0, f = t.count; p < f; p += 3)r.fromBufferAttribute(t, p + 0), n.fromBufferAttribute(t, p + 1), o.fromBufferAttribute(t, p + 2), h.subVectors(o, n), d.subVectors(r, n), h.cross(d), s.setXYZ(p + 0, h.x, h.y, h.z), s.setXYZ(p + 1, h.x, h.y, h.z), s.setXYZ(p + 2, h.x, h.y, h.z); this.normalizeNormals(), s.needsUpdate = !0 } } merge() { return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, s = e.count; t < s; t++)Es.fromBufferAttribute(e, t), Es.normalize(), e.setXYZ(t, Es.x, Es.y, Es.z) } toNonIndexed() { function e(a, l) { const c = a.array, h = a.itemSize, d = a.normalized, p = new c.constructor(l.length * h); let f = 0, g = 0; for (let m = 0, v = l.length; m < v; m++) { a.isInterleavedBufferAttribute ? f = l[m] * a.data.stride + a.offset : f = l[m] * h; for (let A = 0; A < h; A++)p[g++] = c[f++] } return new nt(p, h, d) } if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new yt, s = this.index.array, r = this.attributes; for (const a in r) { const l = r[a], c = e(l, s); t.setAttribute(a, c) } const n = this.morphAttributes; for (const a in n) { const l = [], c = n[a]; for (let h = 0, d = c.length; h < d; h++) { const p = c[h], f = e(p, s); l.push(f) } t.morphAttributes[a] = l } t.morphTargetsRelative = this.morphTargetsRelative; const o = this.groups; for (let a = 0, l = o.length; a < l; a++) { const c = o[a]; t.addGroup(c.start, c.count, c.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) { const l = this.parameters; for (const c in l) l[c] !== void 0 && (e[c] = l[c]); return e } e.data = { attributes: {} }; const t = this.index; t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const s = this.attributes; for (const l in s) { const c = s[l]; e.data.attributes[l] = c.toJSON(e.data) } const r = {}; let n = !1; for (const l in this.morphAttributes) { const c = this.morphAttributes[l], h = []; for (let d = 0, p = c.length; d < p; d++) { const f = c[d]; h.push(f.toJSON(e.data)) } h.length > 0 && (r[l] = h, n = !0) } n && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative); const o = this.groups; o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o))); const a = this.boundingSphere; return a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e } clone() { return new this.constructor().copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const s = e.index; s !== null && this.setIndex(s.clone(t)); const r = e.attributes; for (const c in r) { const h = r[c]; this.setAttribute(c, h.clone(t)) } const n = e.morphAttributes; for (const c in n) { const h = [], d = n[c]; for (let p = 0, f = d.length; p < f; p++)h.push(d[p].clone(t)); this.morphAttributes[c] = h } this.morphTargetsRelative = e.morphTargetsRelative; const o = e.groups; for (let c = 0, h = o.length; c < h; c++) { const d = o[c]; this.addGroup(d.start, d.count, d.materialIndex) } const a = e.boundingBox; a !== null && (this.boundingBox = a.clone()); const l = e.boundingSphere; return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const $T = new He, Hu = new Oa, tw = new Po, Hl = new S, Vl = new S, Wl = new S, iw = new S, sw = new S, rw = new S, dA = new S, pA = new S, fA = new S, gA = new W, mA = new W, vA = new W, nw = new S, AA = new S; class ye extends Me { constructor(e = new yt, t = new di) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const s = e[t[0]]; if (s !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let r = 0, n = s.length; r < n; r++) { const o = s[r].name || String(r); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r } } } } raycast(e, t) { const s = this.geometry, r = this.material, n = this.matrixWorld; if (r === void 0 || (s.boundingSphere === null && s.computeBoundingSphere(), tw.copy(s.boundingSphere), tw.applyMatrix4(n), e.ray.intersectsSphere(tw) === !1) || ($T.copy(n).invert(), Hu.copy(e.ray).applyMatrix4($T), s.boundingBox !== null && Hu.intersectsBox(s.boundingBox) === !1)) return; let o; const a = s.index, l = s.attributes.position, c = s.morphAttributes.position, h = s.morphTargetsRelative, d = s.attributes.uv, p = s.attributes.uv2, f = s.groups, g = s.drawRange; if (a !== null) if (Array.isArray(r)) for (let m = 0, v = f.length; m < v; m++) { const A = f[m], b = r[A.materialIndex], y = Math.max(A.start, g.start), _ = Math.min(a.count, Math.min(A.start + A.count, g.start + g.count)); for (let w = y, E = _; w < E; w += 3) { const P = a.getX(w), C = a.getX(w + 1), R = a.getX(w + 2); o = yA(this, b, e, Hu, l, c, h, d, p, P, C, R), o && (o.faceIndex = Math.floor(w / 3), o.face.materialIndex = A.materialIndex, t.push(o)) } } else { const m = Math.max(0, g.start), v = Math.min(a.count, g.start + g.count); for (let A = m, b = v; A < b; A += 3) { const y = a.getX(A), _ = a.getX(A + 1), w = a.getX(A + 2); o = yA(this, r, e, Hu, l, c, h, d, p, y, _, w), o && (o.faceIndex = Math.floor(A / 3), t.push(o)) } } else if (l !== void 0) if (Array.isArray(r)) for (let m = 0, v = f.length; m < v; m++) { const A = f[m], b = r[A.materialIndex], y = Math.max(A.start, g.start), _ = Math.min(l.count, Math.min(A.start + A.count, g.start + g.count)); for (let w = y, E = _; w < E; w += 3) { const P = w, C = w + 1, R = w + 2; o = yA(this, b, e, Hu, l, c, h, d, p, P, C, R), o && (o.faceIndex = Math.floor(w / 3), o.face.materialIndex = A.materialIndex, t.push(o)) } } else { const m = Math.max(0, g.start), v = Math.min(l.count, g.start + g.count); for (let A = m, b = v; A < b; A += 3) { const y = A, _ = A + 1, w = A + 2; o = yA(this, r, e, Hu, l, c, h, d, p, y, _, w), o && (o.faceIndex = Math.floor(A / 3), t.push(o)) } } } } function A4(i, e, t, s, r, n, o, a) { let l; if (e.side === fs ? l = s.intersectTriangle(o, n, r, !0, a) : l = s.intersectTriangle(r, n, o, e.side !== yi, a), l === null) return null; AA.copy(a), AA.applyMatrix4(i.matrixWorld); const c = t.ray.origin.distanceTo(AA); return c < t.near || c > t.far ? null : { distance: c, point: AA.clone(), object: i } } function yA(i, e, t, s, r, n, o, a, l, c, h, d) { Hl.fromBufferAttribute(r, c), Vl.fromBufferAttribute(r, h), Wl.fromBufferAttribute(r, d); const p = i.morphTargetInfluences; if (n && p) { dA.set(0, 0, 0), pA.set(0, 0, 0), fA.set(0, 0, 0); for (let g = 0, m = n.length; g < m; g++) { const v = p[g], A = n[g]; v !== 0 && (iw.fromBufferAttribute(A, c), sw.fromBufferAttribute(A, h), rw.fromBufferAttribute(A, d), o ? (dA.addScaledVector(iw, v), pA.addScaledVector(sw, v), fA.addScaledVector(rw, v)) : (dA.addScaledVector(iw.sub(Hl), v), pA.addScaledVector(sw.sub(Vl), v), fA.addScaledVector(rw.sub(Wl), v))) } Hl.add(dA), Vl.add(pA), Wl.add(fA) } i.isSkinnedMesh && (i.boneTransform(c, Hl), i.boneTransform(h, Vl), i.boneTransform(d, Wl)); const f = A4(i, e, t, s, Hl, Vl, Wl, nw); if (f) { a && (gA.fromBufferAttribute(a, c), mA.fromBufferAttribute(a, h), vA.fromBufferAttribute(a, d), f.uv = vn.getUV(nw, Hl, Vl, Wl, gA, mA, vA, new W)), l && (gA.fromBufferAttribute(l, c), mA.fromBufferAttribute(l, h), vA.fromBufferAttribute(l, d), f.uv2 = vn.getUV(nw, Hl, Vl, Wl, gA, mA, vA, new W)); const g = { a: c, b: h, c: d, normal: new S, materialIndex: 0 }; vn.getNormal(Hl, Vl, Wl, g.normal), f.face = g } return f } class pi extends yt { constructor(e = 1, t = 1, s = 1, r = 1, n = 1, o = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: s, widthSegments: r, heightSegments: n, depthSegments: o }; const a = this; r = Math.floor(r), n = Math.floor(n), o = Math.floor(o); const l = [], c = [], h = [], d = []; let p = 0, f = 0; g("z", "y", "x", -1, -1, s, t, e, o, n, 0), g("z", "y", "x", 1, -1, s, t, -e, o, n, 1), g("x", "z", "y", 1, 1, e, s, t, r, o, 2), g("x", "z", "y", 1, -1, e, s, -t, r, o, 3), g("x", "y", "z", 1, -1, e, t, s, r, n, 4), g("x", "y", "z", -1, -1, e, t, -s, r, n, 5), this.setIndex(l), this.setAttribute("position", new et(c, 3)), this.setAttribute("normal", new et(h, 3)), this.setAttribute("uv", new et(d, 2)); function g(m, v, A, b, y, _, w, E, P, C, R) { const T = _ / P, z = w / C, H = _ / 2, N = w / 2, F = E / 2, X = P + 1, te = C + 1; let re = 0, Z = 0; const fe = new S; for (let ae = 0; ae < te; ae++) { const De = ae * z - N; for (let Se = 0; Se < X; Se++) { const ie = Se * T - H; fe[m] = ie * b, fe[v] = De * y, fe[A] = F, c.push(fe.x, fe.y, fe.z), fe[m] = 0, fe[v] = 0, fe[A] = E > 0 ? 1 : -1, h.push(fe.x, fe.y, fe.z), d.push(Se / P), d.push(1 - ae / C), re += 1 } } for (let ae = 0; ae < C; ae++)for (let De = 0; De < P; De++) { const Se = p + De + X * ae, ie = p + De + X * (ae + 1), ce = p + (De + 1) + X * (ae + 1), Te = p + (De + 1) + X * ae; l.push(Se, ie, Te), l.push(ie, ce, Te), Z += 6 } a.addGroup(f, Z, R), f += Z, p += re } } static fromJSON(e) { return new pi(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function Vu(i) { const e = {}; for (const t in i) { e[t] = {}; for (const s in i[t]) { const r = i[t][s]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[t][s] = r.clone() : Array.isArray(r) ? e[t][s] = r.slice() : e[t][s] = r } } return e } function gr(i) { const e = {}; for (let t = 0; t < i.length; t++) { const s = Vu(i[t]); for (const r in s) e[r] = s[r] } return e } function y4(i) { const e = []; for (let t = 0; t < i.length; t++)e.push(i[t].clone()); return e } function eR(i) { return i.getRenderTarget() === null && i.outputEncoding === Xe ? to : vf } const ow = { clone: Vu, merge: gr }; var b4 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, _4 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`; class Vt extends Tt { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = b4, this.fragmentShader = _4, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Vu(e.uniforms), this.uniformsGroups = y4(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const r in this.uniforms) { const n = this.uniforms[r].value; n && n.isTexture ? t.uniforms[r] = { type: "t", value: n.toJSON(e).uuid } : n && n.isColor ? t.uniforms[r] = { type: "c", value: n.getHex() } : n && n.isVector2 ? t.uniforms[r] = { type: "v2", value: n.toArray() } : n && n.isVector3 ? t.uniforms[r] = { type: "v3", value: n.toArray() } : n && n.isVector4 ? t.uniforms[r] = { type: "v4", value: n.toArray() } : n && n.isMatrix3 ? t.uniforms[r] = { type: "m3", value: n.toArray() } : n && n.isMatrix4 ? t.uniforms[r] = { type: "m4", value: n.toArray() } : t.uniforms[r] = { value: n } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; const s = {}; for (const r in this.extensions) this.extensions[r] === !0 && (s[r] = !0); return Object.keys(s).length > 0 && (t.extensions = s), t } } let gh = class extends Me { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new He, this.projectionMatrix = new He, this.projectionMatrixInverse = new He } copy(i, e) { return super.copy(i, e), this.matrixWorldInverse.copy(i.matrixWorldInverse), this.projectionMatrix.copy(i.projectionMatrix), this.projectionMatrixInverse.copy(i.projectionMatrixInverse), this } getWorldDirection(i) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return i.set(-e[8], -e[9], -e[10]).normalize() } updateMatrixWorld(i) { super.updateMatrixWorld(i), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(i, e) { super.updateWorldMatrix(i, e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return new this.constructor().copy(this) } }; class Xt extends gh { constructor(e = 50, t = 1, s = .1, r = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = s, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = ku * 2 * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(hh * .5 * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return ku * 2 * Math.atan(Math.tan(hh * .5 * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, s, r, n, o) { this.aspect = e / t, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = s, this.view.offsetY = r, this.view.width = n, this.view.height = o, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(hh * .5 * this.fov) / this.zoom, s = 2 * t, r = this.aspect * s, n = -.5 * r; const o = this.view; if (this.view !== null && this.view.enabled) { const l = o.fullWidth, c = o.fullHeight; n += o.offsetX * r / l, t -= o.offsetY * s / c, r *= o.width / l, s *= o.height / c } const a = this.filmOffset; a !== 0 && (n += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(n, n + r, t, t - s, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } const Wu = -90, qu = 1; class aw extends Me { constructor(e, t, s) { super(), this.type = "CubeCamera", this.renderTarget = s; const r = new Xt(Wu, qu, e, t); r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(1, 0, 0), this.add(r); const n = new Xt(Wu, qu, e, t); n.layers = this.layers, n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), this.add(n); const o = new Xt(Wu, qu, e, t); o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(0, 1, 0), this.add(o); const a = new Xt(Wu, qu, e, t); a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(0, -1, 0), this.add(a); const l = new Xt(Wu, qu, e, t); l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l); const c = new Xt(Wu, qu, e, t); c.layers = this.layers, c.up.set(0, 1, 0), c.lookAt(0, 0, -1), this.add(c) } update(e, t) { this.parent === null && this.updateMatrixWorld(); const s = this.renderTarget, [r, n, o, a, l, c] = this.children, h = e.getRenderTarget(), d = e.toneMapping, p = e.xr.enabled; e.toneMapping = fr, e.xr.enabled = !1; const f = s.texture.generateMipmaps; s.texture.generateMipmaps = !1, e.setRenderTarget(s, 0), e.render(t, r), e.setRenderTarget(s, 1), e.render(t, n), e.setRenderTarget(s, 2), e.render(t, o), e.setRenderTarget(s, 3), e.render(t, a), e.setRenderTarget(s, 4), e.render(t, l), s.texture.generateMipmaps = f, e.setRenderTarget(s, 5), e.render(t, c), e.setRenderTarget(h), e.toneMapping = d, e.xr.enabled = p, s.texture.needsPMREMUpdate = !0 } } class If extends Nt { constructor(e, t, s, r, n, o, a, l, c, h) { e = e !== void 0 ? e : [], t = t !== void 0 ? t : Bl, super(e, t, s, r, n, o, a, l, c, h), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class bA extends ri {
  constructor(e = 1, t = {}) { super(e, e, t), this.isWebGLCubeRenderTarget = !0; const s = { width: e, height: e, depth: 1 }, r = [s, s, s, s, s, s]; this.texture = new If(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Qt } fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const s = {
      uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, r = new pi(5, 5, 5), n = new Vt({ name: "CubemapFromEquirect", uniforms: Vu(s.uniforms), vertexShader: s.vertexShader, fragmentShader: s.fragmentShader, side: fs, blending: Ri }); n.uniforms.tEquirect.value = t; const o = new ye(r, n), a = t.minFilter; return t.minFilter === eo && (t.minFilter = Qt), new aw(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
  } clear(e, t, s, r) { const n = e.getRenderTarget(); for (let o = 0; o < 6; o++)e.setRenderTarget(this, o), e.clear(t, s, r); e.setRenderTarget(n) }
} const lw = new S, x4 = new S, w4 = new ds; class xn { constructor(e = new S(1, 0, 0), t = 0) { this.isPlane = !0, this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, s, r) { return this.normal.set(e, t, s), this.constant = r, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, s) { const r = lw.subVectors(s, t).cross(x4.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(r, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) } intersectLine(e, t) { const s = e.delta(lw), r = this.normal.dot(s); if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null; const n = -(e.start.dot(this.normal) + this.constant) / r; return n < 0 || n > 1 ? null : t.copy(s).multiplyScalar(n).add(e.start) } intersectsLine(e) { const t = this.distanceToPoint(e.start), s = this.distanceToPoint(e.end); return t < 0 && s > 0 || s < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const s = t || w4.getNormalMatrix(e), r = this.coplanarPoint(lw).applyMatrix4(e), n = this.normal.applyMatrix3(s).normalize(); return this.constant = -r.dot(n), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return new this.constructor().copy(this) } } const Xu = new Po, _A = new S; class xA { constructor(e = new xn, t = new xn, s = new xn, r = new xn, n = new xn, o = new xn) { this.planes = [e, t, s, r, n, o] } set(e, t, s, r, n, o) { const a = this.planes; return a[0].copy(e), a[1].copy(t), a[2].copy(s), a[3].copy(r), a[4].copy(n), a[5].copy(o), this } copy(e) { const t = this.planes; for (let s = 0; s < 6; s++)t[s].copy(e.planes[s]); return this } setFromProjectionMatrix(e) { const t = this.planes, s = e.elements, r = s[0], n = s[1], o = s[2], a = s[3], l = s[4], c = s[5], h = s[6], d = s[7], p = s[8], f = s[9], g = s[10], m = s[11], v = s[12], A = s[13], b = s[14], y = s[15]; return t[0].setComponents(a - r, d - l, m - p, y - v).normalize(), t[1].setComponents(a + r, d + l, m + p, y + v).normalize(), t[2].setComponents(a + n, d + c, m + f, y + A).normalize(), t[3].setComponents(a - n, d - c, m - f, y - A).normalize(), t[4].setComponents(a - o, d - h, m - g, y - b).normalize(), t[5].setComponents(a + o, d + h, m + g, y + b).normalize(), this } intersectsObject(e) { const t = e.geometry; return t.boundingSphere === null && t.computeBoundingSphere(), Xu.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Xu) } intersectsSprite(e) { return Xu.center.set(0, 0, 0), Xu.radius = .7071067811865476, Xu.applyMatrix4(e.matrixWorld), this.intersectsSphere(Xu) } intersectsSphere(e) { const t = this.planes, s = e.center, r = -e.radius; for (let n = 0; n < 6; n++)if (t[n].distanceToPoint(s) < r) return !1; return !0 } intersectsBox(e) { const t = this.planes; for (let s = 0; s < 6; s++) { const r = t[s]; if (_A.x = r.normal.x > 0 ? e.max.x : e.min.x, _A.y = r.normal.y > 0 ? e.max.y : e.min.y, _A.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(_A) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let s = 0; s < 6; s++)if (t[s].distanceToPoint(e) < 0) return !1; return !0 } clone() { return new this.constructor().copy(this) } } function tR() { let i = null, e = !1, t = null, s = null; function r(n, o) { t(n, o), s = i.requestAnimationFrame(r) } return { start: function () { e !== !0 && t !== null && (s = i.requestAnimationFrame(r), e = !0) }, stop: function () { i.cancelAnimationFrame(s), e = !1 }, setAnimationLoop: function (n) { t = n }, setContext: function (n) { i = n } } } function C4(i, e) { const t = e.isWebGL2, s = new WeakMap; function r(c, h) { const d = c.array, p = c.usage, f = i.createBuffer(); i.bindBuffer(h, f), i.bufferData(h, d, p), c.onUploadCallback(); let g; if (d instanceof Float32Array) g = 5126; else if (d instanceof Uint16Array) if (c.isFloat16BufferAttribute) if (t) g = 5131; else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); else g = 5123; else if (d instanceof Int16Array) g = 5122; else if (d instanceof Uint32Array) g = 5125; else if (d instanceof Int32Array) g = 5124; else if (d instanceof Int8Array) g = 5120; else if (d instanceof Uint8Array) g = 5121; else if (d instanceof Uint8ClampedArray) g = 5121; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d); return { buffer: f, type: g, bytesPerElement: d.BYTES_PER_ELEMENT, version: c.version } } function n(c, h, d) { const p = h.array, f = h.updateRange; i.bindBuffer(d, c), f.count === -1 ? i.bufferSubData(d, 0, p) : (t ? i.bufferSubData(d, f.offset * p.BYTES_PER_ELEMENT, p, f.offset, f.count) : i.bufferSubData(d, f.offset * p.BYTES_PER_ELEMENT, p.subarray(f.offset, f.offset + f.count)), f.count = -1), h.onUploadCallback() } function o(c) { return c.isInterleavedBufferAttribute && (c = c.data), s.get(c) } function a(c) { c.isInterleavedBufferAttribute && (c = c.data); const h = s.get(c); h && (i.deleteBuffer(h.buffer), s.delete(c)) } function l(c, h) { if (c.isGLBufferAttribute) { const p = s.get(c); (!p || p.version < c.version) && s.set(c, { buffer: c.buffer, type: c.type, bytesPerElement: c.elementSize, version: c.version }); return } c.isInterleavedBufferAttribute && (c = c.data); const d = s.get(c); d === void 0 ? s.set(c, r(c, h)) : d.version < c.version && (n(d.buffer, c, h), d.version = c.version) } return { get: o, remove: a, update: l } } class ks extends yt { constructor(e = 1, t = 1, s = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: s, heightSegments: r }; const n = e / 2, o = t / 2, a = Math.floor(s), l = Math.floor(r), c = a + 1, h = l + 1, d = e / a, p = t / l, f = [], g = [], m = [], v = []; for (let A = 0; A < h; A++) { const b = A * p - o; for (let y = 0; y < c; y++) { const _ = y * d - n; g.push(_, -b, 0), m.push(0, 0, 1), v.push(y / a), v.push(1 - A / l) } } for (let A = 0; A < l; A++)for (let b = 0; b < a; b++) { const y = b + c * A, _ = b + c * (A + 1), w = b + 1 + c * (A + 1), E = b + 1 + c * A; f.push(y, _, E), f.push(_, w, E) } this.setIndex(f), this.setAttribute("position", new et(g, 3)), this.setAttribute("normal", new et(m, 3)), this.setAttribute("uv", new et(v, 2)) } static fromJSON(e) { return new ks(e.width, e.height, e.widthSegments, e.heightSegments) } } var S4 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, E4 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, M4 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, I4 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, T4 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, R4 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, P4 = "vec3 transformed = vec3( position );", B4 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, k4 = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, D4 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, O4 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, L4 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, F4 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, U4 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, N4 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, z4 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, j4 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Q4 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, G4 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, H4 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, V4 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, W4 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, q4 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, X4 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, Y4 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, J4 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, K4 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Z4 = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, $4 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, ej = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, tj = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, ij = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, sj = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, rj = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, nj = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, oj = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, aj = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, lj = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, cj = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, hj = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, uj = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, dj = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, pj = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, fj = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, gj = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, mj = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, vj = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Aj = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, yj = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, bj = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, _j = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, xj = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, wj = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, Cj = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Sj = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Ej = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, Mj = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, Ij = `#ifdef USE_MAP
#ifdef USE_MIPMAP_BIAS
        vec4 sampledDiffuseColor = texture2D( map, vUv, mipmapBias );
#else
		vec4 sampledDiffuseColor = texture2D( map, vUv, -0.5 );
#endif
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Tj = `#ifdef USE_MAP
	uniform sampler2D map;
        
#ifdef USE_MIPMAP_BIAS
    uniform float mipmapBias;
#endif
#endif`, Rj = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Pj = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Bj = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, kj = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Dj = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Oj = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, Lj = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, Fj = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, Uj = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, Nj = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, zj = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, jj = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Qj = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Gj = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, Hj = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, Vj = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, Wj = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, qj = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Xj = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Yj = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, Jj = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, Kj = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Zj = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, $j = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, eQ = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, tQ = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, iQ = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, sQ = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, rQ = `#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, nQ = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, oQ = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, aQ = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, lQ = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, cQ = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, hQ = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, uQ = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, dQ = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, pQ = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, fQ = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, gQ = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, mQ = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, vQ = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, AQ = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, yQ = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, bQ = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, _Q = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, xQ = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`; const wQ = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, CQ = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, SQ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, EQ = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, MQ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, IQ = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, TQ = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, RQ = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, PQ = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, BQ = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, kQ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, DQ = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, OQ = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, LQ = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, FQ = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, UQ = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, NQ = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, zQ = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, jQ = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, QQ = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, GQ = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, HQ = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, VQ = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, WQ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, qQ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, XQ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, YQ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, JQ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, KQ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, ZQ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, $Q = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, eG = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, tG = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, iG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, Mt = { alphamap_fragment: S4, alphamap_pars_fragment: E4, alphatest_fragment: M4, alphatest_pars_fragment: I4, aomap_fragment: T4, aomap_pars_fragment: R4, begin_vertex: P4, beginnormal_vertex: B4, bsdfs: k4, iridescence_fragment: D4, bumpmap_pars_fragment: O4, clipping_planes_fragment: L4, clipping_planes_pars_fragment: F4, clipping_planes_pars_vertex: U4, clipping_planes_vertex: N4, color_fragment: z4, color_pars_fragment: j4, color_pars_vertex: Q4, color_vertex: G4, common: H4, cube_uv_reflection_fragment: V4, defaultnormal_vertex: W4, displacementmap_pars_vertex: q4, displacementmap_vertex: X4, emissivemap_fragment: Y4, emissivemap_pars_fragment: J4, encodings_fragment: K4, encodings_pars_fragment: Z4, envmap_fragment: $4, envmap_common_pars_fragment: ej, envmap_pars_fragment: tj, envmap_pars_vertex: ij, envmap_physical_pars_fragment: fj, envmap_vertex: sj, fog_vertex: rj, fog_pars_vertex: nj, fog_fragment: oj, fog_pars_fragment: aj, gradientmap_pars_fragment: lj, lightmap_fragment: cj, lightmap_pars_fragment: hj, lights_lambert_fragment: uj, lights_lambert_pars_fragment: dj, lights_pars_begin: pj, lights_toon_fragment: gj, lights_toon_pars_fragment: mj, lights_phong_fragment: vj, lights_phong_pars_fragment: Aj, lights_physical_fragment: yj, lights_physical_pars_fragment: bj, lights_fragment_begin: _j, lights_fragment_maps: xj, lights_fragment_end: wj, logdepthbuf_fragment: Cj, logdepthbuf_pars_fragment: Sj, logdepthbuf_pars_vertex: Ej, logdepthbuf_vertex: Mj, map_fragment: Ij, map_pars_fragment: Tj, map_particle_fragment: Rj, map_particle_pars_fragment: Pj, metalnessmap_fragment: Bj, metalnessmap_pars_fragment: kj, morphcolor_vertex: Dj, morphnormal_vertex: Oj, morphtarget_pars_vertex: Lj, morphtarget_vertex: Fj, normal_fragment_begin: Uj, normal_fragment_maps: Nj, normal_pars_fragment: zj, normal_pars_vertex: jj, normal_vertex: Qj, normalmap_pars_fragment: Gj, clearcoat_normal_fragment_begin: Hj, clearcoat_normal_fragment_maps: Vj, clearcoat_pars_fragment: Wj, iridescence_pars_fragment: qj, output_fragment: Xj, packing: Yj, premultiplied_alpha_fragment: Jj, project_vertex: Kj, dithering_fragment: Zj, dithering_pars_fragment: $j, roughnessmap_fragment: eQ, roughnessmap_pars_fragment: tQ, shadowmap_pars_fragment: iQ, shadowmap_pars_vertex: sQ, shadowmap_vertex: rQ, shadowmask_pars_fragment: nQ, skinbase_vertex: oQ, skinning_pars_vertex: aQ, skinning_vertex: lQ, skinnormal_vertex: cQ, specularmap_fragment: hQ, specularmap_pars_fragment: uQ, tonemapping_fragment: dQ, tonemapping_pars_fragment: pQ, transmission_fragment: fQ, transmission_pars_fragment: gQ, uv_pars_fragment: mQ, uv_pars_vertex: vQ, uv_vertex: AQ, uv2_pars_fragment: yQ, uv2_pars_vertex: bQ, uv2_vertex: _Q, worldpos_vertex: xQ, background_vert: wQ, background_frag: CQ, backgroundCube_vert: SQ, backgroundCube_frag: EQ, cube_vert: MQ, cube_frag: IQ, depth_vert: TQ, depth_frag: RQ, distanceRGBA_vert: PQ, distanceRGBA_frag: BQ, equirect_vert: kQ, equirect_frag: DQ, linedashed_vert: OQ, linedashed_frag: LQ, meshbasic_vert: FQ, meshbasic_frag: UQ, meshlambert_vert: NQ, meshlambert_frag: zQ, meshmatcap_vert: jQ, meshmatcap_frag: QQ, meshnormal_vert: GQ, meshnormal_frag: HQ, meshphong_vert: VQ, meshphong_frag: WQ, meshphysical_vert: qQ, meshphysical_frag: XQ, meshtoon_vert: YQ, meshtoon_frag: JQ, points_vert: KQ, points_frag: ZQ, shadow_vert: $Q, shadow_frag: eG, sprite_vert: tG, sprite_frag: iG }, Ye = { common: { diffuse: { value: new xe(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new ds }, uv2Transform: { value: new ds }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new W(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new xe(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new xe(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new ds } }, sprite: { diffuse: { value: new xe(16777215) }, opacity: { value: 1 }, center: { value: new W(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new ds } } }, en = { basic: { uniforms: gr([Ye.common, Ye.specularmap, Ye.envmap, Ye.aomap, Ye.lightmap, Ye.fog]), vertexShader: Mt.meshbasic_vert, fragmentShader: Mt.meshbasic_frag }, lambert: { uniforms: gr([Ye.common, Ye.specularmap, Ye.envmap, Ye.aomap, Ye.lightmap, Ye.emissivemap, Ye.bumpmap, Ye.normalmap, Ye.displacementmap, Ye.fog, Ye.lights, { emissive: { value: new xe(0) } }]), vertexShader: Mt.meshlambert_vert, fragmentShader: Mt.meshlambert_frag }, phong: { uniforms: gr([Ye.common, Ye.specularmap, Ye.envmap, Ye.aomap, Ye.lightmap, Ye.emissivemap, Ye.bumpmap, Ye.normalmap, Ye.displacementmap, Ye.fog, Ye.lights, { emissive: { value: new xe(0) }, specular: { value: new xe(1118481) }, shininess: { value: 30 } }]), vertexShader: Mt.meshphong_vert, fragmentShader: Mt.meshphong_frag }, standard: { uniforms: gr([Ye.common, Ye.envmap, Ye.aomap, Ye.lightmap, Ye.emissivemap, Ye.bumpmap, Ye.normalmap, Ye.displacementmap, Ye.roughnessmap, Ye.metalnessmap, Ye.fog, Ye.lights, { emissive: { value: new xe(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Mt.meshphysical_vert, fragmentShader: Mt.meshphysical_frag }, toon: { uniforms: gr([Ye.common, Ye.aomap, Ye.lightmap, Ye.emissivemap, Ye.bumpmap, Ye.normalmap, Ye.displacementmap, Ye.gradientmap, Ye.fog, Ye.lights, { emissive: { value: new xe(0) } }]), vertexShader: Mt.meshtoon_vert, fragmentShader: Mt.meshtoon_frag }, matcap: { uniforms: gr([Ye.common, Ye.bumpmap, Ye.normalmap, Ye.displacementmap, Ye.fog, { matcap: { value: null } }]), vertexShader: Mt.meshmatcap_vert, fragmentShader: Mt.meshmatcap_frag }, points: { uniforms: gr([Ye.points, Ye.fog]), vertexShader: Mt.points_vert, fragmentShader: Mt.points_frag }, dashed: { uniforms: gr([Ye.common, Ye.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Mt.linedashed_vert, fragmentShader: Mt.linedashed_frag }, depth: { uniforms: gr([Ye.common, Ye.displacementmap]), vertexShader: Mt.depth_vert, fragmentShader: Mt.depth_frag }, normal: { uniforms: gr([Ye.common, Ye.bumpmap, Ye.normalmap, Ye.displacementmap, { opacity: { value: 1 } }]), vertexShader: Mt.meshnormal_vert, fragmentShader: Mt.meshnormal_frag }, sprite: { uniforms: gr([Ye.sprite, Ye.fog]), vertexShader: Mt.sprite_vert, fragmentShader: Mt.sprite_frag }, background: { uniforms: { uvTransform: { value: new ds }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Mt.background_vert, fragmentShader: Mt.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: Mt.backgroundCube_vert, fragmentShader: Mt.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Mt.cube_vert, fragmentShader: Mt.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Mt.equirect_vert, fragmentShader: Mt.equirect_frag }, distanceRGBA: { uniforms: gr([Ye.common, Ye.displacementmap, { referencePosition: { value: new S }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Mt.distanceRGBA_vert, fragmentShader: Mt.distanceRGBA_frag }, shadow: { uniforms: gr([Ye.lights, Ye.fog, { color: { value: new xe(0) }, opacity: { value: 1 } }]), vertexShader: Mt.shadow_vert, fragmentShader: Mt.shadow_frag } }; en.physical = { uniforms: gr([en.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new W(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new xe(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new W }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new xe(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new xe(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: Mt.meshphysical_vert, fragmentShader: Mt.meshphysical_frag }; const wA = { r: 0, b: 0, g: 0 }; function sG(i, e, t, s, r, n, o) { const a = new xe(0); let l = n === !0 ? 0 : 1, c, h, d = null, p = 0, f = null; function g(v, A) { let b = !1, y = A.isScene === !0 ? A.background : null; y && y.isTexture && (y = (A.backgroundBlurriness > 0 ? t : e).get(y)); const _ = i.xr, w = _.getSession && _.getSession(); w && w.environmentBlendMode === "additive" && (y = null), y === null ? m(a, l) : y && y.isColor && (m(y, 1), b = !0), (i.autoClear || b) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), y && (y.isCubeTexture || y.mapping === Ru) ? (h === void 0 && (h = new ye(new pi(1, 1, 1), new Vt({ name: "BackgroundCubeMaterial", uniforms: Vu(en.backgroundCube.uniforms), vertexShader: en.backgroundCube.vertexShader, fragmentShader: en.backgroundCube.fragmentShader, side: fs, depthTest: !1, depthWrite: !1, fog: !1 })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function (E, P, C) { this.matrixWorld.copyPosition(C.matrixWorld) }, Object.defineProperty(h.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(h)), h.material.uniforms.envMap.value = y, h.material.uniforms.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = A.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, (d !== y || p !== y.version || f !== i.toneMapping) && (h.material.needsUpdate = !0, d = y, p = y.version, f = i.toneMapping), h.layers.enableAll(), v.unshift(h, h.geometry, h.material, 0, 0, null)) : y && y.isTexture && (c === void 0 && (c = new ye(new ks(2, 2), new Vt({ name: "BackgroundMaterial", uniforms: Vu(en.background.uniforms), vertexShader: en.background.vertexShader, fragmentShader: en.background.fragmentShader, side: pr, depthTest: !1, depthWrite: !1, fog: !1 })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(c)), c.material.uniforms.t2D.value = y, c.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, y.matrixAutoUpdate === !0 && y.updateMatrix(), c.material.uniforms.uvTransform.value.copy(y.matrix), (d !== y || p !== y.version || f !== i.toneMapping) && (c.material.needsUpdate = !0, d = y, p = y.version, f = i.toneMapping), c.layers.enableAll(), v.unshift(c, c.geometry, c.material, 0, 0, null)) } function m(v, A) { v.getRGB(wA, eR(i)), s.buffers.color.setClear(wA.r, wA.g, wA.b, A, o) } return { getClearColor: function () { return a }, setClearColor: function (v, A = 1) { a.set(v), l = A, m(a, l) }, getClearAlpha: function () { return l }, setClearAlpha: function (v) { l = v, m(a, l) }, render: g } } function rG(i, e, t, s) { const r = i.getParameter(34921), n = s.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = s.isWebGL2 || n !== null, a = {}, l = v(null); let c = l, h = !1; function d(F, X, te, re, Z) { let fe = !1; if (o) { const ae = m(re, te, X); c !== ae && (c = ae, f(c.object)), fe = A(F, re, te, Z), fe && b(F, re, te, Z) } else { const ae = X.wireframe === !0; (c.geometry !== re.id || c.program !== te.id || c.wireframe !== ae) && (c.geometry = re.id, c.program = te.id, c.wireframe = ae, fe = !0) } Z !== null && t.update(Z, 34963), (fe || h) && (h = !1, C(F, X, te, re), Z !== null && i.bindBuffer(34963, t.get(Z).buffer)) } function p() { return s.isWebGL2 ? i.createVertexArray() : n.createVertexArrayOES() } function f(F) { return s.isWebGL2 ? i.bindVertexArray(F) : n.bindVertexArrayOES(F) } function g(F) { return s.isWebGL2 ? i.deleteVertexArray(F) : n.deleteVertexArrayOES(F) } function m(F, X, te) { const re = te.wireframe === !0; let Z = a[F.id]; Z === void 0 && (Z = {}, a[F.id] = Z); let fe = Z[X.id]; fe === void 0 && (fe = {}, Z[X.id] = fe); let ae = fe[re]; return ae === void 0 && (ae = v(p()), fe[re] = ae), ae } function v(F) { const X = [], te = [], re = []; for (let Z = 0; Z < r; Z++)X[Z] = 0, te[Z] = 0, re[Z] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: X, enabledAttributes: te, attributeDivisors: re, object: F, attributes: {}, index: null } } function A(F, X, te, re) { const Z = c.attributes, fe = X.attributes; let ae = 0; const De = te.getAttributes(); for (const Se in De) if (De[Se].location >= 0) { const ie = Z[Se]; let ce = fe[Se]; if (ce === void 0 && (Se === "instanceMatrix" && F.instanceMatrix && (ce = F.instanceMatrix), Se === "instanceColor" && F.instanceColor && (ce = F.instanceColor)), ie === void 0 || ie.attribute !== ce || ce && ie.data !== ce.data) return !0; ae++ } return c.attributesNum !== ae || c.index !== re } function b(F, X, te, re) { const Z = {}, fe = X.attributes; let ae = 0; const De = te.getAttributes(); for (const Se in De) if (De[Se].location >= 0) { let ie = fe[Se]; ie === void 0 && (Se === "instanceMatrix" && F.instanceMatrix && (ie = F.instanceMatrix), Se === "instanceColor" && F.instanceColor && (ie = F.instanceColor)); const ce = {}; ce.attribute = ie, ie && ie.data && (ce.data = ie.data), Z[Se] = ce, ae++ } c.attributes = Z, c.attributesNum = ae, c.index = re } function y() { const F = c.newAttributes; for (let X = 0, te = F.length; X < te; X++)F[X] = 0 } function _(F) { w(F, 0) } function w(F, X) { const te = c.newAttributes, re = c.enabledAttributes, Z = c.attributeDivisors; te[F] = 1, re[F] === 0 && (i.enableVertexAttribArray(F), re[F] = 1), Z[F] !== X && ((s.isWebGL2 ? i : e.get("ANGLE_instanced_arrays"))[s.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](F, X), Z[F] = X) } function E() { const F = c.newAttributes, X = c.enabledAttributes; for (let te = 0, re = X.length; te < re; te++)X[te] !== F[te] && (i.disableVertexAttribArray(te), X[te] = 0) } function P(F, X, te, re, Z, fe) { s.isWebGL2 === !0 && (te === 5124 || te === 5125) ? i.vertexAttribIPointer(F, X, te, Z, fe) : i.vertexAttribPointer(F, X, te, re, Z, fe) } function C(F, X, te, re) { if (s.isWebGL2 === !1 && (F.isInstancedMesh || re.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return; y(); const Z = re.attributes, fe = te.getAttributes(), ae = X.defaultAttributeValues; for (const De in fe) { const Se = fe[De]; if (Se.location >= 0) { let ie = Z[De]; if (ie === void 0 && (De === "instanceMatrix" && F.instanceMatrix && (ie = F.instanceMatrix), De === "instanceColor" && F.instanceColor && (ie = F.instanceColor)), ie !== void 0) { const ce = ie.normalized, Te = ie.itemSize, K = t.get(ie); if (K === void 0) continue; const je = K.buffer, Ue = K.type, Pe = K.bytesPerElement; if (ie.isInterleavedBufferAttribute) { const ve = ie.data, de = ve.stride, Ae = ie.offset; if (ve.isInstancedInterleavedBuffer) { for (let pe = 0; pe < Se.locationSize; pe++)w(Se.location + pe, ve.meshPerAttribute); F.isInstancedMesh !== !0 && re._maxInstanceCount === void 0 && (re._maxInstanceCount = ve.meshPerAttribute * ve.count) } else for (let pe = 0; pe < Se.locationSize; pe++)_(Se.location + pe); i.bindBuffer(34962, je); for (let pe = 0; pe < Se.locationSize; pe++)P(Se.location + pe, Te / Se.locationSize, Ue, ce, de * Pe, (Ae + Te / Se.locationSize * pe) * Pe) } else { if (ie.isInstancedBufferAttribute) { for (let ve = 0; ve < Se.locationSize; ve++)w(Se.location + ve, ie.meshPerAttribute); F.isInstancedMesh !== !0 && re._maxInstanceCount === void 0 && (re._maxInstanceCount = ie.meshPerAttribute * ie.count) } else for (let ve = 0; ve < Se.locationSize; ve++)_(Se.location + ve); i.bindBuffer(34962, je); for (let ve = 0; ve < Se.locationSize; ve++)P(Se.location + ve, Te / Se.locationSize, Ue, ce, Te * Pe, Te / Se.locationSize * ve * Pe) } } else if (ae !== void 0) { const ce = ae[De]; if (ce !== void 0) switch (ce.length) { case 2: i.vertexAttrib2fv(Se.location, ce); break; case 3: i.vertexAttrib3fv(Se.location, ce); break; case 4: i.vertexAttrib4fv(Se.location, ce); break; default: i.vertexAttrib1fv(Se.location, ce) } } } } E() } function R() { H(); for (const F in a) { const X = a[F]; for (const te in X) { const re = X[te]; for (const Z in re) g(re[Z].object), delete re[Z]; delete X[te] } delete a[F] } } function T(F) { if (a[F.id] === void 0) return; const X = a[F.id]; for (const te in X) { const re = X[te]; for (const Z in re) g(re[Z].object), delete re[Z]; delete X[te] } delete a[F.id] } function z(F) { for (const X in a) { const te = a[X]; if (te[F.id] === void 0) continue; const re = te[F.id]; for (const Z in re) g(re[Z].object), delete re[Z]; delete te[F.id] } } function H() { N(), h = !0, c !== l && (c = l, f(c.object)) } function N() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: d, reset: H, resetDefaultState: N, dispose: R, releaseStatesOfGeometry: T, releaseStatesOfProgram: z, initAttributes: y, enableAttribute: _, disableUnusedAttributes: E } } function nG(i, e, t, s) { const r = s.isWebGL2; let n; function o(c) { n = c } function a(c, h) { i.drawArrays(n, c, h), t.update(h, n, 1) } function l(c, h, d) { if (d === 0) return; let p, f; if (r) p = i, f = "drawArraysInstanced"; else if (p = e.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", p === null) { console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } p[f](n, c, h, d), t.update(h, n, d) } this.setMode = o, this.render = a, this.renderInstances = l } function oG(i, e, t) { let s; function r() { if (s !== void 0) return s; if (e.has("EXT_texture_filter_anisotropic") === !0) { const P = e.get("EXT_texture_filter_anisotropic"); s = i.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else s = 0; return s } function n(P) { if (P === "highp") { if (i.getShaderPrecisionFormat(35633, 36338).precision > 0 && i.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; P = "mediump" } return P === "mediump" && i.getShaderPrecisionFormat(35633, 36337).precision > 0 && i.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const o = typeof WebGL2RenderingContext < "u" && i instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && i instanceof WebGL2ComputeRenderingContext; let a = t.precision !== void 0 ? t.precision : "highp"; const l = n(a); l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l); const c = o || e.has("WEBGL_draw_buffers"), h = t.logarithmicDepthBuffer === !0, d = i.getParameter(34930), p = i.getParameter(35660), f = i.getParameter(3379), g = i.getParameter(34076), m = i.getParameter(34921), v = i.getParameter(36347), A = i.getParameter(36348), b = i.getParameter(36349), y = p > 0, _ = o || e.has("OES_texture_float"), w = y && _, E = o ? i.getParameter(36183) : 0; return { isWebGL2: o, drawBuffers: c, getMaxAnisotropy: r, getMaxPrecision: n, precision: a, logarithmicDepthBuffer: h, maxTextures: d, maxVertexTextures: p, maxTextureSize: f, maxCubemapSize: g, maxAttributes: m, maxVertexUniforms: v, maxVaryings: A, maxFragmentUniforms: b, vertexTextures: y, floatFragmentTextures: _, floatVertexTextures: w, maxSamples: E } } function aG(i) { const e = this; let t = null, s = 0, r = !1, n = !1; const o = new xn, a = new ds, l = { value: null, needsUpdate: !1 }; this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (d, p, f) { const g = d.length !== 0 || p || s !== 0 || r; return r = p, t = h(d, f, 0), s = d.length, g }, this.beginShadows = function () { n = !0, h(null) }, this.endShadows = function () { n = !1, c() }, this.setState = function (d, p, f) { const g = d.clippingPlanes, m = d.clipIntersection, v = d.clipShadows, A = i.get(d); if (!r || g === null || g.length === 0 || n && !v) n ? h(null) : c(); else { const b = n ? 0 : s, y = b * 4; let _ = A.clippingState || null; l.value = _, _ = h(g, p, y, f); for (let w = 0; w !== y; ++w)_[w] = t[w]; A.clippingState = _, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += b } }; function c() { l.value !== t && (l.value = t, l.needsUpdate = s > 0), e.numPlanes = s, e.numIntersection = 0 } function h(d, p, f, g) { const m = d !== null ? d.length : 0; let v = null; if (m !== 0) { if (v = l.value, g !== !0 || v === null) { const A = f + m * 4, b = p.matrixWorldInverse; a.getNormalMatrix(b), (v === null || v.length < A) && (v = new Float32Array(A)); for (let y = 0, _ = f; y !== m; ++y, _ += 4)o.copy(d[y]).applyMatrix4(b, a), o.normal.toArray(v, _), v[_ + 3] = o.constant } l.value = v, l.needsUpdate = !0 } return e.numPlanes = m, e.numIntersection = 0, v } } function lG(i) { let e = new WeakMap; function t(o, a) { return a === An ? o.mapping = Bl : a === Tu && (o.mapping = kl), o } function s(o) { if (o && o.isTexture && o.isRenderTargetTexture === !1) { const a = o.mapping; if (a === An || a === Tu) if (e.has(o)) { const l = e.get(o).texture; return t(l, o.mapping) } else { const l = o.image; if (l && l.height > 0) { const c = new bA(l.height / 2); return c.fromEquirectangularTexture(i, o), e.set(o, c), o.addEventListener("dispose", r), t(c.texture, o.mapping) } else return null } } return o } function r(o) { const a = o.target; a.removeEventListener("dispose", r); const l = e.get(a); l !== void 0 && (e.delete(a), l.dispose()) } function n() { e = new WeakMap } return { get: s, dispose: n } } class Yu extends gh { constructor(e = -1, t = 1, s = 1, r = -1, n = .1, o = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = s, this.bottom = r, this.near = n, this.far = o, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this } setViewOffset(e, t, s, r, n, o) { this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = s, this.view.offsetY = r, this.view.width = n, this.view.height = o, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), s = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let n = s - e, o = s + e, a = r + t, l = r - t; if (this.view !== null && this.view.enabled) { const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom; n += c * this.view.offsetX, o = n + c * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height } this.projectionMatrix.makeOrthographic(n, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t } } const Ju = 4, iR = [.125, .215, .35, .446, .526, .582], mh = 20, cw = new Yu, sR = new xe; let hw = null; const vh = (1 + Math.sqrt(5)) / 2, Ku = 1 / vh, rR = [new S(1, 1, 1), new S(-1, 1, 1), new S(1, 1, -1), new S(-1, 1, -1), new S(0, vh, Ku), new S(0, vh, -Ku), new S(Ku, 0, vh), new S(-Ku, 0, vh), new S(vh, Ku, 0), new S(-vh, Ku, 0)]; class uw { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, s = .1, r = 100) { hw = this._renderer.getRenderTarget(), this._setSize(256); const n = this._allocateTargets(); return n.depthBuffer = !0, this._sceneToCubeUV(e, s, r, n), t > 0 && this._blur(n, 0, 0, t), this._applyPMREM(n), this._cleanup(n), n } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { this._cubemapMaterial === null && (this._cubemapMaterial = lR(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { this._equirectMaterial === null && (this._equirectMaterial = aR(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(hw), e.scissorTest = !1, CA(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === Bl || e.mapping === kl ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), hw = this._renderer.getRenderTarget(); const s = t || this._allocateTargets(); return this._textureToCubeUV(e, s), this._applyPMREM(s), this._cleanup(s), s } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, s = { magFilter: Qt, minFilter: Qt, generateMipmaps: !1, type: gs, format: _i, encoding: Qi, depthBuffer: !1 }, r = oR(e, t, s), { _lodMax: n } = this; if ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = nR(n), this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) { this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = oR(e, t, s); const { _lodMax: o } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = nR(o)), this._blurMaterial = cG(o, e, t) } return r } _compileMaterial(e) { const t = new ye(this._lodPlanes[0], e); this._renderer.compile(t, cw) } _sceneToCubeUV(e, t, s, r) { const n = new Xt(90, 1, t, s), o = [1, -1, 1, 1, 1, 1], a = [1, 1, 1, -1, -1, -1], l = this._renderer, c = l.autoClear, h = l.toneMapping; l.getClearColor(sR), l.toneMapping = fr, l.autoClear = !1; const d = new di({ name: "PMREM.Background", side: fs, depthWrite: !1, depthTest: !1 }), p = new ye(new pi, d); let f = !1; const g = e.background; g ? g.isColor && (d.color.copy(g), e.background = null, f = !0) : (d.color.copy(sR), f = !0); for (let m = 0; m < 6; m++) { const v = m % 3; v === 0 ? (n.up.set(0, o[m], 0), n.lookAt(a[m], 0, 0)) : v === 1 ? (n.up.set(0, 0, o[m]), n.lookAt(0, a[m], 0)) : (n.up.set(0, o[m], 0), n.lookAt(0, 0, a[m])); const A = this._cubeSize; CA(r, v * A, m > 2 ? A : 0, A, A), l.setRenderTarget(r), f && l.render(p, n), l.render(e, n) } p.geometry.dispose(), p.material.dispose(), l.toneMapping = h, l.autoClear = c, e.background = g } _textureToCubeUV(e, t) { const s = this._renderer, r = e.mapping === Bl || e.mapping === kl; r ? (this._cubemapMaterial === null && (this._cubemapMaterial = lR()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = aR()); const n = r ? this._cubemapMaterial : this._equirectMaterial, o = new ye(this._lodPlanes[0], n), a = n.uniforms; a.envMap.value = e; const l = this._cubeSize; CA(t, 0, 0, 3 * l, 2 * l), s.setRenderTarget(t), s.render(o, cw) } _applyPMREM(e) { const t = this._renderer, s = t.autoClear; t.autoClear = !1; for (let r = 1; r < this._lodPlanes.length; r++) { const n = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = rR[(r - 1) % rR.length]; this._blur(e, r - 1, r, n, o) } t.autoClear = s } _blur(e, t, s, r, n) { const o = this._pingPongRenderTarget; this._halfBlur(e, o, t, s, r, "latitudinal", n), this._halfBlur(o, e, s, s, r, "longitudinal", n) } _halfBlur(e, t, s, r, n, o, a) { const l = this._renderer, c = this._blurMaterial; o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!"); const h = 3, d = new ye(this._lodPlanes[r], c), p = c.uniforms, f = this._sizeLods[s] - 1, g = isFinite(n) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * mh - 1), m = n / g, v = isFinite(n) ? 1 + Math.floor(h * m) : mh; v > mh && console.warn(`sigmaRadians, ${n}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${mh}`); const A = []; let b = 0; for (let P = 0; P < mh; ++P) { const C = P / m, R = Math.exp(-C * C / 2); A.push(R), P === 0 ? b += R : P < v && (b += 2 * R) } for (let P = 0; P < A.length; P++)A[P] = A[P] / b; p.envMap.value = e.texture, p.samples.value = v, p.weights.value = A, p.latitudinal.value = o === "latitudinal", a && (p.poleAxis.value = a); const { _lodMax: y } = this; p.dTheta.value = g, p.mipInt.value = y - s; const _ = this._sizeLods[r], w = 3 * _ * (r > y - Ju ? r - y + Ju : 0), E = 4 * (this._cubeSize - _); CA(t, w, E, 3 * _, 2 * _), l.setRenderTarget(t), l.render(d, cw) } } function nR(i) { const e = [], t = [], s = []; let r = i; const n = i - Ju + 1 + iR.length; for (let o = 0; o < n; o++) { const a = Math.pow(2, r); t.push(a); let l = 1 / a; o > i - Ju ? l = iR[o - i + Ju - 1] : o === 0 && (l = 0), s.push(l); const c = 1 / (a - 2), h = -c, d = 1 + c, p = [h, h, d, h, d, d, h, h, d, d, h, d], f = 6, g = 6, m = 3, v = 2, A = 1, b = new Float32Array(m * g * f), y = new Float32Array(v * g * f), _ = new Float32Array(A * g * f); for (let E = 0; E < f; E++) { const P = E % 3 * 2 / 3 - 1, C = E > 2 ? 0 : -1, R = [P, C, 0, P + 2 / 3, C, 0, P + 2 / 3, C + 1, 0, P, C, 0, P + 2 / 3, C + 1, 0, P, C + 1, 0]; b.set(R, m * g * E), y.set(p, v * g * E); const T = [E, E, E, E, E, E]; _.set(T, A * g * E) } const w = new yt; w.setAttribute("position", new nt(b, m)), w.setAttribute("uv", new nt(y, v)), w.setAttribute("faceIndex", new nt(_, A)), e.push(w), r > Ju && r-- } return { lodPlanes: e, sizeLods: t, sigmas: s } } function oR(i, e, t) { const s = new ri(i, e, t); return s.texture.mapping = Ru, s.texture.name = "PMREM.cubeUv", s.scissorTest = !0, s } function CA(i, e, t, s, r) { i.viewport.set(e, t, s, r), i.scissor.set(e, t, s, r) } function cG(i, e, t) {
  const s = new Float32Array(mh), r = new S(0, 1, 0); return new Vt({
    name: "SphericalGaussianBlur", defines: { n: mh, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${i}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: s }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: dw(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: Ri, depthTest: !1, depthWrite: !1
  })
} function aR() {
  return new Vt({
    name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: dw(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: Ri, depthTest: !1, depthWrite: !1
  })
} function lR() {
  return new Vt({
    name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: dw(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: Ri, depthTest: !1, depthWrite: !1
  })
} function dw() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function hG(i) { let e = new WeakMap, t = null; function s(a) { if (a && a.isTexture) { const l = a.mapping, c = l === An || l === Tu, h = l === Bl || l === kl; if (c || h) if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) { a.needsPMREMUpdate = !1; let d = e.get(a); return t === null && (t = new uw(i)), d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), e.set(a, d), d.texture } else { if (e.has(a)) return e.get(a).texture; { const d = a.image; if (c && d && d.height > 0 || h && d && r(d)) { t = new uw(i); const p = c ? t.fromEquirectangular(a) : t.fromCubemap(a); return e.set(a, p), a.addEventListener("dispose", n), p.texture } else return null } } } return a } function r(a) { let l = 0; const c = 6; for (let h = 0; h < c; h++)a[h] !== void 0 && l++; return l === c } function n(a) { const l = a.target; l.removeEventListener("dispose", n); const c = e.get(l); c !== void 0 && (e.delete(l), c.dispose()) } function o() { e = new WeakMap, t !== null && (t.dispose(), t = null) } return { get: s, dispose: o } } function uG(i) { const e = {}; function t(s) { if (e[s] !== void 0) return e[s]; let r; switch (s) { case "WEBGL_depth_texture": r = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = i.getExtension(s) }return e[s] = r, r } return { has: function (s) { return t(s) !== null }, init: function (s) { s.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture") }, get: function (s) { const r = t(s); return r === null && console.warn("THREE.WebGLRenderer: " + s + " extension not supported."), r } } } function dG(i, e, t, s) { const r = {}, n = new WeakMap; function o(d) { const p = d.target; p.index !== null && e.remove(p.index); for (const g in p.attributes) e.remove(p.attributes[g]); p.removeEventListener("dispose", o), delete r[p.id]; const f = n.get(p); f && (e.remove(f), n.delete(p)), s.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, t.memory.geometries-- } function a(d, p) { return r[p.id] === !0 || (p.addEventListener("dispose", o), r[p.id] = !0, t.memory.geometries++), p } function l(d) { const p = d.attributes; for (const g in p) e.update(p[g], 34962); const f = d.morphAttributes; for (const g in f) { const m = f[g]; for (let v = 0, A = m.length; v < A; v++)e.update(m[v], 34962) } } function c(d) { const p = [], f = d.index, g = d.attributes.position; let m = 0; if (f !== null) { const b = f.array; m = f.version; for (let y = 0, _ = b.length; y < _; y += 3) { const w = b[y + 0], E = b[y + 1], P = b[y + 2]; p.push(w, E, E, P, P, w) } } else { const b = g.array; m = g.version; for (let y = 0, _ = b.length / 3 - 1; y < _; y += 3) { const w = y + 0, E = y + 1, P = y + 2; p.push(w, E, E, P, P, w) } } const v = new (QT(p) ? $x : Zx)(p, 1); v.version = m; const A = n.get(d); A && e.remove(A), n.set(d, v) } function h(d) { const p = n.get(d); if (p) { const f = d.index; f !== null && p.version < f.version && c(d) } else c(d); return n.get(d) } return { get: a, update: l, getWireframeAttribute: h } } function pG(i, e, t, s) { const r = s.isWebGL2; let n; function o(p) { n = p } let a, l; function c(p) { a = p.type, l = p.bytesPerElement } function h(p, f) { i.drawElements(n, f, a, p * l), t.update(f, n, 1) } function d(p, f, g) { if (g === 0) return; let m, v; if (r) m = i, v = "drawElementsInstanced"; else if (m = e.get("ANGLE_instanced_arrays"), v = "drawElementsInstancedANGLE", m === null) { console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } m[v](n, f, a, p * l, g), t.update(f, n, g) } this.setMode = o, this.setIndex = c, this.render = h, this.renderInstances = d } function fG(i) { const e = { geometries: 0, textures: 0 }, t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; function s(n, o, a) { switch (t.calls++, o) { case 4: t.triangles += a * (n / 3); break; case 1: t.lines += a * (n / 2); break; case 3: t.lines += a * (n - 1); break; case 2: t.lines += a * n; break; case 0: t.points += a * n; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", o); break } } function r() { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 } return { memory: e, render: t, programs: null, autoReset: !0, reset: r, update: s } } function gG(i, e) { return i[0] - e[0] } function mG(i, e) { return Math.abs(e[1]) - Math.abs(i[1]) } function vG(i, e, t) { const s = {}, r = new Float32Array(8), n = new WeakMap, o = new st, a = []; for (let c = 0; c < 8; c++)a[c] = [c, 0]; function l(c, h, d, p) { const f = c.morphTargetInfluences; if (e.isWebGL2 === !0) { const g = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, m = g !== void 0 ? g.length : 0; let v = n.get(h); if (v === void 0 || v.count !== m) { let y = function () { F.dispose(), n.delete(h), h.removeEventListener("dispose", y) }; v !== void 0 && v.texture.dispose(); const _ = h.morphAttributes.position !== void 0, w = h.morphAttributes.normal !== void 0, E = h.morphAttributes.color !== void 0, P = h.morphAttributes.position || [], C = h.morphAttributes.normal || [], R = h.morphAttributes.color || []; let T = 0; _ === !0 && (T = 1), w === !0 && (T = 2), E === !0 && (T = 3); let z = h.attributes.position.count * T, H = 1; z > e.maxTextureSize && (H = Math.ceil(z / e.maxTextureSize), z = e.maxTextureSize); const N = new Float32Array(z * H * 4 * m), F = new xf(N, z, H, m); F.type = $i, F.needsUpdate = !0; const X = T * 4; for (let te = 0; te < m; te++) { const re = P[te], Z = C[te], fe = R[te], ae = z * H * 4 * te; for (let De = 0; De < re.count; De++) { const Se = De * X; _ === !0 && (o.fromBufferAttribute(re, De), N[ae + Se + 0] = o.x, N[ae + Se + 1] = o.y, N[ae + Se + 2] = o.z, N[ae + Se + 3] = 0), w === !0 && (o.fromBufferAttribute(Z, De), N[ae + Se + 4] = o.x, N[ae + Se + 5] = o.y, N[ae + Se + 6] = o.z, N[ae + Se + 7] = 0), E === !0 && (o.fromBufferAttribute(fe, De), N[ae + Se + 8] = o.x, N[ae + Se + 9] = o.y, N[ae + Se + 10] = o.z, N[ae + Se + 11] = fe.itemSize === 4 ? o.w : 1) } } v = { count: m, texture: F, size: new W(z, H) }, n.set(h, v), h.addEventListener("dispose", y) } let A = 0; for (let y = 0; y < f.length; y++)A += f[y]; const b = h.morphTargetsRelative ? 1 : 1 - A; p.getUniforms().setValue(i, "morphTargetBaseInfluence", b), p.getUniforms().setValue(i, "morphTargetInfluences", f), p.getUniforms().setValue(i, "morphTargetsTexture", v.texture, t), p.getUniforms().setValue(i, "morphTargetsTextureSize", v.size) } else { const g = f === void 0 ? 0 : f.length; let m = s[h.id]; if (m === void 0 || m.length !== g) { m = []; for (let _ = 0; _ < g; _++)m[_] = [_, 0]; s[h.id] = m } for (let _ = 0; _ < g; _++) { const w = m[_]; w[0] = _, w[1] = f[_] } m.sort(mG); for (let _ = 0; _ < 8; _++)_ < g && m[_][1] ? (a[_][0] = m[_][0], a[_][1] = m[_][1]) : (a[_][0] = Number.MAX_SAFE_INTEGER, a[_][1] = 0); a.sort(gG); const v = h.morphAttributes.position, A = h.morphAttributes.normal; let b = 0; for (let _ = 0; _ < 8; _++) { const w = a[_], E = w[0], P = w[1]; E !== Number.MAX_SAFE_INTEGER && P ? (v && h.getAttribute("morphTarget" + _) !== v[E] && h.setAttribute("morphTarget" + _, v[E]), A && h.getAttribute("morphNormal" + _) !== A[E] && h.setAttribute("morphNormal" + _, A[E]), r[_] = P, b += P) : (v && h.hasAttribute("morphTarget" + _) === !0 && h.deleteAttribute("morphTarget" + _), A && h.hasAttribute("morphNormal" + _) === !0 && h.deleteAttribute("morphNormal" + _), r[_] = 0) } const y = h.morphTargetsRelative ? 1 : 1 - b; p.getUniforms().setValue(i, "morphTargetBaseInfluence", y), p.getUniforms().setValue(i, "morphTargetInfluences", r) } } return { update: l } } function AG(i, e, t, s) { let r = new WeakMap; function n(l) { const c = s.render.frame, h = l.geometry, d = e.get(l, h); return r.get(d) !== c && (e.update(d), r.set(d, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), t.update(l.instanceMatrix, 34962), l.instanceColor !== null && t.update(l.instanceColor, 34962)), d } function o() { r = new WeakMap } function a(l) { const c = l.target; c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor) } return { update: n, dispose: o } } const cR = new Nt, hR = new xf, uR = new wf, dR = new If, pR = [], fR = [], gR = new Float32Array(16), mR = new Float32Array(9), vR = new Float32Array(4); function Zu(i, e, t) { const s = i[0]; if (s <= 0 || s > 0) return i; const r = e * t; let n = pR[r]; if (n === void 0 && (n = new Float32Array(r), pR[r] = n), e !== 0) { s.toArray(n, 0); for (let o = 1, a = 0; o !== e; ++o)a += t, i[o].toArray(n, a) } return n } function As(i, e) { if (i.length !== e.length) return !1; for (let t = 0, s = i.length; t < s; t++)if (i[t] !== e[t]) return !1; return !0 } function ys(i, e) { for (let t = 0, s = e.length; t < s; t++)i[t] = e[t] } function SA(i, e) { let t = fR[e]; t === void 0 && (t = new Int32Array(e), fR[e] = t); for (let s = 0; s !== e; ++s)t[s] = i.allocateTextureUnit(); return t } function yG(i, e) { const t = this.cache; t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e) } function bG(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (As(t, e)) return; i.uniform2fv(this.addr, e), ys(t, e) } } function _G(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b); else { if (As(t, e)) return; i.uniform3fv(this.addr, e), ys(t, e) } } function xG(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (As(t, e)) return; i.uniform4fv(this.addr, e), ys(t, e) } } function wG(i, e) { const t = this.cache, s = e.elements; if (s === void 0) { if (As(t, e)) return; i.uniformMatrix2fv(this.addr, !1, e), ys(t, e) } else { if (As(t, s)) return; vR.set(s), i.uniformMatrix2fv(this.addr, !1, vR), ys(t, s) } } function CG(i, e) { const t = this.cache, s = e.elements; if (s === void 0) { if (As(t, e)) return; i.uniformMatrix3fv(this.addr, !1, e), ys(t, e) } else { if (As(t, s)) return; mR.set(s), i.uniformMatrix3fv(this.addr, !1, mR), ys(t, s) } } function SG(i, e) { const t = this.cache, s = e.elements; if (s === void 0) { if (As(t, e)) return; i.uniformMatrix4fv(this.addr, !1, e), ys(t, e) } else { if (As(t, s)) return; gR.set(s), i.uniformMatrix4fv(this.addr, !1, gR), ys(t, s) } } function EG(i, e) { const t = this.cache; t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e) } function MG(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (As(t, e)) return; i.uniform2iv(this.addr, e), ys(t, e) } } function IG(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (As(t, e)) return; i.uniform3iv(this.addr, e), ys(t, e) } } function TG(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (As(t, e)) return; i.uniform4iv(this.addr, e), ys(t, e) } } function RG(i, e) { const t = this.cache; t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e) } function PG(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (As(t, e)) return; i.uniform2uiv(this.addr, e), ys(t, e) } } function BG(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (As(t, e)) return; i.uniform3uiv(this.addr, e), ys(t, e) } } function kG(i, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (As(t, e)) return; i.uniform4uiv(this.addr, e), ys(t, e) } } function DG(i, e, t) { const s = this.cache, r = t.allocateTextureUnit(); s[0] !== r && (i.uniform1i(this.addr, r), s[0] = r), t.setTexture2D(e || cR, r) } function OG(i, e, t) { const s = this.cache, r = t.allocateTextureUnit(); s[0] !== r && (i.uniform1i(this.addr, r), s[0] = r), t.setTexture3D(e || uR, r) } function LG(i, e, t) { const s = this.cache, r = t.allocateTextureUnit(); s[0] !== r && (i.uniform1i(this.addr, r), s[0] = r), t.setTextureCube(e || dR, r) } function FG(i, e, t) { const s = this.cache, r = t.allocateTextureUnit(); s[0] !== r && (i.uniform1i(this.addr, r), s[0] = r), t.setTexture2DArray(e || hR, r) } function UG(i) { switch (i) { case 5126: return yG; case 35664: return bG; case 35665: return _G; case 35666: return xG; case 35674: return wG; case 35675: return CG; case 35676: return SG; case 5124: case 35670: return EG; case 35667: case 35671: return MG; case 35668: case 35672: return IG; case 35669: case 35673: return TG; case 5125: return RG; case 36294: return PG; case 36295: return BG; case 36296: return kG; case 35678: case 36198: case 36298: case 36306: case 35682: return DG; case 35679: case 36299: case 36307: return OG; case 35680: case 36300: case 36308: case 36293: return LG; case 36289: case 36303: case 36311: case 36292: return FG } } function NG(i, e) { i.uniform1fv(this.addr, e) } function zG(i, e) { const t = Zu(e, this.size, 2); i.uniform2fv(this.addr, t) } function jG(i, e) { const t = Zu(e, this.size, 3); i.uniform3fv(this.addr, t) } function QG(i, e) { const t = Zu(e, this.size, 4); i.uniform4fv(this.addr, t) } function GG(i, e) { const t = Zu(e, this.size, 4); i.uniformMatrix2fv(this.addr, !1, t) } function HG(i, e) { const t = Zu(e, this.size, 9); i.uniformMatrix3fv(this.addr, !1, t) } function VG(i, e) { const t = Zu(e, this.size, 16); i.uniformMatrix4fv(this.addr, !1, t) } function WG(i, e) { i.uniform1iv(this.addr, e) } function qG(i, e) { i.uniform2iv(this.addr, e) } function XG(i, e) { i.uniform3iv(this.addr, e) } function YG(i, e) { i.uniform4iv(this.addr, e) } function JG(i, e) { i.uniform1uiv(this.addr, e) } function KG(i, e) { i.uniform2uiv(this.addr, e) } function ZG(i, e) { i.uniform3uiv(this.addr, e) } function $G(i, e) { i.uniform4uiv(this.addr, e) } function e5(i, e, t) { const s = this.cache, r = e.length, n = SA(t, r); As(s, n) || (i.uniform1iv(this.addr, n), ys(s, n)); for (let o = 0; o !== r; ++o)t.setTexture2D(e[o] || cR, n[o]) } function t5(i, e, t) { const s = this.cache, r = e.length, n = SA(t, r); As(s, n) || (i.uniform1iv(this.addr, n), ys(s, n)); for (let o = 0; o !== r; ++o)t.setTexture3D(e[o] || uR, n[o]) } function i5(i, e, t) { const s = this.cache, r = e.length, n = SA(t, r); As(s, n) || (i.uniform1iv(this.addr, n), ys(s, n)); for (let o = 0; o !== r; ++o)t.setTextureCube(e[o] || dR, n[o]) } function s5(i, e, t) { const s = this.cache, r = e.length, n = SA(t, r); As(s, n) || (i.uniform1iv(this.addr, n), ys(s, n)); for (let o = 0; o !== r; ++o)t.setTexture2DArray(e[o] || hR, n[o]) } function r5(i) { switch (i) { case 5126: return NG; case 35664: return zG; case 35665: return jG; case 35666: return QG; case 35674: return GG; case 35675: return HG; case 35676: return VG; case 5124: case 35670: return WG; case 35667: case 35671: return qG; case 35668: case 35672: return XG; case 35669: case 35673: return YG; case 5125: return JG; case 36294: return KG; case 36295: return ZG; case 36296: return $G; case 35678: case 36198: case 36298: case 36306: case 35682: return e5; case 35679: case 36299: case 36307: return t5; case 35680: case 36300: case 36308: case 36293: return i5; case 36289: case 36303: case 36311: case 36292: return s5 } } class n5 { constructor(e, t, s) { this.id = e, this.addr = s, this.cache = [], this.setValue = UG(t.type) } } class o5 { constructor(e, t, s) { this.id = e, this.addr = s, this.cache = [], this.size = t.size, this.setValue = r5(t.type) } } class a5 { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, t, s) { const r = this.seq; for (let n = 0, o = r.length; n !== o; ++n) { const a = r[n]; a.setValue(e, t[a.id], s) } } } const pw = /(\w+)(\])?(\[|\.)?/g; function AR(i, e) { i.seq.push(e), i.map[e.id] = e } function l5(i, e, t) { const s = i.name, r = s.length; for (pw.lastIndex = 0; ;) { const n = pw.exec(s), o = pw.lastIndex; let a = n[1]; const l = n[2] === "]", c = n[3]; if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === r) { AR(t, c === void 0 ? new n5(a, i, e) : new o5(a, i, e)); break } else { let h = t.map[a]; h === void 0 && (h = new a5(a), AR(t, h)), t = h } } } class EA { constructor(e, t) { this.seq = [], this.map = {}; const s = e.getProgramParameter(t, 35718); for (let r = 0; r < s; ++r) { const n = e.getActiveUniform(t, r), o = e.getUniformLocation(t, n.name); l5(n, o, this) } } setValue(e, t, s, r) { const n = this.map[t]; n !== void 0 && n.setValue(e, s, r) } setOptional(e, t, s) { const r = t[s]; r !== void 0 && this.setValue(e, s, r) } static upload(e, t, s, r) { for (let n = 0, o = t.length; n !== o; ++n) { const a = t[n], l = s[a.id]; l.needsUpdate !== !1 && a.setValue(e, l.value, r) } } static seqWithValue(e, t) { const s = []; for (let r = 0, n = e.length; r !== n; ++r) { const o = e[r]; o.id in t && s.push(o) } return s } } function yR(i, e, t) { const s = i.createShader(e); return i.shaderSource(s, t), i.compileShader(s), s } let c5 = 0; function h5(i, e) {
  const t = i.split(`
`), s = [], r = Math.max(e - 6, 0), n = Math.min(e + 6, t.length); for (let o = r; o < n; o++) { const a = o + 1; s.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`) } return s.join(`
`)
} function u5(i) { switch (i) { case Qi: return ["Linear", "( value )"]; case Xe: return ["sRGB", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", i), ["Linear", "( value )"] } } function bR(i, e, t) {
  const s = i.getShaderParameter(e, 35713), r = i.getShaderInfoLog(e).trim(); if (s && r === "") return ""; const n = /ERROR: 0:(\d+)/.exec(r); if (n) {
    const o = parseInt(n[1]); return t.toUpperCase() + `

`+ r + `

`+ h5(i.getShaderSource(e), o)
  } else return r
} function d5(i, e) { const t = u5(e); return "vec4 " + i + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }" } function p5(i, e) { let t; switch (e) { case uf: t = "Linear"; break; case hx: t = "Reinhard"; break; case hT: t = "OptimizedCineon"; break; case ux: t = "ACESFilmic"; break; case uT: t = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear" }return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }" } function f5(i) {
  return [i.extensionDerivatives || i.envMapCubeUVHeight || i.bumpMap || i.tangentSpaceNormalMap || i.clearcoatNormalMap || i.flatShading || i.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (i.extensionFragDepth || i.logarithmicDepthBuffer) && i.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", i.extensionDrawBuffers && i.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (i.extensionShaderTextureLOD || i.envMap || i.transmission) && i.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Tf).join(`
`)
} function g5(i) {
  const e = []; for (const t in i) { const s = i[t]; s !== !1 && e.push("#define " + t + " " + s) } return e.join(`
`)
} function m5(i, e) { const t = {}, s = i.getProgramParameter(e, 35721); for (let r = 0; r < s; r++) { const n = i.getActiveAttrib(e, r), o = n.name; let a = 1; n.type === 35674 && (a = 2), n.type === 35675 && (a = 3), n.type === 35676 && (a = 4), t[o] = { type: n.type, location: i.getAttribLocation(e, o), locationSize: a } } return t } function Tf(i) { return i !== "" } function _R(i, e) { const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps; return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function xR(i, e) { return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const v5 = /^[ \t]*#include +<([\w\d./]+)>/gm; function fw(i) { return i.replace(v5, A5) } function A5(i, e) { const t = Mt[e]; if (t === void 0) throw new Error("Can not resolve #include <" + e + ">"); return fw(t) } const y5 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function wR(i) { return i.replace(y5, b5) } function b5(i, e, t, s) { let r = ""; for (let n = parseInt(e); n < parseInt(t); n++)r += s.replace(/\[\s*i\s*\]/g, "[ " + n + " ]").replace(/UNROLLED_LOOP_INDEX/g, n); return r } function CR(i) {
  let e = "precision " + i.precision + ` float;
precision `+ i.precision + " int;"; return i.precision === "highp" ? e += `
#define HIGH_PRECISION`: i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION`: i.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
} function _5(i) { let e = "SHADOWMAP_TYPE_BASIC"; return i.shadowMapType === tx ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === ix ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === Eu && (e = "SHADOWMAP_TYPE_VSM"), e } function x5(i) { let e = "ENVMAP_TYPE_CUBE"; if (i.envMap) switch (i.envMapMode) { case Bl: case kl: e = "ENVMAP_TYPE_CUBE"; break; case Ru: e = "ENVMAP_TYPE_CUBE_UV"; break }return e } function w5(i) { let e = "ENVMAP_MODE_REFLECTION"; if (i.envMap) switch (i.envMapMode) { case kl: e = "ENVMAP_MODE_REFRACTION"; break }return e } function C5(i) { let e = "ENVMAP_BLENDING_NONE"; if (i.envMap) switch (i.combine) { case hf: e = "ENVMAP_BLENDING_MULTIPLY"; break; case lT: e = "ENVMAP_BLENDING_MIX"; break; case cT: e = "ENVMAP_BLENDING_ADD"; break }return e } function S5(i) { const e = i.envMapCubeUVHeight; if (e === null) return null; const t = Math.log2(e) - 2, s = 1 / e; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: s, maxMip: t } } function E5(i, e, t, s) {
  const r = i.getContext(), n = t.defines; let o = t.vertexShader, a = t.fragmentShader; const l = _5(t), c = x5(t), h = w5(t), d = C5(t), p = S5(t), f = t.isWebGL2 ? "" : f5(t), g = g5(n), m = r.createProgram(); let v, A, b = t.glslVersion ? "#version " + t.glslVersion + `
`: ""; t.isRawShaderMaterial ? (v = [g].filter(Tf).join(`
`), v.length > 0 && (v += `
`), A = [f, g].filter(Tf).join(`
`), A.length > 0 && (A += `
`)) : (v = [CR(t), "#define SHADER_NAME " + t.shaderName, g, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Tf).join(`
`), A = [f, CR(t), "#define SHADER_NAME " + t.shaderName, g, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + d : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== fr ? "#define TONE_MAPPING" : "", t.toneMapping !== fr ? Mt.tonemapping_pars_fragment : "", t.toneMapping !== fr ? p5("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Mt.encodings_pars_fragment, d5("linearToOutputTexel", t.outputEncoding), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Tf).join(`
`)), o = fw(o), o = _R(o, t), o = xR(o, t), a = fw(a), a = _R(a, t), a = xR(a, t), o = wR(o), a = wR(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (b = `#version 300 es
`, v = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
`+ v, A = ["#define varying in", t.glslVersion === kx ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === kx ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
`+ A); const y = b + v + o, _ = b + A + a, w = yR(r, 35633, y), E = yR(r, 35632, _); if (r.attachShader(m, w), r.attachShader(m, E), t.index0AttributeName !== void 0 ? r.bindAttribLocation(m, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), i.debug.checkShaderErrors) {
    const R = r.getProgramInfoLog(m).trim(), T = r.getShaderInfoLog(w).trim(), z = r.getShaderInfoLog(E).trim(); let H = !0, N = !0; if (r.getProgramParameter(m, 35714) === !1) {
      H = !1; const F = bR(r, w, "vertex"), X = bR(r, E, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + `

Program Info Log: `+ R + `
`+ F + `
`+ X)
    } else R !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", R) : (T === "" || z === "") && (N = !1); N && (this.diagnostics = { runnable: H, programLog: R, vertexShader: { log: T, prefix: v }, fragmentShader: { log: z, prefix: A } })
  } r.deleteShader(w), r.deleteShader(E); let P; this.getUniforms = function () { return P === void 0 && (P = new EA(r, m)), P }; let C; return this.getAttributes = function () { return C === void 0 && (C = m5(r, m)), C }, this.destroy = function () { s.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0 }, this.name = t.shaderName, this.id = c5++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = w, this.fragmentShader = E, this
} let M5 = 0; class I5 { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const t = e.vertexShader, s = e.fragmentShader, r = this._getShaderStage(t), n = this._getShaderStage(s), o = this._getShaderCacheForMaterial(e); return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(n) === !1 && (o.add(n), n.usedTimes++), this } remove(e) { const t = this.materialCache.get(e); for (const s of t) s.usedTimes--, s.usedTimes === 0 && this.shaderCache.delete(s.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const t = this.materialCache; let s = t.get(e); return s === void 0 && (s = new Set, t.set(e, s)), s } _getShaderStage(e) { const t = this.shaderCache; let s = t.get(e); return s === void 0 && (s = new T5(e), t.set(e, s)), s } } class T5 { constructor(e) { this.id = M5++, this.code = e, this.usedTimes = 0 } } function R5(i, e, t, s, r, n, o) { const a = new bn, l = new I5, c = [], h = r.isWebGL2, d = r.logarithmicDepthBuffer, p = r.vertexTextures; let f = r.precision; const g = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function m(C, R, T, z, H) { const N = z.fog, F = H.geometry, X = C.isMeshStandardMaterial ? z.environment : null, te = (C.isMeshStandardMaterial ? t : e).get(C.envMap || X), re = te && te.mapping === Ru ? te.image.height : null, Z = g[C.type]; C.precision !== null && (f = r.getMaxPrecision(C.precision), f !== C.precision && console.warn("THREE.WebGLProgram.getParameters:", C.precision, "not supported, using", f, "instead.")); const fe = F.morphAttributes.position || F.morphAttributes.normal || F.morphAttributes.color, ae = fe !== void 0 ? fe.length : 0; let De = 0; F.morphAttributes.position !== void 0 && (De = 1), F.morphAttributes.normal !== void 0 && (De = 2), F.morphAttributes.color !== void 0 && (De = 3); let Se, ie, ce, Te; if (Z) { const ve = en[Z]; Se = ve.vertexShader, ie = ve.fragmentShader } else Se = C.vertexShader, ie = C.fragmentShader, l.update(C), ce = l.getVertexShaderID(C), Te = l.getFragmentShaderID(C); const K = i.getRenderTarget(), je = C.alphaTest > 0, Ue = C.clearcoat > 0, Pe = C.iridescence > 0; return { isWebGL2: h, shaderID: Z, shaderName: C.type, vertexShader: Se, fragmentShader: ie, defines: C.defines, customVertexShaderID: ce, customFragmentShaderID: Te, isRawShaderMaterial: C.isRawShaderMaterial === !0, glslVersion: C.glslVersion, precision: f, instancing: H.isInstancedMesh === !0, instancingColor: H.isInstancedMesh === !0 && H.instanceColor !== null, supportsVertexTextures: p, outputEncoding: K === null ? i.outputEncoding : K.isXRRenderTarget === !0 ? K.texture.encoding : Qi, map: !!C.map, matcap: !!C.matcap, envMap: !!te, envMapMode: te && te.mapping, envMapCubeUVHeight: re, lightMap: !!C.lightMap, aoMap: !!C.aoMap, emissiveMap: !!C.emissiveMap, bumpMap: !!C.bumpMap, normalMap: !!C.normalMap, objectSpaceNormalMap: C.normalMapType === ST, tangentSpaceNormalMap: C.normalMapType === Ul, decodeVideoTexture: !!C.map && C.map.isVideoTexture === !0 && C.map.encoding === Xe, clearcoat: Ue, clearcoatMap: Ue && !!C.clearcoatMap, clearcoatRoughnessMap: Ue && !!C.clearcoatRoughnessMap, clearcoatNormalMap: Ue && !!C.clearcoatNormalMap, iridescence: Pe, iridescenceMap: Pe && !!C.iridescenceMap, iridescenceThicknessMap: Pe && !!C.iridescenceThicknessMap, displacementMap: !!C.displacementMap, roughnessMap: !!C.roughnessMap, metalnessMap: !!C.metalnessMap, specularMap: !!C.specularMap, specularIntensityMap: !!C.specularIntensityMap, specularColorMap: !!C.specularColorMap, opaque: C.transparent === !1 && C.blending === Ia, alphaMap: !!C.alphaMap, alphaTest: je, gradientMap: !!C.gradientMap, sheen: C.sheen > 0, sheenColorMap: !!C.sheenColorMap, sheenRoughnessMap: !!C.sheenRoughnessMap, transmission: C.transmission > 0, transmissionMap: !!C.transmissionMap, thicknessMap: !!C.thicknessMap, combine: C.combine, vertexTangents: !!C.normalMap && !!F.attributes.tangent, vertexColors: C.vertexColors, vertexAlphas: C.vertexColors === !0 && !!F.attributes.color && F.attributes.color.itemSize === 4, vertexUvs: !!C.map || !!C.bumpMap || !!C.normalMap || !!C.specularMap || !!C.alphaMap || !!C.emissiveMap || !!C.roughnessMap || !!C.metalnessMap || !!C.clearcoatMap || !!C.clearcoatRoughnessMap || !!C.clearcoatNormalMap || !!C.iridescenceMap || !!C.iridescenceThicknessMap || !!C.displacementMap || !!C.transmissionMap || !!C.thicknessMap || !!C.specularIntensityMap || !!C.specularColorMap || !!C.sheenColorMap || !!C.sheenRoughnessMap, uvsVertexOnly: !(C.map || C.bumpMap || C.normalMap || C.specularMap || C.alphaMap || C.emissiveMap || C.roughnessMap || C.metalnessMap || C.clearcoatNormalMap || C.iridescenceMap || C.iridescenceThicknessMap || C.transmission > 0 || C.transmissionMap || C.thicknessMap || C.specularIntensityMap || C.specularColorMap || C.sheen > 0 || C.sheenColorMap || C.sheenRoughnessMap) && !!C.displacementMap, fog: !!N, useFog: C.fog === !0, fogExp2: N && N.isFogExp2, flatShading: !!C.flatShading, sizeAttenuation: C.sizeAttenuation, logarithmicDepthBuffer: d, skinning: H.isSkinnedMesh === !0, morphTargets: F.morphAttributes.position !== void 0, morphNormals: F.morphAttributes.normal !== void 0, morphColors: F.morphAttributes.color !== void 0, morphTargetsCount: ae, morphTextureStride: De, numDirLights: R.directional.length, numPointLights: R.point.length, numSpotLights: R.spot.length, numSpotLightMaps: R.spotLightMap.length, numRectAreaLights: R.rectArea.length, numHemiLights: R.hemi.length, numDirLightShadows: R.directionalShadowMap.length, numPointLightShadows: R.pointShadowMap.length, numSpotLightShadows: R.spotShadowMap.length, numSpotLightShadowsWithMaps: R.numSpotLightShadowsWithMaps, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: C.dithering, shadowMapEnabled: i.shadowMap.enabled && T.length > 0, shadowMapType: i.shadowMap.type, toneMapping: C.toneMapped ? i.toneMapping : fr, physicallyCorrectLights: i.physicallyCorrectLights, premultipliedAlpha: C.premultipliedAlpha, doubleSided: C.side === yi, flipSided: C.side === fs, useDepthPacking: !!C.depthPacking, depthPacking: C.depthPacking || 0, index0AttributeName: C.index0AttributeName, extensionDerivatives: C.extensions && C.extensions.derivatives, extensionFragDepth: C.extensions && C.extensions.fragDepth, extensionDrawBuffers: C.extensions && C.extensions.drawBuffers, extensionShaderTextureLOD: C.extensions && C.extensions.shaderTextureLOD, rendererExtensionFragDepth: h || s.has("EXT_frag_depth"), rendererExtensionDrawBuffers: h || s.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: h || s.has("EXT_shader_texture_lod"), customProgramCacheKey: C.customProgramCacheKey() } } function v(C) { const R = []; if (C.shaderID ? R.push(C.shaderID) : (R.push(C.customVertexShaderID), R.push(C.customFragmentShaderID)), C.defines !== void 0) for (const T in C.defines) R.push(T), R.push(C.defines[T]); return C.isRawShaderMaterial === !1 && (A(R, C), b(R, C), R.push(i.outputEncoding)), R.push(C.customProgramCacheKey), R.join() } function A(C, R) { C.push(R.precision), C.push(R.outputEncoding), C.push(R.envMapMode), C.push(R.envMapCubeUVHeight), C.push(R.combine), C.push(R.vertexUvs), C.push(R.fogExp2), C.push(R.sizeAttenuation), C.push(R.morphTargetsCount), C.push(R.morphAttributeCount), C.push(R.numDirLights), C.push(R.numPointLights), C.push(R.numSpotLights), C.push(R.numSpotLightMaps), C.push(R.numHemiLights), C.push(R.numRectAreaLights), C.push(R.numDirLightShadows), C.push(R.numPointLightShadows), C.push(R.numSpotLightShadows), C.push(R.numSpotLightShadowsWithMaps), C.push(R.shadowMapType), C.push(R.toneMapping), C.push(R.numClippingPlanes), C.push(R.numClipIntersection), C.push(R.depthPacking) } function b(C, R) { a.disableAll(), R.isWebGL2 && a.enable(0), R.supportsVertexTextures && a.enable(1), R.instancing && a.enable(2), R.instancingColor && a.enable(3), R.map && a.enable(4), R.matcap && a.enable(5), R.envMap && a.enable(6), R.lightMap && a.enable(7), R.aoMap && a.enable(8), R.emissiveMap && a.enable(9), R.bumpMap && a.enable(10), R.normalMap && a.enable(11), R.objectSpaceNormalMap && a.enable(12), R.tangentSpaceNormalMap && a.enable(13), R.clearcoat && a.enable(14), R.clearcoatMap && a.enable(15), R.clearcoatRoughnessMap && a.enable(16), R.clearcoatNormalMap && a.enable(17), R.iridescence && a.enable(18), R.iridescenceMap && a.enable(19), R.iridescenceThicknessMap && a.enable(20), R.displacementMap && a.enable(21), R.specularMap && a.enable(22), R.roughnessMap && a.enable(23), R.metalnessMap && a.enable(24), R.gradientMap && a.enable(25), R.alphaMap && a.enable(26), R.alphaTest && a.enable(27), R.vertexColors && a.enable(28), R.vertexAlphas && a.enable(29), R.vertexUvs && a.enable(30), R.vertexTangents && a.enable(31), R.uvsVertexOnly && a.enable(32), C.push(a.mask), a.disableAll(), R.fog && a.enable(0), R.useFog && a.enable(1), R.flatShading && a.enable(2), R.logarithmicDepthBuffer && a.enable(3), R.skinning && a.enable(4), R.morphTargets && a.enable(5), R.morphNormals && a.enable(6), R.morphColors && a.enable(7), R.premultipliedAlpha && a.enable(8), R.shadowMapEnabled && a.enable(9), R.physicallyCorrectLights && a.enable(10), R.doubleSided && a.enable(11), R.flipSided && a.enable(12), R.useDepthPacking && a.enable(13), R.dithering && a.enable(14), R.specularIntensityMap && a.enable(15), R.specularColorMap && a.enable(16), R.transmission && a.enable(17), R.transmissionMap && a.enable(18), R.thicknessMap && a.enable(19), R.sheen && a.enable(20), R.sheenColorMap && a.enable(21), R.sheenRoughnessMap && a.enable(22), R.decodeVideoTexture && a.enable(23), R.opaque && a.enable(24), C.push(a.mask) } function y(C) { const R = g[C.type]; let T; if (R) { const z = en[R]; T = ow.clone(z.uniforms) } else T = C.uniforms; return T } function _(C, R) { let T; for (let z = 0, H = c.length; z < H; z++) { const N = c[z]; if (N.cacheKey === R) { T = N, ++T.usedTimes; break } } return T === void 0 && (T = new E5(i, R, C, n), c.push(T)), T } function w(C) { if (--C.usedTimes === 0) { const R = c.indexOf(C); c[R] = c[c.length - 1], c.pop(), C.destroy() } } function E(C) { l.remove(C) } function P() { l.dispose() } return { getParameters: m, getProgramCacheKey: v, getUniforms: y, acquireProgram: _, releaseProgram: w, releaseShaderCache: E, programs: c, dispose: P } } function P5() { let i = new WeakMap; function e(n) { let o = i.get(n); return o === void 0 && (o = {}, i.set(n, o)), o } function t(n) { i.delete(n) } function s(n, o, a) { i.get(n)[o] = a } function r() { i = new WeakMap } return { get: e, remove: t, update: s, dispose: r } } function B5(i, e) { return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id } function SR(i, e) { return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id } function ER() { const i = []; let e = 0; const t = [], s = [], r = []; function n() { e = 0, t.length = 0, s.length = 0, r.length = 0 } function o(d, p, f, g, m, v) { let A = i[e]; return A === void 0 ? (A = { id: d.id, object: d, geometry: p, material: f, groupOrder: g, renderOrder: d.renderOrder, z: m, group: v }, i[e] = A) : (A.id = d.id, A.object = d, A.geometry = p, A.material = f, A.groupOrder = g, A.renderOrder = d.renderOrder, A.z = m, A.group = v), e++, A } function a(d, p, f, g, m, v) { const A = o(d, p, f, g, m, v); f.transmission > 0 ? s.push(A) : f.transparent === !0 ? r.push(A) : t.push(A) } function l(d, p, f, g, m, v) { const A = o(d, p, f, g, m, v); f.transmission > 0 ? s.unshift(A) : f.transparent === !0 ? r.unshift(A) : t.unshift(A) } function c(d, p) { t.length > 1 && t.sort(d || B5), s.length > 1 && s.sort(p || SR), r.length > 1 && r.sort(p || SR) } function h() { for (let d = e, p = i.length; d < p; d++) { const f = i[d]; if (f.id === null) break; f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null } } return { opaque: t, transmissive: s, transparent: r, init: n, push: a, unshift: l, finish: h, sort: c } } function k5() { let i = new WeakMap; function e(s, r) { const n = i.get(s); let o; return n === void 0 ? (o = new ER, i.set(s, [o])) : r >= n.length ? (o = new ER, n.push(o)) : o = n[r], o } function t() { i = new WeakMap } return { get: e, dispose: t } } function D5() { const i = {}; return { get: function (e) { if (i[e.id] !== void 0) return i[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { direction: new S, color: new xe }; break; case "SpotLight": t = { position: new S, direction: new S, color: new xe, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": t = { position: new S, color: new xe, distance: 0, decay: 0 }; break; case "HemisphereLight": t = { direction: new S, skyColor: new xe, groundColor: new xe }; break; case "RectAreaLight": t = { color: new xe, position: new S, halfWidth: new S, halfHeight: new S }; break }return i[e.id] = t, t } } } function O5() { const i = {}; return { get: function (e) { if (i[e.id] !== void 0) return i[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new W }; break; case "SpotLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new W }; break; case "PointLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new W, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break }return i[e.id] = t, t } } } let L5 = 0; function F5(i, e) { return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0) } function U5(i, e) { const t = new D5, s = O5(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 }; for (let h = 0; h < 9; h++)r.probe.push(new S); const n = new S, o = new He, a = new He; function l(h, d) { let p = 0, f = 0, g = 0; for (let z = 0; z < 9; z++)r.probe[z].set(0, 0, 0); let m = 0, v = 0, A = 0, b = 0, y = 0, _ = 0, w = 0, E = 0, P = 0, C = 0; h.sort(F5); const R = d !== !0 ? Math.PI : 1; for (let z = 0, H = h.length; z < H; z++) { const N = h[z], F = N.color, X = N.intensity, te = N.distance, re = N.shadow && N.shadow.map ? N.shadow.map.texture : null; if (N.isAmbientLight) p += F.r * X * R, f += F.g * X * R, g += F.b * X * R; else if (N.isLightProbe) for (let Z = 0; Z < 9; Z++)r.probe[Z].addScaledVector(N.sh.coefficients[Z], X); else if (N.isDirectionalLight) { const Z = t.get(N); if (Z.color.copy(N.color).multiplyScalar(N.intensity * R), N.castShadow) { const fe = N.shadow, ae = s.get(N); ae.shadowBias = fe.bias, ae.shadowNormalBias = fe.normalBias, ae.shadowRadius = fe.radius, ae.shadowMapSize = fe.mapSize, r.directionalShadow[m] = ae, r.directionalShadowMap[m] = re, r.directionalShadowMatrix[m] = N.shadow.matrix, _++ } r.directional[m] = Z, m++ } else if (N.isSpotLight) { const Z = t.get(N); Z.position.setFromMatrixPosition(N.matrixWorld), Z.color.copy(F).multiplyScalar(X * R), Z.distance = te, Z.coneCos = Math.cos(N.angle), Z.penumbraCos = Math.cos(N.angle * (1 - N.penumbra)), Z.decay = N.decay, r.spot[A] = Z; const fe = N.shadow; if (N.map && (r.spotLightMap[P] = N.map, P++, fe.updateMatrices(N), N.castShadow && C++), r.spotLightMatrix[A] = fe.matrix, N.castShadow) { const ae = s.get(N); ae.shadowBias = fe.bias, ae.shadowNormalBias = fe.normalBias, ae.shadowRadius = fe.radius, ae.shadowMapSize = fe.mapSize, r.spotShadow[A] = ae, r.spotShadowMap[A] = re, E++ } A++ } else if (N.isRectAreaLight) { const Z = t.get(N); Z.color.copy(F).multiplyScalar(X), Z.halfWidth.set(N.width * .5, 0, 0), Z.halfHeight.set(0, N.height * .5, 0), r.rectArea[b] = Z, b++ } else if (N.isPointLight) { const Z = t.get(N); if (Z.color.copy(N.color).multiplyScalar(N.intensity * R), Z.distance = N.distance, Z.decay = N.decay, N.castShadow) { const fe = N.shadow, ae = s.get(N); ae.shadowBias = fe.bias, ae.shadowNormalBias = fe.normalBias, ae.shadowRadius = fe.radius, ae.shadowMapSize = fe.mapSize, ae.shadowCameraNear = fe.camera.near, ae.shadowCameraFar = fe.camera.far, r.pointShadow[v] = ae, r.pointShadowMap[v] = re, r.pointShadowMatrix[v] = N.shadow.matrix, w++ } r.point[v] = Z, v++ } else if (N.isHemisphereLight) { const Z = t.get(N); Z.skyColor.copy(N.color).multiplyScalar(X * R), Z.groundColor.copy(N.groundColor).multiplyScalar(X * R), r.hemi[y] = Z, y++ } } b > 0 && (e.isWebGL2 || i.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Ye.LTC_FLOAT_1, r.rectAreaLTC2 = Ye.LTC_FLOAT_2) : i.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Ye.LTC_HALF_1, r.rectAreaLTC2 = Ye.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = p, r.ambient[1] = f, r.ambient[2] = g; const T = r.hash; (T.directionalLength !== m || T.pointLength !== v || T.spotLength !== A || T.rectAreaLength !== b || T.hemiLength !== y || T.numDirectionalShadows !== _ || T.numPointShadows !== w || T.numSpotShadows !== E || T.numSpotMaps !== P) && (r.directional.length = m, r.spot.length = A, r.rectArea.length = b, r.point.length = v, r.hemi.length = y, r.directionalShadow.length = _, r.directionalShadowMap.length = _, r.pointShadow.length = w, r.pointShadowMap.length = w, r.spotShadow.length = E, r.spotShadowMap.length = E, r.directionalShadowMatrix.length = _, r.pointShadowMatrix.length = w, r.spotLightMatrix.length = E + P - C, r.spotLightMap.length = P, r.numSpotLightShadowsWithMaps = C, T.directionalLength = m, T.pointLength = v, T.spotLength = A, T.rectAreaLength = b, T.hemiLength = y, T.numDirectionalShadows = _, T.numPointShadows = w, T.numSpotShadows = E, T.numSpotMaps = P, r.version = L5++) } function c(h, d) { let p = 0, f = 0, g = 0, m = 0, v = 0; const A = d.matrixWorldInverse; for (let b = 0, y = h.length; b < y; b++) { const _ = h[b]; if (_.isDirectionalLight) { const w = r.directional[p]; w.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), w.direction.sub(n), w.direction.transformDirection(A), p++ } else if (_.isSpotLight) { const w = r.spot[g]; w.position.setFromMatrixPosition(_.matrixWorld), w.position.applyMatrix4(A), w.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), w.direction.sub(n), w.direction.transformDirection(A), g++ } else if (_.isRectAreaLight) { const w = r.rectArea[m]; w.position.setFromMatrixPosition(_.matrixWorld), w.position.applyMatrix4(A), a.identity(), o.copy(_.matrixWorld), o.premultiply(A), a.extractRotation(o), w.halfWidth.set(_.width * .5, 0, 0), w.halfHeight.set(0, _.height * .5, 0), w.halfWidth.applyMatrix4(a), w.halfHeight.applyMatrix4(a), m++ } else if (_.isPointLight) { const w = r.point[f]; w.position.setFromMatrixPosition(_.matrixWorld), w.position.applyMatrix4(A), f++ } else if (_.isHemisphereLight) { const w = r.hemi[v]; w.direction.setFromMatrixPosition(_.matrixWorld), w.direction.transformDirection(A), v++ } } } return { setup: l, setupView: c, state: r } } function MR(i, e) { const t = new U5(i, e), s = [], r = []; function n() { s.length = 0, r.length = 0 } function o(h) { s.push(h) } function a(h) { r.push(h) } function l(h) { t.setup(s, h) } function c(h) { t.setupView(s, h) } return { init: n, state: { lightsArray: s, shadowsArray: r, lights: t }, setupLights: l, setupLightsView: c, pushLight: o, pushShadow: a } } function N5(i, e) { let t = new WeakMap; function s(n, o = 0) { const a = t.get(n); let l; return a === void 0 ? (l = new MR(i, e), t.set(n, [l])) : o >= a.length ? (l = new MR(i, e), a.push(l)) : l = a[o], l } function r() { t = new WeakMap } return { get: s, dispose: r } } class MA extends Tt { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Os, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class gw extends Tt { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new S, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } const z5 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, j5 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`; function Q5(i, e, t) { let s = new xA; const r = new W, n = new W, o = new st, a = new MA({ depthPacking: $v }), l = new gw, c = {}, h = t.maxTextureSize, d = { 0: fs, 1: pr, 2: yi }, p = new Vt({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new W }, radius: { value: 4 } }, vertexShader: z5, fragmentShader: j5 }), f = p.clone(); f.defines.HORIZONTAL_PASS = 1; const g = new yt; g.setAttribute("position", new nt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const m = new ye(g, p), v = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = tx, this.render = function (_, w, E) { if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || _.length === 0) return; const P = i.getRenderTarget(), C = i.getActiveCubeFace(), R = i.getActiveMipmapLevel(), T = i.state; T.setBlending(Ri), T.buffers.color.setClear(1, 1, 1, 1), T.buffers.depth.setTest(!0), T.setScissorTest(!1); for (let z = 0, H = _.length; z < H; z++) { const N = _[z], F = N.shadow; if (F === void 0) { console.warn("THREE.WebGLShadowMap:", N, "has no shadow."); continue } if (F.autoUpdate === !1 && F.needsUpdate === !1) continue; r.copy(F.mapSize); const X = F.getFrameExtents(); if (r.multiply(X), n.copy(F.mapSize), (r.x > h || r.y > h) && (r.x > h && (n.x = Math.floor(h / X.x), r.x = n.x * X.x, F.mapSize.x = n.x), r.y > h && (n.y = Math.floor(h / X.y), r.y = n.y * X.y, F.mapSize.y = n.y)), F.map === null) { const re = this.type !== Eu ? { minFilter: Zt, magFilter: Zt } : {}; F.map = new ri(r.x, r.y, re), F.map.texture.name = N.name + ".shadowMap", F.camera.updateProjectionMatrix() } i.setRenderTarget(F.map), i.clear(); const te = F.getViewportCount(); for (let re = 0; re < te; re++) { const Z = F.getViewport(re); o.set(n.x * Z.x, n.y * Z.y, n.x * Z.z, n.y * Z.w), T.viewport(o), F.updateMatrices(N, re), s = F.getFrustum(), y(w, E, F.camera, N, this.type) } F.isPointLightShadow !== !0 && this.type === Eu && A(F, E), F.needsUpdate = !1 } v.needsUpdate = !1, i.setRenderTarget(P, C, R) }; function A(_, w) { const E = e.update(m); p.defines.VSM_SAMPLES !== _.blurSamples && (p.defines.VSM_SAMPLES = _.blurSamples, f.defines.VSM_SAMPLES = _.blurSamples, p.needsUpdate = !0, f.needsUpdate = !0), _.mapPass === null && (_.mapPass = new ri(r.x, r.y)), p.uniforms.shadow_pass.value = _.map.texture, p.uniforms.resolution.value = _.mapSize, p.uniforms.radius.value = _.radius, i.setRenderTarget(_.mapPass), i.clear(), i.renderBufferDirect(w, null, E, p, m, null), f.uniforms.shadow_pass.value = _.mapPass.texture, f.uniforms.resolution.value = _.mapSize, f.uniforms.radius.value = _.radius, i.setRenderTarget(_.map), i.clear(), i.renderBufferDirect(w, null, E, f, m, null) } function b(_, w, E, P, C, R) { let T = null; const z = E.isPointLight === !0 ? _.customDistanceMaterial : _.customDepthMaterial; if (z !== void 0 ? T = z : T = E.isPointLight === !0 ? l : a, i.localClippingEnabled && w.clipShadows === !0 && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) { const H = T.uuid, N = w.uuid; let F = c[H]; F === void 0 && (F = {}, c[H] = F); let X = F[N]; X === void 0 && (X = T.clone(), F[N] = X), T = X } return T.visible = w.visible, T.wireframe = w.wireframe, R === Eu ? T.side = w.shadowSide !== null ? w.shadowSide : w.side : T.side = w.shadowSide !== null ? w.shadowSide : d[w.side], T.alphaMap = w.alphaMap, T.alphaTest = w.alphaTest, T.map = w.map, T.clipShadows = w.clipShadows, T.clippingPlanes = w.clippingPlanes, T.clipIntersection = w.clipIntersection, T.displacementMap = w.displacementMap, T.displacementScale = w.displacementScale, T.displacementBias = w.displacementBias, T.wireframeLinewidth = w.wireframeLinewidth, T.linewidth = w.linewidth, E.isPointLight === !0 && T.isMeshDistanceMaterial === !0 && (T.referencePosition.setFromMatrixPosition(E.matrixWorld), T.nearDistance = P, T.farDistance = C), T } function y(_, w, E, P, C) { if (_.visible === !1) return; if (_.layers.test(w.layers) && (_.isMesh || _.isLine || _.isPoints) && (_.castShadow || _.receiveShadow && C === Eu) && (!_.frustumCulled || s.intersectsObject(_))) { _.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, _.matrixWorld); const T = e.update(_), z = _.material; if (Array.isArray(z)) { const H = T.groups; for (let N = 0, F = H.length; N < F; N++) { const X = H[N], te = z[X.materialIndex]; if (te && te.visible) { const re = b(_, te, P, E.near, E.far, C); i.renderBufferDirect(E, null, T, re, _, X) } } } else if (z.visible) { const H = b(_, z, P, E.near, E.far, C); i.renderBufferDirect(E, null, T, H, _, null) } } const R = _.children; for (let T = 0, z = R.length; T < z; T++)y(R[T], w, E, P, C) } } function G5(i, e, t) { const s = t.isWebGL2; function r() { let I = !1; const L = new st; let G = null; const V = new st(0, 0, 0, 0); return { setMask: function (he) { G !== he && !I && (i.colorMask(he, he, he, he), G = he) }, setLocked: function (he) { I = he }, setClear: function (he, be, ke, _e, Oe) { Oe === !0 && (he *= _e, be *= _e, ke *= _e), L.set(he, be, ke, _e), V.equals(L) === !1 && (i.clearColor(he, be, ke, _e), V.copy(L)) }, reset: function () { I = !1, G = null, V.set(-1, 0, 0, 0) } } } function n() { let I = !1, L = null, G = null, V = null; return { setTest: function (he) { he ? je(2929) : Ue(2929) }, setMask: function (he) { L !== he && !I && (i.depthMask(he), L = he) }, setFunc: function (he) { if (G !== he) { switch (he) { case cx: i.depthFunc(512); break; case Uv: i.depthFunc(519); break; case lf: i.depthFunc(513); break; case Mu: i.depthFunc(515); break; case Iu: i.depthFunc(514); break; case Nv: i.depthFunc(518); break; case zv: i.depthFunc(516); break; case cf: i.depthFunc(517); break; default: i.depthFunc(515) }G = he } }, setLocked: function (he) { I = he }, setClear: function (he) { V !== he && (i.clearDepth(he), V = he) }, reset: function () { I = !1, L = null, G = null, V = null } } } function o() { let I = !1, L = null, G = null, V = null, he = null, be = null, ke = null, _e = null, Oe = null; return { setTest: function (Ge) { I || (Ge ? je(2960) : Ue(2960)) }, setMask: function (Ge) { L !== Ge && !I && (i.stencilMask(Ge), L = Ge) }, setFunc: function (Ge, Je, ot) { (G !== Ge || V !== Je || he !== ot) && (i.stencilFunc(Ge, Je, ot), G = Ge, V = Je, he = ot) }, setOp: function (Ge, Je, ot) { (be !== Ge || ke !== Je || _e !== ot) && (i.stencilOp(Ge, Je, ot), be = Ge, ke = Je, _e = ot) }, setLocked: function (Ge) { I = Ge }, setClear: function (Ge) { Oe !== Ge && (i.clearStencil(Ge), Oe = Ge) }, reset: function () { I = !1, L = null, G = null, V = null, he = null, be = null, ke = null, _e = null, Oe = null } } } const a = new r, l = new n, c = new o, h = new WeakMap, d = new WeakMap; let p = {}, f = {}, g = new WeakMap, m = [], v = null, A = !1, b = null, y = null, _ = null, w = null, E = null, P = null, C = null, R = !1, T = null, z = null, H = null, N = null, F = null; const X = i.getParameter(35661); let te = !1, re = 0; const Z = i.getParameter(7938); Z.indexOf("WebGL") !== -1 ? (re = parseFloat(/^WebGL (\d)/.exec(Z)[1]), te = re >= 1) : Z.indexOf("OpenGL ES") !== -1 && (re = parseFloat(/^OpenGL ES (\d)/.exec(Z)[1]), te = re >= 2); let fe = null, ae = {}; const De = i.getParameter(3088), Se = i.getParameter(2978), ie = new st().fromArray(De), ce = new st().fromArray(Se); function Te(I, L, G) { const V = new Uint8Array(4), he = i.createTexture(); i.bindTexture(I, he), i.texParameteri(I, 10241, 9728), i.texParameteri(I, 10240, 9728); for (let be = 0; be < G; be++)i.texImage2D(L + be, 0, 6408, 1, 1, 0, 6408, 5121, V); return he } const K = {}; K[3553] = Te(3553, 3553, 1), K[34067] = Te(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), je(2929), l.setFunc(Mu), ht(!1), me(ex), je(2884), Fe(Ri); function je(I) { p[I] !== !0 && (i.enable(I), p[I] = !0) } function Ue(I) { p[I] !== !1 && (i.disable(I), p[I] = !1) } function Pe(I, L) { return f[I] !== L ? (i.bindFramebuffer(I, L), f[I] = L, s && (I === 36009 && (f[36160] = L), I === 36160 && (f[36009] = L)), !0) : !1 } function ve(I, L) { let G = m, V = !1; if (I) if (G = g.get(L), G === void 0 && (G = [], g.set(L, G)), I.isWebGLMultipleRenderTargets) { const he = I.texture; if (G.length !== he.length || G[0] !== 36064) { for (let be = 0, ke = he.length; be < ke; be++)G[be] = 36064 + be; G.length = he.length, V = !0 } } else G[0] !== 36064 && (G[0] = 36064, V = !0); else G[0] !== 1029 && (G[0] = 1029, V = !0); V && (t.isWebGL2 ? i.drawBuffers(G) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(G)) } function de(I) { return v !== I ? (i.useProgram(I), v = I, !0) : !1 } const Ae = { [nh]: 32774, [KI]: 32778, [ZI]: 32779 }; if (s) Ae[nx] = 32775, Ae[ox] = 32776; else { const I = e.get("EXT_blend_minmax"); I !== null && (Ae[nx] = I.MIN_EXT, Ae[ox] = I.MAX_EXT) } const pe = { [$I]: 0, [eT]: 1, [tT]: 768, [ax]: 770, [aT]: 776, [nT]: 774, [sT]: 772, [iT]: 769, [lx]: 771, [oT]: 775, [rT]: 773 }; function Fe(I, L, G, V, he, be, ke, _e) { if (I === Ri) { A === !0 && (Ue(3042), A = !1); return } if (A === !1 && (je(3042), A = !0), I !== JI) { if (I !== b || _e !== R) { if ((y !== nh || E !== nh) && (i.blendEquation(32774), y = nh, E = nh), _e) switch (I) { case Ia: i.blendFuncSeparate(1, 771, 1, 771); break; case rh: i.blendFunc(1, 1); break; case sx: i.blendFuncSeparate(0, 769, 0, 1); break; case rx: i.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", I); break } else switch (I) { case Ia: i.blendFuncSeparate(770, 771, 1, 771); break; case rh: i.blendFunc(770, 1); break; case sx: i.blendFuncSeparate(0, 769, 0, 1); break; case rx: i.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", I); break }_ = null, w = null, P = null, C = null, b = I, R = _e } return } he = he || L, be = be || G, ke = ke || V, (L !== y || he !== E) && (i.blendEquationSeparate(Ae[L], Ae[he]), y = L, E = he), (G !== _ || V !== w || be !== P || ke !== C) && (i.blendFuncSeparate(pe[G], pe[V], pe[be], pe[ke]), _ = G, w = V, P = be, C = ke), b = I, R = !1 } function Re(I, L) { I.side === yi ? Ue(2884) : je(2884); let G = I.side === fs; L && (G = !G), ht(G), I.blending === Ia && I.transparent === !1 ? Fe(Ri) : Fe(I.blending, I.blendEquation, I.blendSrc, I.blendDst, I.blendEquationAlpha, I.blendSrcAlpha, I.blendDstAlpha, I.premultipliedAlpha), l.setFunc(I.depthFunc), l.setTest(I.depthTest), l.setMask(I.depthWrite), a.setMask(I.colorWrite); const V = I.stencilWrite; c.setTest(V), V && (c.setMask(I.stencilWriteMask), c.setFunc(I.stencilFunc, I.stencilRef, I.stencilFuncMask), c.setOp(I.stencilFail, I.stencilZFail, I.stencilZPass)), dt(I.polygonOffset, I.polygonOffsetFactor, I.polygonOffsetUnits), I.alphaToCoverage === !0 ? je(32926) : Ue(32926) } function ht(I) { T !== I && (I ? i.frontFace(2304) : i.frontFace(2305), T = I) } function me(I) { I !== XI ? (je(2884), I !== z && (I === ex ? i.cullFace(1029) : I === YI ? i.cullFace(1028) : i.cullFace(1032))) : Ue(2884), z = I } function ut(I) { I !== H && (te && i.lineWidth(I), H = I) } function dt(I, L, G) { I ? (je(32823), (N !== L || F !== G) && (i.polygonOffset(L, G), N = L, F = G)) : Ue(32823) } function Pt(I) { I ? je(3089) : Ue(3089) } function ii(I) { I === void 0 && (I = 33984 + X - 1), fe !== I && (i.activeTexture(I), fe = I) } function U(I, L, G) { G === void 0 && (fe === null ? G = 33984 + X - 1 : G = fe); let V = ae[G]; V === void 0 && (V = { type: void 0, texture: void 0 }, ae[G] = V), (V.type !== I || V.texture !== L) && (fe !== G && (i.activeTexture(G), fe = G), i.bindTexture(I, L || K[I]), V.type = I, V.texture = L) } function D() { const I = ae[fe]; I !== void 0 && I.type !== void 0 && (i.bindTexture(I.type, null), I.type = void 0, I.texture = void 0) } function le() { try { i.compressedTexImage2D.apply(i, arguments) } catch (I) { console.error("THREE.WebGLState:", I) } } function Ie() { try { i.compressedTexImage3D.apply(i, arguments) } catch (I) { console.error("THREE.WebGLState:", I) } } function Be() { try { i.texSubImage2D.apply(i, arguments) } catch (I) { console.error("THREE.WebGLState:", I) } } function Qe() { try { i.texSubImage3D.apply(i, arguments) } catch (I) { console.error("THREE.WebGLState:", I) } } function rt() { try { i.compressedTexSubImage2D.apply(i, arguments) } catch (I) { console.error("THREE.WebGLState:", I) } } function j() { try { i.compressedTexSubImage3D.apply(i, arguments) } catch (I) { console.error("THREE.WebGLState:", I) } } function J() { try { i.texStorage2D.apply(i, arguments) } catch (I) { console.error("THREE.WebGLState:", I) } } function Ve() { try { i.texStorage3D.apply(i, arguments) } catch (I) { console.error("THREE.WebGLState:", I) } } function qe() { try { i.texImage2D.apply(i, arguments) } catch (I) { console.error("THREE.WebGLState:", I) } } function ze() { try { i.texImage3D.apply(i, arguments) } catch (I) { console.error("THREE.WebGLState:", I) } } function ge(I) { ie.equals(I) === !1 && (i.scissor(I.x, I.y, I.z, I.w), ie.copy(I)) } function lt(I) { ce.equals(I) === !1 && (i.viewport(I.x, I.y, I.z, I.w), ce.copy(I)) } function It(I, L) { let G = d.get(L); G === void 0 && (G = new WeakMap, d.set(L, G)); let V = G.get(I); V === void 0 && (V = i.getUniformBlockIndex(L, I.name), G.set(I, V)) } function M(I, L) { const G = d.get(L).get(I); h.get(I) !== G && (i.uniformBlockBinding(L, G, I.__bindingPointIndex), h.set(I, G)) } function k() { i.disable(3042), i.disable(2884), i.disable(2929), i.disable(32823), i.disable(3089), i.disable(2960), i.disable(32926), i.blendEquation(32774), i.blendFunc(1, 0), i.blendFuncSeparate(1, 0, 1, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(513), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(519, 0, 4294967295), i.stencilOp(7680, 7680, 7680), i.clearStencil(0), i.cullFace(1029), i.frontFace(2305), i.polygonOffset(0, 0), i.activeTexture(33984), i.bindFramebuffer(36160, null), s === !0 && (i.bindFramebuffer(36009, null), i.bindFramebuffer(36008, null)), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), p = {}, fe = null, ae = {}, f = {}, g = new WeakMap, m = [], v = null, A = !1, b = null, y = null, _ = null, w = null, E = null, P = null, C = null, R = !1, T = null, z = null, H = null, N = null, F = null, ie.set(0, 0, i.canvas.width, i.canvas.height), ce.set(0, 0, i.canvas.width, i.canvas.height), a.reset(), l.reset(), c.reset() } return { buffers: { color: a, depth: l, stencil: c }, enable: je, disable: Ue, bindFramebuffer: Pe, drawBuffers: ve, useProgram: de, setBlending: Fe, setMaterial: Re, setFlipSided: ht, setCullFace: me, setLineWidth: ut, setPolygonOffset: dt, setScissorTest: Pt, activeTexture: ii, bindTexture: U, unbindTexture: D, compressedTexImage2D: le, compressedTexImage3D: Ie, texImage2D: qe, texImage3D: ze, updateUBOMapping: It, uniformBlockBinding: M, texStorage2D: J, texStorage3D: Ve, texSubImage2D: Be, texSubImage3D: Qe, compressedTexSubImage2D: rt, compressedTexSubImage3D: j, scissor: ge, viewport: lt, reset: k } } function H5(i, e, t, s, r, n, o) { const a = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, h = r.maxTextureSize, d = r.maxSamples, p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, f = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), g = new WeakMap; let m; const v = new WeakMap; let A = !1; try { A = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null } catch { } function b(U, D) { return A ? new OffscreenCanvas(U, D) : _f("canvas") } function y(U, D, le, Ie) { let Be = 1; if ((U.width > Ie || U.height > Ie) && (Be = Ie / Math.max(U.width, U.height)), Be < 1 || D === !0) if (typeof HTMLImageElement < "u" && U instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && U instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && U instanceof ImageBitmap) { const Qe = D ? tA : Math.floor, rt = Qe(Be * U.width), j = Qe(Be * U.height); m === void 0 && (m = b(rt, j)); const J = le ? b(rt, j) : m; return J.width = rt, J.height = j, J.getContext("2d").drawImage(U, 0, 0, rt, j), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + U.width + "x" + U.height + ") to (" + rt + "x" + j + ")."), J } else return "data" in U && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + U.width + "x" + U.height + ")."), U; return U } function _(U) { return Ox(U.width) && Ox(U.height) } function w(U) { return a ? !1 : U.wrapS !== Ss || U.wrapT !== Ss || U.minFilter !== Zt && U.minFilter !== Qt } function E(U, D) { return U.generateMipmaps && D && U.minFilter !== Zt && U.minFilter !== Qt } function P(U) { i.generateMipmap(U) } function C(U, D, le, Ie, Be = !1) { if (a === !1) return D; if (U !== null) { if (i[U] !== void 0) return i[U]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + U + "'") } let Qe = D; return D === 6403 && (le === 5126 && (Qe = 33326), le === 5131 && (Qe = 33325), le === 5121 && (Qe = 33321)), D === 33319 && (le === 5126 && (Qe = 33328), le === 5131 && (Qe = 33327), le === 5121 && (Qe = 33323)), D === 6408 && (le === 5126 && (Qe = 34836), le === 5131 && (Qe = 34842), le === 5121 && (Qe = Ie === Xe && Be === !1 ? 35907 : 32856), le === 32819 && (Qe = 32854), le === 32820 && (Qe = 32855)), (Qe === 33325 || Qe === 33326 || Qe === 33327 || Qe === 33328 || Qe === 34842 || Qe === 34836) && e.get("EXT_color_buffer_float"), Qe } function R(U, D, le) { return E(U, le) === !0 || U.isFramebufferTexture && U.minFilter !== Zt && U.minFilter !== Qt ? Math.log2(Math.max(D.width, D.height)) + 1 : U.mipmaps !== void 0 && U.mipmaps.length > 0 ? U.mipmaps.length : U.isCompressedTexture && Array.isArray(U.image) ? D.mipmaps.length : 1 } function T(U) { return U === Zt || U === Pu || U === Bu ? 9728 : 9729 } function z(U) { const D = U.target; D.removeEventListener("dispose", z), N(D), D.isVideoTexture && g.delete(D) } function H(U) { const D = U.target; D.removeEventListener("dispose", H), X(D) } function N(U) { const D = s.get(U); if (D.__webglInit === void 0) return; const le = U.source, Ie = v.get(le); if (Ie) { const Be = Ie[D.__cacheKey]; Be.usedTimes--, Be.usedTimes === 0 && F(U), Object.keys(Ie).length === 0 && v.delete(le) } s.remove(U) } function F(U) { const D = s.get(U); i.deleteTexture(D.__webglTexture); const le = U.source, Ie = v.get(le); delete Ie[D.__cacheKey], o.memory.textures-- } function X(U) { const D = U.texture, le = s.get(U), Ie = s.get(D); if (Ie.__webglTexture !== void 0 && (i.deleteTexture(Ie.__webglTexture), o.memory.textures--), U.depthTexture && U.depthTexture.dispose(), U.isWebGLCubeRenderTarget) for (let Be = 0; Be < 6; Be++)i.deleteFramebuffer(le.__webglFramebuffer[Be]), le.__webglDepthbuffer && i.deleteRenderbuffer(le.__webglDepthbuffer[Be]); else { if (i.deleteFramebuffer(le.__webglFramebuffer), le.__webglDepthbuffer && i.deleteRenderbuffer(le.__webglDepthbuffer), le.__webglMultisampledFramebuffer && i.deleteFramebuffer(le.__webglMultisampledFramebuffer), le.__webglColorRenderbuffer) for (let Be = 0; Be < le.__webglColorRenderbuffer.length; Be++)le.__webglColorRenderbuffer[Be] && i.deleteRenderbuffer(le.__webglColorRenderbuffer[Be]); le.__webglDepthRenderbuffer && i.deleteRenderbuffer(le.__webglDepthRenderbuffer) } if (U.isWebGLMultipleRenderTargets) for (let Be = 0, Qe = D.length; Be < Qe; Be++) { const rt = s.get(D[Be]); rt.__webglTexture && (i.deleteTexture(rt.__webglTexture), o.memory.textures--), s.remove(D[Be]) } s.remove(D), s.remove(U) } let te = 0; function re() { te = 0 } function Z() { const U = te; return U >= l && console.warn("THREE.WebGLTextures: Trying to use " + U + " texture units while this GPU supports only " + l), te += 1, U } function fe(U) { const D = []; return D.push(U.wrapS), D.push(U.wrapT), D.push(U.wrapR || 0), D.push(U.magFilter), D.push(U.minFilter), D.push(U.anisotropy), D.push(U.internalFormat), D.push(U.format), D.push(U.type), D.push(U.generateMipmaps), D.push(U.premultiplyAlpha), D.push(U.flipY), D.push(U.unpackAlignment), D.push(U.encoding), D.join() } function ae(U, D) { const le = s.get(U); if (U.isVideoTexture && Pt(U), U.isRenderTargetTexture === !1 && U.version > 0 && le.__version !== U.version) { const Ie = U.image; if (Ie === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (Ie.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { Ue(le, U, D); return } } t.bindTexture(3553, le.__webglTexture, 33984 + D) } function De(U, D) { const le = s.get(U); if (U.version > 0 && le.__version !== U.version) { Ue(le, U, D); return } t.bindTexture(35866, le.__webglTexture, 33984 + D) } function Se(U, D) { const le = s.get(U); if (U.version > 0 && le.__version !== U.version) { Ue(le, U, D); return } t.bindTexture(32879, le.__webglTexture, 33984 + D) } function ie(U, D) { const le = s.get(U); if (U.version > 0 && le.__version !== U.version) { Pe(le, U, D); return } t.bindTexture(34067, le.__webglTexture, 33984 + D) } const ce = { [yn]: 10497, [Ss]: 33071, [Ta]: 33648 }, Te = { [Zt]: 9728, [Pu]: 9984, [Bu]: 9986, [Qt]: 9729, [df]: 9985, [eo]: 9987 }; function K(U, D, le) { if (le ? (i.texParameteri(U, 10242, ce[D.wrapS]), i.texParameteri(U, 10243, ce[D.wrapT]), (U === 32879 || U === 35866) && i.texParameteri(U, 32882, ce[D.wrapR]), i.texParameteri(U, 10240, Te[D.magFilter]), i.texParameteri(U, 10241, Te[D.minFilter])) : (i.texParameteri(U, 10242, 33071), i.texParameteri(U, 10243, 33071), (U === 32879 || U === 35866) && i.texParameteri(U, 32882, 33071), (D.wrapS !== Ss || D.wrapT !== Ss) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i.texParameteri(U, 10240, T(D.magFilter)), i.texParameteri(U, 10241, T(D.minFilter)), D.minFilter !== Zt && D.minFilter !== Qt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) { const Ie = e.get("EXT_texture_filter_anisotropic"); if (D.type === $i && e.has("OES_texture_float_linear") === !1 || a === !1 && D.type === gs && e.has("OES_texture_half_float_linear") === !1) return; (D.anisotropy > 1 || s.get(D).__currentAnisotropy) && (i.texParameterf(U, Ie.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(D.anisotropy, r.getMaxAnisotropy())), s.get(D).__currentAnisotropy = D.anisotropy) } } function je(U, D) { let le = !1; U.__webglInit === void 0 && (U.__webglInit = !0, D.addEventListener("dispose", z)); const Ie = D.source; let Be = v.get(Ie); Be === void 0 && (Be = {}, v.set(Ie, Be)); const Qe = fe(D); if (Qe !== U.__cacheKey) { Be[Qe] === void 0 && (Be[Qe] = { texture: i.createTexture(), usedTimes: 0 }, o.memory.textures++, le = !0), Be[Qe].usedTimes++; const rt = Be[U.__cacheKey]; rt !== void 0 && (Be[U.__cacheKey].usedTimes--, rt.usedTimes === 0 && F(D)), U.__cacheKey = Qe, U.__webglTexture = Be[Qe].texture } return le } function Ue(U, D, le) { let Ie = 3553; (D.isDataArrayTexture || D.isCompressedArrayTexture) && (Ie = 35866), D.isData3DTexture && (Ie = 32879); const Be = je(U, D), Qe = D.source; t.bindTexture(Ie, U.__webglTexture, 33984 + le); const rt = s.get(Qe); if (Qe.version !== rt.__version || Be === !0) { t.activeTexture(33984 + le), i.pixelStorei(37440, D.flipY), i.pixelStorei(37441, D.premultiplyAlpha), i.pixelStorei(3317, D.unpackAlignment), i.pixelStorei(37443, 0); const j = w(D) && _(D.image) === !1; let J = y(D.image, j, !1, h); J = ii(D, J); const Ve = _(J) || a, qe = n.convert(D.format, D.encoding); let ze = n.convert(D.type), ge = C(D.internalFormat, qe, ze, D.encoding, D.isVideoTexture); K(Ie, D, Ve); let lt; const It = D.mipmaps, M = a && D.isVideoTexture !== !0, k = rt.__version === void 0 || Be === !0, I = R(D, J, Ve); if (D.isDepthTexture) ge = 6402, a ? D.type === $i ? ge = 36012 : D.type === Ra ? ge = 33190 : D.type === Dl ? ge = 35056 : ge = 33189 : D.type === $i && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), D.format === Ol && ge === 6402 && D.type !== dx && D.type !== Ra && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), D.type = Ra, ze = n.convert(D.type)), D.format === Ll && ge === 6402 && (ge = 34041, D.type !== Dl && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), D.type = Dl, ze = n.convert(D.type))), k && (M ? t.texStorage2D(3553, 1, ge, J.width, J.height) : t.texImage2D(3553, 0, ge, J.width, J.height, 0, qe, ze, null)); else if (D.isDataTexture) if (It.length > 0 && Ve) { M && k && t.texStorage2D(3553, I, ge, It[0].width, It[0].height); for (let L = 0, G = It.length; L < G; L++)lt = It[L], M ? t.texSubImage2D(3553, L, 0, 0, lt.width, lt.height, qe, ze, lt.data) : t.texImage2D(3553, L, ge, lt.width, lt.height, 0, qe, ze, lt.data); D.generateMipmaps = !1 } else M ? (k && t.texStorage2D(3553, I, ge, J.width, J.height), t.texSubImage2D(3553, 0, 0, 0, J.width, J.height, qe, ze, J.data)) : t.texImage2D(3553, 0, ge, J.width, J.height, 0, qe, ze, J.data); else if (D.isCompressedTexture) if (D.isCompressedArrayTexture) { M && k && t.texStorage3D(35866, I, ge, It[0].width, It[0].height, J.depth); for (let L = 0, G = It.length; L < G; L++)lt = It[L], D.format !== _i ? qe !== null ? M ? t.compressedTexSubImage3D(35866, L, 0, 0, 0, lt.width, lt.height, J.depth, qe, lt.data, 0, 0) : t.compressedTexImage3D(35866, L, ge, lt.width, lt.height, J.depth, 0, lt.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? t.texSubImage3D(35866, L, 0, 0, 0, lt.width, lt.height, J.depth, qe, ze, lt.data) : t.texImage3D(35866, L, ge, lt.width, lt.height, J.depth, 0, qe, ze, lt.data) } else { M && k && t.texStorage2D(3553, I, ge, It[0].width, It[0].height); for (let L = 0, G = It.length; L < G; L++)lt = It[L], D.format !== _i ? qe !== null ? M ? t.compressedTexSubImage2D(3553, L, 0, 0, lt.width, lt.height, qe, lt.data) : t.compressedTexImage2D(3553, L, ge, lt.width, lt.height, 0, lt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? t.texSubImage2D(3553, L, 0, 0, lt.width, lt.height, qe, ze, lt.data) : t.texImage2D(3553, L, ge, lt.width, lt.height, 0, qe, ze, lt.data) } else if (D.isDataArrayTexture) M ? (k && t.texStorage3D(35866, I, ge, J.width, J.height, J.depth), t.texSubImage3D(35866, 0, 0, 0, 0, J.width, J.height, J.depth, qe, ze, J.data)) : t.texImage3D(35866, 0, ge, J.width, J.height, J.depth, 0, qe, ze, J.data); else if (D.isData3DTexture) M ? (k && t.texStorage3D(32879, I, ge, J.width, J.height, J.depth), t.texSubImage3D(32879, 0, 0, 0, 0, J.width, J.height, J.depth, qe, ze, J.data)) : t.texImage3D(32879, 0, ge, J.width, J.height, J.depth, 0, qe, ze, J.data); else if (D.isFramebufferTexture) { if (k) if (M) t.texStorage2D(3553, I, ge, J.width, J.height); else { let L = J.width, G = J.height; for (let V = 0; V < I; V++)t.texImage2D(3553, V, ge, L, G, 0, qe, ze, null), L >>= 1, G >>= 1 } } else if (It.length > 0 && Ve) { M && k && t.texStorage2D(3553, I, ge, It[0].width, It[0].height); for (let L = 0, G = It.length; L < G; L++)lt = It[L], M ? t.texSubImage2D(3553, L, 0, 0, qe, ze, lt) : t.texImage2D(3553, L, ge, qe, ze, lt); D.generateMipmaps = !1 } else M ? (k && t.texStorage2D(3553, I, ge, J.width, J.height), t.texSubImage2D(3553, 0, 0, 0, qe, ze, J)) : t.texImage2D(3553, 0, ge, qe, ze, J); E(D, Ve) && P(Ie), rt.__version = Qe.version, D.onUpdate && D.onUpdate(D) } U.__version = D.version } function Pe(U, D, le) { if (D.image.length !== 6) return; const Ie = je(U, D), Be = D.source; t.bindTexture(34067, U.__webglTexture, 33984 + le); const Qe = s.get(Be); if (Be.version !== Qe.__version || Ie === !0) { t.activeTexture(33984 + le), i.pixelStorei(37440, D.flipY), i.pixelStorei(37441, D.premultiplyAlpha), i.pixelStorei(3317, D.unpackAlignment), i.pixelStorei(37443, 0); const rt = D.isCompressedTexture || D.image[0].isCompressedTexture, j = D.image[0] && D.image[0].isDataTexture, J = []; for (let L = 0; L < 6; L++)!rt && !j ? J[L] = y(D.image[L], !1, !0, c) : J[L] = j ? D.image[L].image : D.image[L], J[L] = ii(D, J[L]); const Ve = J[0], qe = _(Ve) || a, ze = n.convert(D.format, D.encoding), ge = n.convert(D.type), lt = C(D.internalFormat, ze, ge, D.encoding), It = a && D.isVideoTexture !== !0, M = Qe.__version === void 0 || Ie === !0; let k = R(D, Ve, qe); K(34067, D, qe); let I; if (rt) { It && M && t.texStorage2D(34067, k, lt, Ve.width, Ve.height); for (let L = 0; L < 6; L++) { I = J[L].mipmaps; for (let G = 0; G < I.length; G++) { const V = I[G]; D.format !== _i ? ze !== null ? It ? t.compressedTexSubImage2D(34069 + L, G, 0, 0, V.width, V.height, ze, V.data) : t.compressedTexImage2D(34069 + L, G, lt, V.width, V.height, 0, V.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : It ? t.texSubImage2D(34069 + L, G, 0, 0, V.width, V.height, ze, ge, V.data) : t.texImage2D(34069 + L, G, lt, V.width, V.height, 0, ze, ge, V.data) } } } else { I = D.mipmaps, It && M && (I.length > 0 && k++, t.texStorage2D(34067, k, lt, J[0].width, J[0].height)); for (let L = 0; L < 6; L++)if (j) { It ? t.texSubImage2D(34069 + L, 0, 0, 0, J[L].width, J[L].height, ze, ge, J[L].data) : t.texImage2D(34069 + L, 0, lt, J[L].width, J[L].height, 0, ze, ge, J[L].data); for (let G = 0; G < I.length; G++) { const V = I[G].image[L].image; It ? t.texSubImage2D(34069 + L, G + 1, 0, 0, V.width, V.height, ze, ge, V.data) : t.texImage2D(34069 + L, G + 1, lt, V.width, V.height, 0, ze, ge, V.data) } } else { It ? t.texSubImage2D(34069 + L, 0, 0, 0, ze, ge, J[L]) : t.texImage2D(34069 + L, 0, lt, ze, ge, J[L]); for (let G = 0; G < I.length; G++) { const V = I[G]; It ? t.texSubImage2D(34069 + L, G + 1, 0, 0, ze, ge, V.image[L]) : t.texImage2D(34069 + L, G + 1, lt, ze, ge, V.image[L]) } } } E(D, qe) && P(34067), Qe.__version = Be.version, D.onUpdate && D.onUpdate(D) } U.__version = D.version } function ve(U, D, le, Ie, Be) { const Qe = n.convert(le.format, le.encoding), rt = n.convert(le.type), j = C(le.internalFormat, Qe, rt, le.encoding); s.get(D).__hasExternalTextures || (Be === 32879 || Be === 35866 ? t.texImage3D(Be, 0, j, D.width, D.height, D.depth, 0, Qe, rt, null) : t.texImage2D(Be, 0, j, D.width, D.height, 0, Qe, rt, null)), t.bindFramebuffer(36160, U), dt(D) ? p.framebufferTexture2DMultisampleEXT(36160, Ie, Be, s.get(le).__webglTexture, 0, ut(D)) : (Be === 3553 || Be >= 34069 && Be <= 34074) && i.framebufferTexture2D(36160, Ie, Be, s.get(le).__webglTexture, 0), t.bindFramebuffer(36160, null) } function de(U, D, le) { if (i.bindRenderbuffer(36161, U), D.depthBuffer && !D.stencilBuffer) { let Ie = 33189; if (le || dt(D)) { const Be = D.depthTexture; Be && Be.isDepthTexture && (Be.type === $i ? Ie = 36012 : Be.type === Ra && (Ie = 33190)); const Qe = ut(D); dt(D) ? p.renderbufferStorageMultisampleEXT(36161, Qe, Ie, D.width, D.height) : i.renderbufferStorageMultisample(36161, Qe, Ie, D.width, D.height) } else i.renderbufferStorage(36161, Ie, D.width, D.height); i.framebufferRenderbuffer(36160, 36096, 36161, U) } else if (D.depthBuffer && D.stencilBuffer) { const Ie = ut(D); le && dt(D) === !1 ? i.renderbufferStorageMultisample(36161, Ie, 35056, D.width, D.height) : dt(D) ? p.renderbufferStorageMultisampleEXT(36161, Ie, 35056, D.width, D.height) : i.renderbufferStorage(36161, 34041, D.width, D.height), i.framebufferRenderbuffer(36160, 33306, 36161, U) } else { const Ie = D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture]; for (let Be = 0; Be < Ie.length; Be++) { const Qe = Ie[Be], rt = n.convert(Qe.format, Qe.encoding), j = n.convert(Qe.type), J = C(Qe.internalFormat, rt, j, Qe.encoding), Ve = ut(D); le && dt(D) === !1 ? i.renderbufferStorageMultisample(36161, Ve, J, D.width, D.height) : dt(D) ? p.renderbufferStorageMultisampleEXT(36161, Ve, J, D.width, D.height) : i.renderbufferStorage(36161, J, D.width, D.height) } } i.bindRenderbuffer(36161, null) } function Ae(U, D) { if (D && D.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(36160, U), !(D.depthTexture && D.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); (!s.get(D.depthTexture).__webglTexture || D.depthTexture.image.width !== D.width || D.depthTexture.image.height !== D.height) && (D.depthTexture.image.width = D.width, D.depthTexture.image.height = D.height, D.depthTexture.needsUpdate = !0), ae(D.depthTexture, 0); const le = s.get(D.depthTexture).__webglTexture, Ie = ut(D); if (D.depthTexture.format === Ol) dt(D) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, le, 0, Ie) : i.framebufferTexture2D(36160, 36096, 3553, le, 0); else if (D.depthTexture.format === Ll) dt(D) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, le, 0, Ie) : i.framebufferTexture2D(36160, 33306, 3553, le, 0); else throw new Error("Unknown depthTexture format") } function pe(U) { const D = s.get(U), le = U.isWebGLCubeRenderTarget === !0; if (U.depthTexture && !D.__autoAllocateDepthBuffer) { if (le) throw new Error("target.depthTexture not supported in Cube render targets"); Ae(D.__webglFramebuffer, U) } else if (le) { D.__webglDepthbuffer = []; for (let Ie = 0; Ie < 6; Ie++)t.bindFramebuffer(36160, D.__webglFramebuffer[Ie]), D.__webglDepthbuffer[Ie] = i.createRenderbuffer(), de(D.__webglDepthbuffer[Ie], U, !1) } else t.bindFramebuffer(36160, D.__webglFramebuffer), D.__webglDepthbuffer = i.createRenderbuffer(), de(D.__webglDepthbuffer, U, !1); t.bindFramebuffer(36160, null) } function Fe(U, D, le) { const Ie = s.get(U); D !== void 0 && ve(Ie.__webglFramebuffer, U, U.texture, 36064, 3553), le !== void 0 && pe(U) } function Re(U) { const D = U.texture, le = s.get(U), Ie = s.get(D); U.addEventListener("dispose", H), U.isWebGLMultipleRenderTargets !== !0 && (Ie.__webglTexture === void 0 && (Ie.__webglTexture = i.createTexture()), Ie.__version = D.version, o.memory.textures++); const Be = U.isWebGLCubeRenderTarget === !0, Qe = U.isWebGLMultipleRenderTargets === !0, rt = _(U) || a; if (Be) { le.__webglFramebuffer = []; for (let j = 0; j < 6; j++)le.__webglFramebuffer[j] = i.createFramebuffer() } else { if (le.__webglFramebuffer = i.createFramebuffer(), Qe) if (r.drawBuffers) { const j = U.texture; for (let J = 0, Ve = j.length; J < Ve; J++) { const qe = s.get(j[J]); qe.__webglTexture === void 0 && (qe.__webglTexture = i.createTexture(), o.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); if (a && U.samples > 0 && dt(U) === !1) { const j = Qe ? D : [D]; le.__webglMultisampledFramebuffer = i.createFramebuffer(), le.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, le.__webglMultisampledFramebuffer); for (let J = 0; J < j.length; J++) { const Ve = j[J]; le.__webglColorRenderbuffer[J] = i.createRenderbuffer(), i.bindRenderbuffer(36161, le.__webglColorRenderbuffer[J]); const qe = n.convert(Ve.format, Ve.encoding), ze = n.convert(Ve.type), ge = C(Ve.internalFormat, qe, ze, Ve.encoding, U.isXRRenderTarget === !0), lt = ut(U); i.renderbufferStorageMultisample(36161, lt, ge, U.width, U.height), i.framebufferRenderbuffer(36160, 36064 + J, 36161, le.__webglColorRenderbuffer[J]) } i.bindRenderbuffer(36161, null), U.depthBuffer && (le.__webglDepthRenderbuffer = i.createRenderbuffer(), de(le.__webglDepthRenderbuffer, U, !0)), t.bindFramebuffer(36160, null) } } if (Be) { t.bindTexture(34067, Ie.__webglTexture), K(34067, D, rt); for (let j = 0; j < 6; j++)ve(le.__webglFramebuffer[j], U, D, 36064, 34069 + j); E(D, rt) && P(34067), t.unbindTexture() } else if (Qe) { const j = U.texture; for (let J = 0, Ve = j.length; J < Ve; J++) { const qe = j[J], ze = s.get(qe); t.bindTexture(3553, ze.__webglTexture), K(3553, qe, rt), ve(le.__webglFramebuffer, U, qe, 36064 + J, 3553), E(qe, rt) && P(3553) } t.unbindTexture() } else { let j = 3553; (U.isWebGL3DRenderTarget || U.isWebGLArrayRenderTarget) && (a ? j = U.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(j, Ie.__webglTexture), K(j, D, rt), ve(le.__webglFramebuffer, U, D, 36064, j), E(D, rt) && P(j), t.unbindTexture() } U.depthBuffer && pe(U) } function ht(U) { const D = _(U) || a, le = U.isWebGLMultipleRenderTargets === !0 ? U.texture : [U.texture]; for (let Ie = 0, Be = le.length; Ie < Be; Ie++) { const Qe = le[Ie]; if (E(Qe, D)) { const rt = U.isWebGLCubeRenderTarget ? 34067 : 3553, j = s.get(Qe).__webglTexture; t.bindTexture(rt, j), P(rt), t.unbindTexture() } } } function me(U) { if (a && U.samples > 0 && dt(U) === !1) { const D = U.isWebGLMultipleRenderTargets ? U.texture : [U.texture], le = U.width, Ie = U.height; let Be = 16384; const Qe = [], rt = U.stencilBuffer ? 33306 : 36096, j = s.get(U), J = U.isWebGLMultipleRenderTargets === !0; if (J) for (let Ve = 0; Ve < D.length; Ve++)t.bindFramebuffer(36160, j.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064 + Ve, 36161, null), t.bindFramebuffer(36160, j.__webglFramebuffer), i.framebufferTexture2D(36009, 36064 + Ve, 3553, null, 0); t.bindFramebuffer(36008, j.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, j.__webglFramebuffer); for (let Ve = 0; Ve < D.length; Ve++) { Qe.push(36064 + Ve), U.depthBuffer && Qe.push(rt); const qe = j.__ignoreDepthValues !== void 0 ? j.__ignoreDepthValues : !1; if (qe === !1 && (U.depthBuffer && (Be |= 256), U.stencilBuffer && (Be |= 1024)), J && i.framebufferRenderbuffer(36008, 36064, 36161, j.__webglColorRenderbuffer[Ve]), qe === !0 && (i.invalidateFramebuffer(36008, [rt]), i.invalidateFramebuffer(36009, [rt])), J) { const ze = s.get(D[Ve]).__webglTexture; i.framebufferTexture2D(36009, 36064, 3553, ze, 0) } i.blitFramebuffer(0, 0, le, Ie, 0, 0, le, Ie, Be, 9728), f && i.invalidateFramebuffer(36008, Qe) } if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), J) for (let Ve = 0; Ve < D.length; Ve++) { t.bindFramebuffer(36160, j.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064 + Ve, 36161, j.__webglColorRenderbuffer[Ve]); const qe = s.get(D[Ve]).__webglTexture; t.bindFramebuffer(36160, j.__webglFramebuffer), i.framebufferTexture2D(36009, 36064 + Ve, 3553, qe, 0) } t.bindFramebuffer(36009, j.__webglMultisampledFramebuffer) } } function ut(U) { return Math.min(d, U.samples) } function dt(U) { const D = s.get(U); return a && U.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && D.__useRenderToTexture !== !1 } function Pt(U) { const D = o.render.frame; g.get(U) !== D && (g.set(U, D), U.update()) } function ii(U, D) { const le = U.encoding, Ie = U.format, Be = U.type; return U.isCompressedTexture === !0 || U.isVideoTexture === !0 || U.format === eA || le !== Qi && (le === Xe ? a === !1 ? e.has("EXT_sRGB") === !0 && Ie === _i ? (U.format = eA, U.minFilter = Qt, U.generateMipmaps = !1) : D = Nx.sRGBToLinear(D) : (Ie !== _i || Be !== ui) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", le)), D } this.allocateTextureUnit = Z, this.resetTextureUnits = re, this.setTexture2D = ae, this.setTexture2DArray = De, this.setTexture3D = Se, this.setTextureCube = ie, this.rebindTextures = Fe, this.setupRenderTarget = Re, this.updateRenderTargetMipmap = ht, this.updateMultisampleRenderTarget = me, this.setupDepthRenderbuffer = pe, this.setupFrameBufferTexture = ve, this.useMultisampledRTT = dt } function IR(i, e, t) { const s = t.isWebGL2; function r(n, o = null) { let a; if (n === ui) return 5121; if (n === gT) return 32819; if (n === mT) return 32820; if (n === dT) return 5120; if (n === pT) return 5122; if (n === dx) return 5123; if (n === fT) return 5124; if (n === Ra) return 5125; if (n === $i) return 5126; if (n === gs) return s ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null); if (n === vT) return 6406; if (n === _i) return 6408; if (n === Qv) return 6409; if (n === yT) return 6410; if (n === Ol) return 6402; if (n === Ll) return 34041; if (n === AT) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408; if (n === eA) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null; if (n === Fl) return 6403; if (n === bT) return 36244; if (n === oh) return 33319; if (n === _T) return 33320; if (n === xT) return 36249; if (n === pf || n === Gv || n === Hv || n === ff) if (o === Xe) if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) { if (n === pf) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (n === Gv) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (n === Hv) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (n === ff) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else return null; else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) { if (n === pf) return a.COMPRESSED_RGB_S3TC_DXT1_EXT; if (n === Gv) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (n === Hv) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (n === ff) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT } else return null; if (n === Vv || n === px || n === Wv || n === fx) if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) { if (n === Vv) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (n === px) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (n === Wv) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (n === fx) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } else return null; if (n === gx) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null; if (n === qv || n === Xv) if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) { if (n === qv) return o === Xe ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2; if (n === Xv) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC } else return null; if (n === Yv || n === mx || n === vx || n === Ax || n === yx || n === bx || n === _x || n === xx || n === wx || n === Cx || n === Sx || n === Ex || n === Mx || n === Ix) if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) { if (n === Yv) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR; if (n === mx) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR; if (n === vx) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR; if (n === Ax) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR; if (n === yx) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR; if (n === bx) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR; if (n === _x) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR; if (n === xx) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR; if (n === wx) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR; if (n === Cx) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR; if (n === Sx) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR; if (n === Ex) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR; if (n === Mx) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR; if (n === Ix) return o === Xe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR } else return null; if (n === Jv) if (a = e.get("EXT_texture_compression_bptc"), a !== null) { if (n === Jv) return o === Xe ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT } else return null; return n === Dl ? s ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : i[n] !== void 0 ? i[n] : null } return { convert: r } } class TR extends Xt { constructor(e = []) { super(), this.isArrayCamera = !0, this.cameras = e } } class wn extends Me { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const V5 = { type: "move" }; let mw = class { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return this._hand === null && (this._hand = new wn, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return this._targetRay === null && (this._targetRay = new wn, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new S, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new S), this._targetRay } getGripSpace() { return this._grip === null && (this._grip = new wn, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new S, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new S), this._grip } dispatchEvent(i) { return this._targetRay !== null && this._targetRay.dispatchEvent(i), this._grip !== null && this._grip.dispatchEvent(i), this._hand !== null && this._hand.dispatchEvent(i), this } connect(i) { if (i && i.hand) { const e = this._hand; if (e) for (const t of i.hand.values()) this._getHandJoint(e, t) } return this.dispatchEvent({ type: "connected", data: i }), this } disconnect(i) { return this.dispatchEvent({ type: "disconnected", data: i }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this } update(i, e, t) { let s = null, r = null, n = null; const o = this._targetRay, a = this._grip, l = this._hand; if (i && e.session.visibilityState !== "visible-blurred") { if (l && i.hand) { n = !0; for (const g of i.hand.values()) { const m = e.getJointPose(g, t), v = this._getHandJoint(l, g); m !== null && (v.matrix.fromArray(m.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.jointRadius = m.radius), v.visible = m !== null } const c = l.joints["index-finger-tip"], h = l.joints["thumb-tip"], d = c.position.distanceTo(h.position), p = .02, f = .005; l.inputState.pinching && d > p + f ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: i.handedness, target: this })) : !l.inputState.pinching && d <= p - f && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: i.handedness, target: this })) } else a !== null && i.gripSpace && (r = e.getPose(i.gripSpace, t), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1)); o !== null && (s = e.getPose(i.targetRaySpace, t), s === null && r !== null && (s = r), s !== null && (o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), s.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(s.linearVelocity)) : o.hasLinearVelocity = !1, s.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(s.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(V5))) } return o !== null && (o.visible = s !== null), a !== null && (a.visible = r !== null), l !== null && (l.visible = n !== null), this } _getHandJoint(i, e) { if (i.joints[e.jointName] === void 0) { const t = new wn; t.matrixAutoUpdate = !1, t.visible = !1, i.joints[e.jointName] = t, i.add(t) } return i.joints[e.jointName] } }; class IA extends Nt { constructor(e, t, s, r, n, o, a, l, c, h) { if (h = h !== void 0 ? h : Ol, h !== Ol && h !== Ll) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); s === void 0 && h === Ol && (s = Ra), s === void 0 && h === Ll && (s = Dl), super(null, r, n, o, a, l, h, s, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : Zt, this.minFilter = l !== void 0 ? l : Zt, this.flipY = !1, this.generateMipmaps = !1 } } class W5 extends ms { constructor(e, t) { super(); const s = this; let r = null, n = 1, o = !1, a = null, l = "local-floor", c = null, h = null, d = null, p = null, f = null, g = null; const m = t.getContextAttributes(); let v = null, A = null; const b = [], y = [], _ = new Set, w = new Map, E = new Xt; E.layers.enable(1), E.viewport = new st; const P = new Xt; P.layers.enable(2), P.viewport = new st; const C = [E, P], R = new TR; R.layers.enable(1), R.layers.enable(2); let T = null, z = null; this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (ie) { let ce = b[ie]; return ce === void 0 && (ce = new mw, b[ie] = ce), ce.getTargetRaySpace() }, this.getControllerGrip = function (ie) { let ce = b[ie]; return ce === void 0 && (ce = new mw, b[ie] = ce), ce.getGripSpace() }, this.getHand = function (ie) { let ce = b[ie]; return ce === void 0 && (ce = new mw, b[ie] = ce), ce.getHandSpace() }; function H(ie) { const ce = y.indexOf(ie.inputSource); if (ce === -1) return; const Te = b[ce]; Te !== void 0 && Te.dispatchEvent({ type: ie.type, data: ie.inputSource }) } function N() { r.removeEventListener("select", H), r.removeEventListener("selectstart", H), r.removeEventListener("selectend", H), r.removeEventListener("squeeze", H), r.removeEventListener("squeezestart", H), r.removeEventListener("squeezeend", H), r.removeEventListener("end", N), r.removeEventListener("inputsourceschange", F); for (let ie = 0; ie < b.length; ie++) { const ce = y[ie]; ce !== null && (y[ie] = null, b[ie].disconnect(ce)) } T = null, z = null, e.setRenderTarget(v), f = null, p = null, d = null, r = null, A = null, Se.stop(), s.isPresenting = !1, s.dispatchEvent({ type: "sessionend" }) } this.setFramebufferScaleFactor = function (ie, ce = !1) { n = ie, o = ce, s.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (ie) { l = ie, s.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return c || a }, this.setReferenceSpace = function (ie) { c = ie }, this.getBaseLayer = function () { return p !== null ? p : f }, this.getBinding = function () { return d }, this.getFrame = function () { return g }, this.getSession = function () { return r }, this.setSession = async function (ie) { if (r = ie, r !== null) { if (v = e.getRenderTarget(), r.addEventListener("select", H), r.addEventListener("selectstart", H), r.addEventListener("selectend", H), r.addEventListener("squeeze", H), r.addEventListener("squeezestart", H), r.addEventListener("squeezeend", H), r.addEventListener("end", N), r.addEventListener("inputsourceschange", F), m.xrCompatible !== !0 && await t.makeXRCompatible(), o === !0 && XRWebGLLayer.getNativeFramebufferScaleFactor) { const ce = XRWebGLLayer.getNativeFramebufferScaleFactor(r); ce < n && (n = ce) } if (r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) { const ce = { antialias: r.renderState.layers === void 0 ? m.antialias : !0, alpha: m.alpha, depth: m.depth, stencil: m.stencil, framebufferScaleFactor: n }; f = new XRWebGLLayer(r, t, ce), r.updateRenderState({ baseLayer: f }), A = new ri(f.framebufferWidth, f.framebufferHeight, { format: _i, type: ui, encoding: e.outputEncoding, stencilBuffer: m.stencil }) } else { let ce = null, Te = null, K = null; m.depth && (K = m.stencil ? 35056 : 33190, ce = m.stencil ? Ll : Ol, Te = m.stencil ? Dl : Ra); const je = { colorFormat: 32856, depthFormat: K, scaleFactor: n }; d = new XRWebGLBinding(r, t), p = d.createProjectionLayer(je), r.updateRenderState({ layers: [p] }), A = new ri(p.textureWidth, p.textureHeight, { format: _i, type: ui, depthTexture: new IA(p.textureWidth, p.textureHeight, Te, void 0, void 0, void 0, void 0, void 0, void 0, ce), stencilBuffer: m.stencil, encoding: e.outputEncoding, samples: m.antialias ? 4 : 0 }); const Ue = e.properties.get(A); Ue.__ignoreDepthValues = p.ignoreDepthValues } A.isXRRenderTarget = !0, this.setFoveation(1), c = null, a = await r.requestReferenceSpace(l), Se.setContext(r), Se.start(), s.isPresenting = !0, s.dispatchEvent({ type: "sessionstart" }) } }; function F(ie) { for (let ce = 0; ce < ie.removed.length; ce++) { const Te = ie.removed[ce], K = y.indexOf(Te); K >= 0 && (y[K] = null, b[K].disconnect(Te)) } for (let ce = 0; ce < ie.added.length; ce++) { const Te = ie.added[ce]; let K = y.indexOf(Te); if (K === -1) { for (let Ue = 0; Ue < b.length; Ue++)if (Ue >= y.length) { y.push(Te), K = Ue; break } else if (y[Ue] === null) { y[Ue] = Te, K = Ue; break } if (K === -1) break } const je = b[K]; je && je.connect(Te) } } const X = new S, te = new S; function re(ie, ce, Te) { X.setFromMatrixPosition(ce.matrixWorld), te.setFromMatrixPosition(Te.matrixWorld); const K = X.distanceTo(te), je = ce.projectionMatrix.elements, Ue = Te.projectionMatrix.elements, Pe = je[14] / (je[10] - 1), ve = je[14] / (je[10] + 1), de = (je[9] + 1) / je[5], Ae = (je[9] - 1) / je[5], pe = (je[8] - 1) / je[0], Fe = (Ue[8] + 1) / Ue[0], Re = Pe * pe, ht = Pe * Fe, me = K / (-pe + Fe), ut = me * -pe; ce.matrixWorld.decompose(ie.position, ie.quaternion, ie.scale), ie.translateX(ut), ie.translateZ(me), ie.matrixWorld.compose(ie.position, ie.quaternion, ie.scale), ie.matrixWorldInverse.copy(ie.matrixWorld).invert(); const dt = Pe + me, Pt = ve + me, ii = Re - ut, U = ht + (K - ut), D = de * ve / Pt * dt, le = Ae * ve / Pt * dt; ie.projectionMatrix.makePerspective(ii, U, D, le, dt, Pt), ie.projectionMatrixInverse.copy(ie.projectionMatrix).invert() } function Z(ie, ce) { ce === null ? ie.matrixWorld.copy(ie.matrix) : ie.matrixWorld.multiplyMatrices(ce.matrixWorld, ie.matrix), ie.matrixWorldInverse.copy(ie.matrixWorld).invert() } this.updateCamera = function (ie) { if (r === null) return; R.near = P.near = E.near = ie.near, R.far = P.far = E.far = ie.far, (T !== R.near || z !== R.far) && (r.updateRenderState({ depthNear: R.near, depthFar: R.far }), T = R.near, z = R.far); const ce = ie.parent, Te = R.cameras; Z(R, ce); for (let K = 0; K < Te.length; K++)Z(Te[K], ce); Te.length === 2 ? re(R, E, P) : R.projectionMatrix.copy(E.projectionMatrix), fe(ie, R, ce) }; function fe(ie, ce, Te) { Te === null ? ie.matrix.copy(ce.matrixWorld) : (ie.matrix.copy(Te.matrixWorld), ie.matrix.invert(), ie.matrix.multiply(ce.matrixWorld)), ie.matrix.decompose(ie.position, ie.quaternion, ie.scale), ie.updateMatrixWorld(!0); const K = ie.children; for (let je = 0, Ue = K.length; je < Ue; je++)K[je].updateMatrixWorld(!0); ie.projectionMatrix.copy(ce.projectionMatrix), ie.projectionMatrixInverse.copy(ce.projectionMatrixInverse), ie.isPerspectiveCamera && (ie.fov = ku * 2 * Math.atan(1 / ie.projectionMatrix.elements[5]), ie.zoom = 1) } this.getCamera = function () { return R }, this.getFoveation = function () { if (p !== null) return p.fixedFoveation; if (f !== null) return f.fixedFoveation }, this.setFoveation = function (ie) { p !== null && (p.fixedFoveation = ie), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = ie) }, this.getPlanes = function () { return _ }; let ae = null; function De(ie, ce) { if (h = ce.getViewerPose(c || a), g = ce, h !== null) { const Te = h.views; f !== null && (e.setRenderTargetFramebuffer(A, f.framebuffer), e.setRenderTarget(A)); let K = !1; Te.length !== R.cameras.length && (R.cameras.length = 0, K = !0); for (let je = 0; je < Te.length; je++) { const Ue = Te[je]; let Pe = null; if (f !== null) Pe = f.getViewport(Ue); else { const de = d.getViewSubImage(p, Ue); Pe = de.viewport, je === 0 && (e.setRenderTargetTextures(A, de.colorTexture, p.ignoreDepthValues ? void 0 : de.depthStencilTexture), e.setRenderTarget(A)) } let ve = C[je]; ve === void 0 && (ve = new Xt, ve.layers.enable(je), ve.viewport = new st, C[je] = ve), ve.matrix.fromArray(Ue.transform.matrix), ve.matrix.decompose(ve.position, ve.quaternion, ve.scale), ve.projectionMatrix.fromArray(Ue.projectionMatrix), ve.projectionMatrixInverse.copy(ve.projectionMatrix).invert(), ve.viewport.set(Pe.x, Pe.y, Pe.width, Pe.height), je === 0 && (R.matrix.copy(ve.matrix), R.matrix.decompose(R.position, R.quaternion, R.scale)), K === !0 && R.cameras.push(ve) } } for (let Te = 0; Te < b.length; Te++) { const K = y[Te], je = b[Te]; K !== null && je !== void 0 && je.update(K, ce, c || a) } if (ae && ae(ie, ce), ce.detectedPlanes) { s.dispatchEvent({ type: "planesdetected", data: ce.detectedPlanes }); let Te = null; for (const K of _) ce.detectedPlanes.has(K) || (Te === null && (Te = []), Te.push(K)); if (Te !== null) for (const K of Te) _.delete(K), w.delete(K), s.dispatchEvent({ type: "planeremoved", data: K }); for (const K of ce.detectedPlanes) if (!_.has(K)) _.add(K), w.set(K, ce.lastChangedTime), s.dispatchEvent({ type: "planeadded", data: K }); else { const je = w.get(K); K.lastChangedTime > je && (w.set(K, K.lastChangedTime), s.dispatchEvent({ type: "planechanged", data: K })) } } g = null } const Se = new tR; Se.setAnimationLoop(De), this.setAnimationLoop = function (ie) { ae = ie }, this.dispose = function () { } } } function q5(i, e) { function t(m, v) { v.color.getRGB(m.fogColor.value, eR(i)), v.isFog ? (m.fogNear.value = v.near, m.fogFar.value = v.far) : v.isFogExp2 && (m.fogDensity.value = v.density) } function s(m, v, A, b, y) { v.isMeshBasicMaterial || v.isMeshLambertMaterial ? r(m, v) : v.isMeshToonMaterial ? (r(m, v), h(m, v)) : v.isMeshPhongMaterial ? (r(m, v), c(m, v)) : v.isMeshStandardMaterial ? (r(m, v), d(m, v), v.isMeshPhysicalMaterial && p(m, v, y)) : v.isMeshMatcapMaterial ? (r(m, v), f(m, v)) : v.isMeshDepthMaterial ? r(m, v) : v.isMeshDistanceMaterial ? (r(m, v), g(m, v)) : v.isMeshNormalMaterial ? r(m, v) : v.isLineBasicMaterial ? (n(m, v), v.isLineDashedMaterial && o(m, v)) : v.isPointsMaterial ? a(m, v, A, b) : v.isSpriteMaterial ? l(m, v) : v.isShadowMaterial ? (m.color.value.copy(v.color), m.opacity.value = v.opacity) : v.isShaderMaterial && (v.uniformsNeedUpdate = !1) } function r(m, v) { m.opacity.value = v.opacity, v.color && m.diffuse.value.copy(v.color), v.emissive && m.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity), v.map && (m.map.value = v.map), v.alphaMap && (m.alphaMap.value = v.alphaMap), v.bumpMap && (m.bumpMap.value = v.bumpMap, m.bumpScale.value = v.bumpScale, v.side === fs && (m.bumpScale.value *= -1)), v.displacementMap && (m.displacementMap.value = v.displacementMap, m.displacementScale.value = v.displacementScale, m.displacementBias.value = v.displacementBias), v.emissiveMap && (m.emissiveMap.value = v.emissiveMap), v.normalMap && (m.normalMap.value = v.normalMap, m.normalScale.value.copy(v.normalScale), v.side === fs && m.normalScale.value.negate()), v.specularMap && (m.specularMap.value = v.specularMap), v.alphaTest > 0 && (m.alphaTest.value = v.alphaTest); const A = e.get(v).envMap; if (A && (m.envMap.value = A, m.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1, m.reflectivity.value = v.reflectivity, m.ior.value = v.ior, m.refractionRatio.value = v.refractionRatio), v.lightMap) { m.lightMap.value = v.lightMap; const _ = i.physicallyCorrectLights !== !0 ? Math.PI : 1; m.lightMapIntensity.value = v.lightMapIntensity * _ } v.aoMap && (m.aoMap.value = v.aoMap, m.aoMapIntensity.value = v.aoMapIntensity); let b; v.map ? b = v.map : v.specularMap ? b = v.specularMap : v.displacementMap ? b = v.displacementMap : v.normalMap ? b = v.normalMap : v.bumpMap ? b = v.bumpMap : v.roughnessMap ? b = v.roughnessMap : v.metalnessMap ? b = v.metalnessMap : v.alphaMap ? b = v.alphaMap : v.emissiveMap ? b = v.emissiveMap : v.clearcoatMap ? b = v.clearcoatMap : v.clearcoatNormalMap ? b = v.clearcoatNormalMap : v.clearcoatRoughnessMap ? b = v.clearcoatRoughnessMap : v.iridescenceMap ? b = v.iridescenceMap : v.iridescenceThicknessMap ? b = v.iridescenceThicknessMap : v.specularIntensityMap ? b = v.specularIntensityMap : v.specularColorMap ? b = v.specularColorMap : v.transmissionMap ? b = v.transmissionMap : v.thicknessMap ? b = v.thicknessMap : v.sheenColorMap ? b = v.sheenColorMap : v.sheenRoughnessMap && (b = v.sheenRoughnessMap), b !== void 0 && (b.isWebGLRenderTarget && (b = b.texture), b.matrixAutoUpdate === !0 && b.updateMatrix(), m.uvTransform.value.copy(b.matrix)); let y; v.aoMap ? y = v.aoMap : v.lightMap && (y = v.lightMap), y !== void 0 && (y.isWebGLRenderTarget && (y = y.texture), y.matrixAutoUpdate === !0 && y.updateMatrix(), m.uv2Transform.value.copy(y.matrix)) } function n(m, v) { m.diffuse.value.copy(v.color), m.opacity.value = v.opacity } function o(m, v) { m.dashSize.value = v.dashSize, m.totalSize.value = v.dashSize + v.gapSize, m.scale.value = v.scale } function a(m, v, A, b) { m.diffuse.value.copy(v.color), m.opacity.value = v.opacity, m.size.value = v.size * A, m.scale.value = b * .5, v.map && (m.map.value = v.map), v.alphaMap && (m.alphaMap.value = v.alphaMap), v.alphaTest > 0 && (m.alphaTest.value = v.alphaTest); let y; v.map ? y = v.map : v.alphaMap && (y = v.alphaMap), y !== void 0 && (y.matrixAutoUpdate === !0 && y.updateMatrix(), m.uvTransform.value.copy(y.matrix)) } function l(m, v) { m.diffuse.value.copy(v.color), m.opacity.value = v.opacity, m.rotation.value = v.rotation, v.map && (m.map.value = v.map), v.alphaMap && (m.alphaMap.value = v.alphaMap), v.alphaTest > 0 && (m.alphaTest.value = v.alphaTest); let A; v.map ? A = v.map : v.alphaMap && (A = v.alphaMap), A !== void 0 && (A.matrixAutoUpdate === !0 && A.updateMatrix(), m.uvTransform.value.copy(A.matrix)) } function c(m, v) { m.specular.value.copy(v.specular), m.shininess.value = Math.max(v.shininess, 1e-4) } function h(m, v) { v.gradientMap && (m.gradientMap.value = v.gradientMap) } function d(m, v) { m.roughness.value = v.roughness, m.metalness.value = v.metalness, v.roughnessMap && (m.roughnessMap.value = v.roughnessMap), v.metalnessMap && (m.metalnessMap.value = v.metalnessMap), e.get(v).envMap && (m.envMapIntensity.value = v.envMapIntensity) } function p(m, v, A) { m.ior.value = v.ior, v.sheen > 0 && (m.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen), m.sheenRoughness.value = v.sheenRoughness, v.sheenColorMap && (m.sheenColorMap.value = v.sheenColorMap), v.sheenRoughnessMap && (m.sheenRoughnessMap.value = v.sheenRoughnessMap)), v.clearcoat > 0 && (m.clearcoat.value = v.clearcoat, m.clearcoatRoughness.value = v.clearcoatRoughness, v.clearcoatMap && (m.clearcoatMap.value = v.clearcoatMap), v.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap), v.clearcoatNormalMap && (m.clearcoatNormalScale.value.copy(v.clearcoatNormalScale), m.clearcoatNormalMap.value = v.clearcoatNormalMap, v.side === fs && m.clearcoatNormalScale.value.negate())), v.iridescence > 0 && (m.iridescence.value = v.iridescence, m.iridescenceIOR.value = v.iridescenceIOR, m.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1], v.iridescenceMap && (m.iridescenceMap.value = v.iridescenceMap), v.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = v.iridescenceThicknessMap)), v.transmission > 0 && (m.transmission.value = v.transmission, m.transmissionSamplerMap.value = A.texture, m.transmissionSamplerSize.value.set(A.width, A.height), v.transmissionMap && (m.transmissionMap.value = v.transmissionMap), m.thickness.value = v.thickness, v.thicknessMap && (m.thicknessMap.value = v.thicknessMap), m.attenuationDistance.value = v.attenuationDistance, m.attenuationColor.value.copy(v.attenuationColor)), m.specularIntensity.value = v.specularIntensity, m.specularColor.value.copy(v.specularColor), v.specularIntensityMap && (m.specularIntensityMap.value = v.specularIntensityMap), v.specularColorMap && (m.specularColorMap.value = v.specularColorMap) } function f(m, v) { v.matcap && (m.matcap.value = v.matcap) } function g(m, v) { m.referencePosition.value.copy(v.referencePosition), m.nearDistance.value = v.nearDistance, m.farDistance.value = v.farDistance } return { refreshFogUniforms: t, refreshMaterialUniforms: s } } function X5(i, e, t, s) { let r = {}, n = {}, o = []; const a = t.isWebGL2 ? i.getParameter(35375) : 0; function l(b, y) { const _ = y.program; s.uniformBlockBinding(b, _) } function c(b, y) { let _ = r[b.id]; _ === void 0 && (g(b), _ = h(b), r[b.id] = _, b.addEventListener("dispose", v)); const w = y.program; s.updateUBOMapping(b, w); const E = e.render.frame; n[b.id] !== E && (p(b), n[b.id] = E) } function h(b) { const y = d(); b.__bindingPointIndex = y; const _ = i.createBuffer(), w = b.__size, E = b.usage; return i.bindBuffer(35345, _), i.bufferData(35345, w, E), i.bindBuffer(35345, null), i.bindBufferBase(35345, y, _), _ } function d() { for (let b = 0; b < a; b++)if (o.indexOf(b) === -1) return o.push(b), b; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 } function p(b) { const y = r[b.id], _ = b.uniforms, w = b.__cache; i.bindBuffer(35345, y); for (let E = 0, P = _.length; E < P; E++) { const C = _[E]; if (f(C, E, w) === !0) { const R = C.value, T = C.__offset; typeof R == "number" ? (C.__data[0] = R, i.bufferSubData(35345, T, C.__data)) : (C.value.isMatrix3 ? (C.__data[0] = C.value.elements[0], C.__data[1] = C.value.elements[1], C.__data[2] = C.value.elements[2], C.__data[3] = C.value.elements[0], C.__data[4] = C.value.elements[3], C.__data[5] = C.value.elements[4], C.__data[6] = C.value.elements[5], C.__data[7] = C.value.elements[0], C.__data[8] = C.value.elements[6], C.__data[9] = C.value.elements[7], C.__data[10] = C.value.elements[8], C.__data[11] = C.value.elements[0]) : R.toArray(C.__data), i.bufferSubData(35345, T, C.__data)) } } i.bindBuffer(35345, null) } function f(b, y, _) { const w = b.value; if (_[y] === void 0) return typeof w == "number" ? _[y] = w : _[y] = w.clone(), !0; if (typeof w == "number") { if (_[y] !== w) return _[y] = w, !0 } else { const E = _[y]; if (E.equals(w) === !1) return E.copy(w), !0 } return !1 } function g(b) { const y = b.uniforms; let _ = 0; const w = 16; let E = 0; for (let P = 0, C = y.length; P < C; P++) { const R = y[P], T = m(R); if (R.__data = new Float32Array(T.storage / Float32Array.BYTES_PER_ELEMENT), R.__offset = _, P > 0) { E = _ % w; const z = w - E; E !== 0 && z - T.boundary < 0 && (_ += w - E, R.__offset = _) } _ += T.storage } return E = _ % w, E > 0 && (_ += w - E), b.__size = _, b.__cache = {}, this } function m(b) { const y = b.value, _ = { boundary: 0, storage: 0 }; return typeof y == "number" ? (_.boundary = 4, _.storage = 4) : y.isVector2 ? (_.boundary = 8, _.storage = 8) : y.isVector3 || y.isColor ? (_.boundary = 16, _.storage = 12) : y.isVector4 ? (_.boundary = 16, _.storage = 16) : y.isMatrix3 ? (_.boundary = 48, _.storage = 48) : y.isMatrix4 ? (_.boundary = 64, _.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y), _ } function v(b) { const y = b.target; y.removeEventListener("dispose", v); const _ = o.indexOf(y.__bindingPointIndex); o.splice(_, 1), i.deleteBuffer(r[y.id]), delete r[y.id], delete n[y.id] } function A() { for (const b in r) i.deleteBuffer(r[b]); o = [], r = {}, n = {} } return { bind: l, update: c, dispose: A } } function Y5() { const i = _f("canvas"); return i.style.display = "block", i } function $u(i = {}) { this.isWebGLRenderer = !0; const e = i.canvas !== void 0 ? i.canvas : Y5(), t = i.context !== void 0 ? i.context : null, s = i.depth !== void 0 ? i.depth : !0, r = i.stencil !== void 0 ? i.stencil : !0, n = i.antialias !== void 0 ? i.antialias : !1, o = i.premultipliedAlpha !== void 0 ? i.premultipliedAlpha : !0, a = i.preserveDrawingBuffer !== void 0 ? i.preserveDrawingBuffer : !1, l = i.powerPreference !== void 0 ? i.powerPreference : "default", c = i.failIfMajorPerformanceCaveat !== void 0 ? i.failIfMajorPerformanceCaveat : !1; let h; t !== null ? h = t.getContextAttributes().alpha : h = i.alpha !== void 0 ? i.alpha : !1; let d = null, p = null; const f = [], g = []; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Qi, this.physicallyCorrectLights = !1, this.toneMapping = fr, this.toneMappingExposure = 1; const m = this; let v = !1, A = 0, b = 0, y = null, _ = -1, w = null; const E = new st, P = new st; let C = null, R = e.width, T = e.height, z = 1, H = null, N = null; const F = new st(0, 0, R, T), X = new st(0, 0, R, T); let te = !1; const re = new xA; let Z = !1, fe = !1, ae = null; const De = new He, Se = new W, ie = new S, ce = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function Te() { return y === null ? z : 1 } let K = t; function je(O, ee) { for (let ue = 0; ue < O.length; ue++) { const Y = O[ue], se = e.getContext(Y, ee); if (se !== null) return se } return null } try { const O = { alpha: !0, depth: s, stencil: r, antialias: n, premultipliedAlpha: o, preserveDrawingBuffer: a, powerPreference: l, failIfMajorPerformanceCaveat: c }; if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${th}`), e.addEventListener("webglcontextlost", ge, !1), e.addEventListener("webglcontextrestored", lt, !1), e.addEventListener("webglcontextcreationerror", It, !1), K === null) { const ee = ["webgl2", "webgl", "experimental-webgl"]; if (m.isWebGL1Renderer === !0 && ee.shift(), K = je(ee, O), K === null) throw je(ee) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } K.getShaderPrecisionFormat === void 0 && (K.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (O) { throw console.error("THREE.WebGLRenderer: " + O.message), O } let Ue, Pe, ve, de, Ae, pe, Fe, Re, ht, me, ut, dt, Pt, ii, U, D, le, Ie, Be, Qe, rt, j, J, Ve; function qe() { Ue = new uG(K), Pe = new oG(K, Ue, i), Ue.init(Pe), j = new IR(K, Ue, Pe), ve = new G5(K, Ue, Pe), de = new fG, Ae = new P5, pe = new H5(K, Ue, ve, Ae, Pe, j, de), Fe = new lG(m), Re = new hG(m), ht = new C4(K, Pe), J = new rG(K, Ue, ht, Pe), me = new dG(K, ht, de, J), ut = new AG(K, me, ht, de), Be = new vG(K, Pe, pe), D = new aG(Ae), dt = new R5(m, Fe, Re, Ue, Pe, J, D), Pt = new q5(m, Ae), ii = new k5, U = new N5(Ue, Pe), Ie = new sG(m, Fe, Re, ve, ut, h, o), le = new Q5(m, ut, Pe), Ve = new X5(K, de, Pe, ve), Qe = new nG(K, Ue, de, Pe), rt = new pG(K, Ue, de, Pe), de.programs = dt.programs, m.capabilities = Pe, m.extensions = Ue, m.properties = Ae, m.renderLists = ii, m.shadowMap = le, m.state = ve, m.info = de } qe(); const ze = new W5(m, K); this.xr = ze, this.getContext = function () { return K }, this.getContextAttributes = function () { return K.getContextAttributes() }, this.forceContextLoss = function () { const O = Ue.get("WEBGL_lose_context"); O && O.loseContext() }, this.forceContextRestore = function () { const O = Ue.get("WEBGL_lose_context"); O && O.restoreContext() }, this.getPixelRatio = function () { return z }, this.setPixelRatio = function (O) { O !== void 0 && (z = O, this.setSize(R, T, !1)) }, this.getSize = function (O) { return O.set(R, T) }, this.setSize = function (O, ee, ue) { if (ze.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } R = O, T = ee, e.width = Math.floor(O * z), e.height = Math.floor(ee * z), ue !== !1 && (e.style.width = O + "px", e.style.height = ee + "px"), this.setViewport(0, 0, O, ee) }, this.getDrawingBufferSize = function (O) { return O.set(R * z, T * z).floor() }, this.setDrawingBufferSize = function (O, ee, ue) { R = O, T = ee, z = ue, e.width = Math.floor(O * ue), e.height = Math.floor(ee * ue), this.setViewport(0, 0, O, ee) }, this.getCurrentViewport = function (O) { return O.copy(E) }, this.getViewport = function (O) { return O.copy(F) }, this.setViewport = function (O, ee, ue, Y) { O.isVector4 ? F.set(O.x, O.y, O.z, O.w) : F.set(O, ee, ue, Y), ve.viewport(E.copy(F).multiplyScalar(z).floor()) }, this.getScissor = function (O) { return O.copy(X) }, this.setScissor = function (O, ee, ue, Y) { O.isVector4 ? X.set(O.x, O.y, O.z, O.w) : X.set(O, ee, ue, Y), ve.scissor(P.copy(X).multiplyScalar(z).floor()) }, this.getScissorTest = function () { return te }, this.setScissorTest = function (O) { ve.setScissorTest(te = O) }, this.setOpaqueSort = function (O) { H = O }, this.setTransparentSort = function (O) { N = O }, this.getClearColor = function (O) { return O.copy(Ie.getClearColor()) }, this.setClearColor = function () { Ie.setClearColor.apply(Ie, arguments) }, this.getClearAlpha = function () { return Ie.getClearAlpha() }, this.setClearAlpha = function () { Ie.setClearAlpha.apply(Ie, arguments) }, this.clear = function (O = !0, ee = !0, ue = !0) { let Y = 0; O && (Y |= 16384), ee && (Y |= 256), ue && (Y |= 1024), K.clear(Y) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", ge, !1), e.removeEventListener("webglcontextrestored", lt, !1), e.removeEventListener("webglcontextcreationerror", It, !1), ii.dispose(), U.dispose(), Ae.dispose(), Fe.dispose(), Re.dispose(), ut.dispose(), J.dispose(), Ve.dispose(), dt.dispose(), ze.dispose(), ze.removeEventListener("sessionstart", V), ze.removeEventListener("sessionend", he), ae && (ae.dispose(), ae = null), be.stop() }; function ge(O) { O.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), v = !0 } function lt() { console.log("THREE.WebGLRenderer: Context Restored."), v = !1; const O = de.autoReset, ee = le.enabled, ue = le.autoUpdate, Y = le.needsUpdate, se = le.type; qe(), de.autoReset = O, le.enabled = ee, le.autoUpdate = ue, le.needsUpdate = Y, le.type = se } function It(O) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", O.statusMessage) } function M(O) { const ee = O.target; ee.removeEventListener("dispose", M), k(ee) } function k(O) { I(O), Ae.remove(O) } function I(O) { const ee = Ae.get(O).programs; ee !== void 0 && (ee.forEach(function (ue) { dt.releaseProgram(ue) }), O.isShaderMaterial && dt.releaseShaderCache(O)) } this.renderBufferDirect = function (O, ee, ue, Y, se, We) { ee === null && (ee = ce); const gt = se.isMesh && se.matrixWorld.determinant() < 0, pt = ct(O, ee, ue, Y, se); ve.setMaterial(Y, gt); let $e = ue.index, vt = 1; Y.wireframe === !0 && ($e = me.getWireframeAttribute(ue), vt = 2); const Bt = ue.drawRange, Lt = ue.attributes.position; let fi = Bt.start * vt, Cs = (Bt.start + Bt.count) * vt; We !== null && (fi = Math.max(fi, We.start * vt), Cs = Math.min(Cs, (We.start + We.count) * vt)), $e !== null ? (fi = Math.max(fi, 0), Cs = Math.min(Cs, $e.count)) : Lt != null && (fi = Math.max(fi, 0), Cs = Math.min(Cs, Lt.count)); const Ca = Cs - fi; if (Ca < 0 || Ca === 1 / 0) return; J.setup(se, Y, pt, ue, $e); let Kc, Ki = Qe; if ($e !== null && (Kc = ht.get($e), Ki = rt, Ki.setIndex(Kc)), se.isMesh) Y.wireframe === !0 ? (ve.setLineWidth(Y.wireframeLinewidth * Te()), Ki.setMode(1)) : Ki.setMode(4); else if (se.isLine) { let Kt = Y.linewidth; Kt === void 0 && (Kt = 1), ve.setLineWidth(Kt * Te()), se.isLineSegments ? Ki.setMode(1) : se.isLineLoop ? Ki.setMode(2) : Ki.setMode(3) } else se.isPoints ? Ki.setMode(0) : se.isSprite && Ki.setMode(4); if (se.isInstancedMesh) Ki.renderInstances(fi, Ca, se.count); else if (ue.isInstancedBufferGeometry) { const Kt = ue._maxInstanceCount !== void 0 ? ue._maxInstanceCount : 1 / 0, z_ = Math.min(ue.instanceCount, Kt); Ki.renderInstances(fi, Ca, z_) } else Ki.render(fi, Ca) }, this.compile = function (O, ee) { function ue(Y, se, We) { Y.transparent === !0 && Y.side === yi ? (Y.side = fs, Y.needsUpdate = !0, ot(Y, se, We), Y.side = pr, Y.needsUpdate = !0, ot(Y, se, We), Y.side = yi) : ot(Y, se, We) } p = U.get(O), p.init(), g.push(p), O.traverseVisible(function (Y) { Y.isLight && Y.layers.test(ee.layers) && (p.pushLight(Y), Y.castShadow && p.pushShadow(Y)) }), p.setupLights(m.physicallyCorrectLights), O.traverse(function (Y) { const se = Y.material; if (se) if (Array.isArray(se)) for (let We = 0; We < se.length; We++) { const gt = se[We]; ue(gt, O, Y) } else ue(se, O, Y) }), g.pop(), p = null }; let L = null; function G(O) { L && L(O) } function V() { be.stop() } function he() { be.start() } const be = new tR; be.setAnimationLoop(G), typeof self < "u" && be.setContext(self), this.setAnimationLoop = function (O) { L = O, ze.setAnimationLoop(O), O === null ? be.stop() : be.start() }, ze.addEventListener("sessionstart", V), ze.addEventListener("sessionend", he), this.render = function (O, ee) { if (ee !== void 0 && ee.isCamera !== !0) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (v === !0) return; O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(), ee.parent === null && ee.matrixWorldAutoUpdate === !0 && ee.updateMatrixWorld(), ze.enabled === !0 && ze.isPresenting === !0 && (ze.cameraAutoUpdate === !0 && ze.updateCamera(ee), ee = ze.getCamera()), O.isScene === !0 && O.onBeforeRender(m, O, ee, y), p = U.get(O, g.length), p.init(), g.push(p), De.multiplyMatrices(ee.projectionMatrix, ee.matrixWorldInverse), re.setFromProjectionMatrix(De), fe = this.localClippingEnabled, Z = D.init(this.clippingPlanes, fe, ee), d = ii.get(O, f.length), d.init(), f.push(d), ke(O, ee, 0, m.sortObjects), d.finish(), m.sortObjects === !0 && d.sort(H, N), Z === !0 && D.beginShadows(); const ue = p.state.shadowsArray; if (le.render(ue, O, ee), Z === !0 && D.endShadows(), this.info.autoReset === !0 && this.info.reset(), Ie.render(d, O), p.setupLights(m.physicallyCorrectLights), ee.isArrayCamera) { const Y = ee.cameras; for (let se = 0, We = Y.length; se < We; se++) { const gt = Y[se]; _e(d, O, gt, gt.viewport) } } else _e(d, O, ee); y !== null && (pe.updateMultisampleRenderTarget(y), pe.updateRenderTargetMipmap(y)), O.isScene === !0 && O.onAfterRender(m, O, ee), J.resetDefaultState(), _ = -1, w = null, g.pop(), g.length > 0 ? p = g[g.length - 1] : p = null, f.pop(), f.length > 0 ? d = f[f.length - 1] : d = null }; function ke(O, ee, ue, Y) { if (O.visible === !1) return; if (O.layers.test(ee.layers)) { if (O.isGroup) ue = O.renderOrder; else if (O.isLOD) O.autoUpdate === !0 && O.update(ee); else if (O.isLight) p.pushLight(O), O.castShadow && p.pushShadow(O); else if (O.isSprite) { if (!O.frustumCulled || re.intersectsSprite(O)) { Y && ie.setFromMatrixPosition(O.matrixWorld).applyMatrix4(De); const We = ut.update(O), gt = O.material; gt.visible && d.push(O, We, gt, ue, ie.z, null) } } else if ((O.isMesh || O.isLine || O.isPoints) && (O.isSkinnedMesh && O.skeleton.frame !== de.render.frame && (O.skeleton.update(), O.skeleton.frame = de.render.frame), !O.frustumCulled || re.intersectsObject(O))) { Y && ie.setFromMatrixPosition(O.matrixWorld).applyMatrix4(De); const We = ut.update(O), gt = O.material; if (Array.isArray(gt)) { const pt = We.groups; for (let $e = 0, vt = pt.length; $e < vt; $e++) { const Bt = pt[$e], Lt = gt[Bt.materialIndex]; Lt && Lt.visible && d.push(O, We, Lt, ue, ie.z, Bt) } } else gt.visible && d.push(O, We, gt, ue, ie.z, null) } } const se = O.children; for (let We = 0, gt = se.length; We < gt; We++)ke(se[We], ee, ue, Y) } function _e(O, ee, ue, Y) { const se = O.opaque, We = O.transmissive, gt = O.transparent; p.setupLightsView(ue), We.length > 0 && Oe(se, ee, ue), Y && ve.viewport(E.copy(Y)), se.length > 0 && Ge(se, ee, ue), We.length > 0 && Ge(We, ee, ue), gt.length > 0 && Ge(gt, ee, ue), ve.buffers.depth.setTest(!0), ve.buffers.depth.setMask(!0), ve.buffers.color.setMask(!0), ve.setPolygonOffset(!1) } function Oe(O, ee, ue) { const Y = Pe.isWebGL2; ae === null && (ae = new ri(1, 1, { generateMipmaps: !0, type: Ue.has("EXT_color_buffer_half_float") ? gs : ui, minFilter: eo, samples: Y && n === !0 ? 4 : 0 })), m.getDrawingBufferSize(Se), Y ? ae.setSize(Se.x, Se.y) : ae.setSize(tA(Se.x), tA(Se.y)); const se = m.getRenderTarget(); m.setRenderTarget(ae), m.clear(); const We = m.toneMapping; m.toneMapping = fr, Ge(O, ee, ue), m.toneMapping = We, pe.updateMultisampleRenderTarget(ae), pe.updateRenderTargetMipmap(ae), m.setRenderTarget(se) } function Ge(O, ee, ue) { const Y = ee.isScene === !0 ? ee.overrideMaterial : null; for (let se = 0, We = O.length; se < We; se++) { const gt = O[se], pt = gt.object, $e = gt.geometry, vt = Y === null ? gt.material : Y, Bt = gt.group; pt.layers.test(ue.layers) && Je(pt, ee, ue, $e, vt, Bt) } } function Je(O, ee, ue, Y, se, We) { O.onBeforeRender(m, ee, ue, Y, se, We), O.modelViewMatrix.multiplyMatrices(ue.matrixWorldInverse, O.matrixWorld), O.normalMatrix.getNormalMatrix(O.modelViewMatrix), se.onBeforeRender(m, ee, ue, Y, O, We), se.transparent === !0 && se.side === yi ? (se.side = fs, se.needsUpdate = !0, m.renderBufferDirect(ue, ee, Y, se, O, We), se.side = pr, se.needsUpdate = !0, m.renderBufferDirect(ue, ee, Y, se, O, We), se.side = yi) : m.renderBufferDirect(ue, ee, Y, se, O, We), O.onAfterRender(m, ee, ue, Y, se, We) } function ot(O, ee, ue) { ee.isScene !== !0 && (ee = ce); const Y = Ae.get(O), se = p.state.lights, We = p.state.shadowsArray, gt = se.state.version, pt = dt.getParameters(O, se.state, We, ee, ue), $e = dt.getProgramCacheKey(pt); let vt = Y.programs; Y.environment = O.isMeshStandardMaterial ? ee.environment : null, Y.fog = ee.fog, Y.envMap = (O.isMeshStandardMaterial ? Re : Fe).get(O.envMap || Y.environment), vt === void 0 && (O.addEventListener("dispose", M), vt = new Map, Y.programs = vt); let Bt = vt.get($e); if (Bt !== void 0) { if (Y.currentProgram === Bt && Y.lightsStateVersion === gt) return Rt(O, pt), Bt } else pt.uniforms = dt.getUniforms(O), O.onBuild(ue, pt, m), O.onBeforeCompile(pt, m), Bt = dt.acquireProgram(pt, $e), vt.set($e, Bt), Y.uniforms = pt.uniforms; const Lt = Y.uniforms; (!O.isShaderMaterial && !O.isRawShaderMaterial || O.clipping === !0) && (Lt.clippingPlanes = D.uniform), Rt(O, pt), Y.needsLights = jt(O), Y.lightsStateVersion = gt, Y.needsLights && (Lt.ambientLightColor.value = se.state.ambient, Lt.lightProbe.value = se.state.probe, Lt.directionalLights.value = se.state.directional, Lt.directionalLightShadows.value = se.state.directionalShadow, Lt.spotLights.value = se.state.spot, Lt.spotLightShadows.value = se.state.spotShadow, Lt.rectAreaLights.value = se.state.rectArea, Lt.ltc_1.value = se.state.rectAreaLTC1, Lt.ltc_2.value = se.state.rectAreaLTC2, Lt.pointLights.value = se.state.point, Lt.pointLightShadows.value = se.state.pointShadow, Lt.hemisphereLights.value = se.state.hemi, Lt.directionalShadowMap.value = se.state.directionalShadowMap, Lt.directionalShadowMatrix.value = se.state.directionalShadowMatrix, Lt.spotShadowMap.value = se.state.spotShadowMap, Lt.spotLightMatrix.value = se.state.spotLightMatrix, Lt.spotLightMap.value = se.state.spotLightMap, Lt.pointShadowMap.value = se.state.pointShadowMap, Lt.pointShadowMatrix.value = se.state.pointShadowMatrix); const fi = Bt.getUniforms(), Cs = EA.seqWithValue(fi.seq, Lt); return Y.currentProgram = Bt, Y.uniformsList = Cs, Bt } function Rt(O, ee) { const ue = Ae.get(O); ue.outputEncoding = ee.outputEncoding, ue.instancing = ee.instancing, ue.skinning = ee.skinning, ue.morphTargets = ee.morphTargets, ue.morphNormals = ee.morphNormals, ue.morphColors = ee.morphColors, ue.morphTargetsCount = ee.morphTargetsCount, ue.numClippingPlanes = ee.numClippingPlanes, ue.numIntersection = ee.numClipIntersection, ue.vertexAlphas = ee.vertexAlphas, ue.vertexTangents = ee.vertexTangents, ue.toneMapping = ee.toneMapping } function ct(O, ee, ue, Y, se) { ee.isScene !== !0 && (ee = ce), pe.resetTextureUnits(); const We = ee.fog, gt = Y.isMeshStandardMaterial ? ee.environment : null, pt = y === null ? m.outputEncoding : y.isXRRenderTarget === !0 ? y.texture.encoding : Qi, $e = (Y.isMeshStandardMaterial ? Re : Fe).get(Y.envMap || gt), vt = Y.vertexColors === !0 && !!ue.attributes.color && ue.attributes.color.itemSize === 4, Bt = !!Y.normalMap && !!ue.attributes.tangent, Lt = !!ue.morphAttributes.position, fi = !!ue.morphAttributes.normal, Cs = !!ue.morphAttributes.color, Ca = Y.toneMapped ? m.toneMapping : fr, Kc = ue.morphAttributes.position || ue.morphAttributes.normal || ue.morphAttributes.color, Ki = Kc !== void 0 ? Kc.length : 0, Kt = Ae.get(Y), z_ = p.state.lights; if (Z === !0 && (fe === !0 || O !== w)) { const Yr = O === w && Y.id === _; D.setState(Y, O, Yr) } let j_ = !1; Y.version === Kt.__version ? (Kt.needsLights && Kt.lightsStateVersion !== z_.state.version || Kt.outputEncoding !== pt || se.isInstancedMesh && Kt.instancing === !1 || !se.isInstancedMesh && Kt.instancing === !0 || se.isSkinnedMesh && Kt.skinning === !1 || !se.isSkinnedMesh && Kt.skinning === !0 || Kt.envMap !== $e || Y.fog === !0 && Kt.fog !== We || Kt.numClippingPlanes !== void 0 && (Kt.numClippingPlanes !== D.numPlanes || Kt.numIntersection !== D.numIntersection) || Kt.vertexAlphas !== vt || Kt.vertexTangents !== Bt || Kt.morphTargets !== Lt || Kt.morphNormals !== fi || Kt.morphColors !== Cs || Kt.toneMapping !== Ca || Pe.isWebGL2 === !0 && Kt.morphTargetsCount !== Ki) && (j_ = !0) : (j_ = !0, Kt.__version = Y.version); let Zc = Kt.currentProgram; j_ === !0 && (Zc = ot(Y, ee, se)); let RI = !1, tf = !1, Q_ = !1; const ur = Zc.getUniforms(), $c = Kt.uniforms; if (ve.useProgram(Zc.program) && (RI = !0, tf = !0, Q_ = !0), Y.id !== _ && (_ = Y.id, tf = !0), RI || w !== O) { if (ur.setValue(K, "projectionMatrix", O.projectionMatrix), Pe.logarithmicDepthBuffer && ur.setValue(K, "logDepthBufFC", 2 / (Math.log(O.far + 1) / Math.LN2)), w !== O && (w = O, tf = !0, Q_ = !0), Y.isShaderMaterial || Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshStandardMaterial || Y.envMap) { const Yr = ur.map.cameraPosition; Yr !== void 0 && Yr.setValue(K, ie.setFromMatrixPosition(O.matrixWorld)) } (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial) && ur.setValue(K, "isOrthographic", O.isOrthographicCamera === !0), (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial || Y.isShadowMaterial || se.isSkinnedMesh) && ur.setValue(K, "viewMatrix", O.matrixWorldInverse) } if (se.isSkinnedMesh) { ur.setOptional(K, se, "bindMatrix"), ur.setOptional(K, se, "bindMatrixInverse"); const Yr = se.skeleton; Yr && (Pe.floatVertexTextures ? (Yr.boneTexture === null && Yr.computeBoneTexture(), ur.setValue(K, "boneTexture", Yr.boneTexture, pe), ur.setValue(K, "boneTextureSize", Yr.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.")) } const G_ = ue.morphAttributes; if ((G_.position !== void 0 || G_.normal !== void 0 || G_.color !== void 0 && Pe.isWebGL2 === !0) && Be.update(se, ue, Y, Zc), (tf || Kt.receiveShadow !== se.receiveShadow) && (Kt.receiveShadow = se.receiveShadow, ur.setValue(K, "receiveShadow", se.receiveShadow)), Y.isMeshGouraudMaterial && Y.envMap !== null && ($c.envMap.value = $e, $c.flipEnvMap.value = $e.isCubeTexture && $e.isRenderTargetTexture === !1 ? -1 : 1), tf && (ur.setValue(K, "toneMappingExposure", m.toneMappingExposure), Kt.needsLights && ft($c, Q_), We && Y.fog === !0 && Pt.refreshFogUniforms($c, We), Pt.refreshMaterialUniforms($c, Y, z, T, ae), EA.upload(K, Kt.uniformsList, $c, pe)), Y.isShaderMaterial && Y.uniformsNeedUpdate === !0 && (EA.upload(K, Kt.uniformsList, $c, pe), Y.uniformsNeedUpdate = !1), Y.isSpriteMaterial && ur.setValue(K, "center", se.center), ur.setValue(K, "modelViewMatrix", se.modelViewMatrix), ur.setValue(K, "normalMatrix", se.normalMatrix), ur.setValue(K, "modelMatrix", se.matrixWorld), Y.isShaderMaterial || Y.isRawShaderMaterial) { const Yr = Y.uniformsGroups; for (let H_ = 0, ez = Yr.length; H_ < ez; H_++)if (Pe.isWebGL2) { const PI = Yr[H_]; Ve.update(PI, Zc), Ve.bind(PI, Zc) } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.") } return Zc } function ft(O, ee) { O.ambientLightColor.needsUpdate = ee, O.lightProbe.needsUpdate = ee, O.directionalLights.needsUpdate = ee, O.directionalLightShadows.needsUpdate = ee, O.pointLights.needsUpdate = ee, O.pointLightShadows.needsUpdate = ee, O.spotLights.needsUpdate = ee, O.spotLightShadows.needsUpdate = ee, O.rectAreaLights.needsUpdate = ee, O.hemisphereLights.needsUpdate = ee } function jt(O) { return O.isMeshLambertMaterial || O.isMeshToonMaterial || O.isMeshPhongMaterial || O.isMeshStandardMaterial || O.isShadowMaterial || O.isShaderMaterial && O.lights === !0 } this.getActiveCubeFace = function () { return A }, this.getActiveMipmapLevel = function () { return b }, this.getRenderTarget = function () { return y }, this.setRenderTargetTextures = function (O, ee, ue) { Ae.get(O.texture).__webglTexture = ee, Ae.get(O.depthTexture).__webglTexture = ue; const Y = Ae.get(O); Y.__hasExternalTextures = !0, Y.__hasExternalTextures && (Y.__autoAllocateDepthBuffer = ue === void 0, Y.__autoAllocateDepthBuffer || Ue.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Y.__useRenderToTexture = !1)) }, this.setRenderTargetFramebuffer = function (O, ee) { const ue = Ae.get(O); ue.__webglFramebuffer = ee, ue.__useDefaultFramebuffer = ee === void 0 }, this.setRenderTarget = function (O, ee = 0, ue = 0) { y = O, A = ee, b = ue; let Y = !0, se = null, We = !1, gt = !1; if (O) { const pt = Ae.get(O); pt.__useDefaultFramebuffer !== void 0 ? (ve.bindFramebuffer(36160, null), Y = !1) : pt.__webglFramebuffer === void 0 ? pe.setupRenderTarget(O) : pt.__hasExternalTextures && pe.rebindTextures(O, Ae.get(O.texture).__webglTexture, Ae.get(O.depthTexture).__webglTexture); const $e = O.texture; ($e.isData3DTexture || $e.isDataArrayTexture || $e.isCompressedArrayTexture) && (gt = !0); const vt = Ae.get(O).__webglFramebuffer; O.isWebGLCubeRenderTarget ? (se = vt[ee], We = !0) : Pe.isWebGL2 && O.samples > 0 && pe.useMultisampledRTT(O) === !1 ? se = Ae.get(O).__webglMultisampledFramebuffer : se = vt, E.copy(O.viewport), P.copy(O.scissor), C = O.scissorTest } else E.copy(F).multiplyScalar(z).floor(), P.copy(X).multiplyScalar(z).floor(), C = te; if (ve.bindFramebuffer(36160, se) && Pe.drawBuffers && Y && ve.drawBuffers(O, se), ve.viewport(E), ve.scissor(P), ve.setScissorTest(C), We) { const pt = Ae.get(O.texture); K.framebufferTexture2D(36160, 36064, 34069 + ee, pt.__webglTexture, ue) } else if (gt) { const pt = Ae.get(O.texture), $e = ee || 0; K.framebufferTextureLayer(36160, 36064, pt.__webglTexture, ue || 0, $e) } _ = -1 }, this.readRenderTargetPixels = function (O, ee, ue, Y, se, We, gt) { if (!(O && O.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let pt = Ae.get(O).__webglFramebuffer; if (O.isWebGLCubeRenderTarget && gt !== void 0 && (pt = pt[gt]), pt) { ve.bindFramebuffer(36160, pt); try { const $e = O.texture, vt = $e.format, Bt = $e.type; if (vt !== _i && j.convert(vt) !== K.getParameter(35739)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } const Lt = Bt === gs && (Ue.has("EXT_color_buffer_half_float") || Pe.isWebGL2 && Ue.has("EXT_color_buffer_float")); if (Bt !== ui && j.convert(Bt) !== K.getParameter(35738) && !(Bt === $i && (Pe.isWebGL2 || Ue.has("OES_texture_float") || Ue.has("WEBGL_color_buffer_float"))) && !Lt) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } ee >= 0 && ee <= O.width - Y && ue >= 0 && ue <= O.height - se && K.readPixels(ee, ue, Y, se, j.convert(vt), j.convert(Bt), We) } finally { const $e = y !== null ? Ae.get(y).__webglFramebuffer : null; ve.bindFramebuffer(36160, $e) } } }, this.copyFramebufferToTexture = function (O, ee, ue = 0) { const Y = Math.pow(2, -ue), se = Math.floor(ee.image.width * Y), We = Math.floor(ee.image.height * Y); pe.setTexture2D(ee, 0), K.copyTexSubImage2D(3553, ue, 0, 0, O.x, O.y, se, We), ve.unbindTexture() }, this.copyTextureToTexture = function (O, ee, ue, Y = 0) { const se = ee.image.width, We = ee.image.height, gt = j.convert(ue.format), pt = j.convert(ue.type); pe.setTexture2D(ue, 0), K.pixelStorei(37440, ue.flipY), K.pixelStorei(37441, ue.premultiplyAlpha), K.pixelStorei(3317, ue.unpackAlignment), ee.isDataTexture ? K.texSubImage2D(3553, Y, O.x, O.y, se, We, gt, pt, ee.image.data) : ee.isCompressedTexture ? K.compressedTexSubImage2D(3553, Y, O.x, O.y, ee.mipmaps[0].width, ee.mipmaps[0].height, gt, ee.mipmaps[0].data) : K.texSubImage2D(3553, Y, O.x, O.y, gt, pt, ee.image), Y === 0 && ue.generateMipmaps && K.generateMipmap(3553), ve.unbindTexture() }, this.copyTextureToTexture3D = function (O, ee, ue, Y, se = 0) { if (m.isWebGL1Renderer) { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); return } const We = O.max.x - O.min.x + 1, gt = O.max.y - O.min.y + 1, pt = O.max.z - O.min.z + 1, $e = j.convert(Y.format), vt = j.convert(Y.type); let Bt; if (Y.isData3DTexture) pe.setTexture3D(Y, 0), Bt = 32879; else if (Y.isDataArrayTexture) pe.setTexture2DArray(Y, 0), Bt = 35866; else { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); return } K.pixelStorei(37440, Y.flipY), K.pixelStorei(37441, Y.premultiplyAlpha), K.pixelStorei(3317, Y.unpackAlignment); const Lt = K.getParameter(3314), fi = K.getParameter(32878), Cs = K.getParameter(3316), Ca = K.getParameter(3315), Kc = K.getParameter(32877), Ki = ue.isCompressedTexture ? ue.mipmaps[0] : ue.image; K.pixelStorei(3314, Ki.width), K.pixelStorei(32878, Ki.height), K.pixelStorei(3316, O.min.x), K.pixelStorei(3315, O.min.y), K.pixelStorei(32877, O.min.z), ue.isDataTexture || ue.isData3DTexture ? K.texSubImage3D(Bt, se, ee.x, ee.y, ee.z, We, gt, pt, $e, vt, Ki.data) : ue.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), K.compressedTexSubImage3D(Bt, se, ee.x, ee.y, ee.z, We, gt, pt, $e, Ki.data)) : K.texSubImage3D(Bt, se, ee.x, ee.y, ee.z, We, gt, pt, $e, vt, Ki), K.pixelStorei(3314, Lt), K.pixelStorei(32878, fi), K.pixelStorei(3316, Cs), K.pixelStorei(3315, Ca), K.pixelStorei(32877, Kc), se === 0 && Y.generateMipmaps && K.generateMipmap(Bt), ve.unbindTexture() }, this.initTexture = function (O) { O.isCubeTexture ? pe.setTextureCube(O, 0) : O.isData3DTexture ? pe.setTexture3D(O, 0) : O.isDataArrayTexture || O.isCompressedArrayTexture ? pe.setTexture2DArray(O, 0) : pe.setTexture2D(O, 0), ve.unbindTexture() }, this.resetState = function () { A = 0, b = 0, y = null, ve.reset(), J.reset() }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } class RR extends $u { } RR.prototype.isWebGL1Renderer = !0; class k_ { constructor(e, t = 25e-5) { this.isFogExp2 = !0, this.name = "", this.color = new xe(e), this.density = t } clone() { return new k_(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } let vw = class $N { constructor(e, t = 1, s = 1e3) { this.isFog = !0, this.name = "", this.color = new xe(e), this.near = t, this.far = s } clone() { return new $N(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } }; class Cn extends Me { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.backgroundIntensity = this.backgroundIntensity), t } get autoUpdate() { return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate } set autoUpdate(e) { console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e } } class Rf { constructor(e, t) { this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = yf, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Kr() } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, s) { e *= this.stride, s *= t.stride; for (let r = 0, n = this.stride; r < n; r++)this.array[e + r] = t.array[s + r]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Kr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), s = new this.constructor(t, this.stride); return s.setUsage(this.usage), s } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Kr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const mr = new S; class El { constructor(e, t, s, r = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = s, this.normalized = r === !0 } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, s = this.data.count; t < s; t++)mr.fromBufferAttribute(this, t), mr.applyMatrix4(e), this.setXYZ(t, mr.x, mr.y, mr.z); return this } applyNormalMatrix(e) { for (let t = 0, s = this.count; t < s; t++)mr.fromBufferAttribute(this, t), mr.applyNormalMatrix(e), this.setXYZ(t, mr.x, mr.y, mr.z); return this } transformDirection(e) { for (let t = 0, s = this.count; t < s; t++)mr.fromBufferAttribute(this, t), mr.transformDirection(e), this.setXYZ(t, mr.x, mr.y, mr.z); return this } setX(e, t) { return this.normalized && (t = gi(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.normalized && (t = gi(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.normalized && (t = gi(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.normalized && (t = gi(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { let t = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (t = Ba(t, this.array)), t } getY(e) { let t = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (t = Ba(t, this.array)), t } getZ(e) { let t = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (t = Ba(t, this.array)), t } getW(e) { let t = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (t = Ba(t, this.array)), t } setXY(e, t, s) { return e = e * this.data.stride + this.offset, this.normalized && (t = gi(t, this.array), s = gi(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = s, this } setXYZ(e, t, s, r) { return e = e * this.data.stride + this.offset, this.normalized && (t = gi(t, this.array), s = gi(s, this.array), r = gi(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = s, this.data.array[e + 2] = r, this } setXYZW(e, t, s, r, n) { return e = e * this.data.stride + this.offset, this.normalized && (t = gi(t, this.array), s = gi(s, this.array), r = gi(r, this.array), n = gi(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = s, this.data.array[e + 2] = r, this.data.array[e + 3] = n, this } clone(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data."); const t = []; for (let s = 0; s < this.count; s++) { const r = s * this.data.stride + this.offset; for (let n = 0; n < this.itemSize; n++)t.push(this.data.array[r + n]) } return new nt(new this.array.constructor(t), this.itemSize, this.normalized) } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new El(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data."); const t = []; for (let s = 0; s < this.count; s++) { const r = s * this.data.stride + this.offset; for (let n = 0; n < this.itemSize; n++)t.push(this.data.array[r + n]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } class Aw extends Tt { constructor(e) { super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new xe(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } let ed; const Pf = new S, td = new S, id = new S, sd = new W, Bf = new W, PR = new He, TA = new S, kf = new S, RA = new S, BR = new W, yw = new W, kR = new W; let DR = class extends Me { constructor(i) { if (super(), this.isSprite = !0, this.type = "Sprite", ed === void 0) { ed = new yt; const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), t = new Rf(e, 5); ed.setIndex([0, 1, 2, 0, 2, 3]), ed.setAttribute("position", new El(t, 3, 0, !1)), ed.setAttribute("uv", new El(t, 2, 3, !1)) } this.geometry = ed, this.material = i !== void 0 ? i : new Aw, this.center = new W(.5, .5) } raycast(i, e) { i.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), td.setFromMatrixScale(this.matrixWorld), PR.copy(i.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(i.camera.matrixWorldInverse, this.matrixWorld), id.setFromMatrixPosition(this.modelViewMatrix), i.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && td.multiplyScalar(-id.z); const t = this.material.rotation; let s, r; t !== 0 && (r = Math.cos(t), s = Math.sin(t)); const n = this.center; PA(TA.set(-.5, -.5, 0), id, n, td, s, r), PA(kf.set(.5, -.5, 0), id, n, td, s, r), PA(RA.set(.5, .5, 0), id, n, td, s, r), BR.set(0, 0), yw.set(1, 0), kR.set(1, 1); let o = i.ray.intersectTriangle(TA, kf, RA, !1, Pf); if (o === null && (PA(kf.set(-.5, .5, 0), id, n, td, s, r), yw.set(0, 1), o = i.ray.intersectTriangle(TA, RA, kf, !1, Pf), o === null)) return; const a = i.ray.origin.distanceTo(Pf); a < i.near || a > i.far || e.push({ distance: a, point: Pf.clone(), uv: vn.getUV(Pf, TA, kf, RA, BR, yw, kR, new W), face: null, object: this }) } copy(i, e) { return super.copy(i, e), i.center !== void 0 && this.center.copy(i.center), this.material = i.material, this } }; function PA(i, e, t, s, r, n) { sd.subVectors(i, t).addScalar(.5).multiply(s), r !== void 0 ? (Bf.x = n * sd.x - r * sd.y, Bf.y = r * sd.x + n * sd.y) : Bf.copy(sd), i.copy(e), i.x += Bf.x, i.y += Bf.y, i.applyMatrix4(PR) } const BA = new S, OR = new S; let bw = class extends Me { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(i) { super.copy(i, !1); const e = i.levels; for (let t = 0, s = e.length; t < s; t++) { const r = e[t]; this.addLevel(r.object.clone(), r.distance, r.hysteresis) } return this.autoUpdate = i.autoUpdate, this } addLevel(i, e = 0, t = 0) { e = Math.abs(e); const s = this.levels; let r; for (r = 0; r < s.length && !(e < s[r].distance); r++); return s.splice(r, 0, { distance: e, hysteresis: t, object: i }), this.add(i), this } getCurrentLevel() { return this._currentLevel } getObjectForDistance(i) { const e = this.levels; if (e.length > 0) { let t, s; for (t = 1, s = e.length; t < s; t++) { let r = e[t].distance; if (e[t].object.visible && (r -= r * e[t].hysteresis), i < r) break } return e[t - 1].object } return null } raycast(i, e) { if (this.levels.length > 0) { BA.setFromMatrixPosition(this.matrixWorld); const t = i.ray.origin.distanceTo(BA); this.getObjectForDistance(t).raycast(i, e) } } update(i) { const e = this.levels; if (e.length > 1) { BA.setFromMatrixPosition(i.matrixWorld), OR.setFromMatrixPosition(this.matrixWorld); const t = BA.distanceTo(OR) / i.zoom; e[0].object.visible = !0; let s, r; for (s = 1, r = e.length; s < r; s++) { let n = e[s].distance; if (e[s].object.visible && (n -= n * e[s].hysteresis), t >= n) e[s - 1].object.visible = !1, e[s].object.visible = !0; else break } for (this._currentLevel = s - 1; s < r; s++)e[s].object.visible = !1 } } toJSON(i) { const e = super.toJSON(i); this.autoUpdate === !1 && (e.object.autoUpdate = !1), e.object.levels = []; const t = this.levels; for (let s = 0, r = t.length; s < r; s++) { const n = t[s]; e.object.levels.push({ object: n.object.uuid, distance: n.distance, hysteresis: n.hysteresis }) } return e } }; const LR = new S, FR = new st, UR = new st, J5 = new S, NR = new He; class rd extends ye { constructor(e, t) { super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new He, this.bindMatrixInverse = new He } copy(e, t) { return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this } bind(e, t) { this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new st, t = this.geometry.attributes.skinWeight; for (let s = 0, r = t.count; s < r; s++) { e.fromBufferAttribute(t, s); const n = 1 / e.manhattanLength(); n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0), t.setXYZW(s, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } boneTransform(e, t) { const s = this.skeleton, r = this.geometry; FR.fromBufferAttribute(r.attributes.skinIndex, e), UR.fromBufferAttribute(r.attributes.skinWeight, e), LR.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let n = 0; n < 4; n++) { const o = UR.getComponent(n); if (o !== 0) { const a = FR.getComponent(n); NR.multiplyMatrices(s.bones[a].matrixWorld, s.boneInverses[a]), t.addScaledVector(J5.copy(LR).applyMatrix4(NR), o) } } return t.applyMatrix4(this.bindMatrixInverse) } } class Df extends Me { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class no extends Nt { constructor(e = null, t = 1, s = 1, r, n, o, a, l, c = Zt, h = Zt, d, p) { super(null, o, a, l, c, h, r, n, d, p), this.isDataTexture = !0, this.image = { data: e, width: t, height: s }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const zR = new He, K5 = new He; class Xp { constructor(e = [], t = []) { this.uuid = Kr(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let s = 0, r = this.bones.length; s < r; s++)this.boneInverses.push(new He) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const s = new He; this.bones[e] && s.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(s) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const s = this.bones[e]; s && s.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const s = this.bones[e]; s && (s.parent && s.parent.isBone ? (s.matrix.copy(s.parent.matrixWorld).invert(), s.matrix.multiply(s.matrixWorld)) : s.matrix.copy(s.matrixWorld), s.matrix.decompose(s.position, s.quaternion, s.scale)) } } update() { const e = this.bones, t = this.boneInverses, s = this.boneMatrices, r = this.boneTexture; for (let n = 0, o = e.length; n < o; n++) { const a = e[n] ? e[n].matrixWorld : K5; zR.multiplyMatrices(a, t[n]), zR.toArray(s, n * 16) } r !== null && (r.needsUpdate = !0) } clone() { return new Xp(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(this.bones.length * 4); e = jT(e), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const s = new no(t, e, e, _i, $i); return s.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = s, this.boneTextureSize = e, this } getBoneByName(e) { for (let t = 0, s = this.bones.length; t < s; t++) { const r = this.bones[t]; if (r.name === e) return r } } dispose() { this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let s = 0, r = e.bones.length; s < r; s++) { const n = e.bones[s]; let o = t[n]; o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", n), o = new Df), this.bones.push(o), this.boneInverses.push(new He().fromArray(e.boneInverses[s])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, s = this.boneInverses; for (let r = 0, n = t.length; r < n; r++) { const o = t[r]; e.bones.push(o.uuid); const a = s[r]; e.boneInverses.push(a.toArray()) } return e } } class tn extends nt { constructor(e, t, s, r = 1) { super(e, t, s), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const jR = new He, QR = new He, kA = [], Z5 = new He, Of = new ye; class DA extends ye { constructor(e, t, s) { super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new tn(new Float32Array(s * 16), 16), this.instanceColor = null, this.count = s, this.frustumCulled = !1; for (let r = 0; r < s; r++)this.setMatrixAt(r, Z5) } copy(e, t) { return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, e * 3) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, e * 16) } raycast(e, t) { const s = this.matrixWorld, r = this.count; if (Of.geometry = this.geometry, Of.material = this.material, Of.material !== void 0) for (let n = 0; n < r; n++) { this.getMatrixAt(n, jR), QR.multiplyMatrices(s, jR), Of.matrixWorld = QR, Of.raycast(e, kA); for (let o = 0, a = kA.length; o < a; o++) { const l = kA[o]; l.instanceId = n, l.object = this, t.push(l) } kA.length = 0 } } setColorAt(e, t) { this.instanceColor === null && (this.instanceColor = new tn(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, e * 16) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } class Hi extends Tt { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new xe(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const GR = new S, HR = new S, VR = new He, _w = new Oa, OA = new Po; let Vi = class extends Me { constructor(i = new yt, e = new Hi) { super(), this.isLine = !0, this.type = "Line", this.geometry = i, this.material = e, this.updateMorphTargets() } copy(i, e) { return super.copy(i, e), this.material = i.material, this.geometry = i.geometry, this } computeLineDistances() { const i = this.geometry; if (i.index === null) { const e = i.attributes.position, t = [0]; for (let s = 1, r = e.count; s < r; s++)GR.fromBufferAttribute(e, s - 1), HR.fromBufferAttribute(e, s), t[s] = t[s - 1], t[s] += GR.distanceTo(HR); i.setAttribute("lineDistance", new et(t, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(i, e) { const t = this.geometry, s = this.matrixWorld, r = i.params.Line.threshold, n = t.drawRange; if (t.boundingSphere === null && t.computeBoundingSphere(), OA.copy(t.boundingSphere), OA.applyMatrix4(s), OA.radius += r, i.ray.intersectsSphere(OA) === !1) return; VR.copy(s).invert(), _w.copy(i.ray).applyMatrix4(VR); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o, l = new S, c = new S, h = new S, d = new S, p = this.isLineSegments ? 2 : 1, f = t.index, g = t.attributes.position; if (f !== null) { const m = Math.max(0, n.start), v = Math.min(f.count, n.start + n.count); for (let A = m, b = v - 1; A < b; A += p) { const y = f.getX(A), _ = f.getX(A + 1); if (l.fromBufferAttribute(g, y), c.fromBufferAttribute(g, _), _w.distanceSqToSegment(l, c, d, h) > a) continue; d.applyMatrix4(this.matrixWorld); const w = i.ray.origin.distanceTo(d); w < i.near || w > i.far || e.push({ distance: w, point: h.clone().applyMatrix4(this.matrixWorld), index: A, face: null, faceIndex: null, object: this }) } } else { const m = Math.max(0, n.start), v = Math.min(g.count, n.start + n.count); for (let A = m, b = v - 1; A < b; A += p) { if (l.fromBufferAttribute(g, A), c.fromBufferAttribute(g, A + 1), _w.distanceSqToSegment(l, c, d, h) > a) continue; d.applyMatrix4(this.matrixWorld); const y = i.ray.origin.distanceTo(d); y < i.near || y > i.far || e.push({ distance: y, point: h.clone().applyMatrix4(this.matrixWorld), index: A, face: null, faceIndex: null, object: this }) } } } updateMorphTargets() { const i = this.geometry.morphAttributes, e = Object.keys(i); if (e.length > 0) { const t = i[e[0]]; if (t !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, r = t.length; s < r; s++) { const n = t[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = s } } } } }; const WR = new S, qR = new S; class sn extends Vi { constructor(e, t) { super(e, t), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, s = []; for (let r = 0, n = t.count; r < n; r += 2)WR.fromBufferAttribute(t, r), qR.fromBufferAttribute(t, r + 1), s[r] = r === 0 ? 0 : s[r - 1], s[r + 1] = s[r] + WR.distanceTo(qR); e.setAttribute("lineDistance", new et(s, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class xw extends Vi { constructor(e, t) { super(e, t), this.isLineLoop = !0, this.type = "LineLoop" } } class LA extends Tt { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new xe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const XR = new He, ww = new Oa, FA = new Po, UA = new S; class Cw extends Me { constructor(e = new yt, t = new LA) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this } raycast(e, t) { const s = this.geometry, r = this.matrixWorld, n = e.params.Points.threshold, o = s.drawRange; if (s.boundingSphere === null && s.computeBoundingSphere(), FA.copy(s.boundingSphere), FA.applyMatrix4(r), FA.radius += n, e.ray.intersectsSphere(FA) === !1) return; XR.copy(r).invert(), ww.copy(e.ray).applyMatrix4(XR); const a = n / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = s.index, h = s.attributes.position; if (c !== null) { const d = Math.max(0, o.start), p = Math.min(c.count, o.start + o.count); for (let f = d, g = p; f < g; f++) { const m = c.getX(f); UA.fromBufferAttribute(h, m), YR(UA, m, l, r, e, t, this) } } else { const d = Math.max(0, o.start), p = Math.min(h.count, o.start + o.count); for (let f = d, g = p; f < g; f++)UA.fromBufferAttribute(h, f), YR(UA, f, l, r, e, t, this) } } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const s = e[t[0]]; if (s !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let r = 0, n = s.length; r < n; r++) { const o = s[r].name || String(r); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r } } } } } function YR(i, e, t, s, r, n, o) { const a = ww.distanceSqToPoint(i); if (a < t) { const l = new S; ww.closestPointToPoint(i, l), l.applyMatrix4(s); const c = r.ray.origin.distanceTo(l); if (c < r.near || c > r.far) return; n.push({ distance: c, distanceToRay: Math.sqrt(a), point: l, index: e, face: null, object: o }) } } class JR extends Nt { constructor(e, t, s, r, n, o, a, l, c) { super(e, t, s, r, n, o, a, l, c), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : Qt, this.magFilter = n !== void 0 ? n : Qt, this.generateMipmaps = !1; const h = this; function d() { h.needsUpdate = !0, e.requestVideoFrameCallback(d) } "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; !("requestVideoFrameCallback" in e) && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class $5 extends Nt { constructor(e, t, s) { super({ width: e, height: t }), this.isFramebufferTexture = !0, this.format = s, this.magFilter = Zt, this.minFilter = Zt, this.generateMipmaps = !1, this.needsUpdate = !0 } } class Na extends Nt { constructor(e, t, s, r, n, o, a, l, c, h, d, p) { super(null, o, a, l, c, h, r, n, d, p), this.isCompressedTexture = !0, this.image = { width: t, height: s }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } class KR extends Na { constructor(e, t, s, r, n, o) { super(e, t, s, n, o), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = Ss } } class ZR extends Nt { constructor(e, t, s, r, n, o, a, l, c) { super(e, t, s, r, n, o, a, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0 } } class oo { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { const s = this.getUtoTmapping(e); return this.getPoint(s, t) } getPoints(e = 5) { const t = []; for (let s = 0; s <= e; s++)t.push(this.getPoint(s / e)); return t } getSpacedPoints(e = 5) { const t = []; for (let s = 0; s <= e; s++)t.push(this.getPointAt(s / e)); return t } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let s, r = this.getPoint(0), n = 0; t.push(0); for (let o = 1; o <= e; o++)s = this.getPoint(o / e), n += s.distanceTo(r), t.push(n), r = s; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { const s = this.getLengths(); let r = 0; const n = s.length; let o; t ? o = t : o = e * s[n - 1]; let a = 0, l = n - 1, c; for (; a <= l;)if (r = Math.floor(a + (l - a) / 2), c = s[r] - o, c < 0) a = r + 1; else if (c > 0) l = r - 1; else { l = r; break } if (r = l, s[r] === o) return r / (n - 1); const h = s[r], d = s[r + 1] - h, p = (o - h) / d; return (r + p) / (n - 1) } getTangent(e, t) { let s = e - 1e-4, r = e + 1e-4; s < 0 && (s = 0), r > 1 && (r = 1); const n = this.getPoint(s), o = this.getPoint(r), a = t || (n.isVector2 ? new W : new S); return a.copy(o).sub(n).normalize(), a } getTangentAt(e, t) { const s = this.getUtoTmapping(e); return this.getTangent(s, t) } computeFrenetFrames(e, t) { const s = new S, r = [], n = [], o = [], a = new S, l = new He; for (let f = 0; f <= e; f++) { const g = f / e; r[f] = this.getTangentAt(g, new S) } n[0] = new S, o[0] = new S; let c = Number.MAX_VALUE; const h = Math.abs(r[0].x), d = Math.abs(r[0].y), p = Math.abs(r[0].z); h <= c && (c = h, s.set(1, 0, 0)), d <= c && (c = d, s.set(0, 1, 0)), p <= c && s.set(0, 0, 1), a.crossVectors(r[0], s).normalize(), n[0].crossVectors(r[0], a), o[0].crossVectors(r[0], n[0]); for (let f = 1; f <= e; f++) { if (n[f] = n[f - 1].clone(), o[f] = o[f - 1].clone(), a.crossVectors(r[f - 1], r[f]), a.length() > Number.EPSILON) { a.normalize(); const g = Math.acos(Gi(r[f - 1].dot(r[f]), -1, 1)); n[f].applyMatrix4(l.makeRotationAxis(a, g)) } o[f].crossVectors(r[f], n[f]) } if (t === !0) { let f = Math.acos(Gi(n[0].dot(n[e]), -1, 1)); f /= e, r[0].dot(a.crossVectors(n[0], n[e])) > 0 && (f = -f); for (let g = 1; g <= e; g++)n[g].applyMatrix4(l.makeRotationAxis(r[g], f * g)), o[g].crossVectors(r[g], n[g]) } return { tangents: r, normals: n, binormals: o } } clone() { return new this.constructor().copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class NA extends oo { constructor(e = 0, t = 0, s = 1, r = 1, n = 0, o = Math.PI * 2, a = !1, l = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = s, this.yRadius = r, this.aStartAngle = n, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l } getPoint(e, t) { const s = t || new W, r = Math.PI * 2; let n = this.aEndAngle - this.aStartAngle; const o = Math.abs(n) < Number.EPSILON; for (; n < 0;)n += r; for (; n > r;)n -= r; n < Number.EPSILON && (o ? n = 0 : n = r), this.aClockwise === !0 && !o && (n === r ? n = -r : n = n - r); const a = this.aStartAngle + e * n; let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a); if (this.aRotation !== 0) { const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = l - this.aX, f = c - this.aY; l = p * h - f * d + this.aX, c = p * d + f * h + this.aY } return s.set(l, c) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } class $R extends NA { constructor(e, t, s, r, n, o) { super(e, t, s, s, r, n, o), this.isArcCurve = !0, this.type = "ArcCurve" } } function Sw() { let i = 0, e = 0, t = 0, s = 0; function r(n, o, a, l) { i = n, e = a, t = -3 * n + 3 * o - 2 * a - l, s = 2 * n - 2 * o + a + l } return { initCatmullRom: function (n, o, a, l, c) { r(o, a, c * (a - n), c * (l - o)) }, initNonuniformCatmullRom: function (n, o, a, l, c, h, d) { let p = (o - n) / c - (a - n) / (c + h) + (a - o) / h, f = (a - o) / h - (l - o) / (h + d) + (l - a) / d; p *= h, f *= h, r(o, a, p, f) }, calc: function (n) { const o = n * n, a = o * n; return i + e * n + t * o + s * a } } } const zA = new S, Ew = new Sw, Mw = new Sw, Iw = new Sw; class eP extends oo { constructor(e = [], t = !1, s = "centripetal", r = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = s, this.tension = r } getPoint(e, t = new S) { const s = t, r = this.points, n = r.length, o = (n - (this.closed ? 0 : 1)) * e; let a = Math.floor(o), l = o - a; this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / n) + 1) * n : l === 0 && a === n - 1 && (a = n - 2, l = 1); let c, h; this.closed || a > 0 ? c = r[(a - 1) % n] : (zA.subVectors(r[0], r[1]).add(r[0]), c = zA); const d = r[a % n], p = r[(a + 1) % n]; if (this.closed || a + 2 < n ? h = r[(a + 2) % n] : (zA.subVectors(r[n - 1], r[n - 2]).add(r[n - 1]), h = zA), this.curveType === "centripetal" || this.curveType === "chordal") { const f = this.curveType === "chordal" ? .5 : .25; let g = Math.pow(c.distanceToSquared(d), f), m = Math.pow(d.distanceToSquared(p), f), v = Math.pow(p.distanceToSquared(h), f); m < 1e-4 && (m = 1), g < 1e-4 && (g = m), v < 1e-4 && (v = m), Ew.initNonuniformCatmullRom(c.x, d.x, p.x, h.x, g, m, v), Mw.initNonuniformCatmullRom(c.y, d.y, p.y, h.y, g, m, v), Iw.initNonuniformCatmullRom(c.z, d.z, p.z, h.z, g, m, v) } else this.curveType === "catmullrom" && (Ew.initCatmullRom(c.x, d.x, p.x, h.x, this.tension), Mw.initCatmullRom(c.y, d.y, p.y, h.y, this.tension), Iw.initCatmullRom(c.z, d.z, p.z, h.z, this.tension)); return s.set(Ew.calc(l), Mw.calc(l), Iw.calc(l)), s } copy(e) { super.copy(e), this.points = []; for (let t = 0, s = e.points.length; t < s; t++) { const r = e.points[t]; this.points.push(r.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, s = this.points.length; t < s; t++) { const r = this.points[t]; e.points.push(r.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, s = e.points.length; t < s; t++) { const r = e.points[t]; this.points.push(new S().fromArray(r)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function tP(i, e, t, s, r) { const n = (s - e) * .5, o = (r - t) * .5, a = i * i, l = i * a; return (2 * t - 2 * s + n + o) * l + (-3 * t + 3 * s - 2 * n - o) * a + n * i + t } function eH(i, e) { const t = 1 - i; return t * t * e } function tH(i, e) { return 2 * (1 - i) * i * e } function iH(i, e) { return i * i * e } function Lf(i, e, t, s) { return eH(i, e) + tH(i, t) + iH(i, s) } function sH(i, e) { const t = 1 - i; return t * t * t * e } function rH(i, e) { const t = 1 - i; return 3 * t * t * i * e } function nH(i, e) { return 3 * (1 - i) * i * i * e } function oH(i, e) { return i * i * i * e } function Ff(i, e, t, s, r) { return sH(i, e) + rH(i, t) + nH(i, s) + oH(i, r) } class Tw extends oo { constructor(e = new W, t = new W, s = new W, r = new W) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = s, this.v3 = r } getPoint(e, t = new W) { const s = t, r = this.v0, n = this.v1, o = this.v2, a = this.v3; return s.set(Ff(e, r.x, n.x, o.x, a.x), Ff(e, r.y, n.y, o.y, a.y)), s } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class iP extends oo { constructor(e = new S, t = new S, s = new S, r = new S) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = s, this.v3 = r } getPoint(e, t = new S) { const s = t, r = this.v0, n = this.v1, o = this.v2, a = this.v3; return s.set(Ff(e, r.x, n.x, o.x, a.x), Ff(e, r.y, n.y, o.y, a.y), Ff(e, r.z, n.z, o.z, a.z)), s } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class jA extends oo { constructor(e = new W, t = new W) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new W) { const s = t; return e === 1 ? s.copy(this.v2) : (s.copy(this.v2).sub(this.v1), s.multiplyScalar(e).add(this.v1)), s } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t) { const s = t || new W; return s.copy(this.v2).sub(this.v1).normalize(), s } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class sP extends oo { constructor(e = new S, t = new S) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t } getPoint(e, t = new S) { const s = t; return e === 1 ? s.copy(this.v2) : (s.copy(this.v2).sub(this.v1), s.multiplyScalar(e).add(this.v1)), s } getPointAt(e, t) { return this.getPoint(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class Rw extends oo { constructor(e = new W, t = new W, s = new W) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = s } getPoint(e, t = new W) { const s = t, r = this.v0, n = this.v1, o = this.v2; return s.set(Lf(e, r.x, n.x, o.x), Lf(e, r.y, n.y, o.y)), s } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class Pw extends oo { constructor(e = new S, t = new S, s = new S) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = s } getPoint(e, t = new S) { const s = t, r = this.v0, n = this.v1, o = this.v2; return s.set(Lf(e, r.x, n.x, o.x), Lf(e, r.y, n.y, o.y), Lf(e, r.z, n.z, o.z)), s } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class Bw extends oo { constructor(e = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e } getPoint(e, t = new W) { const s = t, r = this.points, n = (r.length - 1) * e, o = Math.floor(n), a = n - o, l = r[o === 0 ? o : o - 1], c = r[o], h = r[o > r.length - 2 ? r.length - 1 : o + 1], d = r[o > r.length - 3 ? r.length - 1 : o + 2]; return s.set(tP(a, l.x, c.x, h.x, d.x), tP(a, l.y, c.y, h.y, d.y)), s } copy(e) { super.copy(e), this.points = []; for (let t = 0, s = e.points.length; t < s; t++) { const r = e.points[t]; this.points.push(r.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, s = this.points.length; t < s; t++) { const r = this.points[t]; e.points.push(r.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, s = e.points.length; t < s; t++) { const r = e.points[t]; this.points.push(new W().fromArray(r)) } return this } } var kw = Object.freeze({ __proto__: null, ArcCurve: $R, CatmullRomCurve3: eP, CubicBezierCurve: Tw, CubicBezierCurve3: iP, EllipseCurve: NA, LineCurve: jA, LineCurve3: sP, QuadraticBezierCurve: Rw, QuadraticBezierCurve3: Pw, SplineCurve: Bw }); class rP extends oo { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new jA(t, e)) } getPoint(e, t) { const s = e * this.getLength(), r = this.getCurveLengths(); let n = 0; for (; n < r.length;) { if (r[n] >= s) { const o = r[n] - s, a = this.curves[n], l = a.getLength(), c = l === 0 ? 0 : 1 - o / l; return a.getPointAt(c, t) } n++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let s = 0, r = this.curves.length; s < r; s++)t += this.curves[s].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let s = 0; s <= e; s++)t.push(this.getPoint(s / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let s; for (let r = 0, n = this.curves; r < n.length; r++) { const o = n[r], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a); for (let c = 0; c < l.length; c++) { const h = l[c]; s && s.equals(h) || (t.push(h), s = h) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, s = e.curves.length; t < s; t++) { const r = e.curves[t]; this.curves.push(r.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, s = this.curves.length; t < s; t++) { const r = this.curves[t]; e.curves.push(r.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, s = e.curves.length; t < s; t++) { const r = e.curves[t]; this.curves.push(new kw[r.type]().fromJSON(r)) } return this } } class Uf extends rP { constructor(e) { super(), this.type = "Path", this.currentPoint = new W, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, s = e.length; t < s; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const s = new jA(this.currentPoint.clone(), new W(e, t)); return this.curves.push(s), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, s, r) { const n = new Rw(this.currentPoint.clone(), new W(e, t), new W(s, r)); return this.curves.push(n), this.currentPoint.set(s, r), this } bezierCurveTo(e, t, s, r, n, o) { const a = new Tw(this.currentPoint.clone(), new W(e, t), new W(s, r), new W(n, o)); return this.curves.push(a), this.currentPoint.set(n, o), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), s = new Bw(t); return this.curves.push(s), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, s, r, n, o) { const a = this.currentPoint.x, l = this.currentPoint.y; return this.absarc(e + a, t + l, s, r, n, o), this } absarc(e, t, s, r, n, o) { return this.absellipse(e, t, s, s, r, n, o), this } ellipse(e, t, s, r, n, o, a, l) { const c = this.currentPoint.x, h = this.currentPoint.y; return this.absellipse(e + c, t + h, s, r, n, o, a, l), this } absellipse(e, t, s, r, n, o, a, l) { const c = new NA(e, t, s, r, n, o, a, l); if (this.curves.length > 0) { const d = c.getPoint(0); d.equals(this.currentPoint) || this.lineTo(d.x, d.y) } this.curves.push(c); const h = c.getPoint(1); return this.currentPoint.copy(h), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class Yp extends yt { constructor(e = [new W(0, -.5), new W(.5, 0), new W(0, .5)], t = 12, s = 0, r = Math.PI * 2) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: s, phiLength: r }, t = Math.floor(t), r = Gi(r, 0, Math.PI * 2); const n = [], o = [], a = [], l = [], c = [], h = 1 / t, d = new S, p = new W, f = new S, g = new S, m = new S; let v = 0, A = 0; for (let b = 0; b <= e.length - 1; b++)switch (b) { case 0: v = e[b + 1].x - e[b].x, A = e[b + 1].y - e[b].y, f.x = A * 1, f.y = -v, f.z = A * 0, m.copy(f), f.normalize(), l.push(f.x, f.y, f.z); break; case e.length - 1: l.push(m.x, m.y, m.z); break; default: v = e[b + 1].x - e[b].x, A = e[b + 1].y - e[b].y, f.x = A * 1, f.y = -v, f.z = A * 0, g.copy(f), f.x += m.x, f.y += m.y, f.z += m.z, f.normalize(), l.push(f.x, f.y, f.z), m.copy(g) }for (let b = 0; b <= t; b++) { const y = s + b * h * r, _ = Math.sin(y), w = Math.cos(y); for (let E = 0; E <= e.length - 1; E++) { d.x = e[E].x * _, d.y = e[E].y, d.z = e[E].x * w, o.push(d.x, d.y, d.z), p.x = b / t, p.y = E / (e.length - 1), a.push(p.x, p.y); const P = l[3 * E + 0] * _, C = l[3 * E + 1], R = l[3 * E + 0] * w; c.push(P, C, R) } } for (let b = 0; b < t; b++)for (let y = 0; y < e.length - 1; y++) { const _ = y + b * e.length, w = _, E = _ + e.length, P = _ + e.length + 1, C = _ + 1; n.push(w, E, C), n.push(P, C, E) } this.setIndex(n), this.setAttribute("position", new et(o, 3)), this.setAttribute("uv", new et(a, 2)), this.setAttribute("normal", new et(c, 3)) } static fromJSON(e) { return new Yp(e.points, e.segments, e.phiStart, e.phiLength) } } class Av extends Yp { constructor(e = 1, t = 1, s = 4, r = 8) { const n = new Uf; n.absarc(0, -t / 2, e, Math.PI * 1.5, 0), n.absarc(0, t / 2, e, 0, Math.PI * .5), super(n.getPoints(s), r), this.type = "CapsuleGeometry", this.parameters = { radius: e, height: t, capSegments: s, radialSegments: r } } static fromJSON(e) { return new Av(e.radius, e.length, e.capSegments, e.radialSegments) } } class yv extends yt { constructor(e = 1, t = 8, s = 0, r = Math.PI * 2) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: s, thetaLength: r }, t = Math.max(3, t); const n = [], o = [], a = [], l = [], c = new S, h = new W; o.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5); for (let d = 0, p = 3; d <= t; d++, p += 3) { const f = s + d / t * r; c.x = e * Math.cos(f), c.y = e * Math.sin(f), o.push(c.x, c.y, c.z), a.push(0, 0, 1), h.x = (o[p] / e + 1) / 2, h.y = (o[p + 1] / e + 1) / 2, l.push(h.x, h.y) } for (let d = 1; d <= t; d++)n.push(d, d + 1, 0); this.setIndex(n), this.setAttribute("position", new et(o, 3)), this.setAttribute("normal", new et(a, 3)), this.setAttribute("uv", new et(l, 2)) } static fromJSON(e) { return new yv(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class ji extends yt { constructor(e = 1, t = 1, s = 1, r = 8, n = 1, o = !1, a = 0, l = Math.PI * 2) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: s, radialSegments: r, heightSegments: n, openEnded: o, thetaStart: a, thetaLength: l }; const c = this; r = Math.floor(r), n = Math.floor(n); const h = [], d = [], p = [], f = []; let g = 0; const m = [], v = s / 2; let A = 0; b(), o === !1 && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(h), this.setAttribute("position", new et(d, 3)), this.setAttribute("normal", new et(p, 3)), this.setAttribute("uv", new et(f, 2)); function b() { const _ = new S, w = new S; let E = 0; const P = (t - e) / s; for (let C = 0; C <= n; C++) { const R = [], T = C / n, z = T * (t - e) + e; for (let H = 0; H <= r; H++) { const N = H / r, F = N * l + a, X = Math.sin(F), te = Math.cos(F); w.x = z * X, w.y = -T * s + v, w.z = z * te, d.push(w.x, w.y, w.z), _.set(X, P, te).normalize(), p.push(_.x, _.y, _.z), f.push(N, 1 - T), R.push(g++) } m.push(R) } for (let C = 0; C < r; C++)for (let R = 0; R < n; R++) { const T = m[R][C], z = m[R + 1][C], H = m[R + 1][C + 1], N = m[R][C + 1]; h.push(T, z, N), h.push(z, H, N), E += 6 } c.addGroup(A, E, 0), A += E } function y(_) { const w = g, E = new W, P = new S; let C = 0; const R = _ === !0 ? e : t, T = _ === !0 ? 1 : -1; for (let H = 1; H <= r; H++)d.push(0, v * T, 0), p.push(0, T, 0), f.push(.5, .5), g++; const z = g; for (let H = 0; H <= r; H++) { const N = H / r * l + a, F = Math.cos(N), X = Math.sin(N); P.x = R * X, P.y = v * T, P.z = R * F, d.push(P.x, P.y, P.z), p.push(0, T, 0), E.x = F * .5 + .5, E.y = X * .5 * T + .5, f.push(E.x, E.y), g++ } for (let H = 0; H < r; H++) { const N = w + H, F = z + H; _ === !0 ? h.push(F, F + 1, N) : h.push(F + 1, F, N), C += 3 } c.addGroup(A, C, _ === !0 ? 1 : 2), A += C } } static fromJSON(e) { return new ji(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class bv extends ji { constructor(e = 1, t = 1, s = 8, r = 1, n = !1, o = 0, a = Math.PI * 2) { super(0, e, t, s, r, n, o, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: s, heightSegments: r, openEnded: n, thetaStart: o, thetaLength: a } } static fromJSON(e) { return new bv(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class Ml extends yt { constructor(e = [], t = [], s = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: s, detail: r }; const n = [], o = []; a(r), c(s), h(), this.setAttribute("position", new et(n, 3)), this.setAttribute("normal", new et(n.slice(), 3)), this.setAttribute("uv", new et(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals(); function a(b) { const y = new S, _ = new S, w = new S; for (let E = 0; E < t.length; E += 3)f(t[E + 0], y), f(t[E + 1], _), f(t[E + 2], w), l(y, _, w, b) } function l(b, y, _, w) { const E = w + 1, P = []; for (let C = 0; C <= E; C++) { P[C] = []; const R = b.clone().lerp(_, C / E), T = y.clone().lerp(_, C / E), z = E - C; for (let H = 0; H <= z; H++)H === 0 && C === E ? P[C][H] = R : P[C][H] = R.clone().lerp(T, H / z) } for (let C = 0; C < E; C++)for (let R = 0; R < 2 * (E - C) - 1; R++) { const T = Math.floor(R / 2); R % 2 === 0 ? (p(P[C][T + 1]), p(P[C + 1][T]), p(P[C][T])) : (p(P[C][T + 1]), p(P[C + 1][T + 1]), p(P[C + 1][T])) } } function c(b) { const y = new S; for (let _ = 0; _ < n.length; _ += 3)y.x = n[_ + 0], y.y = n[_ + 1], y.z = n[_ + 2], y.normalize().multiplyScalar(b), n[_ + 0] = y.x, n[_ + 1] = y.y, n[_ + 2] = y.z } function h() { const b = new S; for (let y = 0; y < n.length; y += 3) { b.x = n[y + 0], b.y = n[y + 1], b.z = n[y + 2]; const _ = v(b) / 2 / Math.PI + .5, w = A(b) / Math.PI + .5; o.push(_, 1 - w) } g(), d() } function d() { for (let b = 0; b < o.length; b += 6) { const y = o[b + 0], _ = o[b + 2], w = o[b + 4], E = Math.max(y, _, w), P = Math.min(y, _, w); E > .9 && P < .1 && (y < .2 && (o[b + 0] += 1), _ < .2 && (o[b + 2] += 1), w < .2 && (o[b + 4] += 1)) } } function p(b) { n.push(b.x, b.y, b.z) } function f(b, y) { const _ = b * 3; y.x = e[_ + 0], y.y = e[_ + 1], y.z = e[_ + 2] } function g() { const b = new S, y = new S, _ = new S, w = new S, E = new W, P = new W, C = new W; for (let R = 0, T = 0; R < n.length; R += 9, T += 6) { b.set(n[R + 0], n[R + 1], n[R + 2]), y.set(n[R + 3], n[R + 4], n[R + 5]), _.set(n[R + 6], n[R + 7], n[R + 8]), E.set(o[T + 0], o[T + 1]), P.set(o[T + 2], o[T + 3]), C.set(o[T + 4], o[T + 5]), w.copy(b).add(y).add(_).divideScalar(3); const z = v(w); m(E, T + 0, b, z), m(P, T + 2, y, z), m(C, T + 4, _, z) } } function m(b, y, _, w) { w < 0 && b.x === 1 && (o[y] = b.x - 1), _.x === 0 && _.z === 0 && (o[y] = w / 2 / Math.PI + .5) } function v(b) { return Math.atan2(b.z, -b.x) } function A(b) { return Math.atan2(-b.y, Math.sqrt(b.x * b.x + b.z * b.z)) } } static fromJSON(e) { return new Ml(e.vertices, e.indices, e.radius, e.details) } } class _v extends Ml { constructor(e = 1, t = 0) { const s = (1 + Math.sqrt(5)) / 2, r = 1 / s, n = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -s, 0, -r, s, 0, r, -s, 0, r, s, -r, -s, 0, -r, s, 0, r, -s, 0, r, s, 0, -s, 0, -r, s, 0, -r, -s, 0, r, s, 0, r], o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9]; super(n, o, e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new _v(e.radius, e.detail) } } const QA = new S, GA = new S, Dw = new S, HA = new vn; class Ow extends yt { constructor(e = null, t = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) { const s = Math.pow(10, 4), r = Math.cos(hh * t), n = e.getIndex(), o = e.getAttribute("position"), a = n ? n.count : o.count, l = [0, 0, 0], c = ["a", "b", "c"], h = new Array(3), d = {}, p = []; for (let f = 0; f < a; f += 3) { n ? (l[0] = n.getX(f), l[1] = n.getX(f + 1), l[2] = n.getX(f + 2)) : (l[0] = f, l[1] = f + 1, l[2] = f + 2); const { a: g, b: m, c: v } = HA; if (g.fromBufferAttribute(o, l[0]), m.fromBufferAttribute(o, l[1]), v.fromBufferAttribute(o, l[2]), HA.getNormal(Dw), h[0] = `${Math.round(g.x * s)},${Math.round(g.y * s)},${Math.round(g.z * s)}`, h[1] = `${Math.round(m.x * s)},${Math.round(m.y * s)},${Math.round(m.z * s)}`, h[2] = `${Math.round(v.x * s)},${Math.round(v.y * s)},${Math.round(v.z * s)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0])) for (let A = 0; A < 3; A++) { const b = (A + 1) % 3, y = h[A], _ = h[b], w = HA[c[A]], E = HA[c[b]], P = `${y}_${_}`, C = `${_}_${y}`; C in d && d[C] ? (Dw.dot(d[C].normal) <= r && (p.push(w.x, w.y, w.z), p.push(E.x, E.y, E.z)), d[C] = null) : P in d || (d[P] = { index0: l[A], index1: l[b], normal: Dw.clone() }) } } for (const f in d) if (d[f]) { const { index0: g, index1: m } = d[f]; QA.fromBufferAttribute(o, g), GA.fromBufferAttribute(o, m), p.push(QA.x, QA.y, QA.z), p.push(GA.x, GA.y, GA.z) } this.setAttribute("position", new et(p, 3)) } } } class Ah extends Uf { constructor(e) { super(e), this.uuid = Kr(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let s = 0, r = this.holes.length; s < r; s++)t[s] = this.holes[s].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, s = e.holes.length; t < s; t++) { const r = e.holes[t]; this.holes.push(r.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, s = this.holes.length; t < s; t++) { const r = this.holes[t]; e.holes.push(r.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, s = e.holes.length; t < s; t++) { const r = e.holes[t]; this.holes.push(new Uf().fromJSON(r)) } return this } } const aH = { triangulate: function (i, e, t = 2) { const s = e && e.length, r = s ? e[0] * t : i.length; let n = nP(i, 0, r, t, !0); const o = []; if (!n || n.next === n.prev) return o; let a, l, c, h, d, p, f; if (s && (n = dH(i, e, n, t)), i.length > 80 * t) { a = c = i[0], l = h = i[1]; for (let g = t; g < r; g += t)d = i[g], p = i[g + 1], d < a && (a = d), p < l && (l = p), d > c && (c = d), p > h && (h = p); f = Math.max(c - a, h - l), f = f !== 0 ? 32767 / f : 0 } return Nf(n, o, t, a, l, f, 0), o } }; function nP(i, e, t, s, r) { let n, o; if (r === wH(i, e, t, s) > 0) for (n = e; n < t; n += s)o = lP(n, i[n], i[n + 1], o); else for (n = t - s; n >= e; n -= s)o = lP(n, i[n], i[n + 1], o); return o && VA(o, o.next) && (jf(o), o = o.next), o } function yh(i, e) { if (!i) return i; e || (e = i); let t = i, s; do if (s = !1, !t.steiner && (VA(t, t.next) || Pi(t.prev, t, t.next) === 0)) { if (jf(t), t = e = t.prev, t === t.next) break; s = !0 } else t = t.next; while (s || t !== e); return e } function Nf(i, e, t, s, r, n, o) { if (!i) return; !o && n && vH(i, s, r, n); let a = i, l, c; for (; i.prev !== i.next;) { if (l = i.prev, c = i.next, n ? cH(i, s, r, n) : lH(i)) { e.push(l.i / t | 0), e.push(i.i / t | 0), e.push(c.i / t | 0), jf(i), i = c.next, a = c.next; continue } if (i = c, i === a) { o ? o === 1 ? (i = hH(yh(i), e, t), Nf(i, e, t, s, r, n, 2)) : o === 2 && uH(i, e, t, s, r, n) : Nf(yh(i), e, t, s, r, n, 1); break } } } function lH(i) { const e = i.prev, t = i, s = i.next; if (Pi(e, t, s) >= 0) return !1; const r = e.x, n = t.x, o = s.x, a = e.y, l = t.y, c = s.y, h = r < n ? r < o ? r : o : n < o ? n : o, d = a < l ? a < c ? a : c : l < c ? l : c, p = r > n ? r > o ? r : o : n > o ? n : o, f = a > l ? a > c ? a : c : l > c ? l : c; let g = s.next; for (; g !== e;) { if (g.x >= h && g.x <= p && g.y >= d && g.y <= f && nd(r, a, n, l, o, c, g.x, g.y) && Pi(g.prev, g, g.next) >= 0) return !1; g = g.next } return !0 } function cH(i, e, t, s) { const r = i.prev, n = i, o = i.next; if (Pi(r, n, o) >= 0) return !1; const a = r.x, l = n.x, c = o.x, h = r.y, d = n.y, p = o.y, f = a < l ? a < c ? a : c : l < c ? l : c, g = h < d ? h < p ? h : p : d < p ? d : p, m = a > l ? a > c ? a : c : l > c ? l : c, v = h > d ? h > p ? h : p : d > p ? d : p, A = Lw(f, g, e, t, s), b = Lw(m, v, e, t, s); let y = i.prevZ, _ = i.nextZ; for (; y && y.z >= A && _ && _.z <= b;) { if (y.x >= f && y.x <= m && y.y >= g && y.y <= v && y !== r && y !== o && nd(a, h, l, d, c, p, y.x, y.y) && Pi(y.prev, y, y.next) >= 0 || (y = y.prevZ, _.x >= f && _.x <= m && _.y >= g && _.y <= v && _ !== r && _ !== o && nd(a, h, l, d, c, p, _.x, _.y) && Pi(_.prev, _, _.next) >= 0)) return !1; _ = _.nextZ } for (; y && y.z >= A;) { if (y.x >= f && y.x <= m && y.y >= g && y.y <= v && y !== r && y !== o && nd(a, h, l, d, c, p, y.x, y.y) && Pi(y.prev, y, y.next) >= 0) return !1; y = y.prevZ } for (; _ && _.z <= b;) { if (_.x >= f && _.x <= m && _.y >= g && _.y <= v && _ !== r && _ !== o && nd(a, h, l, d, c, p, _.x, _.y) && Pi(_.prev, _, _.next) >= 0) return !1; _ = _.nextZ } return !0 } function hH(i, e, t) { let s = i; do { const r = s.prev, n = s.next.next; !VA(r, n) && oP(r, s, s.next, n) && zf(r, n) && zf(n, r) && (e.push(r.i / t | 0), e.push(s.i / t | 0), e.push(n.i / t | 0), jf(s), jf(s.next), s = i = n), s = s.next } while (s !== i); return yh(s) } function uH(i, e, t, s, r, n) { let o = i; do { let a = o.next.next; for (; a !== o.prev;) { if (o.i !== a.i && bH(o, a)) { let l = aP(o, a); o = yh(o, o.next), l = yh(l, l.next), Nf(o, e, t, s, r, n, 0), Nf(l, e, t, s, r, n, 0); return } a = a.next } o = o.next } while (o !== i) } function dH(i, e, t, s) { const r = []; let n, o, a, l, c; for (n = 0, o = e.length; n < o; n++)a = e[n] * s, l = n < o - 1 ? e[n + 1] * s : i.length, c = nP(i, a, l, s, !1), c === c.next && (c.steiner = !0), r.push(yH(c)); for (r.sort(pH), n = 0; n < r.length; n++)t = fH(r[n], t); return t } function pH(i, e) { return i.x - e.x } function fH(i, e) { const t = gH(i, e); if (!t) return e; const s = aP(t, i); return yh(s, s.next), yh(t, t.next) } function gH(i, e) { let t = e, s = -1 / 0, r; const n = i.x, o = i.y; do { if (o <= t.y && o >= t.next.y && t.next.y !== t.y) { const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y); if (p <= n && p > s && (s = p, r = t.x < t.next.x ? t : t.next, p === n)) return r } t = t.next } while (t !== e); if (!r) return null; const a = r, l = r.x, c = r.y; let h = 1 / 0, d; t = r; do n >= t.x && t.x >= l && n !== t.x && nd(o < c ? n : s, o, l, c, o < c ? s : n, o, t.x, t.y) && (d = Math.abs(o - t.y) / (n - t.x), zf(t, i) && (d < h || d === h && (t.x > r.x || t.x === r.x && mH(r, t))) && (r = t, h = d)), t = t.next; while (t !== a); return r } function mH(i, e) { return Pi(i.prev, i, e.prev) < 0 && Pi(e.next, i, i.next) < 0 } function vH(i, e, t, s) { let r = i; do r.z === 0 && (r.z = Lw(r.x, r.y, e, t, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== i); r.prevZ.nextZ = null, r.prevZ = null, AH(r) } function AH(i) { let e, t, s, r, n, o, a, l, c = 1; do { for (t = i, i = null, n = null, o = 0; t;) { for (o++, s = t, a = 0, e = 0; e < c && (a++, s = s.nextZ, !!s); e++); for (l = c; a > 0 || l > 0 && s;)a !== 0 && (l === 0 || !s || t.z <= s.z) ? (r = t, t = t.nextZ, a--) : (r = s, s = s.nextZ, l--), n ? n.nextZ = r : i = r, r.prevZ = n, n = r; t = s } n.nextZ = null, c *= 2 } while (o > 1); return i } function Lw(i, e, t, s, r) { return i = (i - t) * r | 0, e = (e - s) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1 } function yH(i) { let e = i, t = i; do (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== i); return t } function nd(i, e, t, s, r, n, o, a) { return (r - o) * (e - a) >= (i - o) * (n - a) && (i - o) * (s - a) >= (t - o) * (e - a) && (t - o) * (n - a) >= (r - o) * (s - a) } function bH(i, e) { return i.next.i !== e.i && i.prev.i !== e.i && !_H(i, e) && (zf(i, e) && zf(e, i) && xH(i, e) && (Pi(i.prev, i, e.prev) || Pi(i, e.prev, e)) || VA(i, e) && Pi(i.prev, i, i.next) > 0 && Pi(e.prev, e, e.next) > 0) } function Pi(i, e, t) { return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y) } function VA(i, e) { return i.x === e.x && i.y === e.y } function oP(i, e, t, s) { const r = qA(Pi(i, e, t)), n = qA(Pi(i, e, s)), o = qA(Pi(t, s, i)), a = qA(Pi(t, s, e)); return !!(r !== n && o !== a || r === 0 && WA(i, t, e) || n === 0 && WA(i, s, e) || o === 0 && WA(t, i, s) || a === 0 && WA(t, e, s)) } function WA(i, e, t) { return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y) } function qA(i) { return i > 0 ? 1 : i < 0 ? -1 : 0 } function _H(i, e) { let t = i; do { if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && oP(t, t.next, i, e)) return !0; t = t.next } while (t !== i); return !1 } function zf(i, e) { return Pi(i.prev, i, i.next) < 0 ? Pi(i, e, i.next) >= 0 && Pi(i, i.prev, e) >= 0 : Pi(i, e, i.prev) < 0 || Pi(i, i.next, e) < 0 } function xH(i, e) { let t = i, s = !1; const r = (i.x + e.x) / 2, n = (i.y + e.y) / 2; do t.y > n != t.next.y > n && t.next.y !== t.y && r < (t.next.x - t.x) * (n - t.y) / (t.next.y - t.y) + t.x && (s = !s), t = t.next; while (t !== i); return s } function aP(i, e) { const t = new Fw(i.i, i.x, i.y), s = new Fw(e.i, e.x, e.y), r = i.next, n = e.prev; return i.next = e, e.prev = i, t.next = r, r.prev = t, s.next = t, t.prev = s, n.next = s, s.prev = n, s } function lP(i, e, t, s) { const r = new Fw(i, e, t); return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r } function jf(i) { i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ) } function Fw(i, e, t) { this.i = i, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function wH(i, e, t, s) { let r = 0; for (let n = e, o = t - s; n < t; n += s)r += (i[o] - i[n]) * (i[n + 1] + i[o + 1]), o = n; return r } class va { static area(e) { const t = e.length; let s = 0; for (let r = t - 1, n = 0; n < t; r = n++)s += e[r].x * e[n].y - e[n].x * e[r].y; return s * .5 } static isClockWise(e) { return va.area(e) < 0 } static triangulateShape(e, t) { const s = [], r = [], n = []; cP(e), hP(s, e); let o = e.length; t.forEach(cP); for (let l = 0; l < t.length; l++)r.push(o), o += t[l].length, hP(s, t[l]); const a = aH.triangulate(s, r); for (let l = 0; l < a.length; l += 3)n.push(a.slice(l, l + 3)); return n } } function cP(i) { const e = i.length; e > 2 && i[e - 1].equals(i[0]) && i.pop() } function hP(i, e) { for (let t = 0; t < e.length; t++)i.push(e[t].x), i.push(e[t].y) } class xv extends yt { constructor(e = new Ah([new W(.5, .5), new W(-.5, .5), new W(-.5, -.5), new W(.5, -.5)]), t = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const s = this, r = [], n = []; for (let a = 0, l = e.length; a < l; a++) { const c = e[a]; o(c) } this.setAttribute("position", new et(r, 3)), this.setAttribute("uv", new et(n, 2)), this.computeVertexNormals(); function o(a) { const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 1; let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, f = t.bevelThickness !== void 0 ? t.bevelThickness : .2, g = t.bevelSize !== void 0 ? t.bevelSize : f - .1, m = t.bevelOffset !== void 0 ? t.bevelOffset : 0, v = t.bevelSegments !== void 0 ? t.bevelSegments : 3; const A = t.extrudePath, b = t.UVGenerator !== void 0 ? t.UVGenerator : CH; let y, _ = !1, w, E, P, C; A && (y = A.getSpacedPoints(h), _ = !0, p = !1, w = A.computeFrenetFrames(h, !1), E = new S, P = new S, C = new S), p || (v = 0, f = 0, g = 0, m = 0); const R = a.extractPoints(c); let T = R.shape; const z = R.holes; if (!va.isClockWise(T)) { T = T.reverse(); for (let de = 0, Ae = z.length; de < Ae; de++) { const pe = z[de]; va.isClockWise(pe) && (z[de] = pe.reverse()) } } const H = va.triangulateShape(T, z), N = T; for (let de = 0, Ae = z.length; de < Ae; de++) { const pe = z[de]; T = T.concat(pe) } function F(de, Ae, pe) { return Ae || console.error("THREE.ExtrudeGeometry: vec does not exist"), Ae.clone().multiplyScalar(pe).add(de) } const X = T.length, te = H.length; function re(de, Ae, pe) { let Fe, Re, ht; const me = de.x - Ae.x, ut = de.y - Ae.y, dt = pe.x - de.x, Pt = pe.y - de.y, ii = me * me + ut * ut, U = me * Pt - ut * dt; if (Math.abs(U) > Number.EPSILON) { const D = Math.sqrt(ii), le = Math.sqrt(dt * dt + Pt * Pt), Ie = Ae.x - ut / D, Be = Ae.y + me / D, Qe = pe.x - Pt / le, rt = pe.y + dt / le, j = ((Qe - Ie) * Pt - (rt - Be) * dt) / (me * Pt - ut * dt); Fe = Ie + me * j - de.x, Re = Be + ut * j - de.y; const J = Fe * Fe + Re * Re; if (J <= 2) return new W(Fe, Re); ht = Math.sqrt(J / 2) } else { let D = !1; me > Number.EPSILON ? dt > Number.EPSILON && (D = !0) : me < -Number.EPSILON ? dt < -Number.EPSILON && (D = !0) : Math.sign(ut) === Math.sign(Pt) && (D = !0), D ? (Fe = -ut, Re = me, ht = Math.sqrt(ii)) : (Fe = me, Re = ut, ht = Math.sqrt(ii / 2)) } return new W(Fe / ht, Re / ht) } const Z = []; for (let de = 0, Ae = N.length, pe = Ae - 1, Fe = de + 1; de < Ae; de++, pe++, Fe++)pe === Ae && (pe = 0), Fe === Ae && (Fe = 0), Z[de] = re(N[de], N[pe], N[Fe]); const fe = []; let ae, De = Z.concat(); for (let de = 0, Ae = z.length; de < Ae; de++) { const pe = z[de]; ae = []; for (let Fe = 0, Re = pe.length, ht = Re - 1, me = Fe + 1; Fe < Re; Fe++, ht++, me++)ht === Re && (ht = 0), me === Re && (me = 0), ae[Fe] = re(pe[Fe], pe[ht], pe[me]); fe.push(ae), De = De.concat(ae) } for (let de = 0; de < v; de++) { const Ae = de / v, pe = f * Math.cos(Ae * Math.PI / 2), Fe = g * Math.sin(Ae * Math.PI / 2) + m; for (let Re = 0, ht = N.length; Re < ht; Re++) { const me = F(N[Re], Z[Re], Fe); K(me.x, me.y, -pe) } for (let Re = 0, ht = z.length; Re < ht; Re++) { const me = z[Re]; ae = fe[Re]; for (let ut = 0, dt = me.length; ut < dt; ut++) { const Pt = F(me[ut], ae[ut], Fe); K(Pt.x, Pt.y, -pe) } } } const Se = g + m; for (let de = 0; de < X; de++) { const Ae = p ? F(T[de], De[de], Se) : T[de]; _ ? (P.copy(w.normals[0]).multiplyScalar(Ae.x), E.copy(w.binormals[0]).multiplyScalar(Ae.y), C.copy(y[0]).add(P).add(E), K(C.x, C.y, C.z)) : K(Ae.x, Ae.y, 0) } for (let de = 1; de <= h; de++)for (let Ae = 0; Ae < X; Ae++) { const pe = p ? F(T[Ae], De[Ae], Se) : T[Ae]; _ ? (P.copy(w.normals[de]).multiplyScalar(pe.x), E.copy(w.binormals[de]).multiplyScalar(pe.y), C.copy(y[de]).add(P).add(E), K(C.x, C.y, C.z)) : K(pe.x, pe.y, d / h * de) } for (let de = v - 1; de >= 0; de--) { const Ae = de / v, pe = f * Math.cos(Ae * Math.PI / 2), Fe = g * Math.sin(Ae * Math.PI / 2) + m; for (let Re = 0, ht = N.length; Re < ht; Re++) { const me = F(N[Re], Z[Re], Fe); K(me.x, me.y, d + pe) } for (let Re = 0, ht = z.length; Re < ht; Re++) { const me = z[Re]; ae = fe[Re]; for (let ut = 0, dt = me.length; ut < dt; ut++) { const Pt = F(me[ut], ae[ut], Fe); _ ? K(Pt.x, Pt.y + y[h - 1].y, y[h - 1].x + pe) : K(Pt.x, Pt.y, d + pe) } } } ie(), ce(); function ie() { const de = r.length / 3; if (p) { let Ae = 0, pe = X * Ae; for (let Fe = 0; Fe < te; Fe++) { const Re = H[Fe]; je(Re[2] + pe, Re[1] + pe, Re[0] + pe) } Ae = h + v * 2, pe = X * Ae; for (let Fe = 0; Fe < te; Fe++) { const Re = H[Fe]; je(Re[0] + pe, Re[1] + pe, Re[2] + pe) } } else { for (let Ae = 0; Ae < te; Ae++) { const pe = H[Ae]; je(pe[2], pe[1], pe[0]) } for (let Ae = 0; Ae < te; Ae++) { const pe = H[Ae]; je(pe[0] + X * h, pe[1] + X * h, pe[2] + X * h) } } s.addGroup(de, r.length / 3 - de, 0) } function ce() { const de = r.length / 3; let Ae = 0; Te(N, Ae), Ae += N.length; for (let pe = 0, Fe = z.length; pe < Fe; pe++) { const Re = z[pe]; Te(Re, Ae), Ae += Re.length } s.addGroup(de, r.length / 3 - de, 1) } function Te(de, Ae) { let pe = de.length; for (; --pe >= 0;) { const Fe = pe; let Re = pe - 1; Re < 0 && (Re = de.length - 1); for (let ht = 0, me = h + v * 2; ht < me; ht++) { const ut = X * ht, dt = X * (ht + 1), Pt = Ae + Fe + ut, ii = Ae + Re + ut, U = Ae + Re + dt, D = Ae + Fe + dt; Ue(Pt, ii, U, D) } } } function K(de, Ae, pe) { l.push(de), l.push(Ae), l.push(pe) } function je(de, Ae, pe) { Pe(de), Pe(Ae), Pe(pe); const Fe = r.length / 3, Re = b.generateTopUV(s, r, Fe - 3, Fe - 2, Fe - 1); ve(Re[0]), ve(Re[1]), ve(Re[2]) } function Ue(de, Ae, pe, Fe) { Pe(de), Pe(Ae), Pe(Fe), Pe(Ae), Pe(pe), Pe(Fe); const Re = r.length / 3, ht = b.generateSideWallUV(s, r, Re - 6, Re - 3, Re - 2, Re - 1); ve(ht[0]), ve(ht[1]), ve(ht[3]), ve(ht[1]), ve(ht[2]), ve(ht[3]) } function Pe(de) { r.push(l[de * 3 + 0]), r.push(l[de * 3 + 1]), r.push(l[de * 3 + 2]) } function ve(de) { n.push(de.x), n.push(de.y) } } } toJSON() { const e = super.toJSON(), t = this.parameters.shapes, s = this.parameters.options; return SH(t, s, e) } static fromJSON(e, t) { const s = []; for (let n = 0, o = e.shapes.length; n < o; n++) { const a = t[e.shapes[n]]; s.push(a) } const r = e.options.extrudePath; return r !== void 0 && (e.options.extrudePath = new kw[r.type]().fromJSON(r)), new xv(s, e.options) } } const CH = { generateTopUV: function (i, e, t, s, r) { const n = e[t * 3], o = e[t * 3 + 1], a = e[s * 3], l = e[s * 3 + 1], c = e[r * 3], h = e[r * 3 + 1]; return [new W(n, o), new W(a, l), new W(c, h)] }, generateSideWallUV: function (i, e, t, s, r, n) { const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[s * 3], h = e[s * 3 + 1], d = e[s * 3 + 2], p = e[r * 3], f = e[r * 3 + 1], g = e[r * 3 + 2], m = e[n * 3], v = e[n * 3 + 1], A = e[n * 3 + 2]; return Math.abs(a - h) < Math.abs(o - c) ? [new W(o, 1 - l), new W(c, 1 - d), new W(p, 1 - g), new W(m, 1 - A)] : [new W(a, 1 - l), new W(h, 1 - d), new W(f, 1 - g), new W(v, 1 - A)] } }; function SH(i, e, t) { if (t.shapes = [], Array.isArray(i)) for (let s = 0, r = i.length; s < r; s++) { const n = i[s]; t.shapes.push(n.uuid) } else t.shapes.push(i.uuid); return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t } class Jp extends Ml { constructor(e = 1, t = 0) { const s = (1 + Math.sqrt(5)) / 2, r = [-1, s, 0, 1, s, 0, -1, -s, 0, 1, -s, 0, 0, -1, s, 0, 1, s, 0, -1, -s, 0, 1, -s, s, 0, -1, s, 0, 1, -s, 0, -1, -s, 0, 1], n = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1]; super(r, n, e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Jp(e.radius, e.detail) } } class Aa extends Ml { constructor(e = 1, t = 0) { const s = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2]; super(s, r, e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Aa(e.radius, e.detail) } } class Kp extends yt { constructor(e = .5, t = 1, s = 8, r = 1, n = 0, o = Math.PI * 2) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: s, phiSegments: r, thetaStart: n, thetaLength: o }, s = Math.max(3, s), r = Math.max(1, r); const a = [], l = [], c = [], h = []; let d = e; const p = (t - e) / r, f = new S, g = new W; for (let m = 0; m <= r; m++) { for (let v = 0; v <= s; v++) { const A = n + v / s * o; f.x = d * Math.cos(A), f.y = d * Math.sin(A), l.push(f.x, f.y, f.z), c.push(0, 0, 1), g.x = (f.x / t + 1) / 2, g.y = (f.y / t + 1) / 2, h.push(g.x, g.y) } d += p } for (let m = 0; m < r; m++) { const v = m * (s + 1); for (let A = 0; A < s; A++) { const b = A + v, y = b, _ = b + s + 1, w = b + s + 2, E = b + 1; a.push(y, _, E), a.push(_, w, E) } } this.setIndex(a), this.setAttribute("position", new et(l, 3)), this.setAttribute("normal", new et(c, 3)), this.setAttribute("uv", new et(h, 2)) } static fromJSON(e) { return new Kp(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class wv extends yt { constructor(e = new Ah([new W(0, .5), new W(-.5, -.5), new W(.5, -.5)]), t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const s = [], r = [], n = [], o = []; let a = 0, l = 0; if (Array.isArray(e) === !1) c(e); else for (let h = 0; h < e.length; h++)c(e[h]), this.addGroup(a, l, h), a += l, l = 0; this.setIndex(s), this.setAttribute("position", new et(r, 3)), this.setAttribute("normal", new et(n, 3)), this.setAttribute("uv", new et(o, 2)); function c(h) { const d = r.length / 3, p = h.extractPoints(t); let f = p.shape; const g = p.holes; va.isClockWise(f) === !1 && (f = f.reverse()); for (let v = 0, A = g.length; v < A; v++) { const b = g[v]; va.isClockWise(b) === !0 && (g[v] = b.reverse()) } const m = va.triangulateShape(f, g); for (let v = 0, A = g.length; v < A; v++) { const b = g[v]; f = f.concat(b) } for (let v = 0, A = f.length; v < A; v++) { const b = f[v]; r.push(b.x, b.y, 0), n.push(0, 0, 1), o.push(b.x, b.y) } for (let v = 0, A = m.length; v < A; v++) { const b = m[v], y = b[0] + d, _ = b[1] + d, w = b[2] + d; s.push(y, _, w), l += 3 } } } toJSON() { const e = super.toJSON(), t = this.parameters.shapes; return EH(t, e) } static fromJSON(e, t) { const s = []; for (let r = 0, n = e.shapes.length; r < n; r++) { const o = t[e.shapes[r]]; s.push(o) } return new wv(s, e.curveSegments) } } function EH(i, e) { if (e.shapes = [], Array.isArray(i)) for (let t = 0, s = i.length; t < s; t++) { const r = i[t]; e.shapes.push(r.uuid) } else e.shapes.push(i.uuid); return e } class Zn extends yt { constructor(e = 1, t = 32, s = 16, r = 0, n = Math.PI * 2, o = 0, a = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: s, phiStart: r, phiLength: n, thetaStart: o, thetaLength: a }, t = Math.max(3, Math.floor(t)), s = Math.max(2, Math.floor(s)); const l = Math.min(o + a, Math.PI); let c = 0; const h = [], d = new S, p = new S, f = [], g = [], m = [], v = []; for (let A = 0; A <= s; A++) { const b = [], y = A / s; let _ = 0; A == 0 && o == 0 ? _ = .5 / t : A == s && l == Math.PI && (_ = -.5 / t); for (let w = 0; w <= t; w++) { const E = w / t; d.x = -e * Math.cos(r + E * n) * Math.sin(o + y * a), d.y = e * Math.cos(o + y * a), d.z = e * Math.sin(r + E * n) * Math.sin(o + y * a), g.push(d.x, d.y, d.z), p.copy(d).normalize(), m.push(p.x, p.y, p.z), v.push(E + _, 1 - y), b.push(c++) } h.push(b) } for (let A = 0; A < s; A++)for (let b = 0; b < t; b++) { const y = h[A][b + 1], _ = h[A][b], w = h[A + 1][b], E = h[A + 1][b + 1]; (A !== 0 || o > 0) && f.push(y, _, E), (A !== s - 1 || l < Math.PI) && f.push(_, w, E) } this.setIndex(f), this.setAttribute("position", new et(g, 3)), this.setAttribute("normal", new et(m, 3)), this.setAttribute("uv", new et(v, 2)) } static fromJSON(e) { return new Zn(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class Cv extends Ml { constructor(e = 1, t = 0) { const s = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]; super(s, r, e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Cv(e.radius, e.detail) } } class ya extends yt { constructor(e = 1, t = .4, s = 8, r = 6, n = Math.PI * 2) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: s, tubularSegments: r, arc: n }, s = Math.floor(s), r = Math.floor(r); const o = [], a = [], l = [], c = [], h = new S, d = new S, p = new S; for (let f = 0; f <= s; f++)for (let g = 0; g <= r; g++) { const m = g / r * n, v = f / s * Math.PI * 2; d.x = (e + t * Math.cos(v)) * Math.cos(m), d.y = (e + t * Math.cos(v)) * Math.sin(m), d.z = t * Math.sin(v), a.push(d.x, d.y, d.z), h.x = e * Math.cos(m), h.y = e * Math.sin(m), p.subVectors(d, h).normalize(), l.push(p.x, p.y, p.z), c.push(g / r), c.push(f / s) } for (let f = 1; f <= s; f++)for (let g = 1; g <= r; g++) { const m = (r + 1) * f + g - 1, v = (r + 1) * (f - 1) + g - 1, A = (r + 1) * (f - 1) + g, b = (r + 1) * f + g; o.push(m, v, b), o.push(v, A, b) } this.setIndex(o), this.setAttribute("position", new et(a, 3)), this.setAttribute("normal", new et(l, 3)), this.setAttribute("uv", new et(c, 2)) } static fromJSON(e) { return new ya(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class Sv extends yt { constructor(e = 1, t = .4, s = 64, r = 8, n = 2, o = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: s, radialSegments: r, p: n, q: o }, s = Math.floor(s), r = Math.floor(r); const a = [], l = [], c = [], h = [], d = new S, p = new S, f = new S, g = new S, m = new S, v = new S, A = new S; for (let y = 0; y <= s; ++y) { const _ = y / s * n * Math.PI * 2; b(_, n, o, e, f), b(_ + .01, n, o, e, g), v.subVectors(g, f), A.addVectors(g, f), m.crossVectors(v, A), A.crossVectors(m, v), m.normalize(), A.normalize(); for (let w = 0; w <= r; ++w) { const E = w / r * Math.PI * 2, P = -t * Math.cos(E), C = t * Math.sin(E); d.x = f.x + (P * A.x + C * m.x), d.y = f.y + (P * A.y + C * m.y), d.z = f.z + (P * A.z + C * m.z), l.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), c.push(p.x, p.y, p.z), h.push(y / s), h.push(w / r) } } for (let y = 1; y <= s; y++)for (let _ = 1; _ <= r; _++) { const w = (r + 1) * (y - 1) + (_ - 1), E = (r + 1) * y + (_ - 1), P = (r + 1) * y + _, C = (r + 1) * (y - 1) + _; a.push(w, E, C), a.push(E, P, C) } this.setIndex(a), this.setAttribute("position", new et(l, 3)), this.setAttribute("normal", new et(c, 3)), this.setAttribute("uv", new et(h, 2)); function b(y, _, w, E, P) { const C = Math.cos(y), R = Math.sin(y), T = w / _ * y, z = Math.cos(T); P.x = E * (2 + z) * .5 * C, P.y = E * (2 + z) * R * .5, P.z = E * Math.sin(T) * .5 } } static fromJSON(e) { return new Sv(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class Ev extends yt { constructor(e = new Pw(new S(-1, -1, 0), new S(-1, 1, 0), new S(1, 1, 0)), t = 64, s = 1, r = 8, n = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: s, radialSegments: r, closed: n }; const o = e.computeFrenetFrames(t, n); this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals; const a = new S, l = new S, c = new W; let h = new S; const d = [], p = [], f = [], g = []; m(), this.setIndex(g), this.setAttribute("position", new et(d, 3)), this.setAttribute("normal", new et(p, 3)), this.setAttribute("uv", new et(f, 2)); function m() { for (let y = 0; y < t; y++)v(y); v(n === !1 ? t : 0), b(), A() } function v(y) { h = e.getPointAt(y / t, h); const _ = o.normals[y], w = o.binormals[y]; for (let E = 0; E <= r; E++) { const P = E / r * Math.PI * 2, C = Math.sin(P), R = -Math.cos(P); l.x = R * _.x + C * w.x, l.y = R * _.y + C * w.y, l.z = R * _.z + C * w.z, l.normalize(), p.push(l.x, l.y, l.z), a.x = h.x + s * l.x, a.y = h.y + s * l.y, a.z = h.z + s * l.z, d.push(a.x, a.y, a.z) } } function A() { for (let y = 1; y <= t; y++)for (let _ = 1; _ <= r; _++) { const w = (r + 1) * (y - 1) + (_ - 1), E = (r + 1) * y + (_ - 1), P = (r + 1) * y + _, C = (r + 1) * (y - 1) + _; g.push(w, E, C), g.push(E, P, C) } } function b() { for (let y = 0; y <= t; y++)for (let _ = 0; _ <= r; _++)c.x = y / t, c.y = _ / r, f.push(c.x, c.y) } } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new Ev(new kw[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class uP extends yt { constructor(e = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) { const t = [], s = new Set, r = new S, n = new S; if (e.index !== null) { const o = e.attributes.position, a = e.index; let l = e.groups; l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]); for (let c = 0, h = l.length; c < h; ++c) { const d = l[c], p = d.start, f = d.count; for (let g = p, m = p + f; g < m; g += 3)for (let v = 0; v < 3; v++) { const A = a.getX(g + v), b = a.getX(g + (v + 1) % 3); r.fromBufferAttribute(o, A), n.fromBufferAttribute(o, b), dP(r, n, s) === !0 && (t.push(r.x, r.y, r.z), t.push(n.x, n.y, n.z)) } } } else { const o = e.attributes.position; for (let a = 0, l = o.count / 3; a < l; a++)for (let c = 0; c < 3; c++) { const h = 3 * a + c, d = 3 * a + (c + 1) % 3; r.fromBufferAttribute(o, h), n.fromBufferAttribute(o, d), dP(r, n, s) === !0 && (t.push(r.x, r.y, r.z), t.push(n.x, n.y, n.z)) } } this.setAttribute("position", new et(t, 3)) } } } function dP(i, e, t) { const s = `${i.x},${i.y},${i.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${i.x},${i.y},${i.z}`; return t.has(s) === !0 || t.has(r) === !0 ? !1 : (t.add(s), t.add(r), !0) } var pP = Object.freeze({ __proto__: null, BoxGeometry: pi, CapsuleGeometry: Av, CircleGeometry: yv, ConeGeometry: bv, CylinderGeometry: ji, DodecahedronGeometry: _v, EdgesGeometry: Ow, ExtrudeGeometry: xv, IcosahedronGeometry: Jp, LatheGeometry: Yp, OctahedronGeometry: Aa, PlaneGeometry: ks, PolyhedronGeometry: Ml, RingGeometry: Kp, ShapeGeometry: wv, SphereGeometry: Zn, TetrahedronGeometry: Cv, TorusGeometry: ya, TorusKnotGeometry: Sv, TubeGeometry: Ev, WireframeGeometry: uP }); class Uw extends Tt { constructor(e) { super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new xe(0), this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this } } class Nw extends Vt { constructor(e) { super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class od extends Tt { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new xe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ul, this.normalScale = new W(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class Bo extends od { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new W(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return Gi(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (t) { this.ior = (1 + .4 * t) / (1 - .4 * t) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new xe(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new xe(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new xe(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e) } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class fP extends Tt { constructor(e) { super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new xe(16777215), this.specular = new xe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ul, this.normalScale = new W(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = hf, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class gP extends Tt { constructor(e) { super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new xe(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ul, this.normalScale = new W(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } class zw extends Tt { constructor(e) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ul, this.normalScale = new W(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class mP extends Tt { constructor(e) { super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new xe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ul, this.normalScale = new W(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = hf, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class vP extends Tt { constructor(e) { super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new xe(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ul, this.normalScale = new W(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this } } class AP extends Hi { constructor(e) { super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } function Sn(i, e, t) { return jw(i) ? new i.constructor(i.subarray(e, t !== void 0 ? t : i.length)) : i.slice(e, t) } function bh(i, e, t) { return !i || !t && i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i) } function jw(i) { return ArrayBuffer.isView(i) && !(i instanceof DataView) } function yP(i) { function e(r, n) { return i[r] - i[n] } const t = i.length, s = new Array(t); for (let r = 0; r !== t; ++r)s[r] = r; return s.sort(e), s } function Qw(i, e, t) { const s = i.length, r = new i.constructor(s); for (let n = 0, o = 0; o !== s; ++n) { const a = t[n] * e; for (let l = 0; l !== e; ++l)r[o++] = i[a + l] } return r } function Gw(i, e, t, s) { let r = 1, n = i[0]; for (; n !== void 0 && n[s] === void 0;)n = i[r++]; if (n === void 0) return; let o = n[s]; if (o !== void 0) if (Array.isArray(o)) do o = n[s], o !== void 0 && (e.push(n.time), t.push.apply(t, o)), n = i[r++]; while (n !== void 0); else if (o.toArray !== void 0) do o = n[s], o !== void 0 && (e.push(n.time), o.toArray(t, t.length)), n = i[r++]; while (n !== void 0); else do o = n[s], o !== void 0 && (e.push(n.time), t.push(o)), n = i[r++]; while (n !== void 0) } function MH(i, e, t, s, r = 30) { const n = i.clone(); n.name = e; const o = []; for (let l = 0; l < n.tracks.length; ++l) { const c = n.tracks[l], h = c.getValueSize(), d = [], p = []; for (let f = 0; f < c.times.length; ++f) { const g = c.times[f] * r; if (!(g < t || g >= s)) { d.push(c.times[f]); for (let m = 0; m < h; ++m)p.push(c.values[f * h + m]) } } d.length !== 0 && (c.times = bh(d, c.times.constructor), c.values = bh(p, c.values.constructor), o.push(c)) } n.tracks = o; let a = 1 / 0; for (let l = 0; l < n.tracks.length; ++l)a > n.tracks[l].times[0] && (a = n.tracks[l].times[0]); for (let l = 0; l < n.tracks.length; ++l)n.tracks[l].shift(-1 * a); return n.resetDuration(), n } function IH(i, e = 0, t = i, s = 30) { s <= 0 && (s = 30); const r = t.tracks.length, n = e / s; for (let o = 0; o < r; ++o) { const a = t.tracks[o], l = a.ValueTypeName; if (l === "bool" || l === "string") continue; const c = i.tracks.find(function (A) { return A.name === a.name && A.ValueTypeName === l }); if (c === void 0) continue; let h = 0; const d = a.getValueSize(); a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = d / 3); let p = 0; const f = c.getValueSize(); c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = f / 3); const g = a.times.length - 1; let m; if (n <= a.times[0]) { const A = h, b = d - h; m = Sn(a.values, A, b) } else if (n >= a.times[g]) { const A = g * d + h, b = A + d - h; m = Sn(a.values, A, b) } else { const A = a.createInterpolant(), b = h, y = d - h; A.evaluate(n), m = Sn(A.resultBuffer, b, y) } l === "quaternion" && new we().fromArray(m).normalize().conjugate().toArray(m); const v = c.times.length; for (let A = 0; A < v; ++A) { const b = A * f + p; if (l === "quaternion") we.multiplyQuaternionsFlat(c.values, b, m, 0, c.values, b); else { const y = f - p * 2; for (let _ = 0; _ < y; ++_)c.values[b + _] -= m[_] } } } return i.blendMode = Rx, i } var TH = Object.freeze({ __proto__: null, arraySlice: Sn, convertArray: bh, isTypedArray: jw, getKeyframeOrder: yP, sortedArray: Qw, flattenJSON: Gw, subclip: MH, makeClipAdditive: IH }); class ad { constructor(e, t, s, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(s), this.sampleValues = t, this.valueSize = s, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let s = this._cachedIndex, r = t[s], n = t[s - 1]; e: { t: { let o; i: { s: if (!(e < r)) { for (let a = s + 2; ;) { if (r === void 0) { if (e < n) break s; return s = t.length, this._cachedIndex = s, this.copySampleValue_(s - 1) } if (s === a) break; if (n = r, r = t[++s], e < r) break t } o = t.length; break i } if (!(e >= n)) { const a = t[1]; e < a && (s = 2, n = a); for (let l = s - 2; ;) { if (n === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (s === l) break; if (r = n, n = t[--s - 1], e >= n) break t } o = s, s = 0; break i } break e } for (; s < o;) { const a = s + o >>> 1; e < t[a] ? o = a : s = a + 1 } if (r = t[s], n = t[s - 1], n === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (r === void 0) return s = t.length, this._cachedIndex = s, this.copySampleValue_(s - 1) } this._cachedIndex = s, this.intervalChanged_(s, n, r) } return this.interpolate_(s, n, e, r) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, s = this.sampleValues, r = this.valueSize, n = e * r; for (let o = 0; o !== r; ++o)t[o] = s[n + o]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class bP extends ad { constructor(e, t, s, r) { super(e, t, s, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: lh, endingEnd: lh } } intervalChanged_(e, t, s) { const r = this.parameterPositions; let n = e - 2, o = e + 1, a = r[n], l = r[o]; if (a === void 0) switch (this.getSettings_().endingStart) { case ch: n = e, a = 2 * t - s; break; case mf: n = r.length - 2, a = t + r[n] - r[n + 1]; break; default: n = e, a = s }if (l === void 0) switch (this.getSettings_().endingEnd) { case ch: o = e, l = 2 * s - t; break; case mf: o = 1, l = s + r[1] - r[0]; break; default: o = e - 1, l = t }const c = (s - t) * .5, h = this.valueSize; this._weightPrev = c / (t - a), this._weightNext = c / (l - s), this._offsetPrev = n * h, this._offsetNext = o * h } interpolate_(e, t, s, r) { const n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, h = this._offsetPrev, d = this._offsetNext, p = this._weightPrev, f = this._weightNext, g = (s - t) / (r - t), m = g * g, v = m * g, A = -p * v + 2 * p * m - p * g, b = (1 + p) * v + (-1.5 - 2 * p) * m + (-.5 + p) * g + 1, y = (-1 - f) * v + (1.5 + f) * m + .5 * g, _ = f * v - f * m; for (let w = 0; w !== a; ++w)n[w] = A * o[h + w] + b * o[c + w] + y * o[l + w] + _ * o[d + w]; return n } } class Hw extends ad { constructor(e, t, s, r) { super(e, t, s, r) } interpolate_(e, t, s, r) { const n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, h = (s - t) / (r - t), d = 1 - h; for (let p = 0; p !== a; ++p)n[p] = o[c + p] * d + o[l + p] * h; return n } } class _P extends ad { constructor(e, t, s, r) { super(e, t, s, r) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class rn { constructor(e, t, s, r) { if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = bh(t, this.TimeBufferType), this.values = bh(s, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let s; if (t.toJSON !== this.toJSON) s = t.toJSON(e); else { s = { name: e.name, times: bh(e.times, Array), values: bh(e.values, Array) }; const r = e.getInterpolation(); r !== e.DefaultInterpolation && (s.interpolation = r) } return s.type = e.ValueTypeName, s } InterpolantFactoryMethodDiscrete(e) { return new _P(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new Hw(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new bP(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case ah: t = this.InterpolantFactoryMethodDiscrete; break; case Pa: t = this.InterpolantFactoryMethodLinear; break; case Kv: t = this.InterpolantFactoryMethodSmooth; break }if (t === void 0) { const s = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(s); return console.warn("THREE.KeyframeTrack:", s), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return ah; case this.InterpolantFactoryMethodLinear: return Pa; case this.InterpolantFactoryMethodSmooth: return Kv } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (e !== 0) { const t = this.times; for (let s = 0, r = t.length; s !== r; ++s)t[s] += e } return this } scale(e) { if (e !== 1) { const t = this.times; for (let s = 0, r = t.length; s !== r; ++s)t[s] *= e } return this } trim(e, t) { const s = this.times, r = s.length; let n = 0, o = r - 1; for (; n !== r && s[n] < e;)++n; for (; o !== -1 && s[o] > t;)--o; if (++o, n !== 0 || o !== r) { n >= o && (o = Math.max(o, 1), n = o - 1); const a = this.getValueSize(); this.times = Sn(s, n, o), this.values = Sn(this.values, n * a, o * a) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const s = this.times, r = this.values, n = s.length; n === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let o = null; for (let a = 0; a !== n; a++) { const l = s[a]; if (typeof l == "number" && isNaN(l)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1; break } if (o !== null && o > l) { console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1; break } o = l } if (r !== void 0 && jw(r)) for (let a = 0, l = r.length; a !== l; ++a) { const c = r[a]; if (isNaN(c)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1; break } } return e } optimize() { const e = Sn(this.times), t = Sn(this.values), s = this.getValueSize(), r = this.getInterpolation() === Kv, n = e.length - 1; let o = 1; for (let a = 1; a < n; ++a) { let l = !1; const c = e[a], h = e[a + 1]; if (c !== h && (a !== 1 || c !== e[0])) if (r) l = !0; else { const d = a * s, p = d - s, f = d + s; for (let g = 0; g !== s; ++g) { const m = t[d + g]; if (m !== t[p + g] || m !== t[f + g]) { l = !0; break } } } if (l) { if (a !== o) { e[o] = e[a]; const d = a * s, p = o * s; for (let f = 0; f !== s; ++f)t[p + f] = t[d + f] } ++o } } if (n > 0) { e[o] = e[n]; for (let a = n * s, l = o * s, c = 0; c !== s; ++c)t[l + c] = t[a + c]; ++o } return o !== e.length ? (this.times = Sn(e, 0, o), this.values = Sn(t, 0, o * s)) : (this.times = e, this.values = t), this } clone() { const e = Sn(this.times, 0), t = Sn(this.values, 0), s = this.constructor, r = new s(this.name, e, t); return r.createInterpolant = this.createInterpolant, r } } rn.prototype.TimeBufferType = Float32Array, rn.prototype.ValueBufferType = Float32Array, rn.prototype.DefaultInterpolation = Pa; class _h extends rn { } _h.prototype.ValueTypeName = "bool", _h.prototype.ValueBufferType = Array, _h.prototype.DefaultInterpolation = ah, _h.prototype.InterpolantFactoryMethodLinear = void 0, _h.prototype.InterpolantFactoryMethodSmooth = void 0; class Qf extends rn { } Qf.prototype.ValueTypeName = "color"; class ql extends rn { } ql.prototype.ValueTypeName = "number"; class xP extends ad { constructor(e, t, s, r) { super(e, t, s, r) } interpolate_(e, t, s, r) { const n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (s - t) / (r - t); let c = e * a; for (let h = c + a; c !== h; c += 4)we.slerpFlat(n, 0, o, c - a, o, c, l); return n } } class ko extends rn { InterpolantFactoryMethodLinear(e) { return new xP(this.times, this.values, this.getValueSize(), e) } } ko.prototype.ValueTypeName = "quaternion", ko.prototype.DefaultInterpolation = Pa, ko.prototype.InterpolantFactoryMethodSmooth = void 0; class xh extends rn { } xh.prototype.ValueTypeName = "string", xh.prototype.ValueBufferType = Array, xh.prototype.DefaultInterpolation = ah, xh.prototype.InterpolantFactoryMethodLinear = void 0, xh.prototype.InterpolantFactoryMethodSmooth = void 0; class Xl extends rn { } Xl.prototype.ValueTypeName = "vector"; class En { constructor(e, t = -1, s, r = Zv) { this.name = e, this.tracks = s, this.duration = t, this.blendMode = r, this.uuid = Kr(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], s = e.tracks, r = 1 / (e.fps || 1); for (let o = 0, a = s.length; o !== a; ++o)t.push(PH(s[o]).scale(r)); const n = new this(e.name, e.duration, t, e.blendMode); return n.uuid = e.uuid, n } static toJSON(e) { const t = [], s = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let n = 0, o = s.length; n !== o; ++n)t.push(rn.toJSON(s[n])); return r } static CreateFromMorphTargetSequence(e, t, s, r) { const n = t.length, o = []; for (let a = 0; a < n; a++) { let l = [], c = []; l.push((a + n - 1) % n, a, (a + 1) % n), c.push(0, 1, 0); const h = yP(l); l = Qw(l, 1, h), c = Qw(c, 1, h), !r && l[0] === 0 && (l.push(n), c.push(c[0])), o.push(new ql(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / s)) } return new this(e, -1, o) } static findByName(e, t) { let s = e; if (!Array.isArray(e)) { const r = e; s = r.geometry && r.geometry.animations || r.animations } for (let r = 0; r < s.length; r++)if (s[r].name === t) return s[r]; return null } static CreateClipsFromMorphTargetSequences(e, t, s) { const r = {}, n = /^([\w-]*?)([\d]+)$/; for (let a = 0, l = e.length; a < l; a++) { const c = e[a], h = c.name.match(n); if (h && h.length > 1) { const d = h[1]; let p = r[d]; p || (r[d] = p = []), p.push(c) } } const o = []; for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, s)); return o } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const s = function (h, d, p, f, g) { if (p.length !== 0) { const m = [], v = []; Gw(p, m, v, f), m.length !== 0 && g.push(new h(d, m, v)) } }, r = [], n = e.name || "default", o = e.fps || 30, a = e.blendMode; let l = e.length || -1; const c = e.hierarchy || []; for (let h = 0; h < c.length; h++) { const d = c[h].keys; if (!(!d || d.length === 0)) if (d[0].morphTargets) { const p = {}; let f; for (f = 0; f < d.length; f++)if (d[f].morphTargets) for (let g = 0; g < d[f].morphTargets.length; g++)p[d[f].morphTargets[g]] = -1; for (const g in p) { const m = [], v = []; for (let A = 0; A !== d[f].morphTargets.length; ++A) { const b = d[f]; m.push(b.time), v.push(b.morphTarget === g ? 1 : 0) } r.push(new ql(".morphTargetInfluence[" + g + "]", m, v)) } l = p.length * o } else { const p = ".bones[" + t[h].name + "]"; s(Xl, p + ".position", d, "pos", r), s(ko, p + ".quaternion", d, "rot", r), s(Xl, p + ".scale", d, "scl", r) } } return r.length === 0 ? null : new this(n, l, r, a) } resetDuration() { const e = this.tracks; let t = 0; for (let s = 0, r = e.length; s !== r; ++s) { const n = this.tracks[s]; t = Math.max(t, n.times[n.times.length - 1]) } return this.duration = t, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function RH(i) { switch (i.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return ql; case "vector": case "vector2": case "vector3": case "vector4": return Xl; case "color": return Qf; case "quaternion": return ko; case "bool": case "boolean": return _h; case "string": return xh }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i) } function PH(i) { if (i.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = RH(i.type); if (i.times === void 0) { const t = [], s = []; Gw(i.keys, t, s, "value"), i.times = t, i.values = s } return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation) } const wh = { enabled: !1, files: {}, add: function (i, e) { this.enabled !== !1 && (this.files[i] = e) }, get: function (i) { if (this.enabled !== !1) return this.files[i] }, remove: function (i) { delete this.files[i] }, clear: function () { this.files = {} } }; class XA { constructor(e, t, s) { const r = this; let n = !1, o = 0, a = 0, l; const c = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = s, this.itemStart = function (h) { a++, n === !1 && r.onStart !== void 0 && r.onStart(h, o, a), n = !0 }, this.itemEnd = function (h) { o++, r.onProgress !== void 0 && r.onProgress(h, o, a), o === a && (n = !1, r.onLoad !== void 0 && r.onLoad()) }, this.itemError = function (h) { r.onError !== void 0 && r.onError(h) }, this.resolveURL = function (h) { return l ? l(h) : h }, this.setURLModifier = function (h) { return l = h, this }, this.addHandler = function (h, d) { return c.push(h, d), this }, this.removeHandler = function (h) { const d = c.indexOf(h); return d !== -1 && c.splice(d, 2), this }, this.getHandler = function (h) { for (let d = 0, p = c.length; d < p; d += 2) { const f = c[d], g = c[d + 1]; if (f.global && (f.lastIndex = 0), f.test(h)) return g } return null } } } const wP = new XA; class tr { constructor(e) { this.manager = e !== void 0 ? e : wP, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const s = this; return new Promise(function (r, n) { s.load(e, r, t, n) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } const za = {}; class BH extends Error { constructor(e, t) { super(e), this.response = t } } class bs extends tr { constructor(e) { super(e) } load(e, t, s, r) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const n = wh.get(e); if (n !== void 0) return this.manager.itemStart(e), setTimeout(() => { t && t(n), this.manager.itemEnd(e) }, 0), n; if (za[e] !== void 0) { za[e].push({ onLoad: t, onProgress: s, onError: r }); return } za[e] = [], za[e].push({ onLoad: t, onProgress: s, onError: r }); const o = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, l = this.responseType; fetch(o).then(c => { if (c.status === 200 || c.status === 0) { if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c; const h = za[e], d = c.body.getReader(), p = c.headers.get("Content-Length") || c.headers.get("X-File-Size"), f = p ? parseInt(p) : 0, g = f !== 0; let m = 0; const v = new ReadableStream({ start(A) { b(); function b() { d.read().then(({ done: y, value: _ }) => { if (y) A.close(); else { m += _.byteLength; const w = new ProgressEvent("progress", { lengthComputable: g, loaded: m, total: f }); for (let E = 0, P = h.length; E < P; E++) { const C = h[E]; C.onProgress && C.onProgress(w) } A.enqueue(_), b() } }) } } }); return new Response(v) } else throw new BH(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c) }).then(c => { switch (l) { case "arraybuffer": return c.arrayBuffer(); case "blob": return c.blob(); case "document": return c.text().then(h => new DOMParser().parseFromString(h, a)); case "json": return c.json(); default: if (a === void 0) return c.text(); { const h = /charset="?([^;"\s]*)"?/i.exec(a), d = h && h[1] ? h[1].toLowerCase() : void 0, p = new TextDecoder(d); return c.arrayBuffer().then(f => p.decode(f)) } } }).then(c => { wh.add(e, c); const h = za[e]; delete za[e]; for (let d = 0, p = h.length; d < p; d++) { const f = h[d]; f.onLoad && f.onLoad(c) } }).catch(c => { const h = za[e]; if (h === void 0) throw this.manager.itemError(e), c; delete za[e]; for (let d = 0, p = h.length; d < p; d++) { const f = h[d]; f.onError && f.onError(c) } this.manager.itemError(e) }).finally(() => { this.manager.itemEnd(e) }), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class kH extends tr { constructor(e) { super(e) } load(e, t, s, r) { const n = this, o = new bs(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) { try { t(n.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), n.manager.itemError(e) } }, s, r) } parse(e) { const t = []; for (let s = 0; s < e.length; s++) { const r = En.parse(e[s]); t.push(r) } return t } } class DH extends tr { constructor(e) { super(e) } load(e, t, s, r) { const n = this, o = [], a = new Na, l = new bs(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(n.withCredentials); let c = 0; function h(d) { l.load(e[d], function (p) { const f = n.parse(p, !0); o[d] = { width: f.width, height: f.height, format: f.format, mipmaps: f.mipmaps }, c += 1, c === 6 && (f.mipmapCount === 1 && (a.minFilter = Qt), a.image = o, a.format = f.format, a.needsUpdate = !0, t && t(a)) }, s, r) } if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d)h(d); else l.load(e, function (d) { const p = n.parse(d, !0); if (p.isCubemap) { const f = p.mipmaps.length / p.mipmapCount; for (let g = 0; g < f; g++) { o[g] = { mipmaps: [] }; for (let m = 0; m < p.mipmapCount; m++)o[g].mipmaps.push(p.mipmaps[g * p.mipmapCount + m]), o[g].format = p.format, o[g].width = p.width, o[g].height = p.height } a.image = o } else a.image.width = p.width, a.image.height = p.height, a.mipmaps = p.mipmaps; p.mipmapCount === 1 && (a.minFilter = Qt), a.format = p.format, a.needsUpdate = !0, t && t(a) }, s, r); return a } } class Gf extends tr { constructor(e) { super(e) } load(e, t, s, r) { this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const n = this, o = wh.get(e); if (o !== void 0) return n.manager.itemStart(e), setTimeout(function () { t && t(o), n.manager.itemEnd(e) }, 0), o; const a = _f("img"); function l() { h(), wh.add(e, this), t && t(this), n.manager.itemEnd(e) } function c(d) { h(), r && r(d), n.manager.itemError(e), n.manager.itemEnd(e) } function h() { a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1) } return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), n.manager.itemStart(e), a.src = e, a } } class OH extends tr { constructor(e) { super(e) } load(e, t, s, r) { const n = new If, o = new Gf(this.manager); o.setCrossOrigin(this.crossOrigin), o.setPath(this.path); let a = 0; function l(c) { o.load(e[c], function (h) { n.images[c] = h, a++, a === 6 && (n.needsUpdate = !0, t && t(n)) }, void 0, r) } for (let c = 0; c < e.length; ++c)l(c); return n } } class Vw extends tr { constructor(e) { super(e) } load(e, t, s, r) { const n = this, o = new no, a = new bs(this.manager); return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(n.withCredentials), a.load(e, function (l) { const c = n.parse(l); c && (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : Ss, o.wrapT = c.wrapT !== void 0 ? c.wrapT : Ss, o.magFilter = c.magFilter !== void 0 ? c.magFilter : Qt, o.minFilter = c.minFilter !== void 0 ? c.minFilter : Qt, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.encoding !== void 0 && (o.encoding = c.encoding), c.flipY !== void 0 && (o.flipY = c.flipY), c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = eo), c.mipmapCount === 1 && (o.minFilter = Qt), c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps), o.needsUpdate = !0, t && t(o, c)) }, s, r), o } } class Yl extends tr { constructor(e) { super(e) } load(e, t, s, r) { const n = new Nt, o = new Gf(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function (a) { n.image = a, n.needsUpdate = !0, t !== void 0 && t(n) }, s, r), n } } let Jl = class extends Me { constructor(i, e = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new xe(i), this.intensity = e } dispose() { } copy(i, e) { return super.copy(i, e), this.color.copy(i.color), this.intensity = i.intensity, this } toJSON(i) { const e = super.toJSON(i); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e } }; class Ww extends Jl { constructor(e, t, s) { super(e, s), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Me.DefaultUp), this.updateMatrix(), this.groundColor = new xe(t) } copy(e, t) { return super.copy(e, t), this.groundColor.copy(e.groundColor), this } } const qw = new He, CP = new S, SP = new S; class Xw { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new W(512, 512), this.map = null, this.mapPass = null, this.matrix = new He, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new xA, this._frameExtents = new W(1, 1), this._viewportCount = 1, this._viewports = [new st(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, s = this.matrix; CP.setFromMatrixPosition(e.matrixWorld), t.position.copy(CP), SP.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(SP), t.updateMatrixWorld(), qw.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(qw), s.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), s.multiply(qw) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return new this.constructor().copy(this) } toJSON() { const e = {}; return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class LH extends Xw { constructor() { super(new Xt(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(e) { const t = this.camera, s = ku * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, n = e.distance || t.far; (s !== t.fov || r !== t.aspect || n !== t.far) && (t.fov = s, t.aspect = r, t.far = n, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class YA extends Jl { constructor(e, t, s = 0, r = Math.PI / 3, n = 0, o = 2) { super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Me.DefaultUp), this.updateMatrix(), this.target = new Me, this.distance = s, this.angle = r, this.penumbra = n, this.decay = o, this.map = null, this.shadow = new LH } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const EP = new He, Hf = new S, Yw = new S; class FH extends Xw { constructor() { super(new Xt(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new W(4, 2), this._viewportCount = 6, this._viewports = [new st(2, 1, 1, 1), new st(0, 1, 1, 1), new st(3, 1, 1, 1), new st(1, 1, 1, 1), new st(3, 0, 1, 1), new st(1, 0, 1, 1)], this._cubeDirections = [new S(1, 0, 0), new S(-1, 0, 0), new S(0, 0, 1), new S(0, 0, -1), new S(0, 1, 0), new S(0, -1, 0)], this._cubeUps = [new S(0, 1, 0), new S(0, 1, 0), new S(0, 1, 0), new S(0, 1, 0), new S(0, 0, 1), new S(0, 0, -1)] } updateMatrices(e, t = 0) { const s = this.camera, r = this.matrix, n = e.distance || s.far; n !== s.far && (s.far = n, s.updateProjectionMatrix()), Hf.setFromMatrixPosition(e.matrixWorld), s.position.copy(Hf), Yw.copy(s.position), Yw.add(this._cubeDirections[t]), s.up.copy(this._cubeUps[t]), s.lookAt(Yw), s.updateMatrixWorld(), r.makeTranslation(-Hf.x, -Hf.y, -Hf.z), EP.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), this._frustum.setFromProjectionMatrix(EP) } } class JA extends Jl { constructor(e, t, s = 0, r = 2) { super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = s, this.decay = r, this.shadow = new FH } get power() { return this.intensity * 4 * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class UH extends Xw { constructor() { super(new Yu(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class KA extends Jl { constructor(e, t) { super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Me.DefaultUp), this.updateMatrix(), this.target = new Me, this.shadow = new UH } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class Jw extends Jl { constructor(e, t) { super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight" } } class MP extends Jl { constructor(e, t, s = 10, r = 10) { super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = s, this.height = r } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } class ld { constructor() { this.isSphericalHarmonics3 = !0, this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new S) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const s = e.x, r = e.y, n = e.z, o = this.coefficients; return t.copy(o[0]).multiplyScalar(.282095), t.addScaledVector(o[1], .488603 * r), t.addScaledVector(o[2], .488603 * n), t.addScaledVector(o[3], .488603 * s), t.addScaledVector(o[4], 1.092548 * (s * r)), t.addScaledVector(o[5], 1.092548 * (r * n)), t.addScaledVector(o[6], .315392 * (3 * n * n - 1)), t.addScaledVector(o[7], 1.092548 * (s * n)), t.addScaledVector(o[8], .546274 * (s * s - r * r)), t } getIrradianceAt(e, t) { const s = e.x, r = e.y, n = e.z, o = this.coefficients; return t.copy(o[0]).multiplyScalar(.886227), t.addScaledVector(o[1], 2 * .511664 * r), t.addScaledVector(o[2], 2 * .511664 * n), t.addScaledVector(o[3], 2 * .511664 * s), t.addScaledVector(o[4], 2 * .429043 * s * r), t.addScaledVector(o[5], 2 * .429043 * r * n), t.addScaledVector(o[6], .743125 * n * n - .247708), t.addScaledVector(o[7], 2 * .429043 * s * n), t.addScaledVector(o[8], .429043 * (s * s - r * r)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let s = 0; s < 9; s++)this.coefficients[s].addScaledVector(e.coefficients[s], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let s = 0; s < 9; s++)this.coefficients[s].lerp(e.coefficients[s], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return new this.constructor().copy(this) } fromArray(e, t = 0) { const s = this.coefficients; for (let r = 0; r < 9; r++)s[r].fromArray(e, t + r * 3); return this } toArray(e = [], t = 0) { const s = this.coefficients; for (let r = 0; r < 9; r++)s[r].toArray(e, t + r * 3); return e } static getBasisAt(e, t) { const s = e.x, r = e.y, n = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * n, t[3] = .488603 * s, t[4] = 1.092548 * s * r, t[5] = 1.092548 * r * n, t[6] = .315392 * (3 * n * n - 1), t[7] = 1.092548 * s * n, t[8] = .546274 * (s * s - r * r) } } class cd extends Jl { constructor(e = new ld, t = 1) { super(void 0, t), this.isLightProbe = !0, this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } class D_ extends tr { constructor(e) { super(e), this.textures = {} } load(e, t, s, r) { const n = this, o = new bs(n.manager); o.setPath(n.path), o.setRequestHeader(n.requestHeader), o.setWithCredentials(n.withCredentials), o.load(e, function (a) { try { t(n.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), n.manager.itemError(e) } }, s, r) } parse(e) { const t = this.textures; function s(n) { return t[n] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", n), t[n] } const r = D_.createMaterialFromType(e.type); if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new xe().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== 1 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const n in e.uniforms) { const o = e.uniforms[n]; switch (r.uniforms[n] = {}, o.type) { case "t": r.uniforms[n].value = s(o.value); break; case "c": r.uniforms[n].value = new xe().setHex(o.value); break; case "v2": r.uniforms[n].value = new W().fromArray(o.value); break; case "v3": r.uniforms[n].value = new S().fromArray(o.value); break; case "v4": r.uniforms[n].value = new st().fromArray(o.value); break; case "m3": r.uniforms[n].value = new ds().fromArray(o.value); break; case "m4": r.uniforms[n].value = new He().fromArray(o.value); break; default: r.uniforms[n].value = o.value } } if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0) for (const n in e.extensions) r.extensions[n] = e.extensions[n]; if (e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = s(e.map)), e.matcap !== void 0 && (r.matcap = s(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = s(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = s(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = s(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) { let n = e.normalScale; Array.isArray(n) === !1 && (n = [n, n]), r.normalScale = new W().fromArray(n) } return e.displacementMap !== void 0 && (r.displacementMap = s(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = s(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = s(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = s(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = s(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = s(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = s(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = s(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = s(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = s(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = s(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = s(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = s(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = s(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new W().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = s(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = s(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = s(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = s(e.thicknessMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = s(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = s(e.sheenRoughnessMap)), r } setTextures(e) { return this.textures = e, this } static createMaterialFromType(e) { const t = { ShadowMaterial: Uw, SpriteMaterial: Aw, RawShaderMaterial: Nw, ShaderMaterial: Vt, PointsMaterial: LA, MeshPhysicalMaterial: Bo, MeshStandardMaterial: od, MeshPhongMaterial: fP, MeshToonMaterial: gP, MeshNormalMaterial: zw, MeshLambertMaterial: mP, MeshDepthMaterial: MA, MeshDistanceMaterial: gw, MeshBasicMaterial: di, MeshMatcapMaterial: vP, LineDashedMaterial: AP, LineBasicMaterial: Hi, Material: Tt }; return new t[e] } } class Do { static decodeText(e) { if (typeof TextDecoder < "u") return new TextDecoder().decode(e); let t = ""; for (let s = 0, r = e.length; s < r; s++)t += String.fromCharCode(e[s]); try { return decodeURIComponent(escape(t)) } catch { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return t === -1 ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } } class Kw extends yt { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } toJSON() { const e = super.toJSON(); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } class IP extends tr { constructor(e) { super(e) } load(e, t, s, r) { const n = this, o = new bs(n.manager); o.setPath(n.path), o.setRequestHeader(n.requestHeader), o.setWithCredentials(n.withCredentials), o.load(e, function (a) { try { t(n.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), n.manager.itemError(e) } }, s, r) } parse(e) { const t = {}, s = {}; function r(p, f) { if (t[f] !== void 0) return t[f]; const g = p.interleavedBuffers[f], m = n(p, g.buffer), v = Du(g.type, m), A = new Rf(v, g.stride); return A.uuid = g.uuid, t[f] = A, A } function n(p, f) { if (s[f] !== void 0) return s[f]; const g = p.arrayBuffers[f], m = new Uint32Array(g).buffer; return s[f] = m, m } const o = e.isInstancedBufferGeometry ? new Kw : new yt, a = e.data.index; if (a !== void 0) { const p = Du(a.type, a.array); o.setIndex(new nt(p, 1)) } const l = e.data.attributes; for (const p in l) { const f = l[p]; let g; if (f.isInterleavedBufferAttribute) { const m = r(e.data, f.data); g = new El(m, f.itemSize, f.offset, f.normalized) } else { const m = Du(f.type, f.array), v = f.isInstancedBufferAttribute ? tn : nt; g = new v(m, f.itemSize, f.normalized) } f.name !== void 0 && (g.name = f.name), f.usage !== void 0 && g.setUsage(f.usage), f.updateRange !== void 0 && (g.updateRange.offset = f.updateRange.offset, g.updateRange.count = f.updateRange.count), o.setAttribute(p, g) } const c = e.data.morphAttributes; if (c) for (const p in c) { const f = c[p], g = []; for (let m = 0, v = f.length; m < v; m++) { const A = f[m]; let b; if (A.isInterleavedBufferAttribute) { const y = r(e.data, A.data); b = new El(y, A.itemSize, A.offset, A.normalized) } else { const y = Du(A.type, A.array); b = new nt(y, A.itemSize, A.normalized) } A.name !== void 0 && (b.name = A.name), g.push(b) } o.morphAttributes[p] = g } e.data.morphTargetsRelative && (o.morphTargetsRelative = !0); const h = e.data.groups || e.data.drawcalls || e.data.offsets; if (h !== void 0) for (let p = 0, f = h.length; p !== f; ++p) { const g = h[p]; o.addGroup(g.start, g.count, g.materialIndex) } const d = e.data.boundingSphere; if (d !== void 0) { const p = new S; d.center !== void 0 && p.fromArray(d.center), o.boundingSphere = new Po(p, d.radius) } return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o } } class NH extends tr { constructor(e) { super(e) } load(e, t, s, r) { const n = this, o = this.path === "" ? Do.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || o; const a = new bs(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (l) { let c = null; try { c = JSON.parse(l) } catch (d) { r !== void 0 && r(d), console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message); return } const h = c.metadata; if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") { r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e); return } n.parse(c, t) }, s, r) } async loadAsync(e, t) { const s = this, r = this.path === "" ? Do.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || r; const n = new bs(this.manager); n.setPath(this.path), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials); const o = await n.loadAsync(e, t), a = JSON.parse(o), l = a.metadata; if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e); return await s.parseAsync(a) } parse(e, t) { const s = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), n = this.parseGeometries(e.geometries, r), o = this.parseImages(e.images, function () { t !== void 0 && t(c) }), a = this.parseTextures(e.textures, o), l = this.parseMaterials(e.materials, a), c = this.parseObject(e.object, n, l, a, s), h = this.parseSkeletons(e.skeletons, c); if (this.bindSkeletons(c, h), t !== void 0) { let d = !1; for (const p in o) if (o[p].data instanceof HTMLImageElement) { d = !0; break } d === !1 && t(c) } return c } async parseAsync(e) { const t = this.parseAnimations(e.animations), s = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, s), n = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, n), a = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, r, a, o, t), c = this.parseSkeletons(e.skeletons, l); return this.bindSkeletons(l, c), l } parseShapes(e) { const t = {}; if (e !== void 0) for (let s = 0, r = e.length; s < r; s++) { const n = new Ah().fromJSON(e[s]); t[n.uuid] = n } return t } parseSkeletons(e, t) { const s = {}, r = {}; if (t.traverse(function (n) { n.isBone && (r[n.uuid] = n) }), e !== void 0) for (let n = 0, o = e.length; n < o; n++) { const a = new Xp().fromJSON(e[n], r); s[a.uuid] = a } return s } parseGeometries(e, t) { const s = {}; if (e !== void 0) { const r = new IP; for (let n = 0, o = e.length; n < o; n++) { let a; const l = e[n]; switch (l.type) { case "BufferGeometry": case "InstancedBufferGeometry": a = r.parse(l); break; default: l.type in pP ? a = pP[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`) }a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), a.isBufferGeometry === !0 && l.userData !== void 0 && (a.userData = l.userData), s[l.uuid] = a } } return s } parseMaterials(e, t) { const s = {}, r = {}; if (e !== void 0) { const n = new D_; n.setTextures(t); for (let o = 0, a = e.length; o < a; o++) { const l = e[o]; s[l.uuid] === void 0 && (s[l.uuid] = n.parse(l)), r[l.uuid] = s[l.uuid] } } return r } parseAnimations(e) { const t = {}; if (e !== void 0) for (let s = 0; s < e.length; s++) { const r = e[s], n = En.parse(r); t[n.uuid] = n } return t } parseImages(e, t) { const s = this, r = {}; let n; function o(l) { return s.manager.itemStart(l), n.load(l, function () { s.manager.itemEnd(l) }, void 0, function () { s.manager.itemError(l), s.manager.itemEnd(l) }) } function a(l) { if (typeof l == "string") { const c = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : s.resourcePath + c; return o(h) } else return l.data ? { data: Du(l.type, l.data), width: l.width, height: l.height } : null } if (e !== void 0 && e.length > 0) { const l = new XA(t); n = new Gf(l), n.setCrossOrigin(this.crossOrigin); for (let c = 0, h = e.length; c < h; c++) { const d = e[c], p = d.url; if (Array.isArray(p)) { const f = []; for (let g = 0, m = p.length; g < m; g++) { const v = p[g], A = a(v); A !== null && (A instanceof HTMLImageElement ? f.push(A) : f.push(new no(A.data, A.width, A.height))) } r[d.uuid] = new Nl(f) } else { const f = a(d.url); r[d.uuid] = new Nl(f) } } } return r } async parseImagesAsync(e) { const t = this, s = {}; let r; async function n(o) { if (typeof o == "string") { const a = o, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a; return await r.loadAsync(l) } else return o.data ? { data: Du(o.type, o.data), width: o.width, height: o.height } : null } if (e !== void 0 && e.length > 0) { r = new Gf(this.manager), r.setCrossOrigin(this.crossOrigin); for (let o = 0, a = e.length; o < a; o++) { const l = e[o], c = l.url; if (Array.isArray(c)) { const h = []; for (let d = 0, p = c.length; d < p; d++) { const f = c[d], g = await n(f); g !== null && (g instanceof HTMLImageElement ? h.push(g) : h.push(new no(g.data, g.width, g.height))) } s[l.uuid] = new Nl(h) } else { const h = await n(l.url); s[l.uuid] = new Nl(h) } } } return s } parseTextures(e, t) { function s(n, o) { return typeof n == "number" ? n : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", n), o[n]) } const r = {}; if (e !== void 0) for (let n = 0, o = e.length; n < o; n++) { const a = e[n]; a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image); const l = t[a.image], c = l.data; let h; Array.isArray(c) ? (h = new If, c.length === 6 && (h.needsUpdate = !0)) : (c && c.data ? h = new no : h = new Nt, c && (h.needsUpdate = !0)), h.source = l, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = s(a.mapping, zH)), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = s(a.wrap[0], TP), h.wrapT = s(a.wrap[1], TP)), a.format !== void 0 && (h.format = a.format), a.type !== void 0 && (h.type = a.type), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = s(a.minFilter, RP)), a.magFilter !== void 0 && (h.magFilter = s(a.magFilter, RP)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.userData !== void 0 && (h.userData = a.userData), r[a.uuid] = h } return r } parseObject(e, t, s, r, n) { let o; function a(p) { return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p] } function l(p) { if (p !== void 0) { if (Array.isArray(p)) { const f = []; for (let g = 0, m = p.length; g < m; g++) { const v = p[g]; s[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), f.push(s[v]) } return f } return s[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), s[p] } } function c(p) { return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), r[p] } let h, d; switch (e.type) { case "Scene": o = new Cn, e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new xe(e.background) : o.background = c(e.background)), e.environment !== void 0 && (o.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new vw(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new k_(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness); break; case "PerspectiveCamera": o = new Xt(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view)); break; case "OrthographicCamera": o = new Yu(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view)); break; case "AmbientLight": o = new Jw(e.color, e.intensity); break; case "DirectionalLight": o = new KA(e.color, e.intensity); break; case "PointLight": o = new JA(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": o = new MP(e.color, e.intensity, e.width, e.height); break; case "SpotLight": o = new YA(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": o = new Ww(e.color, e.groundColor, e.intensity); break; case "LightProbe": o = new cd().fromJSON(e); break; case "SkinnedMesh": h = a(e.geometry), d = l(e.material), o = new rd(h, d), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton); break; case "Mesh": h = a(e.geometry), d = l(e.material), o = new ye(h, d); break; case "InstancedMesh": h = a(e.geometry), d = l(e.material); const p = e.count, f = e.instanceMatrix, g = e.instanceColor; o = new DA(h, d, p), o.instanceMatrix = new tn(new Float32Array(f.array), 16), g !== void 0 && (o.instanceColor = new tn(new Float32Array(g.array), g.itemSize)); break; case "LOD": o = new bw; break; case "Line": o = new Vi(a(e.geometry), l(e.material)); break; case "LineLoop": o = new xw(a(e.geometry), l(e.material)); break; case "LineSegments": o = new sn(a(e.geometry), l(e.material)); break; case "PointCloud": case "Points": o = new Cw(a(e.geometry), l(e.material)); break; case "Sprite": o = new DR(l(e.material)); break; case "Group": o = new wn; break; case "Bone": o = new Df; break; default: o = new Me }if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) { const p = e.children; for (let f = 0; f < p.length; f++)o.add(this.parseObject(p[f], t, s, r, n)) } if (e.animations !== void 0) { const p = e.animations; for (let f = 0; f < p.length; f++) { const g = p[f]; o.animations.push(n[g]) } } if (e.type === "LOD") { e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate); const p = e.levels; for (let f = 0; f < p.length; f++) { const g = p[f], m = o.getObjectByProperty("uuid", g.object); m !== void 0 && o.addLevel(m, g.distance, g.hysteresis) } } return o } bindSkeletons(e, t) { Object.keys(t).length !== 0 && e.traverse(function (s) { if (s.isSkinnedMesh === !0 && s.skeleton !== void 0) { const r = t[s.skeleton]; r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", s.skeleton) : s.bind(r, s.bindMatrix) } }) } } const zH = { UVMapping: jv, CubeReflectionMapping: Bl, CubeRefractionMapping: kl, EquirectangularReflectionMapping: An, EquirectangularRefractionMapping: Tu, CubeUVReflectionMapping: Ru }, TP = { RepeatWrapping: yn, ClampToEdgeWrapping: Ss, MirroredRepeatWrapping: Ta }, RP = { NearestFilter: Zt, NearestMipmapNearestFilter: Pu, NearestMipmapLinearFilter: Bu, LinearFilter: Qt, LinearMipmapNearestFilter: df, LinearMipmapLinearFilter: eo }; class PP extends tr { constructor(e) { super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, s, r) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const n = this, o = wh.get(e); if (o !== void 0) return n.manager.itemStart(e), setTimeout(function () { t && t(o), n.manager.itemEnd(e) }, 0), o; const a = {}; a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function (l) { return l.blob() }).then(function (l) { return createImageBitmap(l, Object.assign(n.options, { colorSpaceConversion: "none" })) }).then(function (l) { wh.add(e, l), t && t(l), n.manager.itemEnd(e) }).catch(function (l) { r && r(l), n.manager.itemError(e), n.manager.itemEnd(e) }), n.manager.itemStart(e) } } let ZA; class Zw { static getContext() { return ZA === void 0 && (ZA = new (window.AudioContext || window.webkitAudioContext)), ZA } static setContext(e) { ZA = e } } class $A extends tr { constructor(e) { super(e) } load(e, t, s, r) { const n = this, o = new bs(this.manager); o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) { try { const l = a.slice(0); Zw.getContext().decodeAudioData(l, function (c) { t(c) }) } catch (l) { r ? r(l) : console.error(l), n.manager.itemError(e) } }, s, r) } } class jH extends cd { constructor(e, t, s = 1) { super(void 0, s), this.isHemisphereLightProbe = !0; const r = new xe().set(e), n = new xe().set(t), o = new S(r.r, r.g, r.b), a = new S(n.r, n.g, n.b), l = Math.sqrt(Math.PI), c = l * Math.sqrt(.75); this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c) } } class QH extends cd { constructor(e, t = 1) { super(void 0, t), this.isAmbientLightProbe = !0; const s = new xe().set(e); this.sh.coefficients[0].set(s.r, s.g, s.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } } const BP = new He, kP = new He, Ch = new He; class GH { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Xt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Xt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Ch.copy(e.projectionMatrix); const s = t.eyeSep / 2, r = s * t.near / t.focus, n = t.near * Math.tan(hh * t.fov * .5) / t.zoom; let o, a; kP.elements[12] = -s, BP.elements[12] = s, o = -n * t.aspect + r, a = n * t.aspect + r, Ch.elements[0] = 2 * t.near / (a - o), Ch.elements[8] = (a + o) / (a - o), this.cameraL.projectionMatrix.copy(Ch), o = -n * t.aspect - r, a = n * t.aspect - r, Ch.elements[0] = 2 * t.near / (a - o), Ch.elements[8] = (a + o) / (a - o), this.cameraR.projectionMatrix.copy(Ch) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(kP), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(BP) } } class e0 { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = DP(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = DP(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function DP() { return (typeof performance > "u" ? Date : performance).now() } const Sh = new S, OP = new we, HH = new S, Eh = new S; let $w = class extends Me { constructor() { super(), this.type = "AudioListener", this.context = Zw.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new e0 } getInput() { return this.gain } removeFilter() { return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(i) { return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = i, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(i) { return this.gain.gain.setTargetAtTime(i, this.context.currentTime, .01), this } updateMatrixWorld(i) { super.updateMatrixWorld(i); const e = this.context.listener, t = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Sh, OP, HH), Eh.set(0, 0, -1).applyQuaternion(OP), e.positionX) { const s = this.context.currentTime + this.timeDelta; e.positionX.linearRampToValueAtTime(Sh.x, s), e.positionY.linearRampToValueAtTime(Sh.y, s), e.positionZ.linearRampToValueAtTime(Sh.z, s), e.forwardX.linearRampToValueAtTime(Eh.x, s), e.forwardY.linearRampToValueAtTime(Eh.y, s), e.forwardZ.linearRampToValueAtTime(Eh.z, s), e.upX.linearRampToValueAtTime(t.x, s), e.upY.linearRampToValueAtTime(t.y, s), e.upZ.linearRampToValueAtTime(t.z, s) } else e.setPosition(Sh.x, Sh.y, Sh.z), e.setOrientation(Eh.x, Eh.y, Eh.z, t.x, t.y, t.z) } }; class t0 extends Me { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (this.isPlaying === !0) { console.warn("THREE.Audio: Audio is already playing."); return } if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this } stop() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(e) { return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const Mh = new S, LP = new we, VH = new S, Ih = new S; class FP extends t0 { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } disconnect() { super.disconnect(), this.panner.disconnect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, s) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = s, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return; this.matrixWorld.decompose(Mh, LP, VH), Ih.set(0, 0, 1).applyQuaternion(LP); const t = this.panner; if (t.positionX) { const s = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(Mh.x, s), t.positionY.linearRampToValueAtTime(Mh.y, s), t.positionZ.linearRampToValueAtTime(Mh.z, s), t.orientationX.linearRampToValueAtTime(Ih.x, s), t.orientationY.linearRampToValueAtTime(Ih.y, s), t.orientationZ.linearRampToValueAtTime(Ih.z, s) } else t.setPosition(Mh.x, Mh.y, Mh.z), t.setOrientation(Ih.x, Ih.y, Ih.z) } } class UP { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const t = this.getFrequencyData(); for (let s = 0; s < t.length; s++)e += t[s]; return e / t.length } } class NP { constructor(e, t, s) { this.binding = e, this.valueSize = s; let r, n, o; switch (t) { case "quaternion": r = this._slerp, n = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(s * 6), this._workIndex = 5; break; case "string": case "bool": r = this._select, n = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(s * 5); break; default: r = this._lerp, n = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(s * 5) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = n, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const s = this.buffer, r = this.valueSize, n = e * r + r; let o = this.cumulativeWeight; if (o === 0) { for (let a = 0; a !== r; ++a)s[n + a] = s[a]; o = t } else { o += t; const a = t / o; this._mixBufferRegion(s, n, 0, a, r) } this.cumulativeWeight = o } accumulateAdditive(e) { const t = this.buffer, s = this.valueSize, r = s * this._addIndex; this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, s), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, s = this.buffer, r = e * t + t, n = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, n < 1) { const l = t * this._origIndex; this._mixBufferRegion(s, r, l, 1 - n, t) } o > 0 && this._mixBufferRegionAdditive(s, r, this._addIndex * t, 1, t); for (let l = t, c = t + t; l !== c; ++l)if (s[l] !== s[l + t]) { a.setValue(s, r); break } } saveOriginalState() { const e = this.binding, t = this.buffer, s = this.valueSize, r = s * this._origIndex; e.getValue(t, r); for (let n = s, o = r; n !== o; ++n)t[n] = t[r + n % s]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = this.valueSize * 3; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let s = e; s < t; s++)this.buffer[s] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let s = 0; s < this.valueSize; s++)this.buffer[t + s] = this.buffer[e + s] } _select(e, t, s, r, n) { if (r >= .5) for (let o = 0; o !== n; ++o)e[t + o] = e[s + o] } _slerp(e, t, s, r) { we.slerpFlat(e, t, e, t, e, s, r) } _slerpAdditive(e, t, s, r, n) { const o = this._workIndex * n; we.multiplyQuaternionsFlat(e, o, e, t, e, s), we.slerpFlat(e, t, e, t, e, o, r) } _lerp(e, t, s, r, n) { const o = 1 - r; for (let a = 0; a !== n; ++a) { const l = t + a; e[l] = e[l] * o + e[s + a] * r } } _lerpAdditive(e, t, s, r, n) { for (let o = 0; o !== n; ++o) { const a = t + o; e[a] = e[a] + e[s + o] * r } } } const e1 = "\\[\\]\\.:\\/", WH = new RegExp("[" + e1 + "]", "g"), t1 = "[^" + e1 + "]", qH = "[^" + e1.replace("\\.", "") + "]", XH = /((?:WC+[\/:])*)/.source.replace("WC", t1), YH = /(WCOD+)?/.source.replace("WCOD", qH), JH = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t1), KH = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t1), ZH = new RegExp("^" + XH + YH + JH + KH + "$"), $H = ["material", "materials", "bones", "map"]; class eV { constructor(e, t, s) { const r = s || zt.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, r) } getValue(e, t) { this.bind(); const s = this._targetGroup.nCachedObjects_, r = this._bindings[s]; r !== void 0 && r.getValue(e, t) } setValue(e, t) { const s = this._bindings; for (let r = this._targetGroup.nCachedObjects_, n = s.length; r !== n; ++r)s[r].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, s = e.length; t !== s; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, s = e.length; t !== s; ++t)e[t].unbind() } } class zt { constructor(e, t, s) { this.path = t, this.parsedPath = s || zt.parseTrackName(t), this.node = zt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, s) { return e && e.isAnimationObjectGroup ? new zt.Composite(e, t, s) : new zt(e, t, s) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(WH, "") } static parseTrackName(e) { const t = ZH.exec(e); if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const s = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = s.nodeName && s.nodeName.lastIndexOf("."); if (r !== void 0 && r !== -1) { const n = s.nodeName.substring(r + 1); $H.indexOf(n) !== -1 && (s.nodeName = s.nodeName.substring(0, r), s.objectName = n) } if (s.propertyName === null || s.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return s } static findNode(e, t) { if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e; if (e.skeleton) { const s = e.skeleton.getBoneByName(t); if (s !== void 0) return s } if (e.children) { const s = function (n) { for (let o = 0; o < n.length; o++) { const a = n[o]; if (a.name === t || a.uuid === t) return a; const l = s(a.children); if (l) return l } return null }, r = s(e.children); if (r) return r } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const s = this.resolvedProperty; for (let r = 0, n = s.length; r !== n; ++r)e[t++] = s[r] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const s = this.resolvedProperty; for (let r = 0, n = s.length; r !== n; ++r)s[r] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const s = this.resolvedProperty; for (let r = 0, n = s.length; r !== n; ++r)s[r] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const s = this.resolvedProperty; for (let r = 0, n = s.length; r !== n; ++r)s[r] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, s = t.objectName, r = t.propertyName; let n = t.propertyIndex; if (e || (e = zt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) { console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); return } if (s) { let c = t.objectIndex; switch (s) { case "materials": if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } e = e.material.materials; break; case "bones": if (!e.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } e = e.skeleton.bones; for (let h = 0; h < e.length; h++)if (e[h].name === c) { c = h; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } e = e.material.map; break; default: if (e[s] === void 0) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } e = e[s] }if (c !== void 0) { if (e[c] === void 0) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); return } e = e[c] } } const o = e[r]; if (o === void 0) { const c = t.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e); return } let a = this.Versioning.None; this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate); let l = this.BindingType.Direct; if (n !== void 0) { if (r === "morphTargetInfluences") { if (!e.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!e.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } e.morphTargetDictionary[n] !== void 0 && (n = e.morphTargetDictionary[n]) } l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = n } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r; this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } zt.Composite = eV, zt.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, zt.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, zt.prototype.GetterByBindingType = [zt.prototype._getValue_direct, zt.prototype._getValue_array, zt.prototype._getValue_arrayElement, zt.prototype._getValue_toArray], zt.prototype.SetterByBindingTypeAndVersioning = [[zt.prototype._setValue_direct, zt.prototype._setValue_direct_setNeedsUpdate, zt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [zt.prototype._setValue_array, zt.prototype._setValue_array_setNeedsUpdate, zt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [zt.prototype._setValue_arrayElement, zt.prototype._setValue_arrayElement_setNeedsUpdate, zt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [zt.prototype._setValue_fromArray, zt.prototype._setValue_fromArray_setNeedsUpdate, zt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class tV { constructor() { this.isAnimationObjectGroup = !0, this.uuid = Kr(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let s = 0, r = arguments.length; s !== r; ++s)e[arguments[s].uuid] = s; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { const e = this._objects, t = this._indicesByUUID, s = this._paths, r = this._parsedPaths, n = this._bindings, o = n.length; let a, l = e.length, c = this.nCachedObjects_; for (let h = 0, d = arguments.length; h !== d; ++h) { const p = arguments[h], f = p.uuid; let g = t[f]; if (g === void 0) { g = l++, t[f] = g, e.push(p); for (let m = 0, v = o; m !== v; ++m)n[m].push(new zt(p, s[m], r[m])) } else if (g < c) { a = e[g]; const m = --c, v = e[m]; t[v.uuid] = g, e[g] = v, t[f] = m, e[m] = p; for (let A = 0, b = o; A !== b; ++A) { const y = n[A], _ = y[m]; let w = y[g]; y[g] = _, w === void 0 && (w = new zt(p, s[A], r[A])), y[m] = w } } else e[g] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = c } remove() { const e = this._objects, t = this._indicesByUUID, s = this._bindings, r = s.length; let n = this.nCachedObjects_; for (let o = 0, a = arguments.length; o !== a; ++o) { const l = arguments[o], c = l.uuid, h = t[c]; if (h !== void 0 && h >= n) { const d = n++, p = e[d]; t[p.uuid] = h, e[h] = p, t[c] = d, e[d] = l; for (let f = 0, g = r; f !== g; ++f) { const m = s[f], v = m[d], A = m[h]; m[h] = v, m[d] = A } } } this.nCachedObjects_ = n } uncache() { const e = this._objects, t = this._indicesByUUID, s = this._bindings, r = s.length; let n = this.nCachedObjects_, o = e.length; for (let a = 0, l = arguments.length; a !== l; ++a) { const c = arguments[a], h = c.uuid, d = t[h]; if (d !== void 0) if (delete t[h], d < n) { const p = --n, f = e[p], g = --o, m = e[g]; t[f.uuid] = d, e[d] = f, t[m.uuid] = p, e[p] = m, e.pop(); for (let v = 0, A = r; v !== A; ++v) { const b = s[v], y = b[p], _ = b[g]; b[d] = y, b[p] = _, b.pop() } } else { const p = --o, f = e[p]; p > 0 && (t[f.uuid] = d), e[d] = f, e.pop(); for (let g = 0, m = r; g !== m; ++g) { const v = s[g]; v[d] = v[p], v.pop() } } } this.nCachedObjects_ = n } subscribe_(e, t) { const s = this._bindingsIndicesByPath; let r = s[e]; const n = this._bindings; if (r !== void 0) return n[r]; const o = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, h = this.nCachedObjects_, d = new Array(c); r = n.length, s[e] = r, o.push(e), a.push(t), n.push(d); for (let p = h, f = l.length; p !== f; ++p) { const g = l[p]; d[p] = new zt(g, e, t) } return d } unsubscribe_(e) { const t = this._bindingsIndicesByPath, s = t[e]; if (s !== void 0) { const r = this._paths, n = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], c = e[a]; t[c] = s, o[s] = l, o.pop(), n[s] = n[a], n.pop(), r[s] = r[a], r.pop() } } } class iV { constructor(e, t, s = null, r = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = s, this.blendMode = r; const n = t.tracks, o = n.length, a = new Array(o), l = { endingStart: lh, endingEnd: lh }; for (let c = 0; c !== o; ++c) { const h = n[c].createInterpolant(null); a[c] = h, h.settings = l } this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Tx, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, s) { if (e.fadeOut(t), this.fadeIn(t), s) { const r = this._clip.duration, n = e._clip.duration, o = n / r, a = r / n; e.warp(1, o, t), this.warp(a, 1, t) } return this } crossFadeTo(e, t, s) { return e.crossFadeFrom(this, t, s) } stopFading() { const e = this._weightInterpolant; return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, s) { const r = this._mixer, n = r.time, o = this.timeScale; let a = this._timeScaleInterpolant; a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a); const l = a.parameterPositions, c = a.sampleValues; return l[0] = n, l[1] = n + s, c[0] = e / o, c[1] = t / o, this } stopWarping() { const e = this._timeScaleInterpolant; return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, s, r) { if (!this.enabled) { this._updateWeight(e); return } const n = this._startTime; if (n !== null) { const l = (e - n) * s; l < 0 || s === 0 ? t = 0 : (this._startTime = null, t = s * l) } t *= this._updateTimeScale(e); const o = this._updateTime(t), a = this._updateWeight(e); if (a > 0) { const l = this._interpolants, c = this._propertyBindings; switch (this.blendMode) { case Rx: for (let h = 0, d = l.length; h !== d; ++h)l[h].evaluate(o), c[h].accumulateAdditive(a); break; case Zv: default: for (let h = 0, d = l.length; h !== d; ++h)l[h].evaluate(o), c[h].accumulate(r, a) } } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const s = this._weightInterpolant; if (s !== null) { const r = s.evaluate(e)[0]; t *= r, e > s.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const s = this._timeScaleInterpolant; if (s !== null) { const r = s.evaluate(e)[0]; t *= r, e > s.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t) } } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, s = this.loop; let r = this.time + e, n = this._loopCount; const o = s === wT; if (e === 0) return n === -1 ? r : o && (n & 1) === 1 ? t - r : r; if (s === gf) { n === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else if (r < 0) r = 0; else { this.time = r; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (n === -1 && (e >= 0 ? (n = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= t || r < 0) { const a = Math.floor(r / t); r -= t * a, n += Math.abs(a); const l = this.repetitions - n; if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (l === 1) { const c = e < 0; this._setEndings(c, !c, o) } else this._setEndings(!1, !1, o); this._loopCount = n, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a }) } } else this.time = r; if (o && (n & 1) === 1) return t - r } return r } _setEndings(e, t, s) { const r = this._interpolantSettings; s ? (r.endingStart = ch, r.endingEnd = ch) : (e ? r.endingStart = this.zeroSlopeAtStart ? ch : lh : r.endingStart = mf, t ? r.endingEnd = this.zeroSlopeAtEnd ? ch : lh : r.endingEnd = mf) } _scheduleFading(e, t, s) { const r = this._mixer, n = r.time; let o = this._weightInterpolant; o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o); const a = o.parameterPositions, l = o.sampleValues; return a[0] = n, l[0] = t, a[1] = n + e, l[1] = s, this } } const sV = new Float32Array(1); class i0 extends ms { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const s = e._localRoot || this._root, r = e._clip.tracks, n = r.length, o = e._propertyBindings, a = e._interpolants, l = s.uuid, c = this._bindingsByRootAndName; let h = c[l]; h === void 0 && (h = {}, c[l] = h); for (let d = 0; d !== n; ++d) { const p = r[d], f = p.name; let g = h[f]; if (g !== void 0) ++g.referenceCount, o[d] = g; else { if (g = o[d], g !== void 0) { g._cacheIndex === null && (++g.referenceCount, this._addInactiveBinding(g, l, f)); continue } const m = t && t._propertyBindings[d].binding.parsedPath; g = new NP(zt.create(s, f, m), p.ValueTypeName, p.getValueSize()), ++g.referenceCount, this._addInactiveBinding(g, l, f), o[d] = g } a[d].resultBuffer = g.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (e._cacheIndex === null) { const s = (e._localRoot || this._root).uuid, r = e._clip.uuid, n = this._actionsByClip[r]; this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, r, s) } const t = e._propertyBindings; for (let s = 0, r = t.length; s !== r; ++s) { const n = t[s]; n.useCount++ === 0 && (this._lendBinding(n), n.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let s = 0, r = t.length; s !== r; ++s) { const n = t[s]; --n.useCount === 0 && (n.restoreOriginalState(), this._takeBackBinding(n)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return t !== null && t < this._nActiveActions } _addInactiveAction(e, t, s) { const r = this._actions, n = this._actionsByClip; let o = n[t]; if (o === void 0) o = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, n[t] = o; else { const a = o.knownActions; e._byClipCacheIndex = a.length, a.push(e) } e._cacheIndex = r.length, r.push(e), o.actionByRoot[s] = e } _removeInactiveAction(e) { const t = this._actions, s = t[t.length - 1], r = e._cacheIndex; s._cacheIndex = r, t[r] = s, t.pop(), e._cacheIndex = null; const n = e._clip.uuid, o = this._actionsByClip, a = o[n], l = a.knownActions, c = l[l.length - 1], h = e._byClipCacheIndex; c._byClipCacheIndex = h, l[h] = c, l.pop(), e._byClipCacheIndex = null; const d = a.actionByRoot, p = (e._localRoot || this._root).uuid; delete d[p], l.length === 0 && delete o[n], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let s = 0, r = t.length; s !== r; ++s) { const n = t[s]; --n.referenceCount === 0 && this._removeInactiveBinding(n) } } _lendAction(e) { const t = this._actions, s = e._cacheIndex, r = this._nActiveActions++, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = s, t[s] = n } _takeBackAction(e) { const t = this._actions, s = e._cacheIndex, r = --this._nActiveActions, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = s, t[s] = n } _addInactiveBinding(e, t, s) { const r = this._bindingsByRootAndName, n = this._bindings; let o = r[t]; o === void 0 && (o = {}, r[t] = o), o[s] = e, e._cacheIndex = n.length, n.push(e) } _removeInactiveBinding(e) { const t = this._bindings, s = e.binding, r = s.rootNode.uuid, n = s.path, o = this._bindingsByRootAndName, a = o[r], l = t[t.length - 1], c = e._cacheIndex; l._cacheIndex = c, t[c] = l, t.pop(), delete a[n], Object.keys(a).length === 0 && delete o[r] } _lendBinding(e) { const t = this._bindings, s = e._cacheIndex, r = this._nActiveBindings++, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = s, t[s] = n } _takeBackBinding(e) { const t = this._bindings, s = e._cacheIndex, r = --this._nActiveBindings, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = s, t[s] = n } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let s = e[t]; return s === void 0 && (s = new Hw(new Float32Array(2), new Float32Array(2), 1, sV), s.__cacheIndex = t, e[t] = s), s } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, s = e.__cacheIndex, r = --this._nActiveControlInterpolants, n = t[r]; e.__cacheIndex = r, t[r] = e, n.__cacheIndex = s, t[s] = n } clipAction(e, t, s) { const r = t || this._root, n = r.uuid; let o = typeof e == "string" ? En.findByName(r, e) : e; const a = o !== null ? o.uuid : e, l = this._actionsByClip[a]; let c = null; if (s === void 0 && (o !== null ? s = o.blendMode : s = Zv), l !== void 0) { const d = l.actionByRoot[n]; if (d !== void 0 && d.blendMode === s) return d; c = l.knownActions[0], o === null && (o = c._clip) } if (o === null) return null; const h = new iV(this, o, t, s); return this._bindAction(h, c), this._addInactiveAction(h, a, n), h } existingAction(e, t) { const s = t || this._root, r = s.uuid, n = typeof e == "string" ? En.findByName(s, e) : e, o = n ? n.uuid : e, a = this._actionsByClip[o]; return a !== void 0 && a.actionByRoot[r] || null } stopAllAction() { const e = this._actions, t = this._nActiveActions; for (let s = t - 1; s >= 0; --s)e[s].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, s = this._nActiveActions, r = this.time += e, n = Math.sign(e), o = this._accuIndex ^= 1; for (let c = 0; c !== s; ++c)t[c]._update(r, e, n, o); const a = this._bindings, l = this._nActiveBindings; for (let c = 0; c !== l; ++c)a[c].apply(o); return this } setTime(e) { this.time = 0; for (let t = 0; t < this._actions.length; t++)this._actions[t].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, s = e.uuid, r = this._actionsByClip, n = r[s]; if (n !== void 0) { const o = n.knownActions; for (let a = 0, l = o.length; a !== l; ++a) { const c = o[a]; this._deactivateAction(c); const h = c._cacheIndex, d = t[t.length - 1]; c._cacheIndex = null, c._byClipCacheIndex = null, d._cacheIndex = h, t[h] = d, t.pop(), this._removeInactiveBindingsForAction(c) } delete r[s] } } uncacheRoot(e) { const t = e.uuid, s = this._actionsByClip; for (const o in s) { const a = s[o].actionByRoot, l = a[t]; l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l)) } const r = this._bindingsByRootAndName, n = r[t]; if (n !== void 0) for (const o in n) { const a = n[o]; a.restoreOriginalState(), this._removeInactiveBinding(a) } } uncacheAction(e, t) { const s = this.existingAction(e, t); s !== null && (this._deactivateAction(s), this._removeInactiveAction(s)) } } class Ce { constructor(e) { this.value = e } clone() { return new Ce(this.value.clone === void 0 ? this.value : this.value.clone()) } } let rV = 0; class nV extends ms { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: rV++ }), this.name = "", this.usage = yf, this.uniforms = [] } add(e) { return this.uniforms.push(e), this } remove(e) { const t = this.uniforms.indexOf(e); return t !== -1 && this.uniforms.splice(t, 1), this } setName(e) { return this.name = e, this } setUsage(e) { return this.usage = e, this } dispose() { return this.dispatchEvent({ type: "dispose" }), this } copy(e) { this.name = e.name, this.usage = e.usage; const t = e.uniforms; this.uniforms.length = 0; for (let s = 0, r = t.length; s < r; s++)this.uniforms.push(t[s].clone()); return this } clone() { return new this.constructor().copy(this) } } class oV extends Rf { constructor(e, t, s = 1) { super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = s } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } class aV { constructor(e, t, s, r, n) { this.isGLBufferAttribute = !0, this.buffer = e, this.type = t, this.itemSize = s, this.elementSize = r, this.count = n, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } let hd = class { constructor(i, e, t = 0, s = 1 / 0) { this.ray = new Oa(i, e), this.near = t, this.far = s, this.camera = null, this.layers = new bn, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(i, e) { this.ray.set(i, e) } setFromCamera(i, e) { e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(i.x, i.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(i.x, i.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type) } intersectObject(i, e = !0, t = []) { return i1(i, this, t, e), t.sort(zP), t } intersectObjects(i, e = !0, t = []) { for (let s = 0, r = i.length; s < r; s++)i1(i[s], this, t, e); return t.sort(zP), t } }; function zP(i, e) { return i.distance - e.distance } function i1(i, e, t, s) { if (i.layers.test(e.layers) && i.raycast(e, t), s === !0) { const r = i.children; for (let n = 0, o = r.length; n < o; n++)i1(r[n], e, t, !0) } } class s1 { constructor(e = 1, t = 0, s = 0) { return this.radius = e, this.phi = t, this.theta = s, this } set(e, t, s) { return this.radius = e, this.phi = t, this.theta = s, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, s) { return this.radius = Math.sqrt(e * e + t * t + s * s), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, s), this.phi = Math.acos(Gi(t / this.radius, -1, 1))), this } clone() { return new this.constructor().copy(this) } } class lV { constructor(e = 1, t = 0, s = 0) { return this.radius = e, this.theta = t, this.y = s, this } set(e, t, s) { return this.radius = e, this.theta = t, this.y = s, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, s) { return this.radius = Math.sqrt(e * e + s * s), this.theta = Math.atan2(e, s), this.y = t, this } clone() { return new this.constructor().copy(this) } } const jP = new W; class cV { constructor(e = new W(1 / 0, 1 / 0), t = new W(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, s = e.length; t < s; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const s = jP.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(s), this.max.copy(e).add(s), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return jP.copy(e).clamp(this.min, this.max).sub(e).length() } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const QP = new S, s0 = new S; class GP { constructor(e = new S, t = new S) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { QP.subVectors(e, this.start), s0.subVectors(this.end, this.start); const s = s0.dot(s0); let r = s0.dot(QP) / s; return t && (r = Gi(r, 0, 1)), r } closestPointToPoint(e, t, s) { const r = this.closestPointToPointParameter(e, t); return this.delta(s).multiplyScalar(r).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return new this.constructor().copy(this) } } const HP = new S; class hV extends Me { constructor(e, t) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper"; const s = new yt, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let o = 0, a = 1, l = 32; o < l; o++, a++) { const c = o / l * Math.PI * 2, h = a / l * Math.PI * 2; r.push(Math.cos(c), Math.sin(c), 1, Math.cos(h), Math.sin(h), 1) } s.setAttribute("position", new et(r, 3)); const n = new Hi({ fog: !1, toneMapped: !1 }); this.cone = new sn(s, n), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1); const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), HP.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(HP), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } const Kl = new S, r0 = new He, r1 = new He; class uV extends sn { constructor(e) { const t = VP(e), s = new yt, r = [], n = [], o = new xe(0, 0, 1), a = new xe(0, 1, 0); for (let c = 0; c < t.length; c++) { const h = t[c]; h.parent && h.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), n.push(o.r, o.g, o.b), n.push(a.r, a.g, a.b)) } s.setAttribute("position", new et(r, 3)), s.setAttribute("color", new et(n, 3)); const l = new Hi({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); super(s, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, s = this.geometry, r = s.getAttribute("position"); r1.copy(this.root.matrixWorld).invert(); for (let n = 0, o = 0; n < t.length; n++) { const a = t[n]; a.parent && a.parent.isBone && (r0.multiplyMatrices(r1, a.matrixWorld), Kl.setFromMatrixPosition(r0), r.setXYZ(o, Kl.x, Kl.y, Kl.z), r0.multiplyMatrices(r1, a.parent.matrixWorld), Kl.setFromMatrixPosition(r0), r.setXYZ(o + 1, Kl.x, Kl.y, Kl.z), o += 2) } s.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose() } } function VP(i) { const e = []; i.isBone === !0 && e.push(i); for (let t = 0; t < i.children.length; t++)e.push.apply(e, VP(i.children[t])); return e } class dV extends ye { constructor(e, t, s) { const r = new Zn(t, 4, 2), n = new di({ wireframe: !0, fog: !1, toneMapped: !1 }); super(r, n), this.light = e, this.color = s, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const pV = new S, WP = new xe, qP = new xe; class fV extends Me { constructor(e, t, s) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = s, this.type = "HemisphereLightHelper"; const r = new Aa(t); r.rotateY(Math.PI * .5), this.material = new di({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0); const n = r.getAttribute("position"), o = new Float32Array(n.count * 3); r.setAttribute("color", new nt(o, 3)), this.add(new ye(r, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (this.color !== void 0) this.material.color.set(this.color); else { const t = e.geometry.getAttribute("color"); WP.copy(this.light.color), qP.copy(this.light.groundColor); for (let s = 0, r = t.count; s < r; s++) { const n = s < r / 2 ? WP : qP; t.setXYZ(s, n.r, n.g, n.b) } t.needsUpdate = !0 } this.light.updateWorldMatrix(!0, !1), e.lookAt(pV.setFromMatrixPosition(this.light.matrixWorld).negate()) } } let XP = class extends sn { constructor(i = 10, e = 10, t = 4473924, s = 8947848) { t = new xe(t), s = new xe(s); const r = e / 2, n = i / e, o = i / 2, a = [], l = []; for (let d = 0, p = 0, f = -o; d <= e; d++, f += n) { a.push(-o, 0, f, o, 0, f), a.push(f, 0, -o, f, 0, o); const g = d === r ? t : s; g.toArray(l, p), p += 3, g.toArray(l, p), p += 3, g.toArray(l, p), p += 3, g.toArray(l, p), p += 3 } const c = new yt; c.setAttribute("position", new et(a, 3)), c.setAttribute("color", new et(l, 3)); const h = new Hi({ vertexColors: !0, toneMapped: !1 }); super(c, h), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } }; class gV extends sn { constructor(e = 10, t = 16, s = 8, r = 64, n = 4473924, o = 8947848) { n = new xe(n), o = new xe(o); const a = [], l = []; if (t > 1) for (let d = 0; d < t; d++) { const p = d / t * (Math.PI * 2), f = Math.sin(p) * e, g = Math.cos(p) * e; a.push(0, 0, 0), a.push(f, 0, g); const m = d & 1 ? n : o; l.push(m.r, m.g, m.b), l.push(m.r, m.g, m.b) } for (let d = 0; d < s; d++) { const p = d & 1 ? n : o, f = e - e / s * d; for (let g = 0; g < r; g++) { let m = g / r * (Math.PI * 2), v = Math.sin(m) * f, A = Math.cos(m) * f; a.push(v, 0, A), l.push(p.r, p.g, p.b), m = (g + 1) / r * (Math.PI * 2), v = Math.sin(m) * f, A = Math.cos(m) * f, a.push(v, 0, A), l.push(p.r, p.g, p.b) } } const c = new yt; c.setAttribute("position", new et(a, 3)), c.setAttribute("color", new et(l, 3)); const h = new Hi({ vertexColors: !0, toneMapped: !1 }); super(c, h), this.type = "PolarGridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } const YP = new S, n0 = new S, JP = new S; class KP extends Me { constructor(e, t, s) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = s, this.type = "DirectionalLightHelper", t === void 0 && (t = 1); let r = new yt; r.setAttribute("position", new et([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); const n = new Hi({ fog: !1, toneMapped: !1 }); this.lightPlane = new Vi(r, n), this.add(this.lightPlane), r = new yt, r.setAttribute("position", new et([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Vi(r, n), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), YP.setFromMatrixPosition(this.light.matrixWorld), n0.setFromMatrixPosition(this.light.target.matrixWorld), JP.subVectors(n0, YP), this.lightPlane.lookAt(n0), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(n0), this.targetLine.scale.z = JP.length() } } const o0 = new S, Oi = new gh; class ZP extends sn { constructor(e) { const t = new yt, s = new Hi({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], n = [], o = {}; a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"); function a(g, m) { l(g), l(m) } function l(g) { r.push(0, 0, 0), n.push(0, 0, 0), o[g] === void 0 && (o[g] = []), o[g].push(r.length / 3 - 1) } t.setAttribute("position", new et(r, 3)), t.setAttribute("color", new et(n, 3)), super(t, s), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update(); const c = new xe(16755200), h = new xe(16711680), d = new xe(43775), p = new xe(16777215), f = new xe(3355443); this.setColors(c, h, d, p, f) } setColors(e, t, s, r, n) { const o = this.geometry.getAttribute("color"); o.setXYZ(0, e.r, e.g, e.b), o.setXYZ(1, e.r, e.g, e.b), o.setXYZ(2, e.r, e.g, e.b), o.setXYZ(3, e.r, e.g, e.b), o.setXYZ(4, e.r, e.g, e.b), o.setXYZ(5, e.r, e.g, e.b), o.setXYZ(6, e.r, e.g, e.b), o.setXYZ(7, e.r, e.g, e.b), o.setXYZ(8, e.r, e.g, e.b), o.setXYZ(9, e.r, e.g, e.b), o.setXYZ(10, e.r, e.g, e.b), o.setXYZ(11, e.r, e.g, e.b), o.setXYZ(12, e.r, e.g, e.b), o.setXYZ(13, e.r, e.g, e.b), o.setXYZ(14, e.r, e.g, e.b), o.setXYZ(15, e.r, e.g, e.b), o.setXYZ(16, e.r, e.g, e.b), o.setXYZ(17, e.r, e.g, e.b), o.setXYZ(18, e.r, e.g, e.b), o.setXYZ(19, e.r, e.g, e.b), o.setXYZ(20, e.r, e.g, e.b), o.setXYZ(21, e.r, e.g, e.b), o.setXYZ(22, e.r, e.g, e.b), o.setXYZ(23, e.r, e.g, e.b), o.setXYZ(24, t.r, t.g, t.b), o.setXYZ(25, t.r, t.g, t.b), o.setXYZ(26, t.r, t.g, t.b), o.setXYZ(27, t.r, t.g, t.b), o.setXYZ(28, t.r, t.g, t.b), o.setXYZ(29, t.r, t.g, t.b), o.setXYZ(30, t.r, t.g, t.b), o.setXYZ(31, t.r, t.g, t.b), o.setXYZ(32, s.r, s.g, s.b), o.setXYZ(33, s.r, s.g, s.b), o.setXYZ(34, s.r, s.g, s.b), o.setXYZ(35, s.r, s.g, s.b), o.setXYZ(36, s.r, s.g, s.b), o.setXYZ(37, s.r, s.g, s.b), o.setXYZ(38, r.r, r.g, r.b), o.setXYZ(39, r.r, r.g, r.b), o.setXYZ(40, n.r, n.g, n.b), o.setXYZ(41, n.r, n.g, n.b), o.setXYZ(42, n.r, n.g, n.b), o.setXYZ(43, n.r, n.g, n.b), o.setXYZ(44, n.r, n.g, n.b), o.setXYZ(45, n.r, n.g, n.b), o.setXYZ(46, n.r, n.g, n.b), o.setXYZ(47, n.r, n.g, n.b), o.setXYZ(48, n.r, n.g, n.b), o.setXYZ(49, n.r, n.g, n.b), o.needsUpdate = !0 } update() { const e = this.geometry, t = this.pointMap, s = 1, r = 1; Oi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Wi("c", t, e, Oi, 0, 0, -1), Wi("t", t, e, Oi, 0, 0, 1), Wi("n1", t, e, Oi, -s, -r, -1), Wi("n2", t, e, Oi, s, -r, -1), Wi("n3", t, e, Oi, -s, r, -1), Wi("n4", t, e, Oi, s, r, -1), Wi("f1", t, e, Oi, -s, -r, 1), Wi("f2", t, e, Oi, s, -r, 1), Wi("f3", t, e, Oi, -s, r, 1), Wi("f4", t, e, Oi, s, r, 1), Wi("u1", t, e, Oi, s * .7, r * 1.1, -1), Wi("u2", t, e, Oi, -s * .7, r * 1.1, -1), Wi("u3", t, e, Oi, 0, r * 2, -1), Wi("cf1", t, e, Oi, -s, 0, 1), Wi("cf2", t, e, Oi, s, 0, 1), Wi("cf3", t, e, Oi, 0, -r, 1), Wi("cf4", t, e, Oi, 0, r, 1), Wi("cn1", t, e, Oi, -s, 0, -1), Wi("cn2", t, e, Oi, s, 0, -1), Wi("cn3", t, e, Oi, 0, -r, -1), Wi("cn4", t, e, Oi, 0, r, -1), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function Wi(i, e, t, s, r, n, o) { o0.set(r, n, o).unproject(s); const a = e[i]; if (a !== void 0) { const l = t.getAttribute("position"); for (let c = 0, h = a.length; c < h; c++)l.setXYZ(a[c], o0.x, o0.y, o0.z) } } const a0 = new er; class l0 extends sn { constructor(e, t = 16776960) { const s = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), n = new yt; n.setIndex(new nt(s, 1)), n.setAttribute("position", new nt(r, 3)), super(n, new Hi({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && a0.setFromObject(this.object), a0.isEmpty()) return; const t = a0.min, s = a0.max, r = this.geometry.attributes.position, n = r.array; n[0] = s.x, n[1] = s.y, n[2] = s.z, n[3] = t.x, n[4] = s.y, n[5] = s.z, n[6] = t.x, n[7] = t.y, n[8] = s.z, n[9] = s.x, n[10] = t.y, n[11] = s.z, n[12] = s.x, n[13] = s.y, n[14] = t.z, n[15] = t.x, n[16] = s.y, n[17] = t.z, n[18] = t.x, n[19] = t.y, n[20] = t.z, n[21] = s.x, n[22] = t.y, n[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e, t) { return super.copy(e, t), this.object = e.object, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class mV extends sn { constructor(e, t = 16776960) { const s = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], n = new yt; n.setIndex(new nt(s, 1)), n.setAttribute("position", new et(r, 3)), super(n, new Hi({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } dispose() { this.geometry.dispose(), this.material.dispose() } } class vV extends Vi { constructor(e, t = 1, s = 16776960) { const r = s, n = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new yt; o.setAttribute("position", new et(n, 3)), o.computeBoundingSphere(), super(o, new Hi({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t; const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new yt; l.setAttribute("position", new et(a, 3)), l.computeBoundingSphere(), this.add(new ye(l, new di({ color: r, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() } } const $P = new S; let c0, n1; class AV extends Me { constructor(e = new S(0, 0, 1), t = new S(0, 0, 0), s = 1, r = 16776960, n = s * .2, o = n * .2) { super(), this.type = "ArrowHelper", c0 === void 0 && (c0 = new yt, c0.setAttribute("position", new et([0, 0, 0, 0, 1, 0], 3)), n1 = new ji(0, .5, 1, 5, 1), n1.translate(0, -.5, 0)), this.position.copy(t), this.line = new Vi(c0, new Hi({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ye(n1, new di({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(s, n, o) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { $P.set(e.z, 0, -e.x).normalize(); const t = Math.acos(e.y); this.quaternion.setFromAxisAngle($P, t) } } setLength(e, t = e * .2, s = t * .2) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(s, t, s), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } dispose() { this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose() } } let ud = class extends sn { constructor(i = 1) { const e = [0, 0, 0, i, 0, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, 0, i], t = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], s = new yt; s.setAttribute("position", new et(e, 3)), s.setAttribute("color", new et(t, 3)); const r = new Hi({ vertexColors: !0, toneMapped: !1 }); super(s, r), this.type = "AxesHelper" } setColors(i, e, t) { const s = new xe, r = this.geometry.attributes.color.array; return s.set(i), s.toArray(r, 0), s.toArray(r, 3), s.set(e), s.toArray(r, 6), s.toArray(r, 9), s.set(t), s.toArray(r, 12), s.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } }; class yV { constructor() { this.type = "ShapePath", this.color = new xe, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new Uf, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, s, r) { return this.currentPath.quadraticCurveTo(e, t, s, r), this } bezierCurveTo(e, t, s, r, n, o) { return this.currentPath.bezierCurveTo(e, t, s, r, n, o), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e) { function t(A) { const b = []; for (let y = 0, _ = A.length; y < _; y++) { const w = A[y], E = new Ah; E.curves = w.curves, b.push(E) } return b } function s(A, b) { const y = b.length; let _ = !1; for (let w = y - 1, E = 0; E < y; w = E++) { let P = b[w], C = b[E], R = C.x - P.x, T = C.y - P.y; if (Math.abs(T) > Number.EPSILON) { if (T < 0 && (P = b[E], R = -R, C = b[w], T = -T), A.y < P.y || A.y > C.y) continue; if (A.y === P.y) { if (A.x === P.x) return !0 } else { const z = T * (A.x - P.x) - R * (A.y - P.y); if (z === 0) return !0; if (z < 0) continue; _ = !_ } } else { if (A.y !== P.y) continue; if (C.x <= A.x && A.x <= P.x || P.x <= A.x && A.x <= C.x) return !0 } } return _ } const r = va.isClockWise, n = this.subPaths; if (n.length === 0) return []; let o, a, l; const c = []; if (n.length === 1) return a = n[0], l = new Ah, l.curves = a.curves, c.push(l), c; let h = !r(n[0].getPoints()); h = e ? !h : h; const d = [], p = []; let f = [], g = 0, m; p[g] = void 0, f[g] = []; for (let A = 0, b = n.length; A < b; A++)a = n[A], m = a.getPoints(), o = r(m), o = e ? !o : o, o ? (!h && p[g] && g++, p[g] = { s: new Ah, p: m }, p[g].s.curves = a.curves, h && g++, f[g] = []) : f[g].push({ h: a, p: m[0] }); if (!p[0]) return t(n); if (p.length > 1) { let A = !1, b = 0; for (let y = 0, _ = p.length; y < _; y++)d[y] = []; for (let y = 0, _ = p.length; y < _; y++) { const w = f[y]; for (let E = 0; E < w.length; E++) { const P = w[E]; let C = !0; for (let R = 0; R < p.length; R++)s(P.p, p[R].p) && (y !== R && b++, C ? (C = !1, d[R].push(P)) : A = !0); C && d[y].push(P) } } b > 0 && A === !1 && (f = d) } let v; for (let A = 0, b = p.length; A < b; A++) { l = p[A].s, c.push(l), v = f[A]; for (let y = 0, _ = v.length; y < _; y++)l.holes.push(v[y].h) } return c } } const ja = bV(); function bV() { const i = new ArrayBuffer(4), e = new Float32Array(i), t = new Uint32Array(i), s = new Uint32Array(512), r = new Uint32Array(512); for (let l = 0; l < 256; ++l) { const c = l - 127; c < -27 ? (s[l] = 0, s[l | 256] = 32768, r[l] = 24, r[l | 256] = 24) : c < -14 ? (s[l] = 1024 >> -c - 14, s[l | 256] = 1024 >> -c - 14 | 32768, r[l] = -c - 1, r[l | 256] = -c - 1) : c <= 15 ? (s[l] = c + 15 << 10, s[l | 256] = c + 15 << 10 | 32768, r[l] = 13, r[l | 256] = 13) : c < 128 ? (s[l] = 31744, s[l | 256] = 64512, r[l] = 24, r[l | 256] = 24) : (s[l] = 31744, s[l | 256] = 64512, r[l] = 13, r[l | 256] = 13) } const n = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64); for (let l = 1; l < 1024; ++l) { let c = l << 13, h = 0; for (; !(c & 8388608);)c <<= 1, h -= 8388608; c &= -8388609, h += 947912704, n[l] = c | h } for (let l = 1024; l < 2048; ++l)n[l] = 939524096 + (l - 1024 << 13); for (let l = 1; l < 31; ++l)o[l] = l << 23; o[31] = 1199570944, o[32] = 2147483648; for (let l = 33; l < 63; ++l)o[l] = 2147483648 + (l - 32 << 23); o[63] = 3347054592; for (let l = 1; l < 64; ++l)l !== 32 && (a[l] = 1024); return { floatView: e, uint32View: t, baseTable: s, shiftTable: r, mantissaTable: n, exponentTable: o, offsetTable: a } } function _V(i) { Math.abs(i) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), i = Gi(i, -65504, 65504), ja.floatView[0] = i; const e = ja.uint32View[0], t = e >> 23 & 511; return ja.baseTable[t] + ((e & 8388607) >> ja.shiftTable[t]) } function xV(i) { const e = i >> 10; return ja.uint32View[0] = ja.mantissaTable[ja.offsetTable[e] + (i & 1023)] + ja.exponentTable[e], ja.floatView[0] } var Th = Object.freeze({ __proto__: null, toHalfFloat: _V, fromHalfFloat: xV }); function wV() { console.error("THREE.ImmediateRenderObject has been removed.") } class CV extends ri { constructor(e, t, s) { console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, s), this.samples = 4 } } class SV extends xf { constructor(e, t, s, r) { console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."), super(e, t, s, r) } } class EV extends wf { constructor(e, t, s, r) { console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."), super(e, t, s, r) } } class MV extends pi { constructor(e, t, s, r, n, o) { console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, t, s, r, n, o) } } class IV extends Av { constructor(e, t, s, r) { console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e, t, s, r) } } class TV extends yv { constructor(e, t, s, r) { console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, t, s, r) } } class RV extends bv { constructor(e, t, s, r, n, o, a) { console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, t, s, r, n, o, a) } } class PV extends ji { constructor(e, t, s, r, n, o, a, l) { console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, t, s, r, n, o, a, l) } } class BV extends _v { constructor(e, t) { console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, t) } } class kV extends xv { constructor(e, t) { console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e, t) } } class DV extends Jp { constructor(e, t) { console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e, t) } } class OV extends Yp { constructor(e, t, s, r) { console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, t, s, r) } } class LV extends Aa { constructor(e, t) { console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e, t) } } class FV extends ks { constructor(e, t, s, r) { console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, t, s, r) } } class UV extends Ml { constructor(e, t, s, r) { console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e, t, s, r) } } class NV extends Kp { constructor(e, t, s, r, n, o) { console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e, t, s, r, n, o) } } class zV extends wv { constructor(e, t) { console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e, t) } } class jV extends Zn { constructor(e, t, s, r, n, o, a) { console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e, t, s, r, n, o, a) } } class QV extends Cv { constructor(e, t) { console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e, t) } } class GV extends ya { constructor(e, t, s, r, n) { console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e, t, s, r, n) } } class HV extends Sv { constructor(e, t, s, r, n, o) { console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e, t, s, r, n, o) } } class VV extends Ev { constructor(e, t, s, r, n) { console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, t, s, r, n) } } typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: th } })), typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = th); const WV = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: ux, AddEquation: nh, AddOperation: cT, AdditiveAnimationBlendMode: Rx, AdditiveBlending: rh, AlphaFormat: vT, AlwaysDepth: Uv, AlwaysStencilFunc: Bx, AmbientLight: Jw, AmbientLightProbe: QH, AnimationClip: En, AnimationLoader: kH, AnimationMixer: i0, AnimationObjectGroup: tV, AnimationUtils: TH, ArcCurve: $R, ArrayCamera: TR, ArrowHelper: AV, Audio: t0, AudioAnalyser: UP, AudioContext: Zw, AudioListener: $w, AudioLoader: $A, AxesHelper: ud, BackSide: fs, BasicDepthPacking: Os, BasicShadowMap: wz, Bone: Df, BooleanKeyframeTrack: _h, Box2: cV, Box3: er, Box3Helper: mV, BoxBufferGeometry: MV, BoxGeometry: pi, BoxHelper: l0, BufferAttribute: nt, BufferGeometry: yt, BufferGeometryLoader: IP, ByteType: dT, Cache: wh, Camera: gh, CameraHelper: ZP, CanvasTexture: ZR, CapsuleBufferGeometry: IV, CapsuleGeometry: Av, CatmullRomCurve3: eP, CineonToneMapping: hT, CircleBufferGeometry: TV, CircleGeometry: yv, ClampToEdgeWrapping: Ss, Clock: e0, Color: xe, ColorKeyframeTrack: Qf, ColorManagement: $s, CompressedArrayTexture: KR, CompressedTexture: Na, CompressedTextureLoader: DH, ConeBufferGeometry: RV, ConeGeometry: bv, CubeCamera: aw, CubeReflectionMapping: Bl, CubeRefractionMapping: kl, CubeTexture: If, CubeTextureLoader: OH, CubeUVReflectionMapping: Ru, CubicBezierCurve: Tw, CubicBezierCurve3: iP, CubicInterpolant: bP, CullFaceBack: ex, CullFaceFront: YI, CullFaceFrontBack: xz, CullFaceNone: XI, Curve: oo, CurvePath: rP, CustomBlending: JI, CustomToneMapping: uT, CylinderBufferGeometry: PV, CylinderGeometry: ji, Cylindrical: lV, Data3DTexture: wf, DataArrayTexture: xf, DataTexture: no, DataTexture2DArray: SV, DataTexture3D: EV, DataTextureLoader: Vw, DataUtils: Th, DecrementStencilOp: TT, DecrementWrapStencilOp: PT, DefaultLoadingManager: wP, DepthFormat: Ol, DepthStencilFormat: Ll, DepthTexture: IA, DirectionalLight: KA, DirectionalLightHelper: KP, DiscreteInterpolant: _P, DodecahedronBufferGeometry: BV, DodecahedronGeometry: _v, DoubleSide: yi, DstAlphaFactor: sT, DstColorFactor: nT, DynamicCopyUsage: Oz, DynamicDrawUsage: Ks, DynamicReadUsage: Bz, EdgesGeometry: Ow, EllipseCurve: NA, EqualDepth: Iu, EqualStencilFunc: OT, EquirectangularReflectionMapping: An, EquirectangularRefractionMapping: Tu, Euler: ps, EventDispatcher: ms, ExtrudeBufferGeometry: kV, ExtrudeGeometry: xv, FileLoader: bs, Float16BufferAttribute: g4, Float32BufferAttribute: et, Float64BufferAttribute: m4, FloatType: $i, Fog: vw, FogExp2: k_, FramebufferTexture: $5, FrontSide: pr, Frustum: xA, GLBufferAttribute: aV, GLSL1: Fz, GLSL3: kx, GreaterDepth: zv, GreaterEqualDepth: Nv, GreaterEqualStencilFunc: NT, GreaterStencilFunc: FT, GridHelper: XP, Group: wn, HalfFloatType: gs, HemisphereLight: Ww, HemisphereLightHelper: fV, HemisphereLightProbe: jH, IcosahedronBufferGeometry: DV, IcosahedronGeometry: Jp, ImageBitmapLoader: PP, ImageLoader: Gf, ImageUtils: Nx, ImmediateRenderObject: wV, IncrementStencilOp: IT, IncrementWrapStencilOp: RT, InstancedBufferAttribute: tn, InstancedBufferGeometry: Kw, InstancedInterleavedBuffer: oV, InstancedMesh: DA, Int16BufferAttribute: p4, Int32BufferAttribute: f4, Int8BufferAttribute: h4, IntType: fT, InterleavedBuffer: Rf, InterleavedBufferAttribute: El, Interpolant: ad, InterpolateDiscrete: ah, InterpolateLinear: Pa, InterpolateSmooth: Kv, InvertStencilOp: BT, KeepStencilOp: Af, KeyframeTrack: rn, LOD: bw, LatheBufferGeometry: OV, LatheGeometry: Yp, Layers: bn, LessDepth: lf, LessEqualDepth: Mu, LessEqualStencilFunc: LT, LessStencilFunc: DT, Light: Jl, LightProbe: cd, Line: Vi, Line3: GP, LineBasicMaterial: Hi, LineCurve: jA, LineCurve3: sP, LineDashedMaterial: AP, LineLoop: xw, LineSegments: sn, LinearEncoding: Qi, LinearFilter: Qt, LinearInterpolant: Hw, LinearMipMapLinearFilter: Mz, LinearMipMapNearestFilter: Ez, LinearMipmapLinearFilter: eo, LinearMipmapNearestFilter: df, LinearSRGBColorSpace: vf, LinearToneMapping: uf, Loader: tr, LoaderUtils: Do, LoadingManager: XA, LoopOnce: gf, LoopPingPong: wT, LoopRepeat: Tx, LuminanceAlphaFormat: yT, LuminanceFormat: Qv, MOUSE: ih, Material: Tt, MaterialLoader: D_, MathUtils: kr, Matrix3: ds, Matrix4: He, MaxEquation: ox, Mesh: ye, MeshBasicMaterial: di, MeshDepthMaterial: MA, MeshDistanceMaterial: gw, MeshLambertMaterial: mP, MeshMatcapMaterial: vP, MeshNormalMaterial: zw, MeshPhongMaterial: fP, MeshPhysicalMaterial: Bo, MeshStandardMaterial: od, MeshToonMaterial: gP, MinEquation: nx, MirroredRepeatWrapping: Ta, MixOperation: lT, MultiplyBlending: rx, MultiplyOperation: hf, NearestFilter: Zt, NearestMipMapLinearFilter: Sz, NearestMipMapNearestFilter: Cz, NearestMipmapLinearFilter: Bu, NearestMipmapNearestFilter: Pu, NeverDepth: cx, NeverStencilFunc: kT, NoBlending: Ri, NoColorSpace: Tz, NoToneMapping: fr, NormalAnimationBlendMode: Zv, NormalBlending: Ia, NotEqualDepth: cf, NotEqualStencilFunc: UT, NumberKeyframeTrack: ql, Object3D: Me, ObjectLoader: NH, ObjectSpaceNormalMap: ST, OctahedronBufferGeometry: LV, OctahedronGeometry: Aa, OneFactor: eT, OneMinusDstAlphaFactor: rT, OneMinusDstColorFactor: oT, OneMinusSrcAlphaFactor: lx, OneMinusSrcColorFactor: iT, OrthographicCamera: Yu, PCFShadowMap: tx, PCFSoftShadowMap: ix, PMREMGenerator: uw, Path: Uf, PerspectiveCamera: Xt, Plane: xn, PlaneBufferGeometry: FV, PlaneGeometry: ks, PlaneHelper: vV, PointLight: JA, PointLightHelper: dV, Points: Cw, PointsMaterial: LA, PolarGridHelper: gV, PolyhedronBufferGeometry: UV, PolyhedronGeometry: Ml, PositionalAudio: FP, PropertyBinding: zt, PropertyMixer: NP, QuadraticBezierCurve: Rw, QuadraticBezierCurve3: Pw, Quaternion: we, QuaternionKeyframeTrack: ko, QuaternionLinearInterpolant: xP, REVISION: th, RGBADepthPacking: $v, RGBAFormat: _i, RGBAIntegerFormat: xT, RGBA_ASTC_10x10_Format: Ex, RGBA_ASTC_10x5_Format: wx, RGBA_ASTC_10x6_Format: Cx, RGBA_ASTC_10x8_Format: Sx, RGBA_ASTC_12x10_Format: Mx, RGBA_ASTC_12x12_Format: Ix, RGBA_ASTC_4x4_Format: Yv, RGBA_ASTC_5x4_Format: mx, RGBA_ASTC_5x5_Format: vx, RGBA_ASTC_6x5_Format: Ax, RGBA_ASTC_6x6_Format: yx, RGBA_ASTC_8x5_Format: bx, RGBA_ASTC_8x6_Format: _x, RGBA_ASTC_8x8_Format: xx, RGBA_BPTC_Format: Jv, RGBA_ETC2_EAC_Format: Xv, RGBA_PVRTC_2BPPV1_Format: fx, RGBA_PVRTC_4BPPV1_Format: Wv, RGBA_S3TC_DXT1_Format: Gv, RGBA_S3TC_DXT3_Format: Hv, RGBA_S3TC_DXT5_Format: ff, RGBFormat: AT, RGB_ETC1_Format: gx, RGB_ETC2_Format: qv, RGB_PVRTC_2BPPV1_Format: px, RGB_PVRTC_4BPPV1_Format: Vv, RGB_S3TC_DXT1_Format: pf, RGFormat: oh, RGIntegerFormat: _T, RawShaderMaterial: Nw, Ray: Oa, Raycaster: hd, RectAreaLight: MP, RedFormat: Fl, RedIntegerFormat: bT, ReinhardToneMapping: hx, RepeatWrapping: yn, ReplaceStencilOp: MT, ReverseSubtractEquation: ZI, RingBufferGeometry: NV, RingGeometry: Kp, SRGBColorSpace: to, Scene: Cn, ShaderChunk: Mt, ShaderLib: en, ShaderMaterial: Vt, ShadowMaterial: Uw, Shape: Ah, ShapeBufferGeometry: zV, ShapeGeometry: wv, ShapePath: yV, ShapeUtils: va, ShortType: pT, Skeleton: Xp, SkeletonHelper: uV, SkinnedMesh: rd, Source: Nl, Sphere: Po, SphereBufferGeometry: jV, SphereGeometry: Zn, Spherical: s1, SphericalHarmonics3: ld, SplineCurve: Bw, SpotLight: YA, SpotLightHelper: hV, Sprite: DR, SpriteMaterial: Aw, SrcAlphaFactor: ax, SrcAlphaSaturateFactor: aT, SrcColorFactor: tT, StaticCopyUsage: Dz, StaticDrawUsage: yf, StaticReadUsage: Pz, StereoCamera: GH, StreamCopyUsage: Lz, StreamDrawUsage: Rz, StreamReadUsage: kz, StringKeyframeTrack: xh, SubtractEquation: KI, SubtractiveBlending: sx, TOUCH: sh, TangentSpaceNormalMap: Ul, TetrahedronBufferGeometry: QV, TetrahedronGeometry: Cv, Texture: Nt, TextureLoader: Yl, TorusBufferGeometry: GV, TorusGeometry: ya, TorusKnotBufferGeometry: HV, TorusKnotGeometry: Sv, Triangle: vn, TriangleFanDrawMode: Px, TriangleStripDrawMode: CT, TrianglesDrawMode: Iz, TubeBufferGeometry: VV, TubeGeometry: Ev, UVMapping: jv, Uint16BufferAttribute: Zx, Uint32BufferAttribute: $x, Uint8BufferAttribute: u4, Uint8ClampedBufferAttribute: d4, Uniform: Ce, UniformsGroup: nV, UniformsLib: Ye, UniformsUtils: ow, UnsignedByteType: ui, UnsignedInt248Type: Dl, UnsignedIntType: Ra, UnsignedShort4444Type: gT, UnsignedShort5551Type: mT, UnsignedShortType: dx, VSMShadowMap: Eu, Vector2: W, Vector3: S, Vector4: st, VectorKeyframeTrack: Xl, VideoTexture: JR, WebGL1Renderer: RR, WebGL3DRenderTarget: e4, WebGLArrayRenderTarget: $z, WebGLCubeRenderTarget: bA, WebGLMultipleRenderTargets: t4, WebGLMultisampleRenderTarget: CV, WebGLRenderTarget: ri, WebGLRenderer: $u, WebGLUtils: IR, WireframeGeometry: uP, WrapAroundEnding: mf, ZeroCurvatureEnding: lh, ZeroFactor: $I, ZeroSlopeEnding: ch, ZeroStencilOp: ET, _SRGBAFormat: eA, sRGBEncoding: Xe }, Symbol.toStringTag, { value: "Module" })); let Qa = null, Zl = null, Oo = null, o1 = !1, eB = null; const tB = "\u{1F4DC}", a1 = oe("console"), qV = oe("noerrors"); if (a1 && c1(), !qV && (a1 || dr())) { dr() && console.log("Add the ?console query parameter to the url to show the debug console (on mobile it will automatically open for local development when your get errors)"); const i = Su(); if (i && (iB(), rB(!0), i)) { const e = document.querySelector("needle-engine"); e?.addEventListener("enter-ar", () => { var t; if (a1 || Qa || GI() > 0) { if (oe("noerrors")) return; const s = (t = e.getAROverlayContainer) == null ? void 0 : t.call(e), r = nB(); r && s && s.appendChild(r) } }), e?.addEventListener("exit-ar", () => { ZV() }) } } const l1 = Symbol("consoleParent"); function c1() { if (Qa !== null) { Qa.showSwitch(); return } rB() } function XV() { Qa !== null && (Qa.hide(), Qa.hideSwitch()) } function iB() { eB || (eB = setInterval(YV, 500)) } let sB = 0; function YV() { const i = GI(), e = i !== sB; sB = i, e && JV() } function JV() { c1(), Oo && (Oo.setAttribute("error", "true"), Oo.innerText = "\u{1F92C}") } function KV() { Oo && (Oo.removeAttribute("error"), Oo.innerText = tB) } function ZV() { Zl && Zl[l1] && Zl[l1].appendChild(Zl) } function rB(i = !1) {
  if (Qa || o1) return; o1 = !0; const e = document.createElement("script"); e.src = "https://unpkg.com/vconsole@latest/dist/vconsole.min.js", e.onload = () => {
    if (o1 = !1, iB(), Qa = new window.VConsole, Zl = nB(), Zl && (Zl[l1] = Zl.parentElement), Qa.setSwitchPosition(20, 10), Oo = $V(), Oo) {
      Oo.innerText = tB, Oo.addEventListener("click", KV); const t = document.createElement("style"), s = 40; t.innerHTML = `
                #__vconsole .vc-switch {
                    border: 1px solid rgba(255,255,255,.2);
                    border-radius: 50%;
                    width: ${s}px;
                    height: ${s}px;
                    padding: 0;
                    line-height: ${s}px;
                    font-size: ${s * .4}px;
                    text-align: center;
                    background: rgba(200,200,200,.2);
                    backdrop-filter: blur(10px);
                    user-select: none;
                    pointer-events: auto;
                    transition: transform .2s ease-in-out;
                }
                #__vconsole .vc-switch:hover {
                    cursor: pointer;
                    transform: scale(1.1);
                    transition: transform .1s ease-in-out;
                }
                #__vconsole .vc-switch[error] {
                    background: rgba(255,0,0,.2);
                    animation: vconsole-notify 1s ease-in-out;
                }
                @keyframes vconsole-notify {
                    from {
                        transform: scale(1, 1);
                    }
                    10% {
                        transform: scale(1.3, 1.3);
                    }
                    70% {
                        transform: scale(1.4, 1.4);
                    }
                    to {
                        transform: scale(1, 1);
                    }
                }
            `, document.head.appendChild(t), i === !0 && XV()
    }
  }, document.body.appendChild(e)
} function $V() { return document.querySelector("#__vconsole .vc-switch") || null } function nB() { return document.querySelector("#__vconsole") || null } function Ls(i, e = Ro.Log) { Ea(e, i) } function ao(i) { Ls(i, Ro.Warn) } function Mn() { return dr() } const Vf = oe("gizmos"), ir = oe("debugextension"), h0 = oe("debugresolvedependencies"), e6 = ["/extensions/", "extensions/"], t6 = [{ prefix: "/nodes/", dependencyName: "node" }, { prefix: "/meshes/", dependencyName: "mesh" }, { prefix: "/materials/", dependencyName: "material" }, { prefix: "/textures/", dependencyName: "texture" }, { prefix: "/animations/", dependencyName: "animation" }, { prefix: "nodes/", dependencyName: "node" }, { prefix: "meshes/", dependencyName: "mesh" }, { prefix: "materials/", dependencyName: "material" }, { prefix: "textures/", dependencyName: "texture" }, { prefix: "animations/", dependencyName: "animation" }]; async function h1(i, e) { h0 && console.log(i, e); const t = []; u1(t6, i, e, t); const s = await Promise.all(t); return typeof e == "string" && s.length === 1 ? s[0] : s } function u1(i, e, t, s) { if (typeof t == "object" && t !== void 0 && t !== null) for (const r of Object.keys(t)) { const n = t[r]; if (typeof n == "string") { const o = oB(e, n); if (o != null) typeof o.then == "function" ? s.push(o.then(a => t[r] = a)) : t[r] = o; else for (const a of i) { const l = d1(a.prefix, n); if (l >= 0) { h0 && console.log(a, l, a.dependencyName), s.push(e?.getDependency(a.dependencyName, l).then(c => (t[r] = c, c))); break } } } else if (Array.isArray(n)) for (let o = 0; o < n.length; o++) { const a = n[o], l = oB(e, a); if (l !== null) { typeof l.then == "function" ? s.push(l.then(c => n[o] = c)) : n[o] = l; continue } for (const c of i) { const h = d1(c.prefix, a); if (h >= 0) { h0 && console.log(c, h, c.dependencyName), s.push(e?.getDependency(c.dependencyName, h).then(d => n[o] = d)); break } } typeof a == "object" && u1(i, e, a, s) } else typeof n == "object" && u1(i, e, n, s) } else typeof t == "string" && i6(i, e, t, s) } function oB(i, e) { if (i && i.plugins && typeof e == "string") { for (const t of e6) if (e.startsWith(t)) { let s = e.substring(t.length); const r = s.indexOf("/"); r >= 0 && (s = s.substring(0, r)); const n = i.plugins[s]; if (ir && console.log(s, n), typeof n?.resolve == "function") { const o = e.substring(t.length + s.length + 1); return n.resolve(i, o) } break } } return null } function i6(i, e, t, s) { for (const r of i) { const n = d1(r.prefix, t); if (n >= 0) return h0 && console.log(r, n, r.dependencyName), s.push(e?.getDependency(r.dependencyName, n).then(o => o)), !0 } return !1 } function d1(i, e) { if (typeof e == "string" && e.startsWith(i)) { const t = e.substring(i.length), s = Number.parseInt(t); if (s >= 0) return s } return -1 } class s6 { constructor() { u(this, "_types", {}) } add(e, t) { const s = this._types[e]; s === void 0 ? this._types[e] = t : s !== t && console.warn("Type name exists multiple times in your project and may lead to runtime errors:", e) } get(e) { return this._types[e] } } const r6 = Symbol("BuiltInType"), Q = new s6, p1 = "NEEDLE_persistent_assets"; function n6(i) { return i?.___persistentAsset === !0 } class o6 { constructor(e) { u(this, "parser"), this.parser = e } get name() { return p1 } async afterRoot(e) { var t, s; if (!((s = (t = this.parser) == null ? void 0 : t.json) != null && s.extensions)) return; const r = this.parser.json.extensions[p1]; if (!r) return; ir && console.log(r); const n = new Array; for (const o of r?.assets) { const a = h1(this.parser, o); a && n.push(a) } await Promise.all(n) } resolve(e, t) { const s = Number.parseInt(t); if (s >= 0) { ir && console.log(t); const r = e.json.extensions[p1]; if (r) { const n = r?.assets[s]; if (n && typeof n == "object") { n.___persistentAsset = !0; const o = n.__type; o && Q.get(o) } return n } } return null } } const Ga = oe("debugserializer"); class a6 { constructor() { u(this, "typeMap", {}) } register(e, t) { if (this.typeMap[e] !== void 0) { if (this.typeMap[e] === t) return; console.warn("Type " + e + " is already registered", t, this.typeMap[e]) } Ga && console.log("Register type serializer for " + e, t), this.typeMap[e] = t } getSerializer(e) { if (e) return this.typeMap[e] } getSerializerForConstructor(e, t = 0) { var s; if (t > 20) return; if (!e || !e.constructor) { Ga && console.log("invalid type"); return } const r = e.name ?? ((s = e.constructor) == null ? void 0 : s.name); if (!r) { Ga && console.log("invalid name", r); return } const n = this.getSerializer(r); if (n !== void 0) return Ga && console.log("FOUND " + r, e.name, e.constructor.name, n, this.typeMap), n; let o = Object.getPrototypeOf(e); if (!(o.prototype || o.constructor)) { Ga && console.warn("No prototype for " + r, e, e.name, e.prototype, e.constructor.name); return } const a = o.prototype ?? o.constructor; if (a !== e) { const l = this.getSerializerForConstructor(a, ++t); if (l) { Ga && console.log("FOUND " + a.constructor.name, a.name, a, l); const c = a.name ?? a.constructor.name; c === "Function" ? console.error("Registering Function is not allowed, something went wrong", e, a, l) : this.register(c, l) } return l } } } const u0 = new a6; class $l { constructor(e) { if (Array.isArray(e)) for (const t of e) u0.register(t.name, this); else u0.register(e.name, this) } } class l6 { constructor() { u(this, "isDevMode", dr()), u(this, "cache", {}) } registerDefinedKeys(e, t) { this.isDevMode && this.cache[e] === void 0 && (this.cache[e] = Object.keys(t)) } getDefinedKey(e, t) { return this.cache[e] === void 0 ? !1 : this.cache[e].includes(t) } } class aB { constructor(e) { u(this, "root"), u(this, "gltf"), u(this, "gltfId"), u(this, "object"), u(this, "target"), u(this, "nodeId"), u(this, "nodeToObject"), u(this, "objectToNode"), u(this, "context"), u(this, "path"), u(this, "type"), u(this, "implementationInformation"), this.root = e } } function lB(i, e) { const t = i.$serializedTypes; if (t === void 0) return null; const s = {}; for (const r in t) { let n = i[r]; if (n != null && typeof n == "object") { const o = u0.getSerializerForConstructor(n); if (o) { s[r] = o.onSerialize(n, e); continue } } s[r] = n } return s.name = i.constructor.name, typeof i.guid == "string" && (s.guid = i.guid), s } const d0 = []; function cB(i, e) { if (!i) return e; typeof i.$serializedTypes == "object" && (e || (e = {}), Object.assign(e, i.$serializedTypes)); const t = Object.getPrototypeOf(i); return cB(t, e) } function p0(i, e, t) { if (!i) return !1; if (t.target = i, i.onBeforeDeserialize !== void 0) { const r = i.onBeforeDeserialize(e, t); if (typeof r == "boolean") return r } const s = cB(i); if (e) { if (typeof e.guid == "string" && (i.guid = e.guid), s) for (const r in s) { let n = function (l) { const c = l.type; return c ? f1(a, c, t, void 0, i[r]) : f1(a, l, t, void 0, i[r]) }; const o = s[r], a = e[r]; if (Ga && console.log(r, a, i, o), !(i[r] !== void 0 && a === void 0) && (t.type = void 0, t.path = r, !(i.onBeforeDeserializeMember !== void 0 && i.onBeforeDeserializeMember(r, a, t) === !0))) { if (o === null) i[r] = a; else { if (Array.isArray(o)) for (let l = 0; l < o.length; l++) { const c = o[l], h = n(c); if (h !== void 0 || l === o.length - 1) { i[r] = h; break } } else i[r] = n(o); d0.length = 0 } i.onAfterDeserializeMember !== void 0 && i.onAfterDeserializeMember(r, a, t) } } u6(i, e) } return h6(i, e, t.implementationInformation), i.onAfterDeserialize !== void 0 && i.onAfterDeserialize(e, t), t.path = void 0, !0 } const c6 = oe("noerrors"); function h6(i, e, t) {
  var s; if (c6 || !e || dr() === !1 || !i || i.constructor && i.constructor[r6] === !0) return; const r = (s = i.constructor) == null ? void 0 : s.name, n = Object.getOwnPropertyNames(e); for (const o of n) {
    if (o === "sourceId") continue; const a = i[o]; if (a == null) continue; const l = e[o]; if (t?.getDefinedKey(r, o) === !1) { const c = o.charAt(0).toUpperCase() + o.slice(1); t.getDefinedKey(r, c) && (Ea(Ro.Warn, '<strong>Please rename</strong> "' + c + '" to "' + o + '" in ' + r), console.warn('Please use lowercase for field: "' + c + '" in ' + r, l, i)); continue } if (l != null) {
      if (typeof l == "object" && (a === void 0 || !a.isObject3D) && (typeof l.node == "number" || typeof l.guid == "string")) {
        if (l.could_not_resolve) continue; if (!(a !== void 0 && Object.keys(a).length > 1)) {
          Ea(Ro.Warn, `<strong>Missing serialization for object reference!</strong>

Please change to: 
@serializable(Object3D)
${o}? : Object3D;

in script ${r}.ts
<a href="https://docs.needle.tools/serializable" target="_blank">documentation</a>`), console.warn(r, o, i[o], i); continue
        }
      } if (typeof a == "string" && (l.endsWith(".gltf") || l.endsWith(".glb"))) {
        Ea(Ro.Warn, `<strong>Missing serialization for object reference!</strong>

Please change to: 
@serializable(AssetReference)
${o}? : AssetReference;

in script ${r}.ts
<a href="https://docs.needle.tools/serializable" target="_blank">documentation</a>`), console.warn(r, o, i[o], i); continue
      }
    }
  }
} function u6(i, e) { for (const t of Object.keys(e)) { const s = e[t]; if (typeof s == "object" && s !== null && s !== void 0) { const r = i[t]; if (!r) { Ga && console.log(t, "is undefined on", i); continue } for (const n of Object.keys(s)) if (r[n] === void 0 && hB(s[n]) && !hB(r)) { const o = d6(r, n); if (o && (o?.writable === void 0 || o?.writable === !1) && o.set === void 0) { Ga && console.warn('Property is not writable "' + n + '"', r, o, s[n], r[n]); continue } r[n] = s[n] } } } } function d6(i, e) { for (; i;) { const t = Object.getOwnPropertyDescriptor(i, e); if (t) return t; i = Object.getPrototypeOf(i) } } function hB(i) { switch (typeof i) { case "number": case "string": case "boolean": return !0 }return !1 } function f1(i, e, t, s, r) { let n = typeof e == "function" && e.prototype === void 0, o = e; if (n) try { if (o = e?.call(e, r), n = !1, o == null) return } catch (h) { console.error("Error in callback", h, i) } if (t.type = o, !n && r instanceof o) return r; if (r && typeof r == "object" && n6(r)) { if (r.__concreteInstance) return r.__concreteInstance; const h = r; if (!h.$serializedTypes && o.prototype.$serializedTypes && (h.$serializedTypes = o.prototype.$serializedTypes), h.$serializedTypes && p0(h, i, t), r && o !== void 0) try { const d = new o; ir && console.log("Create concrete instance for persistent asset", r, "instance:", d), Rh(d, r), r.__concreteInstance = d, r = d } catch (d) { console.error("Error creating instance or creating values on instance", d, r, o) } return r } if (s || (s = { serializer: u0.getSerializerForConstructor(o) }), Array.isArray(i)) { const h = []; for (let d = 0; d < i.length; d++) { const p = i[d], f = f1(p, e, t, s, p); h.push(f) } return h } const a = s.serializer; if (a) return a.onDeserialize(i, t); let l; if (i && (i.isMaterial || i.isTexture || i.isObject3D)) l = i; else { if (i === void 0) return; if (i === null && (o === Tt || o === Nt || o === ye || o === En)) return null; l = new o(...p6(i)) } const c = l; return c.$serializedTypes && p0(c, i, t), l } function p6(i) { if (d0.length = 0, typeof i == "object" && i !== null && i !== void 0) for (const e of Object.keys(i)) d0.push(i[e]); return d0 } const g1 = Symbol("assigned component properties"); function Rh(i, e, t) { var s; if (e == null || i == null) return; i[g1] = !0; const r = ((s = i.constructor) == null ? void 0 : s.name) ?? "unknown"; t?.registerDefinedKeys(r, i); for (const n of Object.keys(e)) { const o = f6(i, n); typeof o?.value != "function" && (!o || o.writable === !0 || o?.set !== void 0) && (i[n] = e[n]) } delete i[g1] } function f6(i, e) { let t; do t = Object.getOwnPropertyDescriptor(i, e); while (!t && (i = Object.getPrototypeOf(i))); return t } const In = oe("debuginput"); class f0 { constructor(e) { u(this, "key"), u(this, "keyType"), u(this, "source"), this.key = e.key, this.keyType = e.type, this.source = e } } var Lo = (i => (i.PointerDown = "pointerdown", i.PointerUp = "pointerup", i.PointerMove = "pointermove", i.KeyDown = "keydown", i.KeyUp = "keyup", i.KeyPressed = "keypress", i))(Lo || {}), uB = (i => (i.Mouse = "mouse", i.Touch = "touch", i))(uB || {}); class dB extends EventTarget { constructor(e) { super(), u(this, "_doubleClickTimeThreshold", .2), u(this, "_longPressTimeThreshold", 1), u(this, "_specialCursorTrigger", 0), u(this, "context"), u(this, "_pointerDown", [!1]), u(this, "_pointerUp", [!1]), u(this, "_pointerClick", [!1]), u(this, "_pointerDoubleClick", [!1]), u(this, "_pointerPressed", [!1]), u(this, "_pointerPositions", [new W]), u(this, "_pointerPositionsLastFrame", [new W]), u(this, "_pointerPositionsDelta", [new W]), u(this, "_pointerPositionsRC", [new W]), u(this, "_pointerPositionDown", [new W]), u(this, "_pointerDownTime", []), u(this, "_pointerUpTime", []), u(this, "_pointerUpTimestamp", []), u(this, "_pointerIds", []), u(this, "_pointerTypes", [""]), u(this, "_mouseWheelChanged", [!1]), u(this, "_mouseWheelDeltaY", [0]), u(this, "_pointerEvent", []), u(this, "_pointerUsed", []), u(this, "keysPressed", {}), this.context = e, this.context.post_render_callbacks.push(this.onEndOfFrame.bind(this)), window.addEventListener("touchstart", this.onTouchStart.bind(this), !1), window.addEventListener("touchmove", this.onTouchMove.bind(this), { passive: !0 }), window.addEventListener("touchend", this.onTouchUp.bind(this), !1), window.addEventListener("mousedown", this.onMouseDown.bind(this), !1), window.addEventListener("mousemove", this.onMouseMove.bind(this), !1), window.addEventListener("mouseup", this.onMouseUp.bind(this), !1), window.addEventListener("wheel", this.onMouseWheel.bind(this), { passive: !0 }), window.addEventListener("keydown", this.onKeyDown.bind(this), !1), window.addEventListener("keypress", this.onKeyPressed.bind(this), !1), window.addEventListener("keyup", this.onKeyUp.bind(this), !1), window.addEventListener("blur", this.onLostFocus.bind(this)) } get mousePosition() { return this._pointerPositions[0] } get mousePositionRC() { return this._pointerPositionsRC[0] } get mouseDown() { return this._pointerDown[0] } get mouseUp() { return this._pointerUp[0] } get mouseClick() { return this._pointerClick[0] } get mouseDoubleClick() { return this._pointerDoubleClick[0] } get mousePressed() { return this._pointerPressed[0] } get mouseWheelChanged() { return this.getMouseWheelChanged(0) } setCursorPointer() { this._specialCursorTrigger += 1, this.context.domElement.style.cursor = "pointer" } setCursorNormal() { this._specialCursorTrigger -= 1, this._specialCursorTrigger = Math.max(0, this._specialCursorTrigger), this._specialCursorTrigger === 0 && (this.context.domElement.style.cursor = "default") } setPointerUsed(e, t = !0) { if (e >= this._pointerUsed.length) { if (e >= this._pointerIds.length) return; for (; this._pointerUsed.length <= e;)this._pointerUsed.push(!1) } this._pointerUsed[e] = t } getPointerUsed(e) { return e >= this._pointerUsed.length ? !1 : this._pointerUsed[e] } getPointerPressedCount() { let e = 0; for (let t = 0; t < this._pointerPressed.length; t++)this._pointerPressed[t] && e++; return e } getPointerPosition(e) { return e >= this._pointerPositions.length ? null : this._pointerPositions[e] } getPointerPositionLastFrame(e) { return e >= this._pointerPositionsLastFrame.length ? null : this._pointerPositionsLastFrame[e] } getPointerPositionDelta(e) { return e >= this._pointerPositionsDelta.length ? null : this._pointerPositionsDelta[e] } getPointerPositionRC(e) { return e >= this._pointerPositionsRC.length ? null : this._pointerPositionsRC[e] } getPointerDown(e) { return e >= this._pointerDown.length ? !1 : this._pointerDown[e] } getPointerUp(e) { return e >= this._pointerUp.length ? !1 : this._pointerUp[e] } getPointerPressed(e) { return e >= this._pointerPressed.length ? !1 : this._pointerPressed[e] } getPointerClicked(e) { return e >= this._pointerClick.length ? !1 : this._pointerClick[e] } getPointerDoubleClicked(e) { return e >= this._pointerDoubleClick.length ? !1 : this._pointerDoubleClick[e] } getPointerDownTime(e) { return e >= this._pointerDownTime.length ? -1 : this._pointerDownTime[e] } getPointerUpTime(e) { return e >= this._pointerUpTime.length ? -1 : this._pointerUpTime[e] } getPointerLongPress(e) { return e >= this._pointerDownTime.length ? !1 : this.getPointerPressed(e) && this.context.time.time - this._pointerDownTime[e] > this._longPressTimeThreshold } getIsMouse(e) { return e < 0 || e >= this._pointerTypes.length ? !1 : this._pointerTypes[e] === "mouse" } getIsTouch(e) { return e < 0 || e >= this._pointerTypes.length ? !1 : this._pointerTypes[e] === "touch" } getTouchesPressedCount() { let e = 0; for (let t = 0; t < this._pointerPressed.length; t++)this._pointerPressed[t] && this.getIsTouch(t) && e++; return e } getMouseWheelChanged(e = 0) { return e >= this._mouseWheelChanged.length ? !1 : this._mouseWheelChanged[e] } getMouseWheelDeltaY(e = 0) { return e >= this._mouseWheelDeltaY.length ? 0 : this._mouseWheelDeltaY[e] } getPointerEvent(e) { if (!(e >= this._pointerEvent.length)) return this._pointerEvent[e] ?? void 0 } *foreachPointerId(e) { for (let t = 0; t < this._pointerTypes.length; t++)if (this._pointerIsActive(t)) { if (e !== void 0) { const s = this._pointerTypes[t]; if (Array.isArray(e)) { let r = !1; for (const n of e) if (s === n) { r = !0; break } if (!r) continue } else if (e !== s) continue } yield t } } *foreachTouchId() { for (let e = 0; e < this._pointerTypes.length; e++)this._pointerTypes[e] === "touch" && this._pointerIsActive[e] && (yield e) } _pointerIsActive(e) { return e < 0 ? !1 : this._pointerPressed[e] || this._pointerDown[e] || this._pointerUp[e] } getKeyDown() { for (const e in this.keysPressed) { const t = this.keysPressed[e]; if (t.startFrame === this.context.time.frameCount) return t.key } return null } getKeyPressed() { for (const e in this.keysPressed) { const t = this.keysPressed[e]; if (t.pressed) return t.key } return null } isKeyDown(e) { var t; if (!this.context.application.isVisible || !this.context.application.hasFocus) return !1; const s = this.getCodeForCommonKeyName(e); if (s !== null) { for (const r of s) if (this.isKeyDown(r)) return !0; return !1 } return ((t = this.keysPressed[e]) == null ? void 0 : t.startFrame) === this.context.time.frameCount && this.keysPressed[e].pressed } isKeyUp(e) { var t; if (!this.context.application.isVisible || !this.context.application.hasFocus) return !1; const s = this.getCodeForCommonKeyName(e); if (s !== null) { for (const r of s) if (this.isKeyUp(r)) return !0; return !1 } return ((t = this.keysPressed[e]) == null ? void 0 : t.frame) === this.context.time.frameCount && !this.keysPressed[e].pressed } isKeyPressed(e) { var t; if (!this.context.application.isVisible || !this.context.application.hasFocus) return !1; const s = this.getCodeForCommonKeyName(e); if (s !== null) { for (const r of s) if (this.isKeyPressed(r)) return !0; return !1 } return (t = this.keysPressed[e]) == null ? void 0 : t.pressed } getCodeForCommonKeyName(e) { if (e.length === 1) { if (e >= "0" && e <= "9") return ["Digit" + e]; if (e >= "a" && e <= "z") return ["Key" + e.toUpperCase()]; if (e == " ") return ["Space"] } switch (e) { case "Shift": return ["ShiftLeft", "ShiftRight"]; case "Control": return ["ControlLeft", "ControlRight"]; case "Alt": return ["AltLeft", "AltRight"] }return null } createPointerDown(e) { In && Ls("Create Pointer down"), this.onDown(e) } createPointerMove(e) { In && Ls("Create Pointer move"), this.onMove(e) } createPointerUp(e) { In && Ls("Create Pointer up"), this.onUp(e) } convertScreenspaceToRaycastSpace(e) { e.x = (e.x - this.context.domX) / this.context.domWidth * 2 - 1, e.y = -((e.y - this.context.domY) / this.context.domHeight) * 2 + 1 } onLostFocus() { for (const e in this.keysPressed) this.keysPressed[e].pressed = !1 } onEndOfFrame() { for (let e = 0; e < this._pointerUp.length; e++)this._pointerUp[e] = !1; for (let e = 0; e < this._pointerDown.length; e++)this._pointerDown[e] = !1; for (let e = 0; e < this._pointerClick.length; e++)this._pointerClick[e] = !1; for (let e = 0; e < this._pointerDoubleClick.length; e++)this._pointerDoubleClick[e] = !1; for (const e of this._pointerPositionsDelta) e.set(0, 0); for (let e = 0; e < this._mouseWheelChanged.length; e++)this._mouseWheelChanged[e] = !1; for (let e = 0; e < this._mouseWheelDeltaY.length; e++)this._mouseWheelDeltaY[e] = 0 } canReceiveInput(e) { return e.target === this.context.renderer.domElement } onKeyDown(e) { if (!this.context.application.hasFocus) return; const t = this.keysPressed[e.code]; t && t.pressed || (this.keysPressed[e.code] = { pressed: !0, frame: this.context.time.frameCount + 1, startFrame: this.context.time.frameCount + 1, key: e.key, code: e.code }, this.onDispatchEvent("keydown", new f0(e))) } onKeyPressed(e) { if (!this.context.application.hasFocus) return; const t = this.keysPressed[e.code]; t && (t.pressed = !0, t.frame = this.context.time.frameCount + 1, this.onDispatchEvent("keypress", new f0(e))) } onKeyUp(e) { if (!this.context.application.hasFocus) return; const t = this.keysPressed[e.code]; t && (t.pressed = !1, t.frame = this.context.time.frameCount + 1, this.onDispatchEvent("keyup", new f0(e))) } onMouseWheel(e) { if (this.canReceiveInput(e) === !1) return; this._mouseWheelDeltaY.length <= 0 && this._mouseWheelDeltaY.push(0), this._mouseWheelChanged.length <= 0 && this._mouseWheelChanged.push(!1), this._mouseWheelChanged[0] = !0; const t = this._mouseWheelDeltaY[0]; this._mouseWheelDeltaY[0] = t + e.deltaY } onTouchStart(e) { if (!(e.changedTouches.length <= 0) && this.canReceiveInput(e) !== !1) for (let t = 0; t < e.changedTouches.length; t++) { const s = e.changedTouches[t], r = this.getPointerIndex(s.identifier); In && Ls(`touch start #${r}, identifier:${s.identifier}`); const n = { button: r, clientX: s.clientX, clientY: s.clientY, pointerType: "touch", source: e }; this.onDown(n) } } onTouchMove(e) { if (!(e.changedTouches.length <= 0)) for (let t = 0; t < e.changedTouches.length; t++) { const s = e.changedTouches[t], r = { button: this.getPointerIndex(s.identifier), clientX: s.clientX, clientY: s.clientY, pointerType: "touch", source: e }; this.onMove(r) } } onTouchUp(e) { if (!(e.changedTouches.length <= 0)) for (let t = 0; t < e.changedTouches.length; t++) { const s = e.changedTouches[t], r = this.getPointerIndex(s.identifier); if (!this.isNewEvent(e.timeStamp, r, this._pointerUpTimestamp)) continue; In && Ls(`touch up #${r}, identifier:${s.identifier}`); const n = { button: r, clientX: s.clientX, clientY: s.clientY, pointerType: "touch", source: e }; this.onUp(n) } } onMouseDown(e) { if (e.defaultPrevented || this.canReceiveInput(e) === !1) return; let t = e.button; this.onDown({ button: t, clientX: e.clientX, clientY: e.clientY, pointerType: "mouse", source: e }) } onMouseMove(e) { if (e.defaultPrevented) return; const t = { button: e.button, clientX: e.clientX, clientY: e.clientY, pointerType: "mouse", source: e, movementX: e.movementX, movementY: e.movementY }; this.onMove(t) } onMouseUp(e) { if (e.defaultPrevented) return; let t = e.button; this.isNewEvent(e.timeStamp, t, this._pointerUpTimestamp) && this.onUp({ button: t, clientX: e.clientX, clientY: e.clientY, pointerType: "mouse", source: e }) } isNewEvent(e, t, s) { for (; s.length <= t;)s.push(-1); return e === s[t] ? !1 : (s[t] = e, !0) } isInRect(e) { if (this.context.isInXR) return !0; const t = this.context.domElement.getBoundingClientRect(), s = e.clientX, r = e.clientY, n = s >= t.x && s <= t.right && r >= t.y && r <= t.bottom; return In && !n && console.log("Not in rect", t, s, r), n } onDown(e) { var t; if (In && console.log(e.pointerType, "DOWN", e.button), !!this.isInRect(e)) { if (e.pointerType === "mouse") { const s = this._pointerUpTimestamp[e.button]; if (s > 0 && s === ((t = e.source) == null ? void 0 : t.timeStamp)) { In && console.log("Ignoring mouse.down for touch.up"); return } } for (this.setPointerState(e.button, this._pointerPressed, !0), this.setPointerState(e.button, this._pointerDown, !0), this.setPointerStateT(e.button, this._pointerEvent, e.source); e.button >= this._pointerTypes.length;)this._pointerTypes.push(e.pointerType); for (this._pointerTypes[e.button] = e.pointerType; e.button >= this._pointerPositionDown.length;)this._pointerPositionDown.push(new W); for (this._pointerPositionDown[e.button].set(e.clientX, e.clientY); e.button >= this._pointerPositions.length;)this._pointerPositions.push(new W); this._pointerPositions[e.button].set(e.clientX, e.clientY), e.button >= this._pointerDownTime.length && this._pointerDownTime.push(0), this._pointerDownTime[e.button] = this.context.time.time, this.updatePointerPosition(e), this.onDispatchEvent("pointerdown", e) } } onMove(e) { const t = this.getPointerPressed(e.button); t === !1 && !this.isInRect(e) || e.pointerType === "touch" && !t || (In && console.log(e.pointerType, "MOVE", e.button), this.updatePointerPosition(e), this.setPointerStateT(e.button, this._pointerEvent, e.source), this.onDispatchEvent("pointermove", e)) } onUp(e) { var t; if (((t = this._pointerIds) == null ? void 0 : t.length) >= e.button && (this._pointerIds[e.button] = -1), !this._pointerPressed[e.button]) { In && console.log(e.pointerType, "UP", e.button, "was not down"); return } for (In && console.log(e.pointerType, "UP", e.button), this.setPointerState(e.button, this._pointerPressed, !1), this.setPointerStateT(e.button, this._pointerEvent, e.source), this.setPointerState(e.button, this._pointerUp, !0); e.button >= this._pointerUsed.length;)this._pointerUsed.push(!1); if (this.setPointerState(e.button, this._pointerUsed, !1), this.updatePointerPosition(e), !this._pointerPositionDown[e.button]) { In && ao("Received pointer up event without matching down event for button: " + e.button), console.warn("Received pointer up event without matching down event for button: " + e.button); return } const s = e.clientX - this._pointerPositionDown[e.button].x, r = e.clientY - this._pointerPositionDown[e.button].y; if (e.button >= this._pointerUpTime.length && this._pointerUpTime.push(-99), Math.abs(s) < 5 && Math.abs(r) < 5) { this.setPointerState(e.button, this._pointerClick, !0); const n = this._pointerUpTime[e.button], o = this.context.time.time - n; o < this._doubleClickTimeThreshold && o > 0 && this.setPointerState(e.button, this._pointerDoubleClick, !0) } this._pointerUpTime[e.button] = this.context.time.time, this.onDispatchEvent("pointerup", e) } updatePointerPosition(e) { for (; e.button >= this._pointerPositions.length;)this._pointerPositions.push(new W); for (; e.button >= this._pointerPositionsLastFrame.length;)this._pointerPositionsLastFrame.push(new W); for (; e.button >= this._pointerPositionsDelta.length;)this._pointerPositionsDelta.push(new W); const t = this._pointerPositionsLastFrame[e.button]; t.copy(this._pointerPositions[e.button]); const s = this._pointerPositionsDelta[e.button], r = e.clientX - t.x, n = e.clientY - t.y; s.x += r, s.y += n, this._pointerPositions[e.button].x = e.clientX, this._pointerPositions[e.button].y = e.clientY; const o = e.clientX, a = e.clientY; for (; e.button >= this._pointerPositionsRC.length;)this._pointerPositionsRC.push(new W); const l = this._pointerPositionsRC[e.button]; l.set(o, a), this.convertScreenspaceToRaycastSpace(l) } getPointerIndex(e) { const t = this._pointerIds; let s = -1; for (let r = 0; r < t.length; r++) { if (t[r] === e) return r; s === -1 && t[r] === -1 && (s = r) } return s !== -1 ? (t[s] = e, s) : (t.push(e), t.length - 1) } setPointerState(e, t, s) { for (; t.length <= e;)t.push(!1); t[e] = s } setPointerStateT(e, t, s) { for (; t.length <= e;)t.push(null); t[e] = s } onDispatchEvent(e, t) { const s = _t.Current; try { _t.Current = this.context; const r = new Event(e); Rh(r, t), this.dispatchEvent(r) } finally { _t.Current = s } } } class g6 { constructor() { u(this, "Rad2Deg", 180 / Math.PI), u(this, "Deg2Rad", Math.PI / 180), u(this, "Epsilon", 1e-5) } random() { return Math.random() } clamp(e, t, s) { return e < t ? t : e > s ? s : e } clamp01(e) { return this.clamp(e, 0, 1) } lerp(e, t, s) { return s = s < 0 ? 0 : s, s = s > 1 ? 1 : s, e + (t - e) * s } inverseLerp(e, t, s) { return (s - e) / (t - e) } remap(e, t, s, r, n) { return r + (n - r) * (e - t) / (s - t) } moveTowards(e, t, s) { return e += s, (s < 0 && e < t || s > 0 && e > t) && (e = t), e } toDegrees(e) { return e * 180 / Math.PI } toRadians(e) { return e * Math.PI / 180 } tan(e) { return Math.tan(e) } gammaToLinear(e) { return Math.pow(e, 2.2) } linearToGamma(e) { return Math.pow(e, 1 / 2.2) } } const Ke = new g6; function pB(i, e, t) { const s = i.length(), r = e.length(), n = Ke.lerp(s, r, t); return i.lerp(e, t).normalize().multiplyScalar(n) } const m6 = new we().setFromAxisAngle(new S(0, 1, 0), Math.PI); function v6(i, e) { i.lookAt(e), i.quaternion.multiply(m6) } const m1 = new To(() => new S, 100); function xt(i, e = null, t = !0) { const s = e ?? m1.get(); return i ? i.parent ? (t && i.updateWorldMatrix(!0, !1), i.matrixWorldNeedsUpdate && i.updateMatrixWorld(), s.setFromMatrixPosition(i.matrixWorld), s) : s.copy(i.position) : s.set(0, 0, 0) } function ts(i, e) { if (!i) return; const t = m1.get(); e !== t && t.copy(e), (i?.parent ?? i).worldToLocal(t), i.position.set(t.x, t.y, t.z) } function dd(i, e, t, s) { const r = m1.get(); r.set(e, t, s), ts(i, r) } const g0 = new To(() => new we, 100), Ph = new we, v1 = new we; function _s(i, e = null) { if (!i) return g0.get().identity(); const t = e ?? g0.get(); return i.parent ? (i.getWorldQuaternion(t), t) : t.copy(i.quaternion) } function Dr(i, e) { if (!i) return; e !== Ph && Ph.copy(e); const t = Ph, s = i?.parent; s?.getWorldQuaternion(v1), v1.invert(); const r = v1.multiply(t); i.quaternion.set(r.x, r.y, r.z, r.w) } function fB(i, e, t, s, r) { Ph.set(e, t, s, r), Dr(i, Ph) } const A6 = new To(() => new S, 100), y6 = new S; function Fs(i, e = null) { return e || (e = A6.get()), i ? i.parent ? (i.getWorldScale(e), e) : e.copy(i.scale) : e.set(0, 0, 0) } function A1(i, e) { if (!i) return; if (!i.parent) { i.scale.copy(e); return } const t = y6; i.parent.getWorldScale(t), i.scale.copy(e), i.scale.divide(t) } const b6 = new S, gB = new we; function _6(i) { return _s(i, gB), b6.set(0, 0, 1).applyQuaternion(gB) } const x6 = new To(() => new S, 100), mB = new we; function w6(i, e) { return e || (e = x6.get().set(0, 0, 1)), _s(i, mB), e.applyQuaternion(mB) } const vB = new ps, AB = new ps, C6 = new S; function yB(i) { const e = g0.get(); return i.getWorldQuaternion(e), AB.setFromQuaternion(e), AB } function bB(i, e) { const t = g0.get(); Dr(i, t.setFromEuler(e)) } function y1(i) { const e = yB(i), t = C6; return t.set(e.x, e.y, e.z), t.x = Ke.toDegrees(t.x), t.y = Ke.toDegrees(t.y), t.z = Ke.toDegrees(t.z), t } function S6(i, e) { m0(i, e.x, e.y, e.z, !0) } function m0(i, e, t, s, r = !0) { r && (e = Ke.toRadians(e), t = Ke.toRadians(t), s = Ke.toRadians(s)), vB.set(e, t, s), Ph.setFromEuler(vB), Dr(i, Ph) } function v0(i, e = !0) { i && (e ? function t(s) { console.groupCollapsed((s.name ? s.name : "(no name : " + s.type + ")") + " %o", s), s.children.forEach(t), console.groupEnd() }(i) : i.traverse(function (t) { for (var s = "|___", r = t; r.parent !== null;)s = "	" + s, r = r.parent; console.log(s + t.name + " <" + t.type + ">") })) } function _B(i) { if (i) { const e = i; return e.blendMode !== void 0 && e.clampWhenFinished !== void 0 && e.enabled !== void 0 && e.fadeIn !== void 0 && e.getClip !== void 0 } return !1 } const Wf = class { static createBlitMaterial(i) { return new Vt({ uniforms: { map: new Ce(null) }, vertexShader: this.vertex, fragmentShader: i }) } static copyTexture(i, e) { const t = e ?? this.blipMaterial; t.uniforms.map.value = i, t.needsUpdate = !0, t.uniformsNeedUpdate = !0; const s = this.mesh; s.material = t, s.frustumCulled = !1, this.scene.children.length = 0, this.scene.add(s), this.renderer.setSize(i.image.width, i.image.height), this.renderer.clear(), this.renderer.render(this.scene, this.perspectiveCam); const r = new Nt(this.renderer.domElement); return r.name = "Copy", r.needsUpdate = !0, r } static textureToCanvas(i, e) { if (!i) return null; (e === !0 || i.isCompressedTexture === !0) && (i = xB(i)); const t = i.image; if (M6(t)) { const s = document.createElement("canvas"); s.width = t.width, s.height = t.height; const r = s.getContext("2d"); return r ? (r.drawImage(t, 0, 0, t.width, t.height, 0, 0, s.width, s.height), s) : (console.error("Failed getting canvas 2d context"), null) } return null } }; let lo = Wf; u(lo, "planeGeometry", new ks(2, 2, 1, 1)), u(lo, "renderer", new $u({ antialias: !1 })), u(lo, "perspectiveCam", new Xt), u(lo, "scene", new Cn), u(lo, "vertex", `
    varying vec2 vUv;
    void main(){
        vUv = uv;
        gl_Position = vec4(position.xy * 1.0,0.,.999999);
    }`), u(lo, "fragment", `
    uniform sampler2D map; 
    varying vec2 vUv;
    void main(){ 
        vec2 uv = vUv;
        uv.y = 1.0 - uv.y;
        gl_FragColor = texture2D( map, uv);
        // gl_FragColor = vec4(uv.xy, 0, 1);
    }`), u(lo, "blipMaterial", new Vt({ uniforms: { map: new Ce(null) }, vertexShader: Wf.vertex, fragmentShader: Wf.fragment })), u(lo, "mesh", new ye(Wf.planeGeometry, Wf.blipMaterial)); function xB(i) { return lo.copyTexture(i) } function E6(i, e = !1) { return lo.textureToCanvas(i, e) } function M6(i) { return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas || typeof ImageBitmap < "u" && i instanceof ImageBitmap } const I6 = oe("debugphysics"), wB = new bn; class co { constructor() { u(this, "ray"), u(this, "cam"), u(this, "screenPoint"), u(this, "raycaster"), u(this, "results"), u(this, "targets"), u(this, "recursive", !0), u(this, "minDistance"), u(this, "maxDistance"), u(this, "lineThreshold"), u(this, "layerMask"), u(this, "ignore") } screenPointFromOffset(e, t) { this.screenPoint === void 0 && (this.screenPoint = new W), this.screenPoint.x = e / window.innerWidth * 2 - 1, this.screenPoint.y = -(t / window.innerHeight) * 2 + 1 } setLayer(e) { wB.set(e), this.layerMask = wB } setMask(e) { this.layerMask || (this.layerMask = new bn); const t = this.layerMask; t ? t.mask = e : this.layerMask = e } } u(co, "AllLayers", 4294967295); class CB { constructor(e, t, s) { u(this, "distance"), u(this, "point"), u(this, "object"), this.object = e, this.distance = t, this.point = s } } class SB { constructor(e) { u(this, "context"), u(this, "engine"), u(this, "raycaster", new hd), u(this, "defaultRaycastOptions", new co), u(this, "targetBuffer", new Array(1)), u(this, "defaultThresholds", { Mesh: {}, Line: { threshold: 0 }, LOD: {}, Points: { threshold: 0 }, Sprite: {} }), u(this, "sphereResults", new Array), u(this, "sphereMask", new bn), u(this, "tempBoundingBox", new er), this.context = e } raycastPhysicsFast(e, t = void 0, s = 1 / 0, r = !0) { var n; return ((n = this.context.physics.engine) == null ? void 0 : n.raycast(e, t, s, r)) ?? null } raycastPhysicsFastAndGetNormal(e, t = void 0, s = 1 / 0, r = !0) { var n; return ((n = this.context.physics.engine) == null ? void 0 : n.raycastAndGetNormal(e, t, s, r)) ?? null } sphereOverlapPhysics(e, t) { var s; return ((s = this.context.physics.engine) == null ? void 0 : s.sphereOverlap(e, t)) ?? null } sphereOverlap(e, t, s = !0) { if (this.sphereResults.length = 0, !this.context.scene) return this.sphereResults; const r = new Po(e, t), n = this.sphereMask; n.enableAll(), n.disable(2); for (const o of this.context.scene.children) this.onSphereOverlap(o, r, n, this.sphereResults, s); return this.sphereResults.sort((o, a) => o.distance - a.distance) } onSphereOverlap(e, t, s, r, n) { if (e.type === "Mesh" && e.layers.test(s)) { const o = e, a = o.geometry; if (a.boundingBox || a.computeBoundingBox(), a.boundingBox) { o.matrixWorldNeedsUpdate && o.updateMatrixWorld(); const l = this.tempBoundingBox.copy(a.boundingBox).applyMatrix4(o.matrixWorld); if (t.intersectsBox(l)) { const c = xt(e), h = c.distanceTo(t.center), d = new CB(e, h, c); if (r.push(d), !n) return } } } if (e.children) for (const o of e.children) { const a = r.length; if (this.onSphereOverlap(o, t, s, r, n), a != r.length && !n) return } } raycastFromRay(e, t = null) { const s = t ?? this.defaultRaycastOptions; return s.ray = e, this.raycast(s) } raycast(e = null) { e || (e = this.defaultRaycastOptions); const t = e.screenPoint ?? this.context.input.mousePositionRC, s = e.raycaster ?? this.raycaster; if (s.near = e.minDistance ?? 0, s.far = e.maxDistance ?? 1 / 0, s.params = this.defaultThresholds, e.lineThreshold ? s.params.Line = { threshold: e.lineThreshold } : s.params.Line = { threshold: 0 }, e.ray) s.ray.copy(e.ray); else { const a = e.cam ?? this.context.mainCamera; if (!a) return I6 && console.error("Can not perform raycast - no main camera found"), this.defaultRaycastOptions.results && (this.defaultRaycastOptions.results.length = 0), this.defaultRaycastOptions.results ?? []; s.setFromCamera(t, a) } let r = e.targets; r || (r = this.targetBuffer, r[0] = this.context.scene); let n = e.results; n || (this.defaultRaycastOptions.results || (this.defaultRaycastOptions.results = new Array), n = this.defaultRaycastOptions.results), e.layerMask !== void 0 ? e.layerMask instanceof bn ? s.layers.mask = e.layerMask.mask : s.layers.mask = e.layerMask : (s.layers.enableAll(), s.layers.disable(2)), n.length = 0, s.intersectObjects(r, e.recursive, n); const o = e.ignore; return o !== void 0 && o.length > 0 && (n = n.filter(a => !o.includes(a.object))), n } } const EB = oe("timescale"); let b1 = 1; typeof EB == "number" && (b1 = EB); class MB { constructor() { u(this, "deltaTime", 0), u(this, "time", 0), u(this, "timeScale", 1), u(this, "frame", 0), u(this, "clock", new e0), u(this, "_smoothedFps", 0), u(this, "_smoothedDeltaTime", 0), u(this, "_fpsSamples", []), u(this, "_fpsSampleIndex", 0), typeof b1 == "number" && (this.timeScale = b1) } get realtimeSinceStartup() { return this.clock.elapsedTime } get frameCount() { return this.frame } get smoothedFps() { return this._smoothedFps } get smoothedDeltaTime() { return 1 / this._smoothedFps } update() { this.deltaTime = this.clock.getDelta(), this.deltaTime = Math.min(.1, this.deltaTime), this.deltaTime *= this.timeScale, this.deltaTime <= 0 && (this.deltaTime = 1e-12), this.frame += 1, this.time += this.deltaTime, this._fpsSamples.length < 30 ? this._fpsSamples.push(this.deltaTime) : this._fpsSamples[this._fpsSampleIndex++ % 30] = this.deltaTime; let e = 0; for (let t = 0; t < this._fpsSamples.length; t++)e += this._fpsSamples[t]; this._smoothedDeltaTime = e / this._fpsSamples.length, this._smoothedFps = 1 / this._smoothedDeltaTime } } var A0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function y0(i) { return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i } var IB = {}, TB = {}; Object.defineProperty(TB, "__esModule", { value: !0 }); var b0 = {}; Object.defineProperty(b0, "__esModule", { value: !0 }), b0.ConstantBackoff = void 0; var T6 = function () { function i(e) { this.reset = function () { }, this.backoff = e } return i.prototype.next = function () { return this.backoff }, i }(); b0.ConstantBackoff = T6; var _0 = {}; Object.defineProperty(_0, "__esModule", { value: !0 }), _0.ExponentialBackoff = void 0; var R6 = function () { function i(e, t) { this.initial = e, this.expMax = t, this.expCurrent = 1, this.current = this.initial } return i.prototype.next = function () { var e = this.current; return this.expMax > this.expCurrent++ && (this.current = this.current * 2), e }, i.prototype.reset = function () { this.expCurrent = 1, this.current = this.initial }, i }(); _0.ExponentialBackoff = R6; var x0 = {}; Object.defineProperty(x0, "__esModule", { value: !0 }), x0.LinearBackoff = void 0; var P6 = function () { function i(e, t, s) { this.initial = e, this.increment = t, this.maximum = s, this.current = this.initial } return i.prototype.next = function () { var e = this.current, t = this.current + this.increment; return this.maximum === void 0 ? this.current = t : t <= this.maximum && (this.current = t), e }, i.prototype.reset = function () { this.current = this.initial }, i }(); x0.LinearBackoff = P6; var RB = {}; Object.defineProperty(RB, "__esModule", { value: !0 }); var w0 = {}; Object.defineProperty(w0, "__esModule", { value: !0 }), w0.LRUBuffer = void 0; var B6 = function () { function i(e) { this.writePtr = 0, this.wrapped = !1, this.buffer = Array(e) } return i.prototype.len = function () { return this.wrapped ? this.buffer.length : this.writePtr }, i.prototype.cap = function () { return this.buffer.length }, i.prototype.read = function (e) { if (e == null || e.length === 0 || this.buffer.length === 0 || this.writePtr === 0 && !this.wrapped) return 0; for (var t = this.wrapped ? this.writePtr : 0, s = t - 1 < 0 ? this.buffer.length - 1 : t - 1, r = 0; r < e.length; r++) { var n = (t + r) % this.buffer.length; if (e[r] = this.buffer[n], n === s) return r + 1 } return e.length }, i.prototype.write = function (e) { if (e == null || e.length === 0 || this.buffer.length === 0) return 0; for (var t = e.length > this.buffer.length ? e.length - this.buffer.length : 0, s = 0; s < e.length - t; s++)this.buffer[this.writePtr] = e[t + s], this.writePtr = (this.writePtr + 1) % this.buffer.length, this.writePtr === 0 && (this.wrapped = !0); return e.length }, i.prototype.forEach = function (e) { if (this.writePtr === 0 && !this.wrapped) return 0; for (var t = this.wrapped ? this.writePtr : 0, s = this.wrapped ? t - 1 < 0 ? this.buffer.length - 1 : t - 1 : this.writePtr - 1, r = this.len(); e(this.buffer[t]), t !== s;)t = (t + 1) % this.buffer.length; return r }, i.prototype.clear = function () { this.writePtr = 0, this.wrapped = !1 }, i }(); w0.LRUBuffer = B6; var C0 = {}; Object.defineProperty(C0, "__esModule", { value: !0 }), C0.TimeBuffer = void 0; var k6 = function () { function i(e) { this.maxAge = e } return i.prototype.cap = function () { return Number.POSITIVE_INFINITY }, i.prototype.len = function () { this.forwardTail(); for (var e = this.tail, t = 0; e !== void 0;)t++, e = e.n; return t }, i.prototype.read = function (e) { if (this.forwardTail(), e.length === 0) return 0; for (var t = this.tail, s = 0; t !== void 0 && (e[s++] = t.e, s !== e.length);)t = t.n; return s }, i.prototype.write = function (e) { for (var t = 0; t < e.length; t++)this.putElement(e[t]); return e.length }, i.prototype.forEach = function (e) { this.forwardTail(); for (var t = this.tail, s = 0; t !== void 0;)e(t.e), s++, t = t.n; return s }, i.prototype.putElement = function (e) { var t = { e, t: Date.now(), n: void 0 }; this.tail === void 0 && (this.tail = t), this.head === void 0 ? this.head = t : (this.head.n = t, this.head = t) }, i.prototype.forwardTail = function () { if (this.tail !== void 0) for (var e = Date.now(); e - this.tail.t > this.maxAge && (this.tail === this.head ? (this.tail = void 0, this.head = void 0) : this.tail = this.tail.n, this.tail !== void 0);); }, i.prototype.clear = function () { }, i }(); C0.TimeBuffer = k6; var _1 = {}; (function (i) { Object.defineProperty(i, "__esModule", { value: !0 }), i.Websocket = i.WebsocketEvents = void 0; var e; (function (s) { s.open = "open", s.close = "close", s.error = "error", s.message = "message", s.retry = "retry" })(e = i.WebsocketEvents || (i.WebsocketEvents = {})); var t = function () { function s(r, n, o, a) { var l = this; this.eventListeners = { open: [], close: [], error: [], message: [], retry: [] }, this.closedByUser = !1, this.retries = 0, this.handleOpenEvent = function (c) { return l.handleEvent(e.open, c) }, this.handleCloseEvent = function (c) { return l.handleEvent(e.close, c) }, this.handleErrorEvent = function (c) { return l.handleEvent(e.error, c) }, this.handleMessageEvent = function (c) { return l.handleEvent(e.message, c) }, this.url = r, this.protocols = n, this.buffer = o, this.backoff = a, this.tryConnect() } return Object.defineProperty(s.prototype, "underlyingWebsocket", { get: function () { return this.websocket }, enumerable: !1, configurable: !0 }), s.prototype.send = function (r) { var n; this.closedByUser || (this.websocket === void 0 || this.websocket.readyState !== this.websocket.OPEN ? (n = this.buffer) === null || n === void 0 || n.write([r]) : this.websocket.send(r)) }, s.prototype.close = function (r, n) { var o; this.closedByUser = !0, (o = this.websocket) === null || o === void 0 || o.close(r, n) }, s.prototype.addEventListener = function (r, n, o) { var a = { listener: n, options: o }, l = this.eventListeners[r]; l.push(a) }, s.prototype.removeEventListener = function (r, n, o) { this.eventListeners[r] = this.eventListeners[r].filter(function (a) { return a.listener !== n && (a.options === void 0 || a.options !== o) }) }, s.prototype.dispatchEvent = function (r, n) { var o = this, a = this.eventListeners[r], l = []; a.forEach(function (c) { c.listener(o, n), c.options !== void 0 && c.options.once && l.push(c) }), l.forEach(function (c) { return o.removeEventListener(r, c.listener, c.options) }) }, s.prototype.tryConnect = function () { this.websocket !== void 0 && (this.websocket.removeEventListener(e.open, this.handleOpenEvent), this.websocket.removeEventListener(e.close, this.handleCloseEvent), this.websocket.removeEventListener(e.error, this.handleErrorEvent), this.websocket.removeEventListener(e.message, this.handleMessageEvent), this.websocket.close()), this.websocket = new WebSocket(this.url, this.protocols), this.websocket.addEventListener(e.open, this.handleOpenEvent), this.websocket.addEventListener(e.close, this.handleCloseEvent), this.websocket.addEventListener(e.error, this.handleErrorEvent), this.websocket.addEventListener(e.message, this.handleMessageEvent) }, s.prototype.handleEvent = function (r, n) { var o, a, l; switch (r) { case e.close: this.closedByUser || this.reconnect(); break; case e.open: this.retries = 0, (o = this.backoff) === null || o === void 0 || o.reset(), (a = this.buffer) === null || a === void 0 || a.forEach(this.send.bind(this)), (l = this.buffer) === null || l === void 0 || l.clear(); break }this.dispatchEvent(r, n) }, s.prototype.reconnect = function () { var r = this; if (this.backoff !== void 0) { var n = this.backoff.next(); setTimeout(function () { r.dispatchEvent(e.retry, new CustomEvent(e.retry, { detail: { retries: ++r.retries, backoff: n } })), r.tryConnect() }, n) } }, s }(); i.Websocket = t })(_1); var S0 = {}; Object.defineProperty(S0, "__esModule", { value: !0 }), S0.WebsocketBuilder = void 0; var pd = _1, D6 = function () { function i(e) { this.ws = null, this.onOpenListeners = [], this.onCloseListeners = [], this.onErrorListeners = [], this.onMessageListeners = [], this.onRetryListeners = [], this.url = e } return i.prototype.withProtocols = function (e) { return this.protocols = e, this }, i.prototype.withBackoff = function (e) { return this.backoff = e, this }, i.prototype.withBuffer = function (e) { return this.buffer = e, this }, i.prototype.onOpen = function (e, t) { return this.onOpenListeners.push({ listener: e, options: t }), this }, i.prototype.onClose = function (e, t) { return this.onCloseListeners.push({ listener: e, options: t }), this }, i.prototype.onError = function (e, t) { return this.onErrorListeners.push({ listener: e, options: t }), this }, i.prototype.onMessage = function (e, t) { return this.onMessageListeners.push({ listener: e, options: t }), this }, i.prototype.onRetry = function (e, t) { return this.onRetryListeners.push({ listener: e, options: t }), this }, i.prototype.build = function () { var e = this; return this.ws !== null ? this.ws : (this.ws = new pd.Websocket(this.url, this.protocols, this.buffer, this.backoff), this.onOpenListeners.forEach(function (t) { var s; return (s = e.ws) === null || s === void 0 ? void 0 : s.addEventListener(pd.WebsocketEvents.open, t.listener, t.options) }), this.onCloseListeners.forEach(function (t) { var s; return (s = e.ws) === null || s === void 0 ? void 0 : s.addEventListener(pd.WebsocketEvents.close, t.listener, t.options) }), this.onErrorListeners.forEach(function (t) { var s; return (s = e.ws) === null || s === void 0 ? void 0 : s.addEventListener(pd.WebsocketEvents.error, t.listener, t.options) }), this.onMessageListeners.forEach(function (t) { var s; return (s = e.ws) === null || s === void 0 ? void 0 : s.addEventListener(pd.WebsocketEvents.message, t.listener, t.options) }), this.onRetryListeners.forEach(function (t) { var s; return (s = e.ws) === null || s === void 0 ? void 0 : s.addEventListener(pd.WebsocketEvents.retry, t.listener, t.options) }), this.ws) }, i }(); S0.WebsocketBuilder = D6, function (i) { var e = A0 && A0.__createBinding || (Object.create ? function (s, r, n, o) { o === void 0 && (o = n), Object.defineProperty(s, o, { enumerable: !0, get: function () { return r[n] } }) } : function (s, r, n, o) { o === void 0 && (o = n), s[o] = r[n] }), t = A0 && A0.__exportStar || function (s, r) { for (var n in s) n !== "default" && !Object.prototype.hasOwnProperty.call(r, n) && e(r, s, n) }; Object.defineProperty(i, "__esModule", { value: !0 }), t(TB, i), t(b0, i), t(_0, i), t(x0, i), t(RB, i), t(w0, i), t(C0, i), t(_1, i), t(S0, i) }(IB); const x1 = 2, Fo = 4, Ha = 4, E0 = 4, ec = new Int32Array(2), PB = new Float32Array(ec.buffer), BB = new Float64Array(ec.buffer), M0 = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1; class _a { constructor(e, t) { this.low = e | 0, this.high = t | 0 } static create(e, t) { return e == 0 && t == 0 ? _a.ZERO : new _a(e, t) } toFloat64() { return (this.low >>> 0) + this.high * 4294967296 } equals(e) { return this.low == e.low && this.high == e.high } } _a.ZERO = new _a(0, 0); var w1; (function (i) { i[i.UTF8_BYTES = 1] = "UTF8_BYTES", i[i.UTF16_STRING = 2] = "UTF16_STRING" })(w1 || (w1 = {})); class Mv { constructor(e) { this.bytes_ = e, this.position_ = 0 } static allocate(e) { return new Mv(new Uint8Array(e)) } clear() { this.position_ = 0 } bytes() { return this.bytes_ } position() { return this.position_ } setPosition(e) { this.position_ = e } capacity() { return this.bytes_.length } readInt8(e) { return this.readUint8(e) << 24 >> 24 } readUint8(e) { return this.bytes_[e] } readInt16(e) { return this.readUint16(e) << 16 >> 16 } readUint16(e) { return this.bytes_[e] | this.bytes_[e + 1] << 8 } readInt32(e) { return this.bytes_[e] | this.bytes_[e + 1] << 8 | this.bytes_[e + 2] << 16 | this.bytes_[e + 3] << 24 } readUint32(e) { return this.readInt32(e) >>> 0 } readInt64(e) { return new _a(this.readInt32(e), this.readInt32(e + 4)) } readUint64(e) { return new _a(this.readUint32(e), this.readUint32(e + 4)) } readFloat32(e) { return ec[0] = this.readInt32(e), PB[0] } readFloat64(e) { return ec[M0 ? 0 : 1] = this.readInt32(e), ec[M0 ? 1 : 0] = this.readInt32(e + 4), BB[0] } writeInt8(e, t) { this.bytes_[e] = t } writeUint8(e, t) { this.bytes_[e] = t } writeInt16(e, t) { this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8 } writeUint16(e, t) { this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8 } writeInt32(e, t) { this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24 } writeUint32(e, t) { this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24 } writeInt64(e, t) { this.writeInt32(e, t.low), this.writeInt32(e + 4, t.high) } writeUint64(e, t) { this.writeUint32(e, t.low), this.writeUint32(e + 4, t.high) } writeFloat32(e, t) { PB[0] = t, this.writeInt32(e, ec[0]) } writeFloat64(e, t) { BB[0] = t, this.writeInt32(e, ec[M0 ? 0 : 1]), this.writeInt32(e + 4, ec[M0 ? 1 : 0]) } getBufferIdentifier() { if (this.bytes_.length < this.position_ + Fo + Ha) throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier."); let e = ""; for (let t = 0; t < Ha; t++)e += String.fromCharCode(this.readInt8(this.position_ + Fo + t)); return e } __offset(e, t) { const s = e - this.readInt32(e); return t < this.readInt16(s) ? this.readInt16(s + t) : 0 } __union(e, t) { return e.bb_pos = t + this.readInt32(t), e.bb = this, e } __string(e, t) { e += this.readInt32(e); const s = this.readInt32(e); let r = "", n = 0; if (e += Fo, t === w1.UTF8_BYTES) return this.bytes_.subarray(e, e + s); for (; n < s;) { let o; const a = this.readUint8(e + n++); if (a < 192) o = a; else { const l = this.readUint8(e + n++); if (a < 224) o = (a & 31) << 6 | l & 63; else { const c = this.readUint8(e + n++); if (a < 240) o = (a & 15) << 12 | (l & 63) << 6 | c & 63; else { const h = this.readUint8(e + n++); o = (a & 7) << 18 | (l & 63) << 12 | (c & 63) << 6 | h & 63 } } } o < 65536 ? r += String.fromCharCode(o) : (o -= 65536, r += String.fromCharCode((o >> 10) + 55296, (o & (1 << 10) - 1) + 56320)) } return r } __union_with_string(e, t) { return typeof e == "string" ? this.__string(t) : this.__union(e, t) } __indirect(e) { return e + this.readInt32(e) } __vector(e) { return e + this.readInt32(e) + Fo } __vector_len(e) { return this.readInt32(e + this.readInt32(e)) } __has_identifier(e) { if (e.length != Ha) throw new Error("FlatBuffers: file identifier must be length " + Ha); for (let t = 0; t < Ha; t++)if (e.charCodeAt(t) != this.readInt8(this.position() + Fo + t)) return !1; return !0 } createLong(e, t) { return _a.create(e, t) } createScalarList(e, t) { const s = []; for (let r = 0; r < t; ++r)e(r) !== null && s.push(e(r)); return s } createObjList(e, t) { const s = []; for (let r = 0; r < t; ++r) { const n = e(r); n !== null && s.push(n.unpack()) } return s } } class Zp { constructor(e) { this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null; let t; e ? t = e : t = 1024, this.bb = Mv.allocate(t), this.space = t } clear() { this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null } forceDefaults(e) { this.force_defaults = e } dataBuffer() { return this.bb } asUint8Array() { return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset()) } prep(e, t) { e > this.minalign && (this.minalign = e); const s = ~(this.bb.capacity() - this.space + t) + 1 & e - 1; for (; this.space < s + e + t;) { const r = this.bb.capacity(); this.bb = Zp.growByteBuffer(this.bb), this.space += this.bb.capacity() - r } this.pad(s) } pad(e) { for (let t = 0; t < e; t++)this.bb.writeInt8(--this.space, 0) } writeInt8(e) { this.bb.writeInt8(this.space -= 1, e) } writeInt16(e) { this.bb.writeInt16(this.space -= 2, e) } writeInt32(e) { this.bb.writeInt32(this.space -= 4, e) } writeInt64(e) { this.bb.writeInt64(this.space -= 8, e) } writeFloat32(e) { this.bb.writeFloat32(this.space -= 4, e) } writeFloat64(e) { this.bb.writeFloat64(this.space -= 8, e) } addInt8(e) { this.prep(1, 0), this.writeInt8(e) } addInt16(e) { this.prep(2, 0), this.writeInt16(e) } addInt32(e) { this.prep(4, 0), this.writeInt32(e) } addInt64(e) { this.prep(8, 0), this.writeInt64(e) } addFloat32(e) { this.prep(4, 0), this.writeFloat32(e) } addFloat64(e) { this.prep(8, 0), this.writeFloat64(e) } addFieldInt8(e, t, s) { (this.force_defaults || t != s) && (this.addInt8(t), this.slot(e)) } addFieldInt16(e, t, s) { (this.force_defaults || t != s) && (this.addInt16(t), this.slot(e)) } addFieldInt32(e, t, s) { (this.force_defaults || t != s) && (this.addInt32(t), this.slot(e)) } addFieldInt64(e, t, s) { (this.force_defaults || !t.equals(s)) && (this.addInt64(t), this.slot(e)) } addFieldFloat32(e, t, s) { (this.force_defaults || t != s) && (this.addFloat32(t), this.slot(e)) } addFieldFloat64(e, t, s) { (this.force_defaults || t != s) && (this.addFloat64(t), this.slot(e)) } addFieldOffset(e, t, s) { (this.force_defaults || t != s) && (this.addOffset(t), this.slot(e)) } addFieldStruct(e, t, s) { t != s && (this.nested(t), this.slot(e)) } nested(e) { if (e != this.offset()) throw new Error("FlatBuffers: struct must be serialized inline.") } notNested() { if (this.isNested) throw new Error("FlatBuffers: object serialization must not be nested.") } slot(e) { this.vtable !== null && (this.vtable[e] = this.offset()) } offset() { return this.bb.capacity() - this.space } static growByteBuffer(e) { const t = e.capacity(); if (t & 3221225472) throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes."); const s = t << 1, r = Mv.allocate(s); return r.setPosition(s - t), r.bytes().set(e.bytes(), s - t), r } addOffset(e) { this.prep(Fo, 0), this.writeInt32(this.offset() - e + Fo) } startObject(e) { this.notNested(), this.vtable == null && (this.vtable = []), this.vtable_in_use = e; for (let t = 0; t < e; t++)this.vtable[t] = 0; this.isNested = !0, this.object_start = this.offset() } endObject() { if (this.vtable == null || !this.isNested) throw new Error("FlatBuffers: endObject called without startObject"); this.addInt32(0); const e = this.offset(); let t = this.vtable_in_use - 1; for (; t >= 0 && this.vtable[t] == 0; t--); const s = t + 1; for (; t >= 0; t--)this.addInt16(this.vtable[t] != 0 ? e - this.vtable[t] : 0); const r = 2; this.addInt16(e - this.object_start); const n = (s + r) * x1; this.addInt16(n); let o = 0; const a = this.space; e: for (t = 0; t < this.vtables.length; t++) { const l = this.bb.capacity() - this.vtables[t]; if (n == this.bb.readInt16(l)) { for (let c = x1; c < n; c += x1)if (this.bb.readInt16(a + c) != this.bb.readInt16(l + c)) continue e; o = this.vtables[t]; break } } return o ? (this.space = this.bb.capacity() - e, this.bb.writeInt32(this.space, o - e)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - e, this.offset() - e)), this.isNested = !1, e } finish(e, t, s) { const r = s ? E0 : 0; if (t) { const n = t; if (this.prep(this.minalign, Fo + Ha + r), n.length != Ha) throw new Error("FlatBuffers: file identifier must be length " + Ha); for (let o = Ha - 1; o >= 0; o--)this.writeInt8(n.charCodeAt(o)) } this.prep(this.minalign, Fo + r), this.addOffset(e), r && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space) } finishSizePrefixed(e, t) { this.finish(e, t, !0) } requiredField(e, t) { const s = this.bb.capacity() - e, r = s - this.bb.readInt32(s); if (this.bb.readInt16(r + t) == 0) throw new Error("FlatBuffers: field " + t + " must be set") } startVector(e, t, s) { this.notNested(), this.vector_num_elems = t, this.prep(Fo, e * t), this.prep(s, e * t) } endVector() { return this.writeInt32(this.vector_num_elems), this.offset() } createSharedString(e) { if (!e) return 0; if (this.string_maps || (this.string_maps = new Map), this.string_maps.has(e)) return this.string_maps.get(e); const t = this.createString(e); return this.string_maps.set(e, t), t } createString(e) { if (!e) return 0; let t; if (e instanceof Uint8Array) t = e; else { t = []; let s = 0; for (; s < e.length;) { let r; const n = e.charCodeAt(s++); if (n < 55296 || n >= 56320) r = n; else { const o = e.charCodeAt(s++); r = (n << 10) + o + (65536 - (55296 << 10) - 56320) } r < 128 ? t.push(r) : (r < 2048 ? t.push(r >> 6 & 31 | 192) : (r < 65536 ? t.push(r >> 12 & 15 | 224) : t.push(r >> 18 & 7 | 240, r >> 12 & 63 | 128), t.push(r >> 6 & 63 | 128)), t.push(r & 63 | 128)) } } this.addInt8(0), this.startVector(1, t.length, 1), this.bb.setPosition(this.space -= t.length); for (let s = 0, r = this.space, n = this.bb.bytes(); s < t.length; s++)n[r++] = t[s]; return this.endVector() } createLong(e, t) { return _a.create(e, t) } createObjectOffset(e) { return e === null ? 0 : typeof e == "string" ? this.createString(e) : e.pack(this) } createObjectOffsetList(e) { const t = []; for (let s = 0; s < e.length; ++s) { const r = e[s]; if (r !== null) t.push(this.createObjectOffset(r)); else throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.") } return t } createStructOffsetList(e, t) { return t(this, e.length), this.createObjectOffsetList(e), this.endVector() } } const kB = {}; function C1(i, e) { kB[i] = e } function O6(i) { const e = i.getBufferIdentifier(), t = kB[e]; return t(i) } function L6(i) { return typeof i.guid == "function" ? i.guid() : null } var DB = { exports: {} }; (function (i) { var e = {}; e.useBlobBuilder = function () { try { return new Blob([]), !1 } catch { return !0 } }(), e.useArrayBufferView = !e.useBlobBuilder && function () { try { return new Blob([new Uint8Array([])]).size === 0 } catch { return !0 } }(), i.exports.binaryFeatures = e; var t = i.exports.BlobBuilder; typeof window < "u" && (t = i.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder); function s() { this._pieces = [], this._parts = [] } s.prototype.append = function (r) { typeof r == "number" ? this._pieces.push(r) : (this.flush(), this._parts.push(r)) }, s.prototype.flush = function () { if (this._pieces.length > 0) { var r = new Uint8Array(this._pieces); e.useArrayBufferView || (r = r.buffer), this._parts.push(r), this._pieces = [] } }, s.prototype.getBuffer = function () { if (this.flush(), e.useBlobBuilder) { for (var r = new t, n = 0, o = this._parts.length; n < o; n++)r.append(this._parts[n]); return r.getBlob() } else return new Blob(this._parts) }, i.exports.BufferBuilder = s })(DB); var OB = DB.exports, F6 = OB.BufferBuilder, LB = OB.binaryFeatures, U6 = { unpack: function (i) { var e = new Us(i); return e.unpack() }, pack: function (i) { var e = new Ns; e.pack(i); var t = e.getBuffer(); return t } }, N6 = U6; function Us(i) { this.index = 0, this.dataBuffer = i, this.dataView = new Uint8Array(this.dataBuffer), this.length = this.dataBuffer.byteLength } Us.prototype.unpack = function () { var i = this.unpack_uint8(); if (i < 128) return i; if ((i ^ 224) < 32) return (i ^ 224) - 32; var e; if ((e = i ^ 160) <= 15) return this.unpack_raw(e); if ((e = i ^ 176) <= 15) return this.unpack_string(e); if ((e = i ^ 144) <= 15) return this.unpack_array(e); if ((e = i ^ 128) <= 15) return this.unpack_map(e); switch (i) { case 192: return null; case 193: return; case 194: return !1; case 195: return !0; case 202: return this.unpack_float(); case 203: return this.unpack_double(); case 204: return this.unpack_uint8(); case 205: return this.unpack_uint16(); case 206: return this.unpack_uint32(); case 207: return this.unpack_uint64(); case 208: return this.unpack_int8(); case 209: return this.unpack_int16(); case 210: return this.unpack_int32(); case 211: return this.unpack_int64(); case 212: return; case 213: return; case 214: return; case 215: return; case 216: return e = this.unpack_uint16(), this.unpack_string(e); case 217: return e = this.unpack_uint32(), this.unpack_string(e); case 218: return e = this.unpack_uint16(), this.unpack_raw(e); case 219: return e = this.unpack_uint32(), this.unpack_raw(e); case 220: return e = this.unpack_uint16(), this.unpack_array(e); case 221: return e = this.unpack_uint32(), this.unpack_array(e); case 222: return e = this.unpack_uint16(), this.unpack_map(e); case 223: return e = this.unpack_uint32(), this.unpack_map(e) } }, Us.prototype.unpack_uint8 = function () { var i = this.dataView[this.index] & 255; return this.index++, i }, Us.prototype.unpack_uint16 = function () { var i = this.read(2), e = (i[0] & 255) * 256 + (i[1] & 255); return this.index += 2, e }, Us.prototype.unpack_uint32 = function () { var i = this.read(4), e = ((i[0] * 256 + i[1]) * 256 + i[2]) * 256 + i[3]; return this.index += 4, e }, Us.prototype.unpack_uint64 = function () { var i = this.read(8), e = ((((((i[0] * 256 + i[1]) * 256 + i[2]) * 256 + i[3]) * 256 + i[4]) * 256 + i[5]) * 256 + i[6]) * 256 + i[7]; return this.index += 8, e }, Us.prototype.unpack_int8 = function () { var i = this.unpack_uint8(); return i < 128 ? i : i - (1 << 8) }, Us.prototype.unpack_int16 = function () { var i = this.unpack_uint16(); return i < 32768 ? i : i - (1 << 16) }, Us.prototype.unpack_int32 = function () { var i = this.unpack_uint32(); return i < Math.pow(2, 31) ? i : i - Math.pow(2, 32) }, Us.prototype.unpack_int64 = function () { var i = this.unpack_uint64(); return i < Math.pow(2, 63) ? i : i - Math.pow(2, 64) }, Us.prototype.unpack_raw = function (i) { if (this.length < this.index + i) throw new Error("BinaryPackFailure: index is out of range " + this.index + " " + i + " " + this.length); var e = this.dataBuffer.slice(this.index, this.index + i); return this.index += i, e }, Us.prototype.unpack_string = function (i) { for (var e = this.read(i), t = 0, s = "", r, n; t < i;)r = e[t], r < 128 ? (s += String.fromCharCode(r), t++) : (r ^ 192) < 32 ? (n = (r ^ 192) << 6 | e[t + 1] & 63, s += String.fromCharCode(n), t += 2) : (n = (r & 15) << 12 | (e[t + 1] & 63) << 6 | e[t + 2] & 63, s += String.fromCharCode(n), t += 3); return this.index += i, s }, Us.prototype.unpack_array = function (i) { for (var e = new Array(i), t = 0; t < i; t++)e[t] = this.unpack(); return e }, Us.prototype.unpack_map = function (i) { for (var e = {}, t = 0; t < i; t++) { var s = this.unpack(), r = this.unpack(); e[s] = r } return e }, Us.prototype.unpack_float = function () { var i = this.unpack_uint32(), e = i >> 31, t = (i >> 23 & 255) - 127, s = i & 8388607 | 8388608; return (e === 0 ? 1 : -1) * s * Math.pow(2, t - 23) }, Us.prototype.unpack_double = function () { var i = this.unpack_uint32(), e = this.unpack_uint32(), t = i >> 31, s = (i >> 20 & 2047) - 1023, r = i & 1048575 | 1048576, n = r * Math.pow(2, s - 20) + e * Math.pow(2, s - 52); return (t === 0 ? 1 : -1) * n }, Us.prototype.read = function (i) { var e = this.index; if (e + i <= this.length) return this.dataView.subarray(e, e + i); throw new Error("BinaryPackFailure: read index out of range") }; function Ns() { this.bufferBuilder = new F6 } Ns.prototype.getBuffer = function () { return this.bufferBuilder.getBuffer() }, Ns.prototype.pack = function (i) { var e = typeof i; if (e === "string") this.pack_string(i); else if (e === "number") Math.floor(i) === i ? this.pack_integer(i) : this.pack_double(i); else if (e === "boolean") i === !0 ? this.bufferBuilder.append(195) : i === !1 && this.bufferBuilder.append(194); else if (e === "undefined") this.bufferBuilder.append(192); else if (e === "object") if (i === null) this.bufferBuilder.append(192); else { var t = i.constructor; if (t == Array) this.pack_array(i); else if (t == Blob || t == File || i instanceof Blob || i instanceof File) this.pack_bin(i); else if (t == ArrayBuffer) LB.useArrayBufferView ? this.pack_bin(new Uint8Array(i)) : this.pack_bin(i); else if ("BYTES_PER_ELEMENT" in i) LB.useArrayBufferView ? this.pack_bin(new Uint8Array(i.buffer)) : this.pack_bin(i.buffer); else if (t == Object || t.toString().startsWith("class")) this.pack_object(i); else if (t == Date) this.pack_string(i.toString()); else if (typeof i.toBinaryPack == "function") this.bufferBuilder.append(i.toBinaryPack()); else throw new Error('Type "' + t.toString() + '" not yet supported') } else throw new Error('Type "' + e + '" not yet supported'); this.bufferBuilder.flush() }, Ns.prototype.pack_bin = function (i) { var e = i.length || i.byteLength || i.size; if (e <= 15) this.pack_uint8(160 + e); else if (e <= 65535) this.bufferBuilder.append(218), this.pack_uint16(e); else if (e <= 4294967295) this.bufferBuilder.append(219), this.pack_uint32(e); else throw new Error("Invalid length"); this.bufferBuilder.append(i) }, Ns.prototype.pack_string = function (i) { var e = j6(i); if (e <= 15) this.pack_uint8(176 + e); else if (e <= 65535) this.bufferBuilder.append(216), this.pack_uint16(e); else if (e <= 4294967295) this.bufferBuilder.append(217), this.pack_uint32(e); else throw new Error("Invalid length"); this.bufferBuilder.append(i) }, Ns.prototype.pack_array = function (i) { var e = i.length; if (e <= 15) this.pack_uint8(144 + e); else if (e <= 65535) this.bufferBuilder.append(220), this.pack_uint16(e); else if (e <= 4294967295) this.bufferBuilder.append(221), this.pack_uint32(e); else throw new Error("Invalid length"); for (var t = 0; t < e; t++)this.pack(i[t]) }, Ns.prototype.pack_integer = function (i) { if (i >= -32 && i <= 127) this.bufferBuilder.append(i & 255); else if (i >= 0 && i <= 255) this.bufferBuilder.append(204), this.pack_uint8(i); else if (i >= -128 && i <= 127) this.bufferBuilder.append(208), this.pack_int8(i); else if (i >= 0 && i <= 65535) this.bufferBuilder.append(205), this.pack_uint16(i); else if (i >= -32768 && i <= 32767) this.bufferBuilder.append(209), this.pack_int16(i); else if (i >= 0 && i <= 4294967295) this.bufferBuilder.append(206), this.pack_uint32(i); else if (i >= -2147483648 && i <= 2147483647) this.bufferBuilder.append(210), this.pack_int32(i); else if (i >= -9223372036854776e3 && i <= 9223372036854776e3) this.bufferBuilder.append(211), this.pack_int64(i); else if (i >= 0 && i <= 18446744073709552e3) this.bufferBuilder.append(207), this.pack_uint64(i); else throw new Error("Invalid integer") }, Ns.prototype.pack_double = function (i) { var e = 0; i < 0 && (e = 1, i = -i); var t = Math.floor(Math.log(i) / Math.LN2), s = i / Math.pow(2, t) - 1, r = Math.floor(s * Math.pow(2, 52)), n = Math.pow(2, 32), o = e << 31 | t + 1023 << 20 | r / n & 1048575, a = r % n; this.bufferBuilder.append(203), this.pack_int32(o), this.pack_int32(a) }, Ns.prototype.pack_object = function (i) { var e = Object.keys(i), t = e.length; if (t <= 15) this.pack_uint8(128 + t); else if (t <= 65535) this.bufferBuilder.append(222), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(223), this.pack_uint32(t); else throw new Error("Invalid length"); for (var s in i) i.hasOwnProperty(s) && (this.pack(s), this.pack(i[s])) }, Ns.prototype.pack_uint8 = function (i) { this.bufferBuilder.append(i) }, Ns.prototype.pack_uint16 = function (i) { this.bufferBuilder.append(i >> 8), this.bufferBuilder.append(i & 255) }, Ns.prototype.pack_uint32 = function (i) { var e = i & 4294967295; this.bufferBuilder.append((e & 4278190080) >>> 24), this.bufferBuilder.append((e & 16711680) >>> 16), this.bufferBuilder.append((e & 65280) >>> 8), this.bufferBuilder.append(e & 255) }, Ns.prototype.pack_uint64 = function (i) { var e = i / Math.pow(2, 32), t = i % Math.pow(2, 32); this.bufferBuilder.append((e & 4278190080) >>> 24), this.bufferBuilder.append((e & 16711680) >>> 16), this.bufferBuilder.append((e & 65280) >>> 8), this.bufferBuilder.append(e & 255), this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255) }, Ns.prototype.pack_int8 = function (i) { this.bufferBuilder.append(i & 255) }, Ns.prototype.pack_int16 = function (i) { this.bufferBuilder.append((i & 65280) >> 8), this.bufferBuilder.append(i & 255) }, Ns.prototype.pack_int32 = function (i) { this.bufferBuilder.append(i >>> 24 & 255), this.bufferBuilder.append((i & 16711680) >>> 16), this.bufferBuilder.append((i & 65280) >>> 8), this.bufferBuilder.append(i & 255) }, Ns.prototype.pack_int64 = function (i) { var e = Math.floor(i / Math.pow(2, 32)), t = i % Math.pow(2, 32); this.bufferBuilder.append((e & 4278190080) >>> 24), this.bufferBuilder.append((e & 16711680) >>> 16), this.bufferBuilder.append((e & 65280) >>> 8), this.bufferBuilder.append(e & 255), this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255) }; function z6(i) { var e = i.charCodeAt(0); return e <= 2047 ? "00" : e <= 65535 ? "000" : e <= 2097151 ? "0000" : e <= 67108863 ? "00000" : "000000" } function j6(i) { return i.length > 600 ? new Blob([i]).size : i.replace(/[^\u0000-\u007F]/g, z6).length } const FB = y0(N6); let UB = !0, NB = !0; function qf(i, e, t) { const s = i.match(e); return s && s.length >= t && parseInt(s[t], 10) } function fd(i, e, t) { if (!i.RTCPeerConnection) return; const s = i.RTCPeerConnection.prototype, r = s.addEventListener; s.addEventListener = function (o, a) { if (o !== e) return r.apply(this, arguments); const l = c => { const h = t(c); h && (a.handleEvent ? a.handleEvent(h) : a(h)) }; return this._eventMap = this._eventMap || {}, this._eventMap[e] || (this._eventMap[e] = new Map), this._eventMap[e].set(a, l), r.apply(this, [o, l]) }; const n = s.removeEventListener; s.removeEventListener = function (o, a) { if (o !== e || !this._eventMap || !this._eventMap[e]) return n.apply(this, arguments); if (!this._eventMap[e].has(a)) return n.apply(this, arguments); const l = this._eventMap[e].get(a); return this._eventMap[e].delete(a), this._eventMap[e].size === 0 && delete this._eventMap[e], Object.keys(this._eventMap).length === 0 && delete this._eventMap, n.apply(this, [o, l]) }, Object.defineProperty(s, "on" + e, { get() { return this["_on" + e] }, set(o) { this["_on" + e] && (this.removeEventListener(e, this["_on" + e]), delete this["_on" + e]), o && this.addEventListener(e, this["_on" + e] = o) }, enumerable: !0, configurable: !0 }) } function Q6(i) { return typeof i != "boolean" ? new Error("Argument type: " + typeof i + ". Please use a boolean.") : (UB = i, i ? "adapter.js logging disabled" : "adapter.js logging enabled") } function G6(i) { return typeof i != "boolean" ? new Error("Argument type: " + typeof i + ". Please use a boolean.") : (NB = !i, "adapter.js deprecation warnings " + (i ? "disabled" : "enabled")) } function S1() { if (typeof window == "object") { if (UB) return; typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments) } } function I0(i, e) { NB && console.warn(i + " is deprecated, please use " + e + " instead.") } function H6(i) { const e = { browser: null, version: null }; if (typeof i > "u" || !i.navigator) return e.browser = "Not a browser.", e; const { navigator: t } = i; if (t.mozGetUserMedia) e.browser = "firefox", e.version = qf(t.userAgent, /Firefox\/(\d+)\./, 1); else if (t.webkitGetUserMedia || i.isSecureContext === !1 && i.webkitRTCPeerConnection && !i.RTCIceGatherer) e.browser = "chrome", e.version = qf(t.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else if (t.mediaDevices && t.userAgent.match(/Edge\/(\d+).(\d+)$/)) e.browser = "edge", e.version = qf(t.userAgent, /Edge\/(\d+).(\d+)$/, 2); else if (i.RTCPeerConnection && t.userAgent.match(/AppleWebKit\/(\d+)\./)) e.browser = "safari", e.version = qf(t.userAgent, /AppleWebKit\/(\d+)\./, 1), e.supportsUnifiedPlan = i.RTCRtpTransceiver && "currentDirection" in i.RTCRtpTransceiver.prototype; else return e.browser = "Not a supported browser.", e; return e } function zB(i) { return Object.prototype.toString.call(i) === "[object Object]" } function jB(i) { return zB(i) ? Object.keys(i).reduce(function (e, t) { const s = zB(i[t]), r = s ? jB(i[t]) : i[t], n = s && !Object.keys(r).length; return r === void 0 || n ? e : Object.assign(e, { [t]: r }) }, {}) : i } function E1(i, e, t) { !e || t.has(e.id) || (t.set(e.id, e), Object.keys(e).forEach(s => { s.endsWith("Id") ? E1(i, i.get(e[s]), t) : s.endsWith("Ids") && e[s].forEach(r => { E1(i, i.get(r), t) }) })) } function QB(i, e, t) { const s = t ? "outbound-rtp" : "inbound-rtp", r = new Map; if (e === null) return r; const n = []; return i.forEach(o => { o.type === "track" && o.trackIdentifier === e.id && n.push(o) }), n.forEach(o => { i.forEach(a => { a.type === s && a.trackId === o.id && E1(i, a, r) }) }), r } const GB = S1; function HB(i, e) { const t = i && i.navigator; if (!t.mediaDevices) return; const s = function (a) { if (typeof a != "object" || a.mandatory || a.optional) return a; const l = {}; return Object.keys(a).forEach(c => { if (c === "require" || c === "advanced" || c === "mediaSource") return; const h = typeof a[c] == "object" ? a[c] : { ideal: a[c] }; h.exact !== void 0 && typeof h.exact == "number" && (h.min = h.max = h.exact); const d = function (p, f) { return p ? p + f.charAt(0).toUpperCase() + f.slice(1) : f === "deviceId" ? "sourceId" : f }; if (h.ideal !== void 0) { l.optional = l.optional || []; let p = {}; typeof h.ideal == "number" ? (p[d("min", c)] = h.ideal, l.optional.push(p), p = {}, p[d("max", c)] = h.ideal, l.optional.push(p)) : (p[d("", c)] = h.ideal, l.optional.push(p)) } h.exact !== void 0 && typeof h.exact != "number" ? (l.mandatory = l.mandatory || {}, l.mandatory[d("", c)] = h.exact) : ["min", "max"].forEach(p => { h[p] !== void 0 && (l.mandatory = l.mandatory || {}, l.mandatory[d(p, c)] = h[p]) }) }), a.advanced && (l.optional = (l.optional || []).concat(a.advanced)), l }, r = function (a, l) { if (e.version >= 61) return l(a); if (a = JSON.parse(JSON.stringify(a)), a && typeof a.audio == "object") { const c = function (h, d, p) { d in h && !(p in h) && (h[p] = h[d], delete h[d]) }; a = JSON.parse(JSON.stringify(a)), c(a.audio, "autoGainControl", "googAutoGainControl"), c(a.audio, "noiseSuppression", "googNoiseSuppression"), a.audio = s(a.audio) } if (a && typeof a.video == "object") { let c = a.video.facingMode; c = c && (typeof c == "object" ? c : { ideal: c }); const h = e.version < 66; if (c && (c.exact === "user" || c.exact === "environment" || c.ideal === "user" || c.ideal === "environment") && !(t.mediaDevices.getSupportedConstraints && t.mediaDevices.getSupportedConstraints().facingMode && !h)) { delete a.video.facingMode; let d; if (c.exact === "environment" || c.ideal === "environment" ? d = ["back", "rear"] : (c.exact === "user" || c.ideal === "user") && (d = ["front"]), d) return t.mediaDevices.enumerateDevices().then(p => { p = p.filter(g => g.kind === "videoinput"); let f = p.find(g => d.some(m => g.label.toLowerCase().includes(m))); return !f && p.length && d.includes("back") && (f = p[p.length - 1]), f && (a.video.deviceId = c.exact ? { exact: f.deviceId } : { ideal: f.deviceId }), a.video = s(a.video), GB("chrome: " + JSON.stringify(a)), l(a) }) } a.video = s(a.video) } return GB("chrome: " + JSON.stringify(a)), l(a) }, n = function (a) { return e.version >= 64 ? a : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[a.name] || a.name, message: a.message, constraint: a.constraint || a.constraintName, toString() { return this.name + (this.message && ": ") + this.message } } }, o = function (a, l, c) { r(a, h => { t.webkitGetUserMedia(h, l, d => { c && c(n(d)) }) }) }; if (t.getUserMedia = o.bind(t), t.mediaDevices.getUserMedia) { const a = t.mediaDevices.getUserMedia.bind(t.mediaDevices); t.mediaDevices.getUserMedia = function (l) { return r(l, c => a(c).then(h => { if (c.audio && !h.getAudioTracks().length || c.video && !h.getVideoTracks().length) throw h.getTracks().forEach(d => { d.stop() }), new DOMException("", "NotFoundError"); return h }, h => Promise.reject(n(h)))) } } } function V6(i, e) { if (!(i.navigator.mediaDevices && "getDisplayMedia" in i.navigator.mediaDevices) && i.navigator.mediaDevices) { if (typeof e != "function") { console.error("shimGetDisplayMedia: getSourceId argument is not a function"); return } i.navigator.mediaDevices.getDisplayMedia = function (t) { return e(t).then(s => { const r = t.video && t.video.width, n = t.video && t.video.height, o = t.video && t.video.frameRate; return t.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: s, maxFrameRate: o || 3 } }, r && (t.video.mandatory.maxWidth = r), n && (t.video.mandatory.maxHeight = n), i.navigator.mediaDevices.getUserMedia(t) }) } } } function VB(i) { i.MediaStream = i.MediaStream || i.webkitMediaStream } function WB(i) { if (typeof i == "object" && i.RTCPeerConnection && !("ontrack" in i.RTCPeerConnection.prototype)) { Object.defineProperty(i.RTCPeerConnection.prototype, "ontrack", { get() { return this._ontrack }, set(t) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = t) }, enumerable: !0, configurable: !0 }); const e = i.RTCPeerConnection.prototype.setRemoteDescription; i.RTCPeerConnection.prototype.setRemoteDescription = function () { return this._ontrackpoly || (this._ontrackpoly = t => { t.stream.addEventListener("addtrack", s => { let r; i.RTCPeerConnection.prototype.getReceivers ? r = this.getReceivers().find(o => o.track && o.track.id === s.track.id) : r = { track: s.track }; const n = new Event("track"); n.track = s.track, n.receiver = r, n.transceiver = { receiver: r }, n.streams = [t.stream], this.dispatchEvent(n) }), t.stream.getTracks().forEach(s => { let r; i.RTCPeerConnection.prototype.getReceivers ? r = this.getReceivers().find(o => o.track && o.track.id === s.id) : r = { track: s }; const n = new Event("track"); n.track = s, n.receiver = r, n.transceiver = { receiver: r }, n.streams = [t.stream], this.dispatchEvent(n) }) }, this.addEventListener("addstream", this._ontrackpoly)), e.apply(this, arguments) } } else fd(i, "track", e => (e.transceiver || Object.defineProperty(e, "transceiver", { value: { receiver: e.receiver } }), e)) } function qB(i) { if (typeof i == "object" && i.RTCPeerConnection && !("getSenders" in i.RTCPeerConnection.prototype) && "createDTMFSender" in i.RTCPeerConnection.prototype) { const e = function (r, n) { return { track: n, get dtmf() { return this._dtmf === void 0 && (n.kind === "audio" ? this._dtmf = r.createDTMFSender(n) : this._dtmf = null), this._dtmf }, _pc: r } }; if (!i.RTCPeerConnection.prototype.getSenders) { i.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; const r = i.RTCPeerConnection.prototype.addTrack; i.RTCPeerConnection.prototype.addTrack = function (o, a) { let l = r.apply(this, arguments); return l || (l = e(this, o), this._senders.push(l)), l }; const n = i.RTCPeerConnection.prototype.removeTrack; i.RTCPeerConnection.prototype.removeTrack = function (o) { n.apply(this, arguments); const a = this._senders.indexOf(o); a !== -1 && this._senders.splice(a, 1) } } const t = i.RTCPeerConnection.prototype.addStream; i.RTCPeerConnection.prototype.addStream = function (r) { this._senders = this._senders || [], t.apply(this, [r]), r.getTracks().forEach(n => { this._senders.push(e(this, n)) }) }; const s = i.RTCPeerConnection.prototype.removeStream; i.RTCPeerConnection.prototype.removeStream = function (r) { this._senders = this._senders || [], s.apply(this, [r]), r.getTracks().forEach(n => { const o = this._senders.find(a => a.track === n); o && this._senders.splice(this._senders.indexOf(o), 1) }) } } else if (typeof i == "object" && i.RTCPeerConnection && "getSenders" in i.RTCPeerConnection.prototype && "createDTMFSender" in i.RTCPeerConnection.prototype && i.RTCRtpSender && !("dtmf" in i.RTCRtpSender.prototype)) { const e = i.RTCPeerConnection.prototype.getSenders; i.RTCPeerConnection.prototype.getSenders = function () { const t = e.apply(this, []); return t.forEach(s => s._pc = this), t }, Object.defineProperty(i.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } } function XB(i) { if (!i.RTCPeerConnection) return; const e = i.RTCPeerConnection.prototype.getStats; i.RTCPeerConnection.prototype.getStats = function () { const [t, s, r] = arguments; if (arguments.length > 0 && typeof t == "function") return e.apply(this, arguments); if (e.length === 0 && (arguments.length === 0 || typeof t != "function")) return e.apply(this, []); const n = function (a) { const l = {}; return a.result().forEach(c => { const h = { id: c.id, timestamp: c.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[c.type] || c.type }; c.names().forEach(d => { h[d] = c.stat(d) }), l[h.id] = h }), l }, o = function (a) { return new Map(Object.keys(a).map(l => [l, a[l]])) }; if (arguments.length >= 2) { const a = function (l) { s(o(n(l))) }; return e.apply(this, [a, t]) } return new Promise((a, l) => { e.apply(this, [function (c) { a(o(n(c))) }, l]) }).then(s, r) } } function YB(i) { if (!(typeof i == "object" && i.RTCPeerConnection && i.RTCRtpSender && i.RTCRtpReceiver)) return; if (!("getStats" in i.RTCRtpSender.prototype)) { const t = i.RTCPeerConnection.prototype.getSenders; t && (i.RTCPeerConnection.prototype.getSenders = function () { const r = t.apply(this, []); return r.forEach(n => n._pc = this), r }); const s = i.RTCPeerConnection.prototype.addTrack; s && (i.RTCPeerConnection.prototype.addTrack = function () { const r = s.apply(this, arguments); return r._pc = this, r }), i.RTCRtpSender.prototype.getStats = function () { const r = this; return this._pc.getStats().then(n => QB(n, r.track, !0)) } } if (!("getStats" in i.RTCRtpReceiver.prototype)) { const t = i.RTCPeerConnection.prototype.getReceivers; t && (i.RTCPeerConnection.prototype.getReceivers = function () { const s = t.apply(this, []); return s.forEach(r => r._pc = this), s }), fd(i, "track", s => (s.receiver._pc = s.srcElement, s)), i.RTCRtpReceiver.prototype.getStats = function () { const s = this; return this._pc.getStats().then(r => QB(r, s.track, !1)) } } if (!("getStats" in i.RTCRtpSender.prototype && "getStats" in i.RTCRtpReceiver.prototype)) return; const e = i.RTCPeerConnection.prototype.getStats; i.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof i.MediaStreamTrack) { const t = arguments[0]; let s, r, n; return this.getSenders().forEach(o => { o.track === t && (s ? n = !0 : s = o) }), this.getReceivers().forEach(o => (o.track === t && (r ? n = !0 : r = o), o.track === t)), n || s && r ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : s ? s.getStats() : r ? r.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return e.apply(this, arguments) } } function JB(i) { i.RTCPeerConnection.prototype.getLocalStreams = function () { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(n => this._shimmedLocalStreams[n][0]) }; const e = i.RTCPeerConnection.prototype.addTrack; i.RTCPeerConnection.prototype.addTrack = function (n, o) { if (!o) return e.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; const a = e.apply(this, arguments); return this._shimmedLocalStreams[o.id] ? this._shimmedLocalStreams[o.id].indexOf(a) === -1 && this._shimmedLocalStreams[o.id].push(a) : this._shimmedLocalStreams[o.id] = [o, a], a }; const t = i.RTCPeerConnection.prototype.addStream; i.RTCPeerConnection.prototype.addStream = function (n) { this._shimmedLocalStreams = this._shimmedLocalStreams || {}, n.getTracks().forEach(l => { if (this.getSenders().find(c => c.track === l)) throw new DOMException("Track already exists.", "InvalidAccessError") }); const o = this.getSenders(); t.apply(this, arguments); const a = this.getSenders().filter(l => o.indexOf(l) === -1); this._shimmedLocalStreams[n.id] = [n].concat(a) }; const s = i.RTCPeerConnection.prototype.removeStream; i.RTCPeerConnection.prototype.removeStream = function (n) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[n.id], s.apply(this, arguments) }; const r = i.RTCPeerConnection.prototype.removeTrack; i.RTCPeerConnection.prototype.removeTrack = function (n) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, n && Object.keys(this._shimmedLocalStreams).forEach(o => { const a = this._shimmedLocalStreams[o].indexOf(n); a !== -1 && this._shimmedLocalStreams[o].splice(a, 1), this._shimmedLocalStreams[o].length === 1 && delete this._shimmedLocalStreams[o] }), r.apply(this, arguments) } } function KB(i, e) { if (!i.RTCPeerConnection) return; if (i.RTCPeerConnection.prototype.addTrack && e.version >= 65) return JB(i); const t = i.RTCPeerConnection.prototype.getLocalStreams; i.RTCPeerConnection.prototype.getLocalStreams = function () { const c = t.apply(this); return this._reverseStreams = this._reverseStreams || {}, c.map(h => this._reverseStreams[h.id]) }; const s = i.RTCPeerConnection.prototype.addStream; i.RTCPeerConnection.prototype.addStream = function (c) { if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, c.getTracks().forEach(h => { if (this.getSenders().find(d => d.track === h)) throw new DOMException("Track already exists.", "InvalidAccessError") }), !this._reverseStreams[c.id]) { const h = new i.MediaStream(c.getTracks()); this._streams[c.id] = h, this._reverseStreams[h.id] = c, c = h } s.apply(this, [c]) }; const r = i.RTCPeerConnection.prototype.removeStream; i.RTCPeerConnection.prototype.removeStream = function (c) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r.apply(this, [this._streams[c.id] || c]), delete this._reverseStreams[this._streams[c.id] ? this._streams[c.id].id : c.id], delete this._streams[c.id] }, i.RTCPeerConnection.prototype.addTrack = function (c, h) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); const d = [].slice.call(arguments, 1); if (d.length !== 1 || !d[0].getTracks().find(f => f === c)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); if (this.getSenders().find(f => f.track === c)) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; const p = this._streams[h.id]; if (p) p.addTrack(c), Promise.resolve().then(() => { this.dispatchEvent(new Event("negotiationneeded")) }); else { const f = new i.MediaStream([c]); this._streams[h.id] = f, this._reverseStreams[f.id] = h, this.addStream(f) } return this.getSenders().find(f => f.track === c) }; function n(c, h) { let d = h.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const f = c._reverseStreams[p], g = c._streams[f.id]; d = d.replace(new RegExp(g.id, "g"), f.id) }), new RTCSessionDescription({ type: h.type, sdp: d }) } function o(c, h) { let d = h.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const f = c._reverseStreams[p], g = c._streams[f.id]; d = d.replace(new RegExp(f.id, "g"), g.id) }), new RTCSessionDescription({ type: h.type, sdp: d }) } ["createOffer", "createAnswer"].forEach(function (c) { const h = i.RTCPeerConnection.prototype[c], d = { [c]() { const p = arguments; return arguments.length && typeof arguments[0] == "function" ? h.apply(this, [f => { const g = n(this, f); p[0].apply(null, [g]) }, f => { p[1] && p[1].apply(null, f) }, arguments[2]]) : h.apply(this, arguments).then(f => n(this, f)) } }; i.RTCPeerConnection.prototype[c] = d[c] }); const a = i.RTCPeerConnection.prototype.setLocalDescription; i.RTCPeerConnection.prototype.setLocalDescription = function () { return !arguments.length || !arguments[0].type ? a.apply(this, arguments) : (arguments[0] = o(this, arguments[0]), a.apply(this, arguments)) }; const l = Object.getOwnPropertyDescriptor(i.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(i.RTCPeerConnection.prototype, "localDescription", { get() { const c = l.get.apply(this); return c.type === "" ? c : n(this, c) } }), i.RTCPeerConnection.prototype.removeTrack = function (c) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!c._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (c._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); this._streams = this._streams || {}; let h; Object.keys(this._streams).forEach(d => { this._streams[d].getTracks().find(p => c.track === p) && (h = this._streams[d]) }), h && (h.getTracks().length === 1 ? this.removeStream(this._reverseStreams[h.id]) : h.removeTrack(c.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function M1(i, e) { !i.RTCPeerConnection && i.webkitRTCPeerConnection && (i.RTCPeerConnection = i.webkitRTCPeerConnection), i.RTCPeerConnection && e.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (t) { const s = i.RTCPeerConnection.prototype[t], r = { [t]() { return arguments[0] = new (t === "addIceCandidate" ? i.RTCIceCandidate : i.RTCSessionDescription)(arguments[0]), s.apply(this, arguments) } }; i.RTCPeerConnection.prototype[t] = r[t] }) } function ZB(i, e) { fd(i, "negotiationneeded", t => { const s = t.target; if (!((e.version < 72 || s.getConfiguration && s.getConfiguration().sdpSemantics === "plan-b") && s.signalingState !== "stable")) return t }) } const $B = Object.freeze(Object.defineProperty({ __proto__: null, fixNegotiationNeeded: ZB, shimAddTrackRemoveTrack: KB, shimAddTrackRemoveTrackWithNative: JB, shimGetDisplayMedia: V6, shimGetSendersWithDtmf: qB, shimGetStats: XB, shimGetUserMedia: HB, shimMediaStream: VB, shimOnTrack: WB, shimPeerConnection: M1, shimSenderReceiverGetStats: YB }, Symbol.toStringTag, { value: "Module" })); function W6(i, e) { let t = !1; return i = JSON.parse(JSON.stringify(i)), i.filter(s => { if (s && (s.urls || s.url)) { let r = s.urls || s.url; s.url && !s.urls && I0("RTCIceServer.url", "RTCIceServer.urls"); const n = typeof r == "string"; return n && (r = [r]), r = r.filter(o => { if (o.indexOf("stun:") === 0) return !1; const a = o.startsWith("turn") && !o.startsWith("turn:[") && o.includes("transport=udp"); return a && !t ? (t = !0, !0) : a && !t }), delete s.url, s.urls = n ? r[0] : r, !!r.length } }) } var ek = { exports: {} }; (function (i) {
  var e = {}; e.generateIdentifier = function () { return Math.random().toString(36).substr(2, 10) }, e.localCName = e.generateIdentifier(), e.splitLines = function (t) {
    return t.trim().split(`
`).map(function (s) { return s.trim() })
  }, e.splitSections = function (t) {
    var s = t.split(`
m=`); return s.map(function (r, n) {
      return (n > 0 ? "m=" + r : r).trim() + `\r
`})
  }, e.getDescription = function (t) { var s = e.splitSections(t); return s && s[0] }, e.getMediaSections = function (t) { var s = e.splitSections(t); return s.shift(), s }, e.matchPrefix = function (t, s) { return e.splitLines(t).filter(function (r) { return r.indexOf(s) === 0 }) }, e.parseCandidate = function (t) { var s; t.indexOf("a=candidate:") === 0 ? s = t.substring(12).split(" ") : s = t.substring(10).split(" "); for (var r = { foundation: s[0], component: parseInt(s[1], 10), protocol: s[2].toLowerCase(), priority: parseInt(s[3], 10), ip: s[4], address: s[4], port: parseInt(s[5], 10), type: s[7] }, n = 8; n < s.length; n += 2)switch (s[n]) { case "raddr": r.relatedAddress = s[n + 1]; break; case "rport": r.relatedPort = parseInt(s[n + 1], 10); break; case "tcptype": r.tcpType = s[n + 1]; break; case "ufrag": r.ufrag = s[n + 1], r.usernameFragment = s[n + 1]; break; default: r[s[n]] = s[n + 1]; break }return r }, e.writeCandidate = function (t) { var s = []; s.push(t.foundation), s.push(t.component), s.push(t.protocol.toUpperCase()), s.push(t.priority), s.push(t.address || t.ip), s.push(t.port); var r = t.type; return s.push("typ"), s.push(r), r !== "host" && t.relatedAddress && t.relatedPort && (s.push("raddr"), s.push(t.relatedAddress), s.push("rport"), s.push(t.relatedPort)), t.tcpType && t.protocol.toLowerCase() === "tcp" && (s.push("tcptype"), s.push(t.tcpType)), (t.usernameFragment || t.ufrag) && (s.push("ufrag"), s.push(t.usernameFragment || t.ufrag)), "candidate:" + s.join(" ") }, e.parseIceOptions = function (t) { return t.substr(14).split(" ") }, e.parseRtpMap = function (t) { var s = t.substr(9).split(" "), r = { payloadType: parseInt(s.shift(), 10) }; return s = s[0].split("/"), r.name = s[0], r.clockRate = parseInt(s[1], 10), r.channels = s.length === 3 ? parseInt(s[2], 10) : 1, r.numChannels = r.channels, r }, e.writeRtpMap = function (t) {
    var s = t.payloadType; t.preferredPayloadType !== void 0 && (s = t.preferredPayloadType); var r = t.channels || t.numChannels || 1; return "a=rtpmap:" + s + " " + t.name + "/" + t.clockRate + (r !== 1 ? "/" + r : "") + `\r
`}, e.parseExtmap = function (t) { var s = t.substr(9).split(" "); return { id: parseInt(s[0], 10), direction: s[0].indexOf("/") > 0 ? s[0].split("/")[1] : "sendrecv", uri: s[1] } }, e.writeExtmap = function (t) {
      return "a=extmap:" + (t.id || t.preferredId) + (t.direction && t.direction !== "sendrecv" ? "/" + t.direction : "") + " " + t.uri + `\r
`}, e.parseFmtp = function (t) { for (var s = {}, r, n = t.substr(t.indexOf(" ") + 1).split(";"), o = 0; o < n.length; o++)r = n[o].trim().split("="), s[r[0].trim()] = r[1]; return s }, e.writeFmtp = function (t) {
      var s = "", r = t.payloadType; if (t.preferredPayloadType !== void 0 && (r = t.preferredPayloadType), t.parameters && Object.keys(t.parameters).length) {
        var n = []; Object.keys(t.parameters).forEach(function (o) { t.parameters[o] ? n.push(o + "=" + t.parameters[o]) : n.push(o) }), s += "a=fmtp:" + r + " " + n.join(";") + `\r
`} return s
    }, e.parseRtcpFb = function (t) { var s = t.substr(t.indexOf(" ") + 1).split(" "); return { type: s.shift(), parameter: s.join(" ") } }, e.writeRtcpFb = function (t) {
      var s = "", r = t.payloadType; return t.preferredPayloadType !== void 0 && (r = t.preferredPayloadType), t.rtcpFeedback && t.rtcpFeedback.length && t.rtcpFeedback.forEach(function (n) {
        s += "a=rtcp-fb:" + r + " " + n.type + (n.parameter && n.parameter.length ? " " + n.parameter : "") + `\r
`}), s
    }, e.parseSsrcMedia = function (t) { var s = t.indexOf(" "), r = { ssrc: parseInt(t.substr(7, s - 7), 10) }, n = t.indexOf(":", s); return n > -1 ? (r.attribute = t.substr(s + 1, n - s - 1), r.value = t.substr(n + 1)) : r.attribute = t.substr(s + 1), r }, e.parseSsrcGroup = function (t) { var s = t.substr(13).split(" "); return { semantics: s.shift(), ssrcs: s.map(function (r) { return parseInt(r, 10) }) } }, e.getMid = function (t) { var s = e.matchPrefix(t, "a=mid:")[0]; if (s) return s.substr(6) }, e.parseFingerprint = function (t) { var s = t.substr(14).split(" "); return { algorithm: s[0].toLowerCase(), value: s[1] } }, e.getDtlsParameters = function (t, s) { var r = e.matchPrefix(t + s, "a=fingerprint:"); return { role: "auto", fingerprints: r.map(e.parseFingerprint) } }, e.writeDtlsParameters = function (t, s) {
      var r = "a=setup:" + s + `\r
`; return t.fingerprints.forEach(function (n) {
        r += "a=fingerprint:" + n.algorithm + " " + n.value + `\r
`}), r
    }, e.parseCryptoLine = function (t) { var s = t.substr(9).split(" "); return { tag: parseInt(s[0], 10), cryptoSuite: s[1], keyParams: s[2], sessionParams: s.slice(3) } }, e.writeCryptoLine = function (t) {
      return "a=crypto:" + t.tag + " " + t.cryptoSuite + " " + (typeof t.keyParams == "object" ? e.writeCryptoKeyParams(t.keyParams) : t.keyParams) + (t.sessionParams ? " " + t.sessionParams.join(" ") : "") + `\r
`}, e.parseCryptoKeyParams = function (t) { if (t.indexOf("inline:") !== 0) return null; var s = t.substr(7).split("|"); return { keyMethod: "inline", keySalt: s[0], lifeTime: s[1], mkiValue: s[2] ? s[2].split(":")[0] : void 0, mkiLength: s[2] ? s[2].split(":")[1] : void 0 } }, e.writeCryptoKeyParams = function (t) { return t.keyMethod + ":" + t.keySalt + (t.lifeTime ? "|" + t.lifeTime : "") + (t.mkiValue && t.mkiLength ? "|" + t.mkiValue + ":" + t.mkiLength : "") }, e.getCryptoParameters = function (t, s) { var r = e.matchPrefix(t + s, "a=crypto:"); return r.map(e.parseCryptoLine) }, e.getIceParameters = function (t, s) { var r = e.matchPrefix(t + s, "a=ice-ufrag:")[0], n = e.matchPrefix(t + s, "a=ice-pwd:")[0]; return r && n ? { usernameFragment: r.substr(12), password: n.substr(10) } : null }, e.writeIceParameters = function (t) {
      return "a=ice-ufrag:" + t.usernameFragment + `\r
a=ice-pwd:`+ t.password + `\r
`}, e.parseRtpParameters = function (t) { for (var s = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r = e.splitLines(t), n = r[0].split(" "), o = 3; o < n.length; o++) { var a = n[o], l = e.matchPrefix(t, "a=rtpmap:" + a + " ")[0]; if (l) { var c = e.parseRtpMap(l), h = e.matchPrefix(t, "a=fmtp:" + a + " "); switch (c.parameters = h.length ? e.parseFmtp(h[0]) : {}, c.rtcpFeedback = e.matchPrefix(t, "a=rtcp-fb:" + a + " ").map(e.parseRtcpFb), s.codecs.push(c), c.name.toUpperCase()) { case "RED": case "ULPFEC": s.fecMechanisms.push(c.name.toUpperCase()); break } } } return e.matchPrefix(t, "a=extmap:").forEach(function (d) { s.headerExtensions.push(e.parseExtmap(d)) }), s }, e.writeRtpDescription = function (t, s) {
      var r = ""; r += "m=" + t + " ", r += s.codecs.length > 0 ? "9" : "0", r += " UDP/TLS/RTP/SAVPF ", r += s.codecs.map(function (o) { return o.preferredPayloadType !== void 0 ? o.preferredPayloadType : o.payloadType }).join(" ") + `\r
`, r += `c=IN IP4 0.0.0.0\r
`, r += `a=rtcp:9 IN IP4 0.0.0.0\r
`, s.codecs.forEach(function (o) { r += e.writeRtpMap(o), r += e.writeFmtp(o), r += e.writeRtcpFb(o) }); var n = 0; return s.codecs.forEach(function (o) { o.maxptime > n && (n = o.maxptime) }), n > 0 && (r += "a=maxptime:" + n + `\r
`), r += `a=rtcp-mux\r
`, s.headerExtensions && s.headerExtensions.forEach(function (o) { r += e.writeExtmap(o) }), r
    }, e.parseRtpEncodingParameters = function (t) { var s = [], r = e.parseRtpParameters(t), n = r.fecMechanisms.indexOf("RED") !== -1, o = r.fecMechanisms.indexOf("ULPFEC") !== -1, a = e.matchPrefix(t, "a=ssrc:").map(function (p) { return e.parseSsrcMedia(p) }).filter(function (p) { return p.attribute === "cname" }), l = a.length > 0 && a[0].ssrc, c, h = e.matchPrefix(t, "a=ssrc-group:FID").map(function (p) { var f = p.substr(17).split(" "); return f.map(function (g) { return parseInt(g, 10) }) }); h.length > 0 && h[0].length > 1 && h[0][0] === l && (c = h[0][1]), r.codecs.forEach(function (p) { if (p.name.toUpperCase() === "RTX" && p.parameters.apt) { var f = { ssrc: l, codecPayloadType: parseInt(p.parameters.apt, 10) }; l && c && (f.rtx = { ssrc: c }), s.push(f), n && (f = JSON.parse(JSON.stringify(f)), f.fec = { ssrc: l, mechanism: o ? "red+ulpfec" : "red" }, s.push(f)) } }), s.length === 0 && l && s.push({ ssrc: l }); var d = e.matchPrefix(t, "b="); return d.length && (d[0].indexOf("b=TIAS:") === 0 ? d = parseInt(d[0].substr(7), 10) : d[0].indexOf("b=AS:") === 0 ? d = parseInt(d[0].substr(5), 10) * 1e3 * .95 - 50 * 40 * 8 : d = void 0, s.forEach(function (p) { p.maxBitrate = d })), s }, e.parseRtcpParameters = function (t) { var s = {}, r = e.matchPrefix(t, "a=ssrc:").map(function (a) { return e.parseSsrcMedia(a) }).filter(function (a) { return a.attribute === "cname" })[0]; r && (s.cname = r.value, s.ssrc = r.ssrc); var n = e.matchPrefix(t, "a=rtcp-rsize"); s.reducedSize = n.length > 0, s.compound = n.length === 0; var o = e.matchPrefix(t, "a=rtcp-mux"); return s.mux = o.length > 0, s }, e.parseMsid = function (t) { var s, r = e.matchPrefix(t, "a=msid:"); if (r.length === 1) return s = r[0].substr(7).split(" "), { stream: s[0], track: s[1] }; var n = e.matchPrefix(t, "a=ssrc:").map(function (o) { return e.parseSsrcMedia(o) }).filter(function (o) { return o.attribute === "msid" }); if (n.length > 0) return s = n[0].value.split(" "), { stream: s[0], track: s[1] } }, e.parseSctpDescription = function (t) { var s = e.parseMLine(t), r = e.matchPrefix(t, "a=max-message-size:"), n; r.length > 0 && (n = parseInt(r[0].substr(19), 10)), isNaN(n) && (n = 65536); var o = e.matchPrefix(t, "a=sctp-port:"); if (o.length > 0) return { port: parseInt(o[0].substr(12), 10), protocol: s.fmt, maxMessageSize: n }; var a = e.matchPrefix(t, "a=sctpmap:"); if (a.length > 0) { var l = e.matchPrefix(t, "a=sctpmap:")[0].substr(10).split(" "); return { port: parseInt(l[0], 10), protocol: l[1], maxMessageSize: n } } }, e.writeSctpDescription = function (t, s) {
      var r = []; return t.protocol !== "DTLS/SCTP" ? r = ["m=" + t.kind + " 9 " + t.protocol + " " + s.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + s.port + `\r
`] : r = ["m=" + t.kind + " 9 " + t.protocol + " " + s.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + s.port + " " + s.protocol + ` 65535\r
`], s.maxMessageSize !== void 0 && r.push("a=max-message-size:" + s.maxMessageSize + `\r
`), r.join("")
    }, e.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, e.writeSessionBoilerplate = function (t, s, r) {
      var n, o = s !== void 0 ? s : 2; t ? n = t : n = e.generateSessionId(); var a = r || "thisisadapterortc"; return `v=0\r
o=`+ a + " " + n + " " + o + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`}, e.writeMediaSection = function (t, s, r, n) {
      var o = e.writeRtpDescription(t.kind, s); if (o += e.writeIceParameters(t.iceGatherer.getLocalParameters()), o += e.writeDtlsParameters(t.dtlsTransport.getLocalParameters(), r === "offer" ? "actpass" : "active"), o += "a=mid:" + t.mid + `\r
`, t.direction ? o += "a=" + t.direction + `\r
`: t.rtpSender && t.rtpReceiver ? o += `a=sendrecv\r
`: t.rtpSender ? o += `a=sendonly\r
`: t.rtpReceiver ? o += `a=recvonly\r
`: o += `a=inactive\r
`, t.rtpSender) {
        var a = "msid:" + n.id + " " + t.rtpSender.track.id + `\r
`; o += "a=" + a, o += "a=ssrc:" + t.sendEncodingParameters[0].ssrc + " " + a, t.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + t.sendEncodingParameters[0].rtx.ssrc + " " + a, o += "a=ssrc-group:FID " + t.sendEncodingParameters[0].ssrc + " " + t.sendEncodingParameters[0].rtx.ssrc + `\r
`)
      } return o += "a=ssrc:" + t.sendEncodingParameters[0].ssrc + " cname:" + e.localCName + `\r
`, t.rtpSender && t.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + t.sendEncodingParameters[0].rtx.ssrc + " cname:" + e.localCName + `\r
`), o
    }, e.getDirection = function (t, s) { for (var r = e.splitLines(t), n = 0; n < r.length; n++)switch (r[n]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return r[n].substr(2) }return s ? e.getDirection(s) : "sendrecv" }, e.getKind = function (t) { var s = e.splitLines(t), r = s[0].split(" "); return r[0].substr(2) }, e.isRejected = function (t) { return t.split(" ", 2)[1] === "0" }, e.parseMLine = function (t) { var s = e.splitLines(t), r = s[0].substr(2).split(" "); return { kind: r[0], port: parseInt(r[1], 10), protocol: r[2], fmt: r.slice(3).join(" ") } }, e.parseOLine = function (t) { var s = e.matchPrefix(t, "o=")[0], r = s.substr(2).split(" "); return { username: r[0], sessionId: r[1], sessionVersion: parseInt(r[2], 10), netType: r[3], addressType: r[4], address: r[5] } }, e.isValidSDP = function (t) { if (typeof t != "string" || t.length === 0) return !1; for (var s = e.splitLines(t), r = 0; r < s.length; r++)if (s[r].length < 2 || s[r].charAt(1) !== "=") return !1; return !0 }, i.exports = e
})(ek); var tk = ek.exports; const T0 = y0(tk); var Ct = tk; function q6(i) { return { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[i.type] || i.type } function ik(i, e, t, s, r) {
  var n = Ct.writeRtpDescription(i.kind, e); if (n += Ct.writeIceParameters(i.iceGatherer.getLocalParameters()), n += Ct.writeDtlsParameters(i.dtlsTransport.getLocalParameters(), t === "offer" ? "actpass" : r || "active"), n += "a=mid:" + i.mid + `\r
`, i.rtpSender && i.rtpReceiver ? n += `a=sendrecv\r
`: i.rtpSender ? n += `a=sendonly\r
`: i.rtpReceiver ? n += `a=recvonly\r
`: n += `a=inactive\r
`, i.rtpSender) {
    var o = i.rtpSender._initialTrackId || i.rtpSender.track.id; i.rtpSender._initialTrackId = o; var a = "msid:" + (s ? s.id : "-") + " " + o + `\r
`; n += "a=" + a, n += "a=ssrc:" + i.sendEncodingParameters[0].ssrc + " " + a, i.sendEncodingParameters[0].rtx && (n += "a=ssrc:" + i.sendEncodingParameters[0].rtx.ssrc + " " + a, n += "a=ssrc-group:FID " + i.sendEncodingParameters[0].ssrc + " " + i.sendEncodingParameters[0].rtx.ssrc + `\r
`)
  } return n += "a=ssrc:" + i.sendEncodingParameters[0].ssrc + " cname:" + Ct.localCName + `\r
`, i.rtpSender && i.sendEncodingParameters[0].rtx && (n += "a=ssrc:" + i.sendEncodingParameters[0].rtx.ssrc + " cname:" + Ct.localCName + `\r
`), n
} function X6(i, e) { var t = !1; return i = JSON.parse(JSON.stringify(i)), i.filter(function (s) { if (s && (s.urls || s.url)) { var r = s.urls || s.url; s.url && !s.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead."); var n = typeof r == "string"; return n && (r = [r]), r = r.filter(function (o) { var a = o.indexOf("turn:") === 0 && o.indexOf("transport=udp") !== -1 && o.indexOf("turn:[") === -1 && !t; return a ? (t = !0, !0) : o.indexOf("stun:") === 0 && e >= 14393 && o.indexOf("?transport=udp") === -1 }), delete s.url, s.urls = n ? r[0] : r, !!r.length } }) } function R0(i, e) { var t = { codecs: [], headerExtensions: [], fecMechanisms: [] }, s = function (n, o) { n = parseInt(n, 10); for (var a = 0; a < o.length; a++)if (o[a].payloadType === n || o[a].preferredPayloadType === n) return o[a] }, r = function (n, o, a, l) { var c = s(n.parameters.apt, a), h = s(o.parameters.apt, l); return c && h && c.name.toLowerCase() === h.name.toLowerCase() }; return i.codecs.forEach(function (n) { for (var o = 0; o < e.codecs.length; o++) { var a = e.codecs[o]; if (n.name.toLowerCase() === a.name.toLowerCase() && n.clockRate === a.clockRate) { if (n.name.toLowerCase() === "rtx" && n.parameters && a.parameters.apt && !r(n, a, i.codecs, e.codecs)) continue; a = JSON.parse(JSON.stringify(a)), a.numChannels = Math.min(n.numChannels, a.numChannels), t.codecs.push(a), a.rtcpFeedback = a.rtcpFeedback.filter(function (l) { for (var c = 0; c < n.rtcpFeedback.length; c++)if (n.rtcpFeedback[c].type === l.type && n.rtcpFeedback[c].parameter === l.parameter) return !0; return !1 }); break } } }), i.headerExtensions.forEach(function (n) { for (var o = 0; o < e.headerExtensions.length; o++) { var a = e.headerExtensions[o]; if (n.uri === a.uri) { t.headerExtensions.push(a); break } } }), t } function sk(i, e, t) { return { offer: { setLocalDescription: ["stable", "have-local-offer"], setRemoteDescription: ["stable", "have-remote-offer"] }, answer: { setLocalDescription: ["have-remote-offer", "have-local-pranswer"], setRemoteDescription: ["have-local-offer", "have-remote-pranswer"] } }[e][i].indexOf(t) !== -1 } function I1(i, e) { var t = i.getRemoteCandidates().find(function (s) { return e.foundation === s.foundation && e.ip === s.ip && e.port === s.port && e.priority === s.priority && e.protocol === s.protocol && e.type === s.type }); return t || i.addRemoteCandidate(e), !t } function sr(i, e) { var t = new Error(e); return t.name = i, t.code = { NotSupportedError: 9, InvalidStateError: 11, InvalidAccessError: 15, TypeError: void 0, OperationError: void 0 }[i], t } var Y6 = function (i, e) {
  function t(l, c) { c.addTrack(l), c.dispatchEvent(new i.MediaStreamTrackEvent("addtrack", { track: l })) } function s(l, c) { c.removeTrack(l), c.dispatchEvent(new i.MediaStreamTrackEvent("removetrack", { track: l })) } function r(l, c, h, d) { var p = new Event("track"); p.track = c, p.receiver = h, p.transceiver = { receiver: h }, p.streams = d, i.setTimeout(function () { l._dispatchEvent("track", p) }) } var n = function (l) { var c = this, h = document.createDocumentFragment(); if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function (p) { c[p] = h[p].bind(h) }), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", l = JSON.parse(JSON.stringify(l || {})), this.usingBundle = l.bundlePolicy === "max-bundle", l.rtcpMuxPolicy === "negotiate") throw sr("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported"); switch (l.rtcpMuxPolicy || (l.rtcpMuxPolicy = "require"), l.iceTransportPolicy) { case "all": case "relay": break; default: l.iceTransportPolicy = "all"; break }switch (l.bundlePolicy) { case "balanced": case "max-compat": case "max-bundle": break; default: l.bundlePolicy = "balanced"; break }if (l.iceServers = X6(l.iceServers || [], e), this._iceGatherers = [], l.iceCandidatePoolSize) for (var d = l.iceCandidatePoolSize; d > 0; d--)this._iceGatherers.push(new i.RTCIceGatherer({ iceServers: l.iceServers, gatherPolicy: l.iceTransportPolicy })); else l.iceCandidatePoolSize = 0; this._config = l, this.transceivers = [], this._sdpSessionId = Ct.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1 }; Object.defineProperty(n.prototype, "localDescription", { configurable: !0, get: function () { return this._localDescription } }), Object.defineProperty(n.prototype, "remoteDescription", { configurable: !0, get: function () { return this._remoteDescription } }), n.prototype.onicecandidate = null, n.prototype.onaddstream = null, n.prototype.ontrack = null, n.prototype.onremovestream = null, n.prototype.onsignalingstatechange = null, n.prototype.oniceconnectionstatechange = null, n.prototype.onconnectionstatechange = null, n.prototype.onicegatheringstatechange = null, n.prototype.onnegotiationneeded = null, n.prototype.ondatachannel = null, n.prototype._dispatchEvent = function (l, c) { this._isClosed || (this.dispatchEvent(c), typeof this["on" + l] == "function" && this["on" + l](c)) }, n.prototype._emitGatheringStateChange = function () { var l = new Event("icegatheringstatechange"); this._dispatchEvent("icegatheringstatechange", l) }, n.prototype.getConfiguration = function () { return this._config }, n.prototype.getLocalStreams = function () { return this.localStreams }, n.prototype.getRemoteStreams = function () { return this.remoteStreams }, n.prototype._createTransceiver = function (l, c) { var h = this.transceivers.length > 0, d = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: l, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, associatedRemoteMediaStreams: [], wantReceive: !0 }; if (this.usingBundle && h) d.iceTransport = this.transceivers[0].iceTransport, d.dtlsTransport = this.transceivers[0].dtlsTransport; else { var p = this._createIceAndDtlsTransports(); d.iceTransport = p.iceTransport, d.dtlsTransport = p.dtlsTransport } return c || this.transceivers.push(d), d }, n.prototype.addTrack = function (l, c) { if (this._isClosed) throw sr("InvalidStateError", "Attempted to call addTrack on a closed peerconnection."); var h = this.transceivers.find(function (f) { return f.track === l }); if (h) throw sr("InvalidAccessError", "Track already exists."); for (var d, p = 0; p < this.transceivers.length; p++)!this.transceivers[p].track && this.transceivers[p].kind === l.kind && (d = this.transceivers[p]); return d || (d = this._createTransceiver(l.kind)), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(c) === -1 && this.localStreams.push(c), d.track = l, d.stream = c, d.rtpSender = new i.RTCRtpSender(l, d.dtlsTransport), d.rtpSender }, n.prototype.addStream = function (l) { var c = this; if (e >= 15025) l.getTracks().forEach(function (d) { c.addTrack(d, l) }); else { var h = l.clone(); l.getTracks().forEach(function (d, p) { var f = h.getTracks()[p]; d.addEventListener("enabled", function (g) { f.enabled = g.enabled }) }), h.getTracks().forEach(function (d) { c.addTrack(d, h) }) } }, n.prototype.removeTrack = function (l) { if (this._isClosed) throw sr("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection."); if (!(l instanceof i.RTCRtpSender)) throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender."); var c = this.transceivers.find(function (p) { return p.rtpSender === l }); if (!c) throw sr("InvalidAccessError", "Sender was not created by this connection."); var h = c.stream; c.rtpSender.stop(), c.rtpSender = null, c.track = null, c.stream = null; var d = this.transceivers.map(function (p) { return p.stream }); d.indexOf(h) === -1 && this.localStreams.indexOf(h) > -1 && this.localStreams.splice(this.localStreams.indexOf(h), 1), this._maybeFireNegotiationNeeded() }, n.prototype.removeStream = function (l) { var c = this; l.getTracks().forEach(function (h) { var d = c.getSenders().find(function (p) { return p.track === h }); d && c.removeTrack(d) }) }, n.prototype.getSenders = function () { return this.transceivers.filter(function (l) { return !!l.rtpSender }).map(function (l) { return l.rtpSender }) }, n.prototype.getReceivers = function () { return this.transceivers.filter(function (l) { return !!l.rtpReceiver }).map(function (l) { return l.rtpReceiver }) }, n.prototype._createIceGatherer = function (l, c) { var h = this; if (c && l > 0) return this.transceivers[0].iceGatherer; if (this._iceGatherers.length) return this._iceGatherers.shift(); var d = new i.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy }); return Object.defineProperty(d, "state", { value: "new", writable: !0 }), this.transceivers[l].bufferedCandidateEvents = [], this.transceivers[l].bufferCandidates = function (p) { var f = !p.candidate || Object.keys(p.candidate).length === 0; d.state = f ? "completed" : "gathering", h.transceivers[l].bufferedCandidateEvents !== null && h.transceivers[l].bufferedCandidateEvents.push(p) }, d.addEventListener("localcandidate", this.transceivers[l].bufferCandidates), d }, n.prototype._gather = function (l, c) {
    var h = this, d = this.transceivers[c].iceGatherer; if (!d.onlocalcandidate) {
      var p = this.transceivers[c].bufferedCandidateEvents; this.transceivers[c].bufferedCandidateEvents = null, d.removeEventListener("localcandidate", this.transceivers[c].bufferCandidates), d.onlocalcandidate = function (f) {
        if (!(h.usingBundle && c > 0)) {
          var g = new Event("icecandidate"); g.candidate = { sdpMid: l, sdpMLineIndex: c }; var m = f.candidate, v = !m || Object.keys(m).length === 0; if (v) (d.state === "new" || d.state === "gathering") && (d.state = "completed"); else { d.state === "new" && (d.state = "gathering"), m.component = 1, m.ufrag = d.getLocalParameters().usernameFragment; var A = Ct.writeCandidate(m); g.candidate = Object.assign(g.candidate, Ct.parseCandidate(A)), g.candidate.candidate = A, g.candidate.toJSON = function () { return { candidate: g.candidate.candidate, sdpMid: g.candidate.sdpMid, sdpMLineIndex: g.candidate.sdpMLineIndex, usernameFragment: g.candidate.usernameFragment } } } var b = Ct.getMediaSections(h._localDescription.sdp); v ? b[g.candidate.sdpMLineIndex] += `a=end-of-candidates\r
`: b[g.candidate.sdpMLineIndex] += "a=" + g.candidate.candidate + `\r
`, h._localDescription.sdp = Ct.getDescription(h._localDescription.sdp) + b.join(""); var y = h.transceivers.every(function (_) { return _.iceGatherer && _.iceGatherer.state === "completed" }); h.iceGatheringState !== "gathering" && (h.iceGatheringState = "gathering", h._emitGatheringStateChange()), v || h._dispatchEvent("icecandidate", g), y && (h._dispatchEvent("icecandidate", new Event("icecandidate")), h.iceGatheringState = "complete", h._emitGatheringStateChange())
        }
      }, i.setTimeout(function () { p.forEach(function (f) { d.onlocalcandidate(f) }) }, 0)
    }
  }, n.prototype._createIceAndDtlsTransports = function () { var l = this, c = new i.RTCIceTransport(null); c.onicestatechange = function () { l._updateIceConnectionState(), l._updateConnectionState() }; var h = new i.RTCDtlsTransport(c); return h.ondtlsstatechange = function () { l._updateConnectionState() }, h.onerror = function () { Object.defineProperty(h, "state", { value: "failed", writable: !0 }), l._updateConnectionState() }, { iceTransport: c, dtlsTransport: h } }, n.prototype._disposeIceAndDtlsTransports = function (l) { var c = this.transceivers[l].iceGatherer; c && (delete c.onlocalcandidate, delete this.transceivers[l].iceGatherer); var h = this.transceivers[l].iceTransport; h && (delete h.onicestatechange, delete this.transceivers[l].iceTransport); var d = this.transceivers[l].dtlsTransport; d && (delete d.ondtlsstatechange, delete d.onerror, delete this.transceivers[l].dtlsTransport) }, n.prototype._transceive = function (l, c, h) { var d = R0(l.localCapabilities, l.remoteCapabilities); c && l.rtpSender && (d.encodings = l.sendEncodingParameters, d.rtcp = { cname: Ct.localCName, compound: l.rtcpParameters.compound }, l.recvEncodingParameters.length && (d.rtcp.ssrc = l.recvEncodingParameters[0].ssrc), l.rtpSender.send(d)), h && l.rtpReceiver && d.codecs.length > 0 && (l.kind === "video" && l.recvEncodingParameters && e < 15019 && l.recvEncodingParameters.forEach(function (p) { delete p.rtx }), l.recvEncodingParameters.length ? d.encodings = l.recvEncodingParameters : d.encodings = [{}], d.rtcp = { compound: l.rtcpParameters.compound }, l.rtcpParameters.cname && (d.rtcp.cname = l.rtcpParameters.cname), l.sendEncodingParameters.length && (d.rtcp.ssrc = l.sendEncodingParameters[0].ssrc), l.rtpReceiver.receive(d)) }, n.prototype.setLocalDescription = function (l) { var c = this; if (["offer", "answer"].indexOf(l.type) === -1) return Promise.reject(sr("TypeError", 'Unsupported type "' + l.type + '"')); if (!sk("setLocalDescription", l.type, c.signalingState) || c._isClosed) return Promise.reject(sr("InvalidStateError", "Can not set local " + l.type + " in state " + c.signalingState)); var h, d; if (l.type === "offer") h = Ct.splitSections(l.sdp), d = h.shift(), h.forEach(function (f, g) { var m = Ct.parseRtpParameters(f); c.transceivers[g].localCapabilities = m }), c.transceivers.forEach(function (f, g) { c._gather(f.mid, g) }); else if (l.type === "answer") { h = Ct.splitSections(c._remoteDescription.sdp), d = h.shift(); var p = Ct.matchPrefix(d, "a=ice-lite").length > 0; h.forEach(function (f, g) { var m = c.transceivers[g], v = m.iceGatherer, A = m.iceTransport, b = m.dtlsTransport, y = m.localCapabilities, _ = m.remoteCapabilities, w = Ct.isRejected(f) && Ct.matchPrefix(f, "a=bundle-only").length === 0; if (!w && !m.rejected) { var E = Ct.getIceParameters(f, d), P = Ct.getDtlsParameters(f, d); p && (P.role = "server"), (!c.usingBundle || g === 0) && (c._gather(m.mid, g), A.state === "new" && A.start(v, E, p ? "controlling" : "controlled"), b.state === "new" && b.start(P)); var C = R0(y, _); c._transceive(m, C.codecs.length > 0, !1) } }) } return c._localDescription = { type: l.type, sdp: l.sdp }, l.type === "offer" ? c._updateSignalingState("have-local-offer") : c._updateSignalingState("stable"), Promise.resolve() }, n.prototype.setRemoteDescription = function (l) { var c = this; if (["offer", "answer"].indexOf(l.type) === -1) return Promise.reject(sr("TypeError", 'Unsupported type "' + l.type + '"')); if (!sk("setRemoteDescription", l.type, c.signalingState) || c._isClosed) return Promise.reject(sr("InvalidStateError", "Can not set remote " + l.type + " in state " + c.signalingState)); var h = {}; c.remoteStreams.forEach(function (A) { h[A.id] = A }); var d = [], p = Ct.splitSections(l.sdp), f = p.shift(), g = Ct.matchPrefix(f, "a=ice-lite").length > 0, m = Ct.matchPrefix(f, "a=group:BUNDLE ").length > 0; c.usingBundle = m; var v = Ct.matchPrefix(f, "a=ice-options:")[0]; return v ? c.canTrickleIceCandidates = v.substr(14).split(" ").indexOf("trickle") >= 0 : c.canTrickleIceCandidates = !1, p.forEach(function (A, b) { var y = Ct.splitLines(A), _ = Ct.getKind(A), w = Ct.isRejected(A) && Ct.matchPrefix(A, "a=bundle-only").length === 0, E = y[0].substr(2).split(" ")[2], P = Ct.getDirection(A, f), C = Ct.parseMsid(A), R = Ct.getMid(A) || Ct.generateIdentifier(); if (w || _ === "application" && (E === "DTLS/SCTP" || E === "UDP/DTLS/SCTP")) { c.transceivers[b] = { mid: R, kind: _, protocol: E, rejected: !0 }; return } !w && c.transceivers[b] && c.transceivers[b].rejected && (c.transceivers[b] = c._createTransceiver(_, !0)); var T, z, H, N, F, X, te, re, Z, fe = Ct.parseRtpParameters(A), ae, De; w || (ae = Ct.getIceParameters(A, f), De = Ct.getDtlsParameters(A, f), De.role = "client"), te = Ct.parseRtpEncodingParameters(A); var Se = Ct.parseRtcpParameters(A), ie = Ct.matchPrefix(A, "a=end-of-candidates", f).length > 0, ce = Ct.matchPrefix(A, "a=candidate:").map(function (Pe) { return Ct.parseCandidate(Pe) }).filter(function (Pe) { return Pe.component === 1 }); if ((l.type === "offer" || l.type === "answer") && !w && m && b > 0 && c.transceivers[b] && (c._disposeIceAndDtlsTransports(b), c.transceivers[b].iceGatherer = c.transceivers[0].iceGatherer, c.transceivers[b].iceTransport = c.transceivers[0].iceTransport, c.transceivers[b].dtlsTransport = c.transceivers[0].dtlsTransport, c.transceivers[b].rtpSender && c.transceivers[b].rtpSender.setTransport(c.transceivers[0].dtlsTransport), c.transceivers[b].rtpReceiver && c.transceivers[b].rtpReceiver.setTransport(c.transceivers[0].dtlsTransport)), l.type === "offer" && !w) { T = c.transceivers[b] || c._createTransceiver(_), T.mid = R, T.iceGatherer || (T.iceGatherer = c._createIceGatherer(b, m)), ce.length && T.iceTransport.state === "new" && (ie && (!m || b === 0) ? T.iceTransport.setRemoteCandidates(ce) : ce.forEach(function (Pe) { I1(T.iceTransport, Pe) })), re = i.RTCRtpReceiver.getCapabilities(_), e < 15019 && (re.codecs = re.codecs.filter(function (Pe) { return Pe.name !== "rtx" })), X = T.sendEncodingParameters || [{ ssrc: (2 * b + 2) * 1001 }]; var Te = !1; if (P === "sendrecv" || P === "sendonly") { if (Te = !T.rtpReceiver, F = T.rtpReceiver || new i.RTCRtpReceiver(T.dtlsTransport, _), Te) { var K; Z = F.track, C && C.stream === "-" || (C ? (h[C.stream] || (h[C.stream] = new i.MediaStream, Object.defineProperty(h[C.stream], "id", { get: function () { return C.stream } })), Object.defineProperty(Z, "id", { get: function () { return C.track } }), K = h[C.stream]) : (h.default || (h.default = new i.MediaStream), K = h.default)), K && (t(Z, K), T.associatedRemoteMediaStreams.push(K)), d.push([Z, F, K]) } } else T.rtpReceiver && T.rtpReceiver.track && (T.associatedRemoteMediaStreams.forEach(function (Pe) { var ve = Pe.getTracks().find(function (de) { return de.id === T.rtpReceiver.track.id }); ve && s(ve, Pe) }), T.associatedRemoteMediaStreams = []); T.localCapabilities = re, T.remoteCapabilities = fe, T.rtpReceiver = F, T.rtcpParameters = Se, T.sendEncodingParameters = X, T.recvEncodingParameters = te, c._transceive(c.transceivers[b], !1, Te) } else if (l.type === "answer" && !w) { T = c.transceivers[b], z = T.iceGatherer, H = T.iceTransport, N = T.dtlsTransport, F = T.rtpReceiver, X = T.sendEncodingParameters, re = T.localCapabilities, c.transceivers[b].recvEncodingParameters = te, c.transceivers[b].remoteCapabilities = fe, c.transceivers[b].rtcpParameters = Se, ce.length && H.state === "new" && ((g || ie) && (!m || b === 0) ? H.setRemoteCandidates(ce) : ce.forEach(function (Pe) { I1(T.iceTransport, Pe) })), (!m || b === 0) && (H.state === "new" && H.start(z, ae, "controlling"), N.state === "new" && N.start(De)); var je = R0(T.localCapabilities, T.remoteCapabilities), Ue = je.codecs.filter(function (Pe) { return Pe.name.toLowerCase() === "rtx" }).length; !Ue && T.sendEncodingParameters[0].rtx && delete T.sendEncodingParameters[0].rtx, c._transceive(T, P === "sendrecv" || P === "recvonly", P === "sendrecv" || P === "sendonly"), F && (P === "sendrecv" || P === "sendonly") ? (Z = F.track, C ? (h[C.stream] || (h[C.stream] = new i.MediaStream), t(Z, h[C.stream]), d.push([Z, F, h[C.stream]])) : (h.default || (h.default = new i.MediaStream), t(Z, h.default), d.push([Z, F, h.default]))) : delete T.rtpReceiver } }), c._dtlsRole === void 0 && (c._dtlsRole = l.type === "offer" ? "active" : "passive"), c._remoteDescription = { type: l.type, sdp: l.sdp }, l.type === "offer" ? c._updateSignalingState("have-remote-offer") : c._updateSignalingState("stable"), Object.keys(h).forEach(function (A) { var b = h[A]; if (b.getTracks().length) { if (c.remoteStreams.indexOf(b) === -1) { c.remoteStreams.push(b); var y = new Event("addstream"); y.stream = b, i.setTimeout(function () { c._dispatchEvent("addstream", y) }) } d.forEach(function (_) { var w = _[0], E = _[1]; b.id === _[2].id && r(c, w, E, [b]) }) } }), d.forEach(function (A) { A[2] || r(c, A[0], A[1], []) }), i.setTimeout(function () { c && c.transceivers && c.transceivers.forEach(function (A) { A.iceTransport && A.iceTransport.state === "new" && A.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), A.iceTransport.addRemoteCandidate({})) }) }, 4e3), Promise.resolve() }, n.prototype.close = function () { this.transceivers.forEach(function (l) { l.iceTransport && l.iceTransport.stop(), l.dtlsTransport && l.dtlsTransport.stop(), l.rtpSender && l.rtpSender.stop(), l.rtpReceiver && l.rtpReceiver.stop() }), this._isClosed = !0, this._updateSignalingState("closed") }, n.prototype._updateSignalingState = function (l) { this.signalingState = l; var c = new Event("signalingstatechange"); this._dispatchEvent("signalingstatechange", c) }, n.prototype._maybeFireNegotiationNeeded = function () { var l = this; this.signalingState !== "stable" || this.needNegotiation === !0 || (this.needNegotiation = !0, i.setTimeout(function () { if (l.needNegotiation) { l.needNegotiation = !1; var c = new Event("negotiationneeded"); l._dispatchEvent("negotiationneeded", c) } }, 0)) }, n.prototype._updateIceConnectionState = function () { var l, c = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (d) { d.iceTransport && !d.rejected && c[d.iceTransport.state]++ }), l = "new", c.failed > 0 ? l = "failed" : c.checking > 0 ? l = "checking" : c.disconnected > 0 ? l = "disconnected" : c.new > 0 ? l = "new" : c.connected > 0 ? l = "connected" : c.completed > 0 && (l = "completed"), l !== this.iceConnectionState) { this.iceConnectionState = l; var h = new Event("iceconnectionstatechange"); this._dispatchEvent("iceconnectionstatechange", h) } }, n.prototype._updateConnectionState = function () { var l, c = { new: 0, closed: 0, connecting: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (d) { d.iceTransport && d.dtlsTransport && !d.rejected && (c[d.iceTransport.state]++, c[d.dtlsTransport.state]++) }), c.connected += c.completed, l = "new", c.failed > 0 ? l = "failed" : c.connecting > 0 ? l = "connecting" : c.disconnected > 0 ? l = "disconnected" : c.new > 0 ? l = "new" : c.connected > 0 && (l = "connected"), l !== this.connectionState) { this.connectionState = l; var h = new Event("connectionstatechange"); this._dispatchEvent("connectionstatechange", h) } }, n.prototype.createOffer = function () {
    var l = this; if (l._isClosed) return Promise.reject(sr("InvalidStateError", "Can not call createOffer after close")); var c = l.transceivers.filter(function (g) { return g.kind === "audio" }).length, h = l.transceivers.filter(function (g) { return g.kind === "video" }).length, d = arguments[0]; if (d) { if (d.mandatory || d.optional) throw new TypeError("Legacy mandatory/optional constraints not supported."); d.offerToReceiveAudio !== void 0 && (d.offerToReceiveAudio === !0 ? c = 1 : d.offerToReceiveAudio === !1 ? c = 0 : c = d.offerToReceiveAudio), d.offerToReceiveVideo !== void 0 && (d.offerToReceiveVideo === !0 ? h = 1 : d.offerToReceiveVideo === !1 ? h = 0 : h = d.offerToReceiveVideo) } for (l.transceivers.forEach(function (g) { g.kind === "audio" ? (c--, c < 0 && (g.wantReceive = !1)) : g.kind === "video" && (h--, h < 0 && (g.wantReceive = !1)) }); c > 0 || h > 0;)c > 0 && (l._createTransceiver("audio"), c--), h > 0 && (l._createTransceiver("video"), h--); var p = Ct.writeSessionBoilerplate(l._sdpSessionId, l._sdpSessionVersion++); l.transceivers.forEach(function (g, m) { var v = g.track, A = g.kind, b = g.mid || Ct.generateIdentifier(); g.mid = b, g.iceGatherer || (g.iceGatherer = l._createIceGatherer(m, l.usingBundle)); var y = i.RTCRtpSender.getCapabilities(A); e < 15019 && (y.codecs = y.codecs.filter(function (w) { return w.name !== "rtx" })), y.codecs.forEach(function (w) { w.name === "H264" && w.parameters["level-asymmetry-allowed"] === void 0 && (w.parameters["level-asymmetry-allowed"] = "1"), g.remoteCapabilities && g.remoteCapabilities.codecs && g.remoteCapabilities.codecs.forEach(function (E) { w.name.toLowerCase() === E.name.toLowerCase() && w.clockRate === E.clockRate && (w.preferredPayloadType = E.payloadType) }) }), y.headerExtensions.forEach(function (w) { var E = g.remoteCapabilities && g.remoteCapabilities.headerExtensions || []; E.forEach(function (P) { w.uri === P.uri && (w.id = P.id) }) }); var _ = g.sendEncodingParameters || [{ ssrc: (2 * m + 1) * 1001 }]; v && e >= 15019 && A === "video" && !_[0].rtx && (_[0].rtx = { ssrc: _[0].ssrc + 1 }), g.wantReceive && (g.rtpReceiver = new i.RTCRtpReceiver(g.dtlsTransport, A)), g.localCapabilities = y, g.sendEncodingParameters = _ }), l._config.bundlePolicy !== "max-compat" && (p += "a=group:BUNDLE " + l.transceivers.map(function (g) { return g.mid }).join(" ") + `\r
`), p += `a=ice-options:trickle\r
`, l.transceivers.forEach(function (g, m) {
      p += ik(g, g.localCapabilities, "offer", g.stream, l._dtlsRole), p += `a=rtcp-rsize\r
`, g.iceGatherer && l.iceGatheringState !== "new" && (m === 0 || !l.usingBundle) && (g.iceGatherer.getLocalCandidates().forEach(function (v) {
        v.component = 1, p += "a=" + Ct.writeCandidate(v) + `\r
`}), g.iceGatherer.state === "completed" && (p += `a=end-of-candidates\r
`))
    }); var f = new i.RTCSessionDescription({ type: "offer", sdp: p }); return Promise.resolve(f)
  }, n.prototype.createAnswer = function () {
    var l = this; if (l._isClosed) return Promise.reject(sr("InvalidStateError", "Can not call createAnswer after close")); if (!(l.signalingState === "have-remote-offer" || l.signalingState === "have-local-pranswer")) return Promise.reject(sr("InvalidStateError", "Can not call createAnswer in signalingState " + l.signalingState)); var c = Ct.writeSessionBoilerplate(l._sdpSessionId, l._sdpSessionVersion++); l.usingBundle && (c += "a=group:BUNDLE " + l.transceivers.map(function (p) { return p.mid }).join(" ") + `\r
`), c += `a=ice-options:trickle\r
`; var h = Ct.getMediaSections(l._remoteDescription.sdp).length; l.transceivers.forEach(function (p, f) {
      if (!(f + 1 > h)) {
        if (p.rejected) {
          p.kind === "application" ? p.protocol === "DTLS/SCTP" ? c += `m=application 0 DTLS/SCTP 5000\r
`: c += "m=application 0 " + p.protocol + ` webrtc-datachannel\r
`: p.kind === "audio" ? c += `m=audio 0 UDP/TLS/RTP/SAVPF 0\r
a=rtpmap:0 PCMU/8000\r
`: p.kind === "video" && (c += `m=video 0 UDP/TLS/RTP/SAVPF 120\r
a=rtpmap:120 VP8/90000\r
`), c += `c=IN IP4 0.0.0.0\r
a=inactive\r
a=mid:`+ p.mid + `\r
`; return
        } if (p.stream) { var g; p.kind === "audio" ? g = p.stream.getAudioTracks()[0] : p.kind === "video" && (g = p.stream.getVideoTracks()[0]), g && e >= 15019 && p.kind === "video" && !p.sendEncodingParameters[0].rtx && (p.sendEncodingParameters[0].rtx = { ssrc: p.sendEncodingParameters[0].ssrc + 1 }) } var m = R0(p.localCapabilities, p.remoteCapabilities), v = m.codecs.filter(function (A) { return A.name.toLowerCase() === "rtx" }).length; !v && p.sendEncodingParameters[0].rtx && delete p.sendEncodingParameters[0].rtx, c += ik(p, m, "answer", p.stream, l._dtlsRole), p.rtcpParameters && p.rtcpParameters.reducedSize && (c += `a=rtcp-rsize\r
`)
      }
    }); var d = new i.RTCSessionDescription({ type: "answer", sdp: c }); return Promise.resolve(d)
  }, n.prototype.addIceCandidate = function (l) {
    var c = this, h; return l && !(l.sdpMLineIndex !== void 0 || l.sdpMid) ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function (d, p) {
      if (c._remoteDescription) if (!l || l.candidate === "") for (var f = 0; f < c.transceivers.length && !(!c.transceivers[f].rejected && (c.transceivers[f].iceTransport.addRemoteCandidate({}), h = Ct.getMediaSections(c._remoteDescription.sdp), h[f] += `a=end-of-candidates\r
`, c._remoteDescription.sdp = Ct.getDescription(c._remoteDescription.sdp) + h.join(""), c.usingBundle)); f++); else {
        var g = l.sdpMLineIndex; if (l.sdpMid) { for (var m = 0; m < c.transceivers.length; m++)if (c.transceivers[m].mid === l.sdpMid) { g = m; break } } var v = c.transceivers[g]; if (v) {
          if (v.rejected) return d(); var A = Object.keys(l.candidate).length > 0 ? Ct.parseCandidate(l.candidate) : {}; if (A.protocol === "tcp" && (A.port === 0 || A.port === 9) || A.component && A.component !== 1) return d(); if ((g === 0 || g > 0 && v.iceTransport !== c.transceivers[0].iceTransport) && !I1(v.iceTransport, A)) return p(sr("OperationError", "Can not add ICE candidate")); var b = l.candidate.trim(); b.indexOf("a=") === 0 && (b = b.substr(2)), h = Ct.getMediaSections(c._remoteDescription.sdp), h[g] += "a=" + (A.type ? b : "end-of-candidates") + `\r
`, c._remoteDescription.sdp = Ct.getDescription(c._remoteDescription.sdp) + h.join("")
        } else return p(sr("OperationError", "Can not add ICE candidate"))
      } else return p(sr("InvalidStateError", "Can not add ICE candidate without a remote description")); d()
    })
  }, n.prototype.getStats = function (l) { if (l && l instanceof i.MediaStreamTrack) { var c = null; if (this.transceivers.forEach(function (d) { d.rtpSender && d.rtpSender.track === l ? c = d.rtpSender : d.rtpReceiver && d.rtpReceiver.track === l && (c = d.rtpReceiver) }), !c) throw sr("InvalidAccessError", "Invalid selector."); return c.getStats() } var h = []; return this.transceivers.forEach(function (d) { ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function (p) { d[p] && h.push(d[p].getStats()) }) }), Promise.all(h).then(function (d) { var p = new Map; return d.forEach(function (f) { f.forEach(function (g) { p.set(g.id, g) }) }), p }) }; var o = ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"]; o.forEach(function (l) { var c = i[l]; if (c && c.prototype && c.prototype.getStats) { var h = c.prototype.getStats; c.prototype.getStats = function () { return h.apply(this).then(function (d) { var p = new Map; return Object.keys(d).forEach(function (f) { d[f].type = q6(d[f]), p.set(f, d[f]) }), p }) } } }); var a = ["createOffer", "createAnswer"]; return a.forEach(function (l) { var c = n.prototype[l]; n.prototype[l] = function () { var h = arguments; return typeof h[0] == "function" || typeof h[1] == "function" ? c.apply(this, [arguments[2]]).then(function (d) { typeof h[0] == "function" && h[0].apply(null, [d]) }, function (d) { typeof h[1] == "function" && h[1].apply(null, [d]) }) : c.apply(this, arguments) } }), a = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"], a.forEach(function (l) { var c = n.prototype[l]; n.prototype[l] = function () { var h = arguments; return typeof h[1] == "function" || typeof h[2] == "function" ? c.apply(this, arguments).then(function () { typeof h[1] == "function" && h[1].apply(null) }, function (d) { typeof h[2] == "function" && h[2].apply(null, [d]) }) : c.apply(this, arguments) } }), ["getStats"].forEach(function (l) { var c = n.prototype[l]; n.prototype[l] = function () { var h = arguments; return typeof h[1] == "function" ? c.apply(this, arguments).then(function () { typeof h[1] == "function" && h[1].apply(null) }) : c.apply(this, arguments) } }), n
}; const J6 = y0(Y6); function rk(i) { const e = i && i.navigator, t = function (r) { return { name: { PermissionDeniedError: "NotAllowedError" }[r.name] || r.name, message: r.message, constraint: r.constraint, toString() { return this.name } } }, s = e.mediaDevices.getUserMedia.bind(e.mediaDevices); e.mediaDevices.getUserMedia = function (r) { return s(r).catch(n => Promise.reject(t(n))) } } function nk(i) { "getDisplayMedia" in i.navigator && i.navigator.mediaDevices && (i.navigator.mediaDevices && "getDisplayMedia" in i.navigator.mediaDevices || (i.navigator.mediaDevices.getDisplayMedia = i.navigator.getDisplayMedia.bind(i.navigator))) } function T1(i, e) { if (i.RTCIceGatherer && (i.RTCIceCandidate || (i.RTCIceCandidate = function (s) { return s }), i.RTCSessionDescription || (i.RTCSessionDescription = function (s) { return s }), e.version < 15025)) { const s = Object.getOwnPropertyDescriptor(i.MediaStreamTrack.prototype, "enabled"); Object.defineProperty(i.MediaStreamTrack.prototype, "enabled", { set(r) { s.set.call(this, r); const n = new Event("enabled"); n.enabled = r, this.dispatchEvent(n) } }) } i.RTCRtpSender && !("dtmf" in i.RTCRtpSender.prototype) && Object.defineProperty(i.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = new i.RTCDtmfSender(this) : this.track.kind === "video" && (this._dtmf = null)), this._dtmf } }), i.RTCDtmfSender && !i.RTCDTMFSender && (i.RTCDTMFSender = i.RTCDtmfSender); const t = J6(i, e.version); i.RTCPeerConnection = function (s) { return s && s.iceServers && (s.iceServers = W6(s.iceServers, e.version), S1("ICE servers after filtering:", s.iceServers)), new t(s) }, i.RTCPeerConnection.prototype = t.prototype } function ok(i) { i.RTCRtpSender && !("replaceTrack" in i.RTCRtpSender.prototype) && (i.RTCRtpSender.prototype.replaceTrack = i.RTCRtpSender.prototype.setTrack) } const ak = Object.freeze(Object.defineProperty({ __proto__: null, shimGetDisplayMedia: nk, shimGetUserMedia: rk, shimPeerConnection: T1, shimReplaceTrack: ok }, Symbol.toStringTag, { value: "Module" })); function lk(i, e) { const t = i && i.navigator, s = i && i.MediaStreamTrack; if (t.getUserMedia = function (r, n, o) { I0("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), t.mediaDevices.getUserMedia(r).then(n, o) }, !(e.version > 55 && "autoGainControl" in t.mediaDevices.getSupportedConstraints())) { const r = function (o, a, l) { a in o && !(l in o) && (o[l] = o[a], delete o[a]) }, n = t.mediaDevices.getUserMedia.bind(t.mediaDevices); if (t.mediaDevices.getUserMedia = function (o) { return typeof o == "object" && typeof o.audio == "object" && (o = JSON.parse(JSON.stringify(o)), r(o.audio, "autoGainControl", "mozAutoGainControl"), r(o.audio, "noiseSuppression", "mozNoiseSuppression")), n(o) }, s && s.prototype.getSettings) { const o = s.prototype.getSettings; s.prototype.getSettings = function () { const a = o.apply(this, arguments); return r(a, "mozAutoGainControl", "autoGainControl"), r(a, "mozNoiseSuppression", "noiseSuppression"), a } } if (s && s.prototype.applyConstraints) { const o = s.prototype.applyConstraints; s.prototype.applyConstraints = function (a) { return this.kind === "audio" && typeof a == "object" && (a = JSON.parse(JSON.stringify(a)), r(a, "autoGainControl", "mozAutoGainControl"), r(a, "noiseSuppression", "mozNoiseSuppression")), o.apply(this, [a]) } } } } function K6(i, e) { i.navigator.mediaDevices && "getDisplayMedia" in i.navigator.mediaDevices || i.navigator.mediaDevices && (i.navigator.mediaDevices.getDisplayMedia = function (t) { if (!(t && t.video)) { const s = new DOMException("getDisplayMedia without video constraints is undefined"); return s.name = "NotFoundError", s.code = 8, Promise.reject(s) } return t.video === !0 ? t.video = { mediaSource: e } : t.video.mediaSource = e, i.navigator.mediaDevices.getUserMedia(t) }) } function ck(i) { typeof i == "object" && i.RTCTrackEvent && "receiver" in i.RTCTrackEvent.prototype && !("transceiver" in i.RTCTrackEvent.prototype) && Object.defineProperty(i.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function R1(i, e) { if (typeof i != "object" || !(i.RTCPeerConnection || i.mozRTCPeerConnection)) return; !i.RTCPeerConnection && i.mozRTCPeerConnection && (i.RTCPeerConnection = i.mozRTCPeerConnection), e.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (r) { const n = i.RTCPeerConnection.prototype[r], o = { [r]() { return arguments[0] = new (r === "addIceCandidate" ? i.RTCIceCandidate : i.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } }; i.RTCPeerConnection.prototype[r] = o[r] }); const t = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, s = i.RTCPeerConnection.prototype.getStats; i.RTCPeerConnection.prototype.getStats = function () { const [r, n, o] = arguments; return s.apply(this, [r || null]).then(a => { if (e.version < 53 && !n) try { a.forEach(l => { l.type = t[l.type] || l.type }) } catch (l) { if (l.name !== "TypeError") throw l; a.forEach((c, h) => { a.set(h, Object.assign({}, c, { type: t[c.type] || c.type })) }) } return a }).then(n, o) } } function hk(i) { if (!(typeof i == "object" && i.RTCPeerConnection && i.RTCRtpSender) || i.RTCRtpSender && "getStats" in i.RTCRtpSender.prototype) return; const e = i.RTCPeerConnection.prototype.getSenders; e && (i.RTCPeerConnection.prototype.getSenders = function () { const s = e.apply(this, []); return s.forEach(r => r._pc = this), s }); const t = i.RTCPeerConnection.prototype.addTrack; t && (i.RTCPeerConnection.prototype.addTrack = function () { const s = t.apply(this, arguments); return s._pc = this, s }), i.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map) } } function uk(i) { if (!(typeof i == "object" && i.RTCPeerConnection && i.RTCRtpSender) || i.RTCRtpSender && "getStats" in i.RTCRtpReceiver.prototype) return; const e = i.RTCPeerConnection.prototype.getReceivers; e && (i.RTCPeerConnection.prototype.getReceivers = function () { const t = e.apply(this, []); return t.forEach(s => s._pc = this), t }), fd(i, "track", t => (t.receiver._pc = t.srcElement, t)), i.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } function dk(i) { !i.RTCPeerConnection || "removeStream" in i.RTCPeerConnection.prototype || (i.RTCPeerConnection.prototype.removeStream = function (e) { I0("removeStream", "removeTrack"), this.getSenders().forEach(t => { t.track && e.getTracks().includes(t.track) && this.removeTrack(t) }) }) } function pk(i) { i.DataChannel && !i.RTCDataChannel && (i.RTCDataChannel = i.DataChannel) } function fk(i) { if (!(typeof i == "object" && i.RTCPeerConnection)) return; const e = i.RTCPeerConnection.prototype.addTransceiver; e && (i.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; const t = arguments[1], s = t && "sendEncodings" in t; s && t.sendEncodings.forEach(n => { if ("rid" in n && !/^[a-z0-9]{0,16}$/i.test(n.rid)) throw new TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in n && !(parseFloat(n.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in n && !(parseFloat(n.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0") }); const r = e.apply(this, arguments); if (s) { const { sender: n } = r, o = n.getParameters(); (!("encodings" in o) || o.encodings.length === 1 && Object.keys(o.encodings[0]).length === 0) && (o.encodings = t.sendEncodings, n.sendEncodings = t.sendEncodings, this.setParametersPromises.push(n.setParameters(o).then(() => { delete n.sendEncodings }).catch(() => { delete n.sendEncodings }))) } return r }) } function gk(i) { if (!(typeof i == "object" && i.RTCRtpSender)) return; const e = i.RTCRtpSender.prototype.getParameters; e && (i.RTCRtpSender.prototype.getParameters = function () { const t = e.apply(this, arguments); return "encodings" in t || (t.encodings = [].concat(this.sendEncodings || [{}])), t }) } function mk(i) { if (!(typeof i == "object" && i.RTCPeerConnection)) return; const e = i.RTCPeerConnection.prototype.createOffer; i.RTCPeerConnection.prototype.createOffer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => e.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : e.apply(this, arguments) } } function vk(i) { if (!(typeof i == "object" && i.RTCPeerConnection)) return; const e = i.RTCPeerConnection.prototype.createAnswer; i.RTCPeerConnection.prototype.createAnswer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => e.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : e.apply(this, arguments) } } const Ak = Object.freeze(Object.defineProperty({ __proto__: null, shimAddTransceiver: fk, shimCreateAnswer: vk, shimCreateOffer: mk, shimGetDisplayMedia: K6, shimGetParameters: gk, shimGetUserMedia: lk, shimOnTrack: ck, shimPeerConnection: R1, shimRTCDataChannel: pk, shimReceiverGetStats: uk, shimRemoveStream: dk, shimSenderGetStats: hk }, Symbol.toStringTag, { value: "Module" })); function yk(i) { if (!(typeof i != "object" || !i.RTCPeerConnection)) { if ("getLocalStreams" in i.RTCPeerConnection.prototype || (i.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in i.RTCPeerConnection.prototype)) { const e = i.RTCPeerConnection.prototype.addTrack; i.RTCPeerConnection.prototype.addStream = function (t) { this._localStreams || (this._localStreams = []), this._localStreams.includes(t) || this._localStreams.push(t), t.getAudioTracks().forEach(s => e.call(this, s, t)), t.getVideoTracks().forEach(s => e.call(this, s, t)) }, i.RTCPeerConnection.prototype.addTrack = function (t, ...s) { return s && s.forEach(r => { this._localStreams ? this._localStreams.includes(r) || this._localStreams.push(r) : this._localStreams = [r] }), e.apply(this, arguments) } } "removeStream" in i.RTCPeerConnection.prototype || (i.RTCPeerConnection.prototype.removeStream = function (e) { this._localStreams || (this._localStreams = []); const t = this._localStreams.indexOf(e); if (t === -1) return; this._localStreams.splice(t, 1); const s = e.getTracks(); this.getSenders().forEach(r => { s.includes(r.track) && this.removeTrack(r) }) }) } } function bk(i) { if (!(typeof i != "object" || !i.RTCPeerConnection) && ("getRemoteStreams" in i.RTCPeerConnection.prototype || (i.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in i.RTCPeerConnection.prototype))) { Object.defineProperty(i.RTCPeerConnection.prototype, "onaddstream", { get() { return this._onaddstream }, set(t) { this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = t), this.addEventListener("track", this._onaddstreampoly = s => { s.streams.forEach(r => { if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(r)) return; this._remoteStreams.push(r); const n = new Event("addstream"); n.stream = r, this.dispatchEvent(n) }) }) } }); const e = i.RTCPeerConnection.prototype.setRemoteDescription; i.RTCPeerConnection.prototype.setRemoteDescription = function () { const t = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (s) { s.streams.forEach(r => { if (t._remoteStreams || (t._remoteStreams = []), t._remoteStreams.indexOf(r) >= 0) return; t._remoteStreams.push(r); const n = new Event("addstream"); n.stream = r, t.dispatchEvent(n) }) }), e.apply(t, arguments) } } } function _k(i) { if (typeof i != "object" || !i.RTCPeerConnection) return; const e = i.RTCPeerConnection.prototype, t = e.createOffer, s = e.createAnswer, r = e.setLocalDescription, n = e.setRemoteDescription, o = e.addIceCandidate; e.createOffer = function (l, c) { const h = arguments.length >= 2 ? arguments[2] : arguments[0], d = t.apply(this, [h]); return c ? (d.then(l, c), Promise.resolve()) : d }, e.createAnswer = function (l, c) { const h = arguments.length >= 2 ? arguments[2] : arguments[0], d = s.apply(this, [h]); return c ? (d.then(l, c), Promise.resolve()) : d }; let a = function (l, c, h) { const d = r.apply(this, [l]); return h ? (d.then(c, h), Promise.resolve()) : d }; e.setLocalDescription = a, a = function (l, c, h) { const d = n.apply(this, [l]); return h ? (d.then(c, h), Promise.resolve()) : d }, e.setRemoteDescription = a, a = function (l, c, h) { const d = o.apply(this, [l]); return h ? (d.then(c, h), Promise.resolve()) : d }, e.addIceCandidate = a } function xk(i) { const e = i && i.navigator; if (e.mediaDevices && e.mediaDevices.getUserMedia) { const t = e.mediaDevices, s = t.getUserMedia.bind(t); e.mediaDevices.getUserMedia = r => s(wk(r)) } !e.getUserMedia && e.mediaDevices && e.mediaDevices.getUserMedia && (e.getUserMedia = function (t, s, r) { e.mediaDevices.getUserMedia(t).then(s, r) }.bind(e)) } function wk(i) { return i && i.video !== void 0 ? Object.assign({}, i, { video: jB(i.video) }) : i } function Ck(i) { if (!i.RTCPeerConnection) return; const e = i.RTCPeerConnection; i.RTCPeerConnection = function (t, s) { if (t && t.iceServers) { const r = []; for (let n = 0; n < t.iceServers.length; n++) { let o = t.iceServers[n]; !o.hasOwnProperty("urls") && o.hasOwnProperty("url") ? (I0("RTCIceServer.url", "RTCIceServer.urls"), o = JSON.parse(JSON.stringify(o)), o.urls = o.url, delete o.url, r.push(o)) : r.push(t.iceServers[n]) } t.iceServers = r } return new e(t, s) }, i.RTCPeerConnection.prototype = e.prototype, "generateCertificate" in e && Object.defineProperty(i.RTCPeerConnection, "generateCertificate", { get() { return e.generateCertificate } }) } function Sk(i) { typeof i == "object" && i.RTCTrackEvent && "receiver" in i.RTCTrackEvent.prototype && !("transceiver" in i.RTCTrackEvent.prototype) && Object.defineProperty(i.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function Ek(i) { const e = i.RTCPeerConnection.prototype.createOffer; i.RTCPeerConnection.prototype.createOffer = function (t) { if (t) { typeof t.offerToReceiveAudio < "u" && (t.offerToReceiveAudio = !!t.offerToReceiveAudio); const s = this.getTransceivers().find(n => n.receiver.track.kind === "audio"); t.offerToReceiveAudio === !1 && s ? s.direction === "sendrecv" ? s.setDirection ? s.setDirection("sendonly") : s.direction = "sendonly" : s.direction === "recvonly" && (s.setDirection ? s.setDirection("inactive") : s.direction = "inactive") : t.offerToReceiveAudio === !0 && !s && this.addTransceiver("audio"), typeof t.offerToReceiveVideo < "u" && (t.offerToReceiveVideo = !!t.offerToReceiveVideo); const r = this.getTransceivers().find(n => n.receiver.track.kind === "video"); t.offerToReceiveVideo === !1 && r ? r.direction === "sendrecv" ? r.setDirection ? r.setDirection("sendonly") : r.direction = "sendonly" : r.direction === "recvonly" && (r.setDirection ? r.setDirection("inactive") : r.direction = "inactive") : t.offerToReceiveVideo === !0 && !r && this.addTransceiver("video") } return e.apply(this, arguments) } } function Mk(i) { typeof i != "object" || i.AudioContext || (i.AudioContext = i.webkitAudioContext) } const Ik = Object.freeze(Object.defineProperty({ __proto__: null, shimAudioContext: Mk, shimCallbacksAPI: _k, shimConstraints: wk, shimCreateOfferLegacy: Ek, shimGetUserMedia: xk, shimLocalStreamsAPI: yk, shimRTCIceServerUrls: Ck, shimRemoteStreamsAPI: bk, shimTrackEventTransceiver: Sk }, Symbol.toStringTag, { value: "Module" })); function P0(i) { if (!i.RTCIceCandidate || i.RTCIceCandidate && "foundation" in i.RTCIceCandidate.prototype) return; const e = i.RTCIceCandidate; i.RTCIceCandidate = function (t) { if (typeof t == "object" && t.candidate && t.candidate.indexOf("a=") === 0 && (t = JSON.parse(JSON.stringify(t)), t.candidate = t.candidate.substr(2)), t.candidate && t.candidate.length) { const s = new e(t), r = T0.parseCandidate(t.candidate), n = Object.assign(s, r); return n.toJSON = function () { return { candidate: n.candidate, sdpMid: n.sdpMid, sdpMLineIndex: n.sdpMLineIndex, usernameFragment: n.usernameFragment } }, n } return new e(t) }, i.RTCIceCandidate.prototype = e.prototype, fd(i, "icecandidate", t => (t.candidate && Object.defineProperty(t, "candidate", { value: new i.RTCIceCandidate(t.candidate), writable: "false" }), t)) } function Xf(i, e) { if (!i.RTCPeerConnection) return; "sctp" in i.RTCPeerConnection.prototype || Object.defineProperty(i.RTCPeerConnection.prototype, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp } }); const t = function (a) { if (!a || !a.sdp) return !1; const l = T0.splitSections(a.sdp); return l.shift(), l.some(c => { const h = T0.parseMLine(c); return h && h.kind === "application" && h.protocol.indexOf("SCTP") !== -1 }) }, s = function (a) { const l = a.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (l === null || l.length < 2) return -1; const c = parseInt(l[1], 10); return c !== c ? -1 : c }, r = function (a) { let l = 65536; return e.browser === "firefox" && (e.version < 57 ? a === -1 ? l = 16384 : l = 2147483637 : e.version < 60 ? l = e.version === 57 ? 65535 : 65536 : l = 2147483637), l }, n = function (a, l) { let c = 65536; e.browser === "firefox" && e.version === 57 && (c = 65535); const h = T0.matchPrefix(a.sdp, "a=max-message-size:"); return h.length > 0 ? c = parseInt(h[0].substr(19), 10) : e.browser === "firefox" && l !== -1 && (c = 2147483637), c }, o = i.RTCPeerConnection.prototype.setRemoteDescription; i.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, e.browser === "chrome" && e.version >= 76) { const { sdpSemantics: a } = this.getConfiguration(); a === "plan-b" && Object.defineProperty(this, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp }, enumerable: !0, configurable: !0 }) } if (t(arguments[0])) { const a = s(arguments[0]), l = r(a), c = n(arguments[0], a); let h; l === 0 && c === 0 ? h = Number.POSITIVE_INFINITY : l === 0 || c === 0 ? h = Math.max(l, c) : h = Math.min(l, c); const d = {}; Object.defineProperty(d, "maxMessageSize", { get() { return h } }), this._sctp = d } return o.apply(this, arguments) } } function Yf(i) { if (!(i.RTCPeerConnection && "createDataChannel" in i.RTCPeerConnection.prototype)) return; function e(s, r) { const n = s.send; s.send = function () { const o = arguments[0], a = o.length || o.size || o.byteLength; if (s.readyState === "open" && r.sctp && a > r.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + r.sctp.maxMessageSize + " bytes)"); return n.apply(s, arguments) } } const t = i.RTCPeerConnection.prototype.createDataChannel; i.RTCPeerConnection.prototype.createDataChannel = function () { const s = t.apply(this, arguments); return e(s, this), s }, fd(i, "datachannel", s => (e(s.channel, s.target), s)) } function P1(i) { if (!i.RTCPeerConnection || "connectionState" in i.RTCPeerConnection.prototype) return; const e = i.RTCPeerConnection.prototype; Object.defineProperty(e, "connectionState", { get() { return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(e, "onconnectionstatechange", { get() { return this._onconnectionstatechange || null }, set(t) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), t && this.addEventListener("connectionstatechange", this._onconnectionstatechange = t) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach(t => { const s = e[t]; e[t] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = r => { const n = r.target; if (n._lastConnectionState !== n.connectionState) { n._lastConnectionState = n.connectionState; const o = new Event("connectionstatechange", r); n.dispatchEvent(o) } return r }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), s.apply(this, arguments) } }) } function B1(i, e) {
  if (!i.RTCPeerConnection || e.browser === "chrome" && e.version >= 71 || e.browser === "safari" && e.version >= 605) return; const t = i.RTCPeerConnection.prototype.setRemoteDescription; i.RTCPeerConnection.prototype.setRemoteDescription = function (s) {
    if (s && s.sdp && s.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
      const r = s.sdp.split(`
`).filter(n => n.trim() !== "a=extmap-allow-mixed").join(`
`); i.RTCSessionDescription && s instanceof i.RTCSessionDescription ? arguments[0] = new i.RTCSessionDescription({ type: s.type, sdp: r }) : s.sdp = r
    } return t.apply(this, arguments)
  }
} function B0(i, e) { if (!(i.RTCPeerConnection && i.RTCPeerConnection.prototype)) return; const t = i.RTCPeerConnection.prototype.addIceCandidate; !t || t.length === 0 || (i.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? (e.browser === "chrome" && e.version < 78 || e.browser === "firefox" && e.version < 68 || e.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : t.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }) } const Z6 = Object.freeze(Object.defineProperty({ __proto__: null, removeExtmapAllowMixed: B1, shimAddIceCandidateNullOrEmpty: B0, shimConnectionState: P1, shimMaxMessageSize: Xf, shimRTCIceCandidate: P0, shimSendThrowTypeError: Yf }, Symbol.toStringTag, { value: "Module" })); function $6({ window: i } = {}, e = { shimChrome: !0, shimFirefox: !0, shimEdge: !0, shimSafari: !0 }) { const t = S1, s = H6(i), r = { browserDetails: s, commonShim: Z6, extractVersion: qf, disableLog: Q6, disableWarnings: G6 }; switch (s.browser) { case "chrome": if (!$B || !M1 || !e.shimChrome) return t("Chrome shim is not included in this adapter release."), r; if (s.version === null) return t("Chrome shim can not determine version, not shimming."), r; t("adapter.js shimming chrome."), r.browserShim = $B, B0(i, s), HB(i, s), VB(i), M1(i, s), WB(i), KB(i, s), qB(i), XB(i), YB(i), ZB(i, s), P0(i), P1(i), Xf(i, s), Yf(i), B1(i, s); break; case "firefox": if (!Ak || !R1 || !e.shimFirefox) return t("Firefox shim is not included in this adapter release."), r; t("adapter.js shimming firefox."), r.browserShim = Ak, B0(i, s), lk(i, s), R1(i, s), ck(i), dk(i), hk(i), uk(i), pk(i), fk(i), gk(i), mk(i), vk(i), P0(i), P1(i), Xf(i, s), Yf(i); break; case "edge": if (!ak || !T1 || !e.shimEdge) return t("MS edge shim is not included in this adapter release."), r; t("adapter.js shimming edge."), r.browserShim = ak, rk(i), nk(i), T1(i, s), ok(i), Xf(i, s), Yf(i); break; case "safari": if (!Ik || !e.shimSafari) return t("Safari shim is not included in this adapter release."), r; t("adapter.js shimming safari."), r.browserShim = Ik, B0(i, s), Ck(i), Ek(i), _k(i), yk(i), bk(i), Sk(i), xk(i), Mk(i), P0(i), Xf(i, s), Yf(i), B1(i, s); break; default: t("Unsupported browser!"); break }return r } const Tk = $6({ window: typeof window > "u" ? void 0 : window }); function Uo(i, e, t, s) { Object.defineProperty(i, e, { get: t, set: s, enumerable: !0, configurable: !0 }) } var k1 = Tk.default || Tk, Jf = new (function () {
  function i() { this.isIOS = ["iPad", "iPhone", "iPod"].includes(navigator.platform), this.supportedBrowsers = ["firefox", "chrome", "safari"], this.minFirefoxVersion = 59, this.minChromeVersion = 72, this.minSafariVersion = 605 } return i.prototype.isWebRTCSupported = function () { return typeof RTCPeerConnection < "u" }, i.prototype.isBrowserSupported = function () { var e = this.getBrowser(), t = this.getVersion(), s = this.supportedBrowsers.includes(e); return s ? e === "chrome" ? t >= this.minChromeVersion : e === "firefox" ? t >= this.minFirefoxVersion : e === "safari" ? !this.isIOS && t >= this.minSafariVersion : !1 : !1 }, i.prototype.getBrowser = function () { return k1.browserDetails.browser }, i.prototype.getVersion = function () { return k1.browserDetails.version || 0 }, i.prototype.isUnifiedPlanSupported = function () { var e = this.getBrowser(), t = k1.browserDetails.version || 0; if (e === "chrome" && t < this.minChromeVersion) return !1; if (e === "firefox" && t >= this.minFirefoxVersion) return !0; if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return !1; var s, r = !1; try { s = new RTCPeerConnection, s.addTransceiver("audio"), r = !0 } catch { } finally { s && s.close() } return r }, i.prototype.toString = function () {
    return `Supports:
    browser:`.concat(this.getBrowser(), `
    version:`).concat(this.getVersion(), `
    isIOS:`).concat(this.isIOS, `
    isWebRTCSupported:`).concat(this.isWebRTCSupported(), `
    isBrowserSupported:`).concat(this.isBrowserSupported(), `
    isUnifiedPlanSupported:`).concat(this.isUnifiedPlanSupported())
  }, i
}()), Rk = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: ["turn:eu-0.turn.peerjs.com:3478", "turn:us-0.turn.peerjs.com:3478"], username: "peerjs", credential: "peerjsp" }], sdpSemantics: "unified-plan" }, e8 = function () { function i() { this.CLOUD_HOST = "0.peerjs.com", this.CLOUD_PORT = 443, this.chunkedBrowsers = { Chrome: 1, chrome: 1 }, this.chunkedMTU = 16300, this.defaultConfig = Rk, this.browser = Jf.getBrowser(), this.browserVersion = Jf.getVersion(), this.supports = function () { var e = { browser: Jf.isBrowserSupported(), webRTC: Jf.isWebRTCSupported(), audioVideo: !1, data: !1, binaryBlob: !1, reliable: !1 }; if (!e.webRTC) return e; var t; try { t = new RTCPeerConnection(Rk), e.audioVideo = !0; var s = void 0; try { s = t.createDataChannel("_PEERJSTEST", { ordered: !0 }), e.data = !0, e.reliable = !!s.ordered; try { s.binaryType = "blob", e.binaryBlob = !Jf.isIOS } catch { } } catch { } finally { s && s.close() } } catch { } finally { t && t.close() } return e }(), this.pack = FB.pack, this.unpack = FB.unpack, this._dataCount = 1 } return i.prototype.noop = function () { }, i.prototype.validateId = function (e) { return !e || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(e) }, i.prototype.chunk = function (e) { for (var t = [], s = e.size, r = Math.ceil(s / oi.chunkedMTU), n = 0, o = 0; o < s;) { var a = Math.min(s, o + oi.chunkedMTU), l = e.slice(o, a), c = { __peerData: this._dataCount, n, data: l, total: r }; t.push(c), o = a, n++ } return this._dataCount++, t }, i.prototype.blobToArrayBuffer = function (e, t) { var s = new FileReader; return s.onload = function (r) { r.target && t(r.target.result) }, s.readAsArrayBuffer(e), s }, i.prototype.binaryStringToArrayBuffer = function (e) { for (var t = new Uint8Array(e.length), s = 0; s < e.length; s++)t[s] = e.charCodeAt(s) & 255; return t.buffer }, i.prototype.randomToken = function () { return Math.random().toString(36).slice(2) }, i.prototype.isSecure = function () { return location.protocol === "https:" }, i }(), oi = new e8, Pk = {}; Uo(Pk, "Peer", () => Wk, i => Wk = i); var Kf = {}, t8 = Object.prototype.hasOwnProperty, vr = "~"; function Zf() { } Object.create && (Zf.prototype = Object.create(null), new Zf().__proto__ || (vr = !1)); function i8(i, e, t) { this.fn = i, this.context = e, this.once = t || !1 } function Bk(i, e, t, s, r) { if (typeof t != "function") throw new TypeError("The listener must be a function"); var n = new i8(t, s || i, r), o = vr ? vr + e : e; return i._events[o] ? i._events[o].fn ? i._events[o] = [i._events[o], n] : i._events[o].push(n) : (i._events[o] = n, i._eventsCount++), i } function k0(i, e) { --i._eventsCount === 0 ? i._events = new Zf : delete i._events[e] } function rr() { this._events = new Zf, this._eventsCount = 0 } rr.prototype.eventNames = function () { var i = [], e, t; if (this._eventsCount === 0) return i; for (t in e = this._events) t8.call(e, t) && i.push(vr ? t.slice(1) : t); return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i }, rr.prototype.listeners = function (i) { var e = vr ? vr + i : i, t = this._events[e]; if (!t) return []; if (t.fn) return [t.fn]; for (var s = 0, r = t.length, n = new Array(r); s < r; s++)n[s] = t[s].fn; return n }, rr.prototype.listenerCount = function (i) { var e = vr ? vr + i : i, t = this._events[e]; return t ? t.fn ? 1 : t.length : 0 }, rr.prototype.emit = function (i, e, t, s, r, n) { var o = vr ? vr + i : i; if (!this._events[o]) return !1; var a = this._events[o], l = arguments.length, c, h; if (a.fn) { switch (a.once && this.removeListener(i, a.fn, void 0, !0), l) { case 1: return a.fn.call(a.context), !0; case 2: return a.fn.call(a.context, e), !0; case 3: return a.fn.call(a.context, e, t), !0; case 4: return a.fn.call(a.context, e, t, s), !0; case 5: return a.fn.call(a.context, e, t, s, r), !0; case 6: return a.fn.call(a.context, e, t, s, r, n), !0 }for (h = 1, c = new Array(l - 1); h < l; h++)c[h - 1] = arguments[h]; a.fn.apply(a.context, c) } else { var d = a.length, p; for (h = 0; h < d; h++)switch (a[h].once && this.removeListener(i, a[h].fn, void 0, !0), l) { case 1: a[h].fn.call(a[h].context); break; case 2: a[h].fn.call(a[h].context, e); break; case 3: a[h].fn.call(a[h].context, e, t); break; case 4: a[h].fn.call(a[h].context, e, t, s); break; default: if (!c) for (p = 1, c = new Array(l - 1); p < l; p++)c[p - 1] = arguments[p]; a[h].fn.apply(a[h].context, c) } } return !0 }, rr.prototype.on = function (i, e, t) { return Bk(this, i, e, t, !1) }, rr.prototype.once = function (i, e, t) { return Bk(this, i, e, t, !0) }, rr.prototype.removeListener = function (i, e, t, s) { var r = vr ? vr + i : i; if (!this._events[r]) return this; if (!e) return k0(this, r), this; var n = this._events[r]; if (n.fn) n.fn === e && (!s || n.once) && (!t || n.context === t) && k0(this, r); else { for (var o = 0, a = [], l = n.length; o < l; o++)(n[o].fn !== e || s && !n[o].once || t && n[o].context !== t) && a.push(n[o]); a.length ? this._events[r] = a.length === 1 ? a[0] : a : k0(this, r) } return this }, rr.prototype.removeAllListeners = function (i) { var e; return i ? (e = vr ? vr + i : i, this._events[e] && k0(this, e)) : (this._events = new Zf, this._eventsCount = 0), this }, rr.prototype.off = rr.prototype.removeListener, rr.prototype.addListener = rr.prototype.on, rr.prefixed = vr, rr.EventEmitter = rr, Kf = rr; var tt = {}; Uo(tt, "LogLevel", () => Or, i => Or = i), Uo(tt, "default", () => kk, i => kk = i); var Bh = function (i, e) { var t = typeof Symbol == "function" && i[Symbol.iterator]; if (!t) return i; var s = t.call(i), r, n = [], o; try { for (; (e === void 0 || e-- > 0) && !(r = s.next()).done;)n.push(r.value) } catch (a) { o = { error: a } } finally { try { r && !r.done && (t = s.return) && t.call(s) } finally { if (o) throw o.error } } return n }, kh = function (i, e, t) { if (t || arguments.length === 2) for (var s = 0, r = e.length, n; s < r; s++)(n || !(s in e)) && (n || (n = Array.prototype.slice.call(e, 0, s)), n[s] = e[s]); return i.concat(n || Array.prototype.slice.call(e)) }, s8 = "PeerJS: ", Or; (function (i) { i[i.Disabled = 0] = "Disabled", i[i.Errors = 1] = "Errors", i[i.Warnings = 2] = "Warnings", i[i.All = 3] = "All" })(Or || (Or = {})); var r8 = function () { function i() { this._logLevel = Or.Disabled } return Object.defineProperty(i.prototype, "logLevel", { get: function () { return this._logLevel }, set: function (e) { this._logLevel = e }, enumerable: !1, configurable: !0 }), i.prototype.log = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; this._logLevel >= Or.All && this._print.apply(this, kh([Or.All], Bh(e), !1)) }, i.prototype.warn = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; this._logLevel >= Or.Warnings && this._print.apply(this, kh([Or.Warnings], Bh(e), !1)) }, i.prototype.error = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; this._logLevel >= Or.Errors && this._print.apply(this, kh([Or.Errors], Bh(e), !1)) }, i.prototype.setLogFunction = function (e) { this._print = e }, i.prototype._print = function (e) { for (var t = [], s = 1; s < arguments.length; s++)t[s - 1] = arguments[s]; var r = kh([s8], Bh(t), !1); for (var n in r) r[n] instanceof Error && (r[n] = "(" + r[n].name + ") " + r[n].message); e >= Or.All ? console.log.apply(console, kh([], Bh(r), !1)) : e >= Or.Warnings ? console.warn.apply(console, kh(["WARNING"], Bh(r), !1)) : e >= Or.Errors && console.error.apply(console, kh(["ERROR"], Bh(r), !1)) }, i }(), kk = new r8, Dk = {}; Uo(Dk, "Socket", () => Ok, i => Ok = i); var ho; (function (i) { i.Data = "data", i.Media = "media" })(ho || (ho = {})); var qi; (function (i) { i.BrowserIncompatible = "browser-incompatible", i.Disconnected = "disconnected", i.InvalidID = "invalid-id", i.InvalidKey = "invalid-key", i.Network = "network", i.PeerUnavailable = "peer-unavailable", i.SslUnavailable = "ssl-unavailable", i.ServerError = "server-error", i.SocketError = "socket-error", i.SocketClosed = "socket-closed", i.UnavailableID = "unavailable-id", i.WebRTC = "webrtc" })(qi || (qi = {})); var Va; (function (i) { i.Binary = "binary", i.BinaryUTF8 = "binary-utf8", i.JSON = "json" })(Va || (Va = {})); var Wa; (function (i) { i.Message = "message", i.Disconnected = "disconnected", i.Error = "error", i.Close = "close" })(Wa || (Wa = {})); var zs; (function (i) { i.Heartbeat = "HEARTBEAT", i.Candidate = "CANDIDATE", i.Offer = "OFFER", i.Answer = "ANSWER", i.Open = "OPEN", i.Error = "ERROR", i.IdTaken = "ID-TAKEN", i.InvalidKey = "INVALID-KEY", i.Leave = "LEAVE", i.Expire = "EXPIRE" })(zs || (zs = {})); var D1 = {}; D1 = JSON.parse('{"name":"peerjs","version":"1.4.7","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz St\xFCckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","So\u0308ren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.js","browser-unminified":"dist/peerjs.js","types":"dist/types.d.ts","engines":{"node":">= 10"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"context":"browser","outputFormat":"global","optimize":true,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"},"browser-unminified":{"context":"browser","outputFormat":"global","optimize":false,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build","prepublishOnly":"npm run build","test":"mocha -r ts-node/register -r jsdom-global/register test/**/*.ts","format":"prettier --write .","semantic-release":"semantic-release"},"devDependencies":{"@parcel/config-default":"^2.5.0","@parcel/packager-ts":"^2.5.0","@parcel/transformer-typescript-tsc":"^2.5.0","@parcel/transformer-typescript-types":"^2.5.0","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.18","chai":"^4.3.6","git-authors-cli":"^1.0.40","jsdom":"^19.0.0","jsdom-global":"^3.0.2","mocha":"^9.2.0","mock-socket":"8.0.5","parcel":"^2.5.0","parcel-transformer-tsc-sourcemaps":"^1.0.2","prettier":"^2.6.2","semantic-release":"^19.0.2","standard":"^16.0.4","ts-node":"^10.5.0","typescript":"^4.5.5"},"dependencies":{"@swc/helpers":"^0.3.13","eventemitter3":"^4.0.7","peerjs-js-binarypack":"1.0.1","webrtc-adapter":"^7.7.1"}}'); var n8 = function () { var i = function (e, t) { return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (s, r) { s.__proto__ = r } || function (s, r) { for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (s[n] = r[n]) }, i(e, t) }; return function (e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); i(e, t); function s() { this.constructor = e } e.prototype = t === null ? Object.create(t) : (s.prototype = t.prototype, new s) } }(), o8 = function (i, e) { var t = typeof Symbol == "function" && i[Symbol.iterator]; if (!t) return i; var s = t.call(i), r, n = [], o; try { for (; (e === void 0 || e-- > 0) && !(r = s.next()).done;)n.push(r.value) } catch (a) { o = { error: a } } finally { try { r && !r.done && (t = s.return) && t.call(s) } finally { if (o) throw o.error } } return n }, a8 = function (i, e, t) { if (t || arguments.length === 2) for (var s = 0, r = e.length, n; s < r; s++)(n || !(s in e)) && (n || (n = Array.prototype.slice.call(e, 0, s)), n[s] = e[s]); return i.concat(n || Array.prototype.slice.call(e)) }, l8 = function (i) { var e = typeof Symbol == "function" && Symbol.iterator, t = e && i[e], s = 0; if (t) return t.call(i); if (i && typeof i.length == "number") return { next: function () { return i && s >= i.length && (i = void 0), { value: i && i[s++], done: !i } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") }, Ok = function (i) { n8(e, i); function e(t, s, r, n, o, a) { a === void 0 && (a = 5e3); var l = i.call(this) || this; l.pingInterval = a, l._disconnected = !0, l._messagesQueue = []; var c = t ? "wss://" : "ws://"; return l._baseUrl = c + s + ":" + r + n + "peerjs?key=" + o, l } return e.prototype.start = function (t, s) { var r = this; this._id = t; var n = "".concat(this._baseUrl, "&id=").concat(t, "&token=").concat(s); this._socket || !this._disconnected || (this._socket = new WebSocket(n + "&version=" + D1.version), this._disconnected = !1, this._socket.onmessage = function (o) { var a; try { a = JSON.parse(o.data), tt.default.log("Server message received:", a) } catch { tt.default.log("Invalid server message", o.data); return } r.emit(Wa.Message, a) }, this._socket.onclose = function (o) { r._disconnected || (tt.default.log("Socket closed.", o), r._cleanup(), r._disconnected = !0, r.emit(Wa.Disconnected)) }, this._socket.onopen = function () { r._disconnected || (r._sendQueuedMessages(), tt.default.log("Socket open"), r._scheduleHeartbeat()) }) }, e.prototype._scheduleHeartbeat = function () { var t = this; this._wsPingTimer = setTimeout(function () { t._sendHeartbeat() }, this.pingInterval) }, e.prototype._sendHeartbeat = function () { if (!this._wsOpen()) { tt.default.log("Cannot send heartbeat, because socket closed"); return } var t = JSON.stringify({ type: zs.Heartbeat }); this._socket.send(t), this._scheduleHeartbeat() }, e.prototype._wsOpen = function () { return !!this._socket && this._socket.readyState === 1 }, e.prototype._sendQueuedMessages = function () { var t, s, r = a8([], o8(this._messagesQueue), !1); this._messagesQueue = []; try { for (var n = l8(r), o = n.next(); !o.done; o = n.next()) { var a = o.value; this.send(a) } } catch (l) { t = { error: l } } finally { try { o && !o.done && (s = n.return) && s.call(n) } finally { if (t) throw t.error } } }, e.prototype.send = function (t) { if (!this._disconnected) { if (!this._id) { this._messagesQueue.push(t); return } if (!t.type) { this.emit(Wa.Error, "Invalid message"); return } if (this._wsOpen()) { var s = JSON.stringify(t); this._socket.send(s) } } }, e.prototype.close = function () { this._disconnected || (this._cleanup(), this._disconnected = !0) }, e.prototype._cleanup = function () { this._socket && (this._socket.onopen = this._socket.onmessage = this._socket.onclose = null, this._socket.close(), this._socket = void 0), clearTimeout(this._wsPingTimer) }, e }(Kf.EventEmitter), O1 = {}; Uo(O1, "MediaConnection", () => Uk, i => Uk = i); var L1 = {}; Uo(L1, "Negotiator", () => Lk, i => Lk = i); var D0 = function () { return D0 = Object.assign || function (i) { for (var e, t = 1, s = arguments.length; t < s; t++) { e = arguments[t]; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (i[r] = e[r]) } return i }, D0.apply(this, arguments) }, O0 = function (i, e, t, s) { function r(n) { return n instanceof t ? n : new t(function (o) { o(n) }) } return new (t || (t = Promise))(function (n, o) { function a(h) { try { c(s.next(h)) } catch (d) { o(d) } } function l(h) { try { c(s.throw(h)) } catch (d) { o(d) } } function c(h) { h.done ? n(h.value) : r(h.value).then(a, l) } c((s = s.apply(i, e || [])).next()) }) }, L0 = function (i, e) { var t = { label: 0, sent: function () { if (n[0] & 1) throw n[1]; return n[1] }, trys: [], ops: [] }, s, r, n, o; return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function a(c) { return function (h) { return l([c, h]) } } function l(c) { if (s) throw new TypeError("Generator is already executing."); for (; t;)try { if (s = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done) return n; switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) { case 0: case 1: n = c; break; case 4: return t.label++, { value: c[1], done: !1 }; case 5: t.label++, r = c[1], c = [0]; continue; case 7: c = t.ops.pop(), t.trys.pop(); continue; default: if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) { t = 0; continue } if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) { t.label = c[1]; break } if (c[0] === 6 && t.label < n[1]) { t.label = n[1], n = c; break } if (n && t.label < n[2]) { t.label = n[2], t.ops.push(c); break } n[2] && t.ops.pop(), t.trys.pop(); continue }c = e.call(i, t) } catch (h) { c = [6, h], r = 0 } finally { s = n = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, Lk = function () { function i(e) { this.connection = e } return i.prototype.startConnection = function (e) { var t = this._startPeerConnection(); if (this.connection.peerConnection = t, this.connection.type === ho.Media && e._stream && this._addTracksToConnection(e._stream, t), e.originator) { if (this.connection.type === ho.Data) { var s = this.connection, r = { ordered: !!e.reliable }, n = t.createDataChannel(s.label, r); s.initialize(n) } this._makeOffer() } else this.handleSDP("OFFER", e.sdp) }, i.prototype._startPeerConnection = function () { tt.default.log("Creating RTCPeerConnection."); var e = new RTCPeerConnection(this.connection.provider.options.config); return this._setupListeners(e), e }, i.prototype._setupListeners = function (e) { var t = this, s = this.connection.peer, r = this.connection.connectionId, n = this.connection.type, o = this.connection.provider; tt.default.log("Listening for ICE candidates."), e.onicecandidate = function (a) { !a.candidate || !a.candidate.candidate || (tt.default.log("Received ICE candidates for ".concat(s, ":"), a.candidate), o.socket.send({ type: zs.Candidate, payload: { candidate: a.candidate, type: n, connectionId: r }, dst: s })) }, e.oniceconnectionstatechange = function () { switch (e.iceConnectionState) { case "failed": tt.default.log("iceConnectionState is failed, closing connections to " + s), t.connection.emit("error", new Error("Negotiation of connection to " + s + " failed.")), t.connection.close(); break; case "closed": tt.default.log("iceConnectionState is closed, closing connections to " + s), t.connection.emit("error", new Error("Connection to " + s + " closed.")), t.connection.close(); break; case "disconnected": tt.default.log("iceConnectionState changed to disconnected on the connection with " + s); break; case "completed": e.onicecandidate = oi.noop; break }t.connection.emit("iceStateChanged", e.iceConnectionState) }, tt.default.log("Listening for data channel"), e.ondatachannel = function (a) { tt.default.log("Received data channel"); var l = a.channel, c = o.getConnection(s, r); c.initialize(l) }, tt.default.log("Listening for remote stream"), e.ontrack = function (a) { tt.default.log("Received remote stream"); var l = a.streams[0], c = o.getConnection(s, r); if (c.type === ho.Media) { var h = c; t._addStreamToMediaConnection(l, h) } } }, i.prototype.cleanup = function () { tt.default.log("Cleaning up PeerConnection to " + this.connection.peer); var e = this.connection.peerConnection; if (e) { this.connection.peerConnection = null, e.onicecandidate = e.oniceconnectionstatechange = e.ondatachannel = e.ontrack = function () { }; var t = e.signalingState !== "closed", s = !1; if (this.connection.type === ho.Data) { var r = this.connection, n = r.dataChannel; n && (s = !!n.readyState && n.readyState !== "closed") } (t || s) && e.close() } }, i.prototype._makeOffer = function () { return O0(this, void 0, Promise, function () { var e, t, s, r, n, o, a; return L0(this, function (l) { switch (l.label) { case 0: e = this.connection.peerConnection, t = this.connection.provider, l.label = 1; case 1: return l.trys.push([1, 7, , 8]), [4, e.createOffer(this.connection.options.constraints)]; case 2: s = l.sent(), tt.default.log("Created offer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (s.sdp = this.connection.options.sdpTransform(s.sdp) || s.sdp), l.label = 3; case 3: return l.trys.push([3, 5, , 6]), [4, e.setLocalDescription(s)]; case 4: return l.sent(), tt.default.log("Set localDescription:", s, "for:".concat(this.connection.peer)), r = { sdp: s, type: this.connection.type, connectionId: this.connection.connectionId, metadata: this.connection.metadata, browser: oi.browser }, this.connection.type === ho.Data && (n = this.connection, r = D0(D0({}, r), { label: n.label, reliable: n.reliable, serialization: n.serialization })), t.socket.send({ type: zs.Offer, payload: r, dst: this.connection.peer }), [3, 6]; case 5: return o = l.sent(), o != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer" && (t.emitError(qi.WebRTC, o), tt.default.log("Failed to setLocalDescription, ", o)), [3, 6]; case 6: return [3, 8]; case 7: return a = l.sent(), t.emitError(qi.WebRTC, a), tt.default.log("Failed to createOffer, ", a), [3, 8]; case 8: return [2] } }) }) }, i.prototype._makeAnswer = function () { return O0(this, void 0, Promise, function () { var e, t, s, r, n; return L0(this, function (o) { switch (o.label) { case 0: e = this.connection.peerConnection, t = this.connection.provider, o.label = 1; case 1: return o.trys.push([1, 7, , 8]), [4, e.createAnswer()]; case 2: s = o.sent(), tt.default.log("Created answer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (s.sdp = this.connection.options.sdpTransform(s.sdp) || s.sdp), o.label = 3; case 3: return o.trys.push([3, 5, , 6]), [4, e.setLocalDescription(s)]; case 4: return o.sent(), tt.default.log("Set localDescription:", s, "for:".concat(this.connection.peer)), t.socket.send({ type: zs.Answer, payload: { sdp: s, type: this.connection.type, connectionId: this.connection.connectionId, browser: oi.browser }, dst: this.connection.peer }), [3, 6]; case 5: return r = o.sent(), t.emitError(qi.WebRTC, r), tt.default.log("Failed to setLocalDescription, ", r), [3, 6]; case 6: return [3, 8]; case 7: return n = o.sent(), t.emitError(qi.WebRTC, n), tt.default.log("Failed to create answer, ", n), [3, 8]; case 8: return [2] } }) }) }, i.prototype.handleSDP = function (e, t) { return O0(this, void 0, Promise, function () { var s, r, n, o; return L0(this, function (a) { switch (a.label) { case 0: t = new RTCSessionDescription(t), s = this.connection.peerConnection, r = this.connection.provider, tt.default.log("Setting remote description", t), n = this, a.label = 1; case 1: return a.trys.push([1, 5, , 6]), [4, s.setRemoteDescription(t)]; case 2: return a.sent(), tt.default.log("Set remoteDescription:".concat(e, " for:").concat(this.connection.peer)), e !== "OFFER" ? [3, 4] : [4, n._makeAnswer()]; case 3: a.sent(), a.label = 4; case 4: return [3, 6]; case 5: return o = a.sent(), r.emitError(qi.WebRTC, o), tt.default.log("Failed to setRemoteDescription, ", o), [3, 6]; case 6: return [2] } }) }) }, i.prototype.handleCandidate = function (e) { return O0(this, void 0, Promise, function () { var t, s, r, n, o, a; return L0(this, function (l) { switch (l.label) { case 0: tt.default.log("handleCandidate:", e), t = e.candidate, s = e.sdpMLineIndex, r = e.sdpMid, n = this.connection.peerConnection, o = this.connection.provider, l.label = 1; case 1: return l.trys.push([1, 3, , 4]), [4, n.addIceCandidate(new RTCIceCandidate({ sdpMid: r, sdpMLineIndex: s, candidate: t }))]; case 2: return l.sent(), tt.default.log("Added ICE candidate for:".concat(this.connection.peer)), [3, 4]; case 3: return a = l.sent(), o.emitError(qi.WebRTC, a), tt.default.log("Failed to handleCandidate, ", a), [3, 4]; case 4: return [2] } }) }) }, i.prototype._addTracksToConnection = function (e, t) { if (tt.default.log("add tracks from stream ".concat(e.id, " to peer connection")), !t.addTrack) return tt.default.error("Your browser does't support RTCPeerConnection#addTrack. Ignored."); e.getTracks().forEach(function (s) { t.addTrack(s, e) }) }, i.prototype._addStreamToMediaConnection = function (e, t) { tt.default.log("add stream ".concat(e.id, " to media connection ").concat(t.connectionId)), t.addStream(e) }, i }(), F1 = {}; Uo(F1, "BaseConnection", () => Fk, i => Fk = i); var c8 = function () { var i = function (e, t) { return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (s, r) { s.__proto__ = r } || function (s, r) { for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (s[n] = r[n]) }, i(e, t) }; return function (e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); i(e, t); function s() { this.constructor = e } e.prototype = t === null ? Object.create(t) : (s.prototype = t.prototype, new s) } }(), Fk = function (i) { c8(e, i); function e(t, s, r) { var n = i.call(this) || this; return n.peer = t, n.provider = s, n.options = r, n._open = !1, n.metadata = r.metadata, n } return Object.defineProperty(e.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), e }(Kf.EventEmitter), h8 = function () { var i = function (e, t) { return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (s, r) { s.__proto__ = r } || function (s, r) { for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (s[n] = r[n]) }, i(e, t) }; return function (e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); i(e, t); function s() { this.constructor = e } e.prototype = t === null ? Object.create(t) : (s.prototype = t.prototype, new s) } }(), F0 = function () { return F0 = Object.assign || function (i) { for (var e, t = 1, s = arguments.length; t < s; t++) { e = arguments[t]; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (i[r] = e[r]) } return i }, F0.apply(this, arguments) }, u8 = function (i) { var e = typeof Symbol == "function" && Symbol.iterator, t = e && i[e], s = 0; if (t) return t.call(i); if (i && typeof i.length == "number") return { next: function () { return i && s >= i.length && (i = void 0), { value: i && i[s++], done: !i } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") }, Uk = function (i) { h8(e, i); function e(t, s, r) { var n = i.call(this, t, s, r) || this; return n._localStream = n.options._stream, n.connectionId = n.options.connectionId || e.ID_PREFIX + oi.randomToken(), n._negotiator = new L1.Negotiator(n), n._localStream && n._negotiator.startConnection({ _stream: n._localStream, originator: !0 }), n } return Object.defineProperty(e.prototype, "type", { get: function () { return ho.Media }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "localStream", { get: function () { return this._localStream }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "remoteStream", { get: function () { return this._remoteStream }, enumerable: !1, configurable: !0 }), e.prototype.addStream = function (t) { tt.default.log("Receiving stream", t), this._remoteStream = t, i.prototype.emit.call(this, "stream", t) }, e.prototype.handleMessage = function (t) { var s = t.type, r = t.payload; switch (t.type) { case zs.Answer: this._negotiator.handleSDP(s, r.sdp), this._open = !0; break; case zs.Candidate: this._negotiator.handleCandidate(r.candidate); break; default: tt.default.warn("Unrecognized message type:".concat(s, " from peer:").concat(this.peer)); break } }, e.prototype.answer = function (t, s) { var r, n; if (s === void 0 && (s = {}), this._localStream) { tt.default.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?"); return } this._localStream = t, s && s.sdpTransform && (this.options.sdpTransform = s.sdpTransform), this._negotiator.startConnection(F0(F0({}, this.options._payload), { _stream: t })); var o = this.provider._getMessages(this.connectionId); try { for (var a = u8(o), l = a.next(); !l.done; l = a.next()) { var c = l.value; this.handleMessage(c) } } catch (h) { r = { error: h } } finally { try { l && !l.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } this._open = !0 }, e.prototype.close = function () { this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this._localStream = null, this._remoteStream = null, this.provider && (this.provider._removeConnection(this), this.provider = null), this.options && this.options._stream && (this.options._stream = null), this.open && (this._open = !1, i.prototype.emit.call(this, "close")) }, e.ID_PREFIX = "mc_", e }(F1.BaseConnection), U1 = {}; Uo(U1, "DataConnection", () => jk, i => jk = i); var Nk = {}; Uo(Nk, "EncodingQueue", () => zk, i => zk = i); var d8 = function () { var i = function (e, t) { return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (s, r) { s.__proto__ = r } || function (s, r) { for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (s[n] = r[n]) }, i(e, t) }; return function (e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); i(e, t); function s() { this.constructor = e } e.prototype = t === null ? Object.create(t) : (s.prototype = t.prototype, new s) } }(), zk = function (i) { d8(e, i); function e() { var t = i.call(this) || this; return t.fileReader = new FileReader, t._queue = [], t._processing = !1, t.fileReader.onload = function (s) { t._processing = !1, s.target && t.emit("done", s.target.result), t.doNextTask() }, t.fileReader.onerror = function (s) { tt.default.error("EncodingQueue error:", s), t._processing = !1, t.destroy(), t.emit("error", s) }, t } return Object.defineProperty(e.prototype, "queue", { get: function () { return this._queue }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "size", { get: function () { return this.queue.length }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "processing", { get: function () { return this._processing }, enumerable: !1, configurable: !0 }), e.prototype.enque = function (t) { this.queue.push(t), !this.processing && this.doNextTask() }, e.prototype.destroy = function () { this.fileReader.abort(), this._queue = [] }, e.prototype.doNextTask = function () { this.size !== 0 && (this.processing || (this._processing = !0, this.fileReader.readAsArrayBuffer(this.queue.shift()))) }, e }(Kf.EventEmitter), p8 = function () { var i = function (e, t) { return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (s, r) { s.__proto__ = r } || function (s, r) { for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (s[n] = r[n]) }, i(e, t) }; return function (e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); i(e, t); function s() { this.constructor = e } e.prototype = t === null ? Object.create(t) : (s.prototype = t.prototype, new s) } }(), f8 = function (i) { var e = typeof Symbol == "function" && Symbol.iterator, t = e && i[e], s = 0; if (t) return t.call(i); if (i && typeof i.length == "number") return { next: function () { return i && s >= i.length && (i = void 0), { value: i && i[s++], done: !i } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") }, jk = function (i) { p8(e, i); function e(t, s, r) { var n = i.call(this, t, s, r) || this; return n.stringify = JSON.stringify, n.parse = JSON.parse, n._buffer = [], n._bufferSize = 0, n._buffering = !1, n._chunkedData = {}, n._encodingQueue = new Nk.EncodingQueue, n.connectionId = n.options.connectionId || e.ID_PREFIX + oi.randomToken(), n.label = n.options.label || n.connectionId, n.serialization = n.options.serialization || Va.Binary, n.reliable = !!n.options.reliable, n._encodingQueue.on("done", function (o) { n._bufferedSend(o) }), n._encodingQueue.on("error", function () { tt.default.error("DC#".concat(n.connectionId, ": Error occured in encoding from blob to arraybuffer, close DC")), n.close() }), n._negotiator = new L1.Negotiator(n), n._negotiator.startConnection(n.options._payload || { originator: !0 }), n } return Object.defineProperty(e.prototype, "type", { get: function () { return ho.Data }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "dataChannel", { get: function () { return this._dc }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "bufferSize", { get: function () { return this._bufferSize }, enumerable: !1, configurable: !0 }), e.prototype.initialize = function (t) { this._dc = t, this._configureDataChannel() }, e.prototype._configureDataChannel = function () { var t = this; (!oi.supports.binaryBlob || oi.supports.reliable) && (this.dataChannel.binaryType = "arraybuffer"), this.dataChannel.onopen = function () { tt.default.log("DC#".concat(t.connectionId, " dc connection success")), t._open = !0, t.emit("open") }, this.dataChannel.onmessage = function (s) { tt.default.log("DC#".concat(t.connectionId, " dc onmessage:"), s.data), t._handleDataMessage(s) }, this.dataChannel.onclose = function () { tt.default.log("DC#".concat(t.connectionId, " dc closed for:"), t.peer), t.close() } }, e.prototype._handleDataMessage = function (t) { var s = this, r = t.data, n = r.constructor, o = this.serialization === Va.Binary || this.serialization === Va.BinaryUTF8, a = r; if (o) { if (n === Blob) { oi.blobToArrayBuffer(r, function (c) { var h = oi.unpack(c); s.emit("data", h) }); return } else if (n === ArrayBuffer) a = oi.unpack(r); else if (n === String) { var l = oi.binaryStringToArrayBuffer(r); a = oi.unpack(l) } } else this.serialization === Va.JSON && (a = this.parse(r)); if (a.__peerData) { this._handleChunk(a); return } i.prototype.emit.call(this, "data", a) }, e.prototype._handleChunk = function (t) { var s = t.__peerData, r = this._chunkedData[s] || { data: [], count: 0, total: t.total }; if (r.data[t.n] = t.data, r.count++, this._chunkedData[s] = r, r.total === r.count) { delete this._chunkedData[s]; var n = new Blob(r.data); this._handleDataMessage({ data: n }) } }, e.prototype.close = function () { this._buffer = [], this._bufferSize = 0, this._chunkedData = {}, this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this.provider && (this.provider._removeConnection(this), this.provider = null), this.dataChannel && (this.dataChannel.onopen = null, this.dataChannel.onmessage = null, this.dataChannel.onclose = null, this._dc = null), this._encodingQueue && (this._encodingQueue.destroy(), this._encodingQueue.removeAllListeners(), this._encodingQueue = null), this.open && (this._open = !1, i.prototype.emit.call(this, "close")) }, e.prototype.send = function (t, s) { if (!this.open) { i.prototype.emit.call(this, "error", new Error("Connection is not open. You should listen for the `open` event before sending messages.")); return } if (this.serialization === Va.JSON) this._bufferedSend(this.stringify(t)); else if (this.serialization === Va.Binary || this.serialization === Va.BinaryUTF8) { var r = oi.pack(t); if (!s && r.size > oi.chunkedMTU) { this._sendChunks(r); return } oi.supports.binaryBlob ? this._bufferedSend(r) : this._encodingQueue.enque(r) } else this._bufferedSend(t) }, e.prototype._bufferedSend = function (t) { (this._buffering || !this._trySend(t)) && (this._buffer.push(t), this._bufferSize = this._buffer.length) }, e.prototype._trySend = function (t) { var s = this; if (!this.open) return !1; if (this.dataChannel.bufferedAmount > e.MAX_BUFFERED_AMOUNT) return this._buffering = !0, setTimeout(function () { s._buffering = !1, s._tryBuffer() }, 50), !1; try { this.dataChannel.send(t) } catch (r) { return tt.default.error("DC#:".concat(this.connectionId, " Error when sending:"), r), this._buffering = !0, this.close(), !1 } return !0 }, e.prototype._tryBuffer = function () { if (this.open && this._buffer.length !== 0) { var t = this._buffer[0]; this._trySend(t) && (this._buffer.shift(), this._bufferSize = this._buffer.length, this._tryBuffer()) } }, e.prototype._sendChunks = function (t) { var s, r, n = oi.chunk(t); tt.default.log("DC#".concat(this.connectionId, " Try to send ").concat(n.length, " chunks...")); try { for (var o = f8(n), a = o.next(); !a.done; a = o.next()) { var l = a.value; this.send(l, !0) } } catch (c) { s = { error: c } } finally { try { a && !a.done && (r = o.return) && r.call(o) } finally { if (s) throw s.error } } }, e.prototype.handleMessage = function (t) { var s = t.payload; switch (t.type) { case zs.Answer: this._negotiator.handleSDP(t.type, s.sdp); break; case zs.Candidate: this._negotiator.handleCandidate(s.candidate); break; default: tt.default.warn("Unrecognized message type:", t.type, "from peer:", this.peer); break } }, e.ID_PREFIX = "dc_", e.MAX_BUFFERED_AMOUNT = 8388608, e }(F1.BaseConnection), Qk = {}; Uo(Qk, "API", () => Vk, i => Vk = i); var Gk = function (i, e, t, s) { function r(n) { return n instanceof t ? n : new t(function (o) { o(n) }) } return new (t || (t = Promise))(function (n, o) { function a(h) { try { c(s.next(h)) } catch (d) { o(d) } } function l(h) { try { c(s.throw(h)) } catch (d) { o(d) } } function c(h) { h.done ? n(h.value) : r(h.value).then(a, l) } c((s = s.apply(i, e || [])).next()) }) }, Hk = function (i, e) { var t = { label: 0, sent: function () { if (n[0] & 1) throw n[1]; return n[1] }, trys: [], ops: [] }, s, r, n, o; return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function a(c) { return function (h) { return l([c, h]) } } function l(c) { if (s) throw new TypeError("Generator is already executing."); for (; t;)try { if (s = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done) return n; switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) { case 0: case 1: n = c; break; case 4: return t.label++, { value: c[1], done: !1 }; case 5: t.label++, r = c[1], c = [0]; continue; case 7: c = t.ops.pop(), t.trys.pop(); continue; default: if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) { t = 0; continue } if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) { t.label = c[1]; break } if (c[0] === 6 && t.label < n[1]) { t.label = n[1], n = c; break } if (n && t.label < n[2]) { t.label = n[2], t.ops.push(c); break } n[2] && t.ops.pop(), t.trys.pop(); continue }c = e.call(i, t) } catch (h) { c = [6, h], r = 0 } finally { s = n = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, Vk = function () { function i(e) { this._options = e } return i.prototype._buildRequest = function (e) { var t = this._options.secure ? "https" : "http", s = this._options, r = s.host, n = s.port, o = s.path, a = s.key, l = new URL("".concat(t, "://").concat(r, ":").concat(n).concat(o).concat(a, "/").concat(e)); return l.searchParams.set("ts", "".concat(Date.now()).concat(Math.random())), l.searchParams.set("version", D1.version), fetch(l.href, { referrerPolicy: this._options.referrerPolicy }) }, i.prototype.retrieveId = function () { return Gk(this, void 0, Promise, function () { var e, t, s; return Hk(this, function (r) { switch (r.label) { case 0: return r.trys.push([0, 2, , 3]), [4, this._buildRequest("id")]; case 1: if (e = r.sent(), e.status !== 200) throw new Error("Error. Status:".concat(e.status)); return [2, e.text()]; case 2: throw t = r.sent(), tt.default.error("Error retrieving ID", t), s = "", this._options.path === "/" && this._options.host !== oi.CLOUD_HOST && (s = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer."), new Error("Could not get an ID from the server." + s); case 3: return [2] } }) }) }, i.prototype.listAllPeers = function () { return Gk(this, void 0, Promise, function () { var e, t, s; return Hk(this, function (r) { switch (r.label) { case 0: return r.trys.push([0, 2, , 3]), [4, this._buildRequest("peers")]; case 1: if (e = r.sent(), e.status !== 200) throw e.status === 401 ? (t = "", this._options.host === oi.CLOUD_HOST ? t = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key." : t = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.", new Error("It doesn't look like you have permission to list peers IDs. " + t)) : new Error("Error. Status:".concat(e.status)); return [2, e.json()]; case 2: throw s = r.sent(), tt.default.error("Error retrieving list peers", s), new Error("Could not get list peers from the server." + s); case 3: return [2] } }) }) }, i }(), g8 = function () { var i = function (e, t) { return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (s, r) { s.__proto__ = r } || function (s, r) { for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (s[n] = r[n]) }, i(e, t) }; return function (e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); i(e, t); function s() { this.constructor = e } e.prototype = t === null ? Object.create(t) : (s.prototype = t.prototype, new s) } }(), $f = function () { return $f = Object.assign || function (i) { for (var e, t = 1, s = arguments.length; t < s; t++) { e = arguments[t]; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (i[r] = e[r]) } return i }, $f.apply(this, arguments) }, eg = function (i) { var e = typeof Symbol == "function" && Symbol.iterator, t = e && i[e], s = 0; if (t) return t.call(i); if (i && typeof i.length == "number") return { next: function () { return i && s >= i.length && (i = void 0), { value: i && i[s++], done: !i } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") }, m8 = function (i, e) { var t = typeof Symbol == "function" && i[Symbol.iterator]; if (!t) return i; var s = t.call(i), r, n = [], o; try { for (; (e === void 0 || e-- > 0) && !(r = s.next()).done;)n.push(r.value) } catch (a) { o = { error: a } } finally { try { r && !r.done && (t = s.return) && t.call(s) } finally { if (o) throw o.error } } return n }, Wk = function (i) { g8(e, i); function e(t, s) { var r = i.call(this) || this; r._id = null, r._lastServerId = null, r._destroyed = !1, r._disconnected = !1, r._open = !1, r._connections = new Map, r._lostMessages = new Map; var n; return t && t.constructor == Object ? s = t : t && (n = t.toString()), s = $f({ debug: 0, host: oi.CLOUD_HOST, port: oi.CLOUD_PORT, path: "/", key: e.DEFAULT_KEY, token: oi.randomToken(), config: oi.defaultConfig, referrerPolicy: "strict-origin-when-cross-origin" }, s), r._options = s, r._options.host === "/" && (r._options.host = window.location.hostname), r._options.path && (r._options.path[0] !== "/" && (r._options.path = "/" + r._options.path), r._options.path[r._options.path.length - 1] !== "/" && (r._options.path += "/")), r._options.secure === void 0 && r._options.host !== oi.CLOUD_HOST ? r._options.secure = oi.isSecure() : r._options.host == oi.CLOUD_HOST && (r._options.secure = !0), r._options.logFunction && tt.default.setLogFunction(r._options.logFunction), tt.default.logLevel = r._options.debug || 0, r._api = new Qk.API(s), r._socket = r._createServerConnection(), !oi.supports.audioVideo && !oi.supports.data ? (r._delayedAbort(qi.BrowserIncompatible, "The current browser does not support WebRTC"), r) : n && !oi.validateId(n) ? (r._delayedAbort(qi.InvalidID, 'ID "'.concat(n, '" is invalid')), r) : (n ? r._initialize(n) : r._api.retrieveId().then(function (o) { return r._initialize(o) }).catch(function (o) { return r._abort(qi.ServerError, o) }), r) } return Object.defineProperty(e.prototype, "id", { get: function () { return this._id }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "options", { get: function () { return this._options }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "socket", { get: function () { return this._socket }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "connections", { get: function () { var t, s, r = Object.create(null); try { for (var n = eg(this._connections), o = n.next(); !o.done; o = n.next()) { var a = m8(o.value, 2), l = a[0], c = a[1]; r[l] = c } } catch (h) { t = { error: h } } finally { try { o && !o.done && (s = n.return) && s.call(n) } finally { if (t) throw t.error } } return r }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "destroyed", { get: function () { return this._destroyed }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "disconnected", { get: function () { return this._disconnected }, enumerable: !1, configurable: !0 }), e.prototype._createServerConnection = function () { var t = this, s = new Dk.Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval); return s.on(Wa.Message, function (r) { t._handleMessage(r) }), s.on(Wa.Error, function (r) { t._abort(qi.SocketError, r) }), s.on(Wa.Disconnected, function () { t.disconnected || (t.emitError(qi.Network, "Lost connection to server."), t.disconnect()) }), s.on(Wa.Close, function () { t.disconnected || t._abort(qi.SocketClosed, "Underlying socket is already closed.") }), s }, e.prototype._initialize = function (t) { this._id = t, this.socket.start(t, this._options.token) }, e.prototype._handleMessage = function (t) { var s, r, n = t.type, o = t.payload, a = t.src; switch (n) { case zs.Open: this._lastServerId = this.id, this._open = !0, this.emit("open", this.id); break; case zs.Error: this._abort(qi.ServerError, o.msg); break; case zs.IdTaken: this._abort(qi.UnavailableID, 'ID "'.concat(this.id, '" is taken')); break; case zs.InvalidKey: this._abort(qi.InvalidKey, 'API KEY "'.concat(this._options.key, '" is invalid')); break; case zs.Leave: tt.default.log("Received leave message from ".concat(a)), this._cleanupPeer(a), this._connections.delete(a); break; case zs.Expire: this.emitError(qi.PeerUnavailable, "Could not connect to peer ".concat(a)); break; case zs.Offer: var g = o.connectionId, m = this.getConnection(a, g); if (m && (m.close(), tt.default.warn("Offer received for existing Connection ID:".concat(g))), o.type === ho.Media) { var l = new O1.MediaConnection(a, this, { connectionId: g, _payload: o, metadata: o.metadata }); m = l, this._addConnection(a, m), this.emit("call", l) } else if (o.type === ho.Data) { var c = new U1.DataConnection(a, this, { connectionId: g, _payload: o, metadata: o.metadata, label: o.label, serialization: o.serialization, reliable: o.reliable }); m = c, this._addConnection(a, m), this.emit("connection", c) } else { tt.default.warn("Received malformed connection type:".concat(o.type)); return } var h = this._getMessages(g); try { for (var d = eg(h), p = d.next(); !p.done; p = d.next()) { var f = p.value; m.handleMessage(f) } } catch (v) { s = { error: v } } finally { try { p && !p.done && (r = d.return) && r.call(d) } finally { if (s) throw s.error } } break; default: if (!o) { tt.default.warn("You received a malformed message from ".concat(a, " of type ").concat(n)); return } var g = o.connectionId, m = this.getConnection(a, g); m && m.peerConnection ? m.handleMessage(t) : g ? this._storeMessage(g, t) : tt.default.warn("You received an unrecognized message:", t); break } }, e.prototype._storeMessage = function (t, s) { this._lostMessages.has(t) || this._lostMessages.set(t, []), this._lostMessages.get(t).push(s) }, e.prototype._getMessages = function (t) { var s = this._lostMessages.get(t); return s ? (this._lostMessages.delete(t), s) : [] }, e.prototype.connect = function (t, s) { if (s === void 0 && (s = {}), this.disconnected) { tt.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available."), this.emitError(qi.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } var r = new U1.DataConnection(t, this, s); return this._addConnection(t, r), r }, e.prototype.call = function (t, s, r) { if (r === void 0 && (r = {}), this.disconnected) { tt.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect."), this.emitError(qi.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } if (!s) { tt.default.error("To call a peer, you must provide a stream from your browser's `getUserMedia`."); return } var n = new O1.MediaConnection(t, this, $f($f({}, r), { _stream: s })); return this._addConnection(t, n), n }, e.prototype._addConnection = function (t, s) { tt.default.log("add connection ".concat(s.type, ":").concat(s.connectionId, " to peerId:").concat(t)), this._connections.has(t) || this._connections.set(t, []), this._connections.get(t).push(s) }, e.prototype._removeConnection = function (t) { var s = this._connections.get(t.peer); if (s) { var r = s.indexOf(t); r !== -1 && s.splice(r, 1) } this._lostMessages.delete(t.connectionId) }, e.prototype.getConnection = function (t, s) { var r, n, o = this._connections.get(t); if (!o) return null; try { for (var a = eg(o), l = a.next(); !l.done; l = a.next()) { var c = l.value; if (c.connectionId === s) return c } } catch (h) { r = { error: h } } finally { try { l && !l.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } return null }, e.prototype._delayedAbort = function (t, s) { var r = this; setTimeout(function () { r._abort(t, s) }, 0) }, e.prototype._abort = function (t, s) { tt.default.error("Aborting!"), this.emitError(t, s), this._lastServerId ? this.disconnect() : this.destroy() }, e.prototype.emitError = function (t, s) { tt.default.error("Error:", s); var r; typeof s == "string" ? r = new Error(s) : r = s, r.type = t, this.emit("error", r) }, e.prototype.destroy = function () { this.destroyed || (tt.default.log("Destroy peer with ID:".concat(this.id)), this.disconnect(), this._cleanup(), this._destroyed = !0, this.emit("close")) }, e.prototype._cleanup = function () { var t, s; try { for (var r = eg(this._connections.keys()), n = r.next(); !n.done; n = r.next()) { var o = n.value; this._cleanupPeer(o), this._connections.delete(o) } } catch (a) { t = { error: a } } finally { try { n && !n.done && (s = r.return) && s.call(r) } finally { if (t) throw t.error } } this.socket.removeAllListeners() }, e.prototype._cleanupPeer = function (t) { var s, r, n = this._connections.get(t); if (n) try { for (var o = eg(n), a = o.next(); !a.done; a = o.next()) { var l = a.value; l.close() } } catch (c) { s = { error: c } } finally { try { a && !a.done && (r = o.return) && r.call(o) } finally { if (s) throw s.error } } }, e.prototype.disconnect = function () { if (!this.disconnected) { var t = this.id; tt.default.log("Disconnect peer with ID:".concat(t)), this._disconnected = !0, this._open = !1, this.socket.close(), this._lastServerId = t, this._id = null, this.emit("disconnected", t) } }, e.prototype.reconnect = function () { if (this.disconnected && !this.destroyed) tt.default.log("Attempting reconnection to server with ID ".concat(this._lastServerId)), this._disconnected = !1, this._initialize(this._lastServerId); else { if (this.destroyed) throw new Error("This peer cannot reconnect to the server. It has already been destroyed."); if (!this.disconnected && !this.open) tt.default.error("In a hurry? We're still trying to make the initial connection!"); else throw new Error("Peer ".concat(this.id, " cannot reconnect because it is not disconnected from the server!")) } }, e.prototype.listAllPeers = function (t) { var s = this; t === void 0 && (t = function (r) { }), this._api.listAllPeers().then(function (r) { return t(r) }).catch(function (r) { return s._abort(qi.ServerError, r) }) }, e.DEFAULT_KEY = "peerjs", e }(Kf.EventEmitter), U0 = Pk.Peer; class v8 { constructor() { u(this, "_host"), u(this, "_client"), u(this, "_clientData"), this.onEnable() } get isHost() { return this._host !== void 0 } onEnable() { const e = "HOST-5980e65c-8438-453e-8b35-f13c736dcd81"; this.trySetupHost(e) } trySetupHost(e) { let t = new U0(e); t.on("error", s => { console.error(s), this._host = void 0, this.trySetupClient(e) }), t.on("open", s => { this._host = new y8(t) }) } trySetupClient(e) { this._client = new U0, this._client.on("error", t => { console.error("Client error", t) }), this._client.on("open", t => { console.log("client connected", t), this._clientData = this._client.connect(e, { metadata: { id: t } }), this._clientData.on("open", () => { console.log("Connected to host") }), this._clientData.on("data", s => { console.log("<<", s) }) }) } } class A8 { constructor(e) { u(this, "_peer"), this._peer = e } } class y8 extends A8 { constructor(e) { var t; super(e), u(this, "_connections", []), console.log("I AM THE HOST"), (t = this._peer) == null || t.on("connection", this.onConnection.bind(this)), this._peer.on("close", () => { this.broadcast("BYE") }), setInterval(() => { this.broadcast("HELLO") }, 2e3) } get isHost() { return !0 } onConnection(e) { console.log("host connection", e), e.on("open", () => { this._connections.push(e), this.broadcastConnection(e) }) } broadcastConnection(e) { const t = this._connections.map(s => { var r; return (r = s.metadata) == null ? void 0 : r.id }).filter(s => s !== void 0); this.broadcast({ type: "connection-list", connections: t }) } broadcast(e) { if (e != null) { console.log(">>", e); for (const t in this._peer.connections) { const s = this._peer.connections[t]; if (s) if (Array.isArray(s)) for (const r of s) r && r.send(e); else console.warn(s) } } } } var Lr = (i => (i[i.OnConnection = 0] = "OnConnection", i[i.OnRoomJoin = 1] = "OnRoomJoin", i[i.Queued = 2] = "Queued", i[i.Immediate = 3] = "Immediate", i))(Lr || {}); let N0 = "wss://needle-tiny-starter.glitch.me/socket"; const Ar = !!oe("debugnet"), tg = !!(Ar || oe("debugowner")); var qk = (i => (i.ConnectionInfo = "connection-start-info", i))(qk || {}), Li = (i => (i.Join = "join-room", i.Leave = "leave-room", i.JoinedRoom = "joined-room", i.LeftRoom = "left-room", i.UserJoinedRoom = "user-joined-room", i.UserLeftRoom = "user-left-room", i))(Li || {}); class b8 { constructor() { u(this, "room"), u(this, "viewId"), u(this, "allowEditing"), u(this, "inRoom") } } class _8 { constructor() { u(this, "room") } } class x8 { constructor() { u(this, "userId") } } var Xk = (i => (i.RequestHasOwner = "request-has-owner", i.ResponseHasOwner = "response-has-owner", i.RequestIsOwner = "request-is-owner", i.ResponseIsOwner = "response-is-owner", i.RequestOwnership = "request-ownership", i.GainedOwnership = "gained-ownership", i.RemoveOwnership = "remove-ownership", i.LostOwnership = "lost-ownership", i.GainedOwnershipBroadcast = "gained-ownership-broadcast", i.LostOwnershipBroadcast = "lost-ownership-broadcast", i))(Xk || {}); class z0 { constructor(e, t) { u(this, "guid"), u(this, "connection"), u(this, "_hasOwnership", !1), u(this, "_isOwned"), u(this, "_gainSubscription"), u(this, "_lostSubscription"), u(this, "_hasOwnerResponse"), u(this, "_isWaitingForOwnershipResponseCallback", null), this.connection = e, this.guid = t, this._gainSubscription = this.onGainedOwnership.bind(this), this._lostSubscription = this.onLostOwnership.bind(this), e.beginListen("lost-ownership", this._lostSubscription), e.beginListen("gained-ownership-broadcast", this._gainSubscription), this._hasOwnerResponse = this.onHasOwnerResponse.bind(this), e.beginListen("response-has-owner", this._hasOwnerResponse) } get hasOwnership() { return this._hasOwnership } get isOwned() { return this._isOwned } get isConnected() { return this.connection.isConnected } updateIsOwned() { this.connection.send("request-has-owner", { guid: this.guid }) } onHasOwnerResponse(e) { e.guid === this.guid && (this._isOwned = e.value) } requestOwnershipIfNotOwned() { return this._isWaitingForOwnershipResponseCallback !== null ? this : (this._isWaitingForOwnershipResponseCallback = this.waitForHasOwnershipRequestResponse.bind(this), this.connection.beginListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this.connection.send("request-has-owner", { guid: this.guid }), this) } waitForHasOwnershipRequestResponse(e) { e.guid === this.guid && (this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null), this._isOwned = e.value, e.value || (tg && console.log("request ownership", this.guid), this.requestOwnership())) } requestOwnershipAsync() { return new Promise((e, t) => { this.requestOwnership(); let s = 0; const r = () => { if (s++ > 10) return t("Timeout"); setTimeout(() => { this.hasOwnership ? e(this) : r() }, 100) }; r() }) } requestOwnership() { return tg && console.log("Request ownership", this.guid), this.connection.send("request-ownership", { guid: this.guid }), this } freeOwnership() { return this.connection.send("remove-ownership", { guid: this.guid }), this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null), this } destroy() { this.connection.stopListen("gained-ownership", this._gainSubscription), this.connection.stopListen("lost-ownership", this._lostSubscription), this.connection.stopListen("response-has-owner", this._hasOwnerResponse), this._isWaitingForOwnershipResponseCallback && (this.connection.stopListen("response-has-owner", this._isWaitingForOwnershipResponseCallback), this._isWaitingForOwnershipResponseCallback = null) } onGainedOwnership(e) { e.guid === this.guid && (this._isOwned = !0, this.connection.connectionId === e.owner ? (tg && console.log("GAINED OWNERSHIP", this.guid), this._hasOwnership = !0) : this._hasOwnership = !1) } onLostOwnership(e) { e === this.guid && (tg && console.log("LOST OWNERSHIP", this.guid), this._hasOwnership = !1, this._isOwned = !1) } } class Yk { constructor(e) { u(this, "context"), u(this, "_peer", null), u(this, "_usersInRoomCopy", []), u(this, "_defaultMessagesBuffer", []), u(this, "_defaultMessagesBufferArray", []), u(this, "netWebSocketUrlProvider"), u(this, "_listeners", {}), u(this, "_listenersBinary", {}), u(this, "connected", !1), u(this, "channelId"), u(this, "_connectionId", null), u(this, "_isConnectingToWebsocket", !1), u(this, "_ws"), u(this, "_waitingForSocket", {}), u(this, "_isInRoom", !1), u(this, "_currentRoomName", null), u(this, "_currentRoomViewId", null), u(this, "_currentRoomAllowEditing", !0), u(this, "_currentInRoom", []), u(this, "_state", {}), u(this, "_currentDelay", -1), this.context = e } get peer() { return this._peer || (this._peer = new v8), this._peer } tryGetState(e) { return e === "invalid" ? null : this._state[e] } get connectionId() { return this._connectionId } get isDebugEnabled() { return Ar } get isConnected() { return this.connected } get currentRoomName() { return this._currentRoomName } get allowEditing() { return this._currentRoomAllowEditing } get currentRoomViewId() { return this._currentRoomViewId } get isInRoom() { return this._isInRoom } get currentLatency() { return this._currentDelay } sendPing() { this.send("ping", { time: this.context.time.time }) } userIsInRoom(e) { return this._currentInRoom.indexOf(e) !== -1 } usersInRoom(e = null) { e || (e = this._usersInRoomCopy), e.length = 0; for (const t of this._currentInRoom) e.push(t); return e } joinRoom(e, t = !1) { this.connect(), Ar && console.log("join: " + e), this.send("join-room", { room: e, viewOnly: t }, Lr.OnConnection) } leaveRoom(e = null) { if (e || (e = this.currentRoomName), !e) { console.error("Can not leave unknown room"); return } this.send("leave-room", { room: e }) } send(e, t = null, s = Lr.Queued) { if (t === null && (t = {}), s === Lr.Queued) { this._defaultMessagesBuffer.push({ key: e, value: t }); return } return this.sendWithWebsocket(e, t, s) } sendDeleteRemoteState(e) { this.send("delete-state", { guid: e, dontSave: !0 }), delete this._state[e] } sendDeleteRemoteStateAll() { this.send("delete-all-state"), this._state = {} } sendBinary(e) { var t; Ar && console.log("<< bin", e.length), (t = this._ws) == null || t.send(e) } sendBufferedMessagesNow() { var e; if (!this._ws) return; this._defaultMessagesBufferArray.length = 0; const t = Object.keys(this._defaultMessagesBuffer).length; for (const r in this._defaultMessagesBuffer) { const n = this._defaultMessagesBuffer[r]; if (t <= 1) { this.sendWithWebsocket(n.key, n.value, Lr.Immediate); break } const o = this.toMessage(n.key, n.value); this._defaultMessagesBufferArray.push(o) } if (this._defaultMessagesBuffer.length = 0, this._defaultMessagesBufferArray.length > 0 && Ar && console.log("SEND BUFFERED", this._defaultMessagesBufferArray.length), this._defaultMessagesBufferArray.length <= 0) return; const s = JSON.stringify(this._defaultMessagesBufferArray); (e = this._ws) == null || e.send(s) } beginListen(e, t) { return this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t), t } stopListening(e, t) { return this.stopListen(e, t) } stopListen(e, t) { if (!t || !this._listeners[e]) return; const s = this._listeners[e].indexOf(t); s >= 0 && this._listeners[e].splice(s, 1) } beginListenBinary(e, t) { return this._listenersBinary[e] || (this._listenersBinary[e] = []), this._listenersBinary[e].push(t), t } stopListenBinary(e, t) { if (!this._listenersBinary[e]) return; const s = this._listenersBinary[e].indexOf(t); s >= 0 && this._listenersBinary[e].splice(s, 1) } registerProvider(e) { this.netWebSocketUrlProvider = e } connect() { var e; if (this.connected) return; Ar && console.log("connecting"); const t = (e = this.netWebSocketUrlProvider) == null ? void 0 : e.getWebsocketUrl(); t ? N0 = t : zI() && (N0 = "wss://" + window.location.host + "/socket"), this.connectWebsocket() } connectWebsocket() { if (this._isConnectingToWebsocket) return; this._isConnectingToWebsocket = !0, console.log("Connecting to " + N0); const e = new IB.WebsocketBuilder(N0).onOpen(() => { this._ws = e, this._isConnectingToWebsocket = !1, this.connected = !0, console.log("Connected to websocket"), this.onSendQueued(Lr.OnConnection) }).onClose(t => { this.connected = !1, this._isInRoom = !1 }).onError((t, s) => { console.error(t, s) }).onMessage(this.onMessage.bind(this)).onRetry(() => { console.log("websocket connection retry") }).build() } onMessage(e, t) { const s = t.data; try { if (typeof s != "string") { s.size && this.handleIncomingBinaryMessage(s); return } const r = JSON.parse(s); if (Array.isArray(r)) for (const n of r) this.handleIncomingStringMessage(n); else this.handleIncomingStringMessage(r); return } catch { Ar && s === "pong" && console.log("<<", s) } } async handleIncomingBinaryMessage(e) { const t = await e.arrayBuffer(); var s = new Uint8Array(t); const r = new Mv(s), n = r.getBufferIdentifier(), o = this._listenersBinary[n], a = O6(r), l = L6(a); if (l && typeof l == "string" && (this._state[l] = a), !o) return; const c = a ?? r; for (const h of o) h(c) } handleIncomingStringMessage(e) { var t, s; if (Ar && console.log("<<", e.key ?? e), e.key) switch (e.key) { case "connection-start-info": if (e.data) { const a = e.data; a && (console.assert(a.id !== void 0 && a.id !== null && a.id.length > 0, "server did not send connection id", a.id), console.log("Your id is: " + a.id, this.context.alias ?? ""), this._connectionId = a.id) } else console.warn("Expected connection id in " + e.key); break; case "joined-room": if (Ar && console.log(e), e) { this._isInRoom = !0; const a = e; this._currentRoomName = a.room, this._currentRoomViewId = a.viewId, this._currentRoomAllowEditing = a.allowEditing ?? !0, console.log("Room view id", this._currentRoomViewId), this._currentInRoom.length = 0, this._currentInRoom.push(...a.inRoom), Ar && console.log("joined room with", this._currentInRoom, this.context.alias ?? "") } this.onSendQueued(Lr.OnRoomJoin); break; case "left-room": e.room === this.currentRoomName && (this._isInRoom = !1, this._currentRoomName = null, this._currentInRoom.length = 0); break; case "user-joined-room": if (e.data) { const a = e.data; this._currentInRoom.push(a.userId), Ar && console.log(a.userId + " joined", "now in room:", this._currentInRoom) } break; case "user-left-room": if (e.data) { const a = e.data, l = this._currentInRoom.indexOf(a.userId); l >= 0 && (console.log(a.userId + " left", this.context.alias ?? ""), this._currentInRoom.splice(l, 1)), a.userId === this.connectionId && console.log("you left the room") } break; case "all-room-state-deleted": Ar && console.log("RECEIVED all-room-state-deleted"), this._state = {}; break; case "ping": case "pong": const o = (t = e.data) == null ? void 0 : t.time; o && (this._currentDelay = this.context.time.time - o), Ar && console.log("Current latency: " + this._currentDelay.toFixed(1) + " sec", "Clients in room: " + ((s = this._currentInRoom) == null ? void 0 : s.length)); break }const r = this._listeners[e.key]; if (r) for (const o of r) o(e.data); const n = e.data; n && (this._state[n.guid] = n) } toMessage(e, t) { return { key: e, data: t } } sendWithWebsocket(e, t, s = Lr.OnRoomJoin) { if (!this._ws) { const n = this._waitingForSocket[s] || []; n.push(() => this.sendWithWebsocket(e, t, s)), this._waitingForSocket[s] = n; return } const r = JSON.stringify(this.toMessage(e, t)); Ar && console.log(">>", e), this._ws.send(r) } onSendQueued(e) { const t = this._waitingForSocket[e]; if (t) { for (const s of t) s(); t.length = 0 } } } function gd(i, e) { try { e ? i(e) : i() } catch (t) { return console.error(t), !1 } return !0 } const w8 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i; function C8(i) { return typeof i == "string" && w8.test(i) } const js = []; for (let i = 0; i < 256; ++i)js.push((i + 256).toString(16).slice(1)); function S8(i, e = 0) { return (js[i[e + 0]] + js[i[e + 1]] + js[i[e + 2]] + js[i[e + 3]] + "-" + js[i[e + 4]] + js[i[e + 5]] + "-" + js[i[e + 6]] + js[i[e + 7]] + "-" + js[i[e + 8]] + js[i[e + 9]] + "-" + js[i[e + 10]] + js[i[e + 11]] + js[i[e + 12]] + js[i[e + 13]] + js[i[e + 14]] + js[i[e + 15]]).toLowerCase() } function E8(i) { if (!C8(i)) throw TypeError("Invalid UUID"); let e; const t = new Uint8Array(16); return t[0] = (e = parseInt(i.slice(0, 8), 16)) >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = e & 255, t[4] = (e = parseInt(i.slice(9, 13), 16)) >>> 8, t[5] = e & 255, t[6] = (e = parseInt(i.slice(14, 18), 16)) >>> 8, t[7] = e & 255, t[8] = (e = parseInt(i.slice(19, 23), 16)) >>> 8, t[9] = e & 255, t[10] = (e = parseInt(i.slice(24, 36), 16)) / 1099511627776 & 255, t[11] = e / 4294967296 & 255, t[12] = e >>> 24 & 255, t[13] = e >>> 16 & 255, t[14] = e >>> 8 & 255, t[15] = e & 255, t } function M8(i) { i = unescape(encodeURIComponent(i)); const e = []; for (let t = 0; t < i.length; ++t)e.push(i.charCodeAt(t)); return e } const I8 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", T8 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"; function R8(i, e, t) { function s(r, n, o, a) { var l; if (typeof r == "string" && (r = M8(r)), typeof n == "string" && (n = E8(n)), ((l = n) === null || l === void 0 ? void 0 : l.length) !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)"); let c = new Uint8Array(16 + r.length); if (c.set(n), c.set(r, n.length), c = t(c), c[6] = c[6] & 15 | e, c[8] = c[8] & 63 | 128, o) { a = a || 0; for (let h = 0; h < 16; ++h)o[a + h] = c[h]; return o } return S8(c) } try { s.name = i } catch { } return s.DNS = I8, s.URL = T8, s } function P8(i, e, t, s) { switch (i) { case 0: return e & t ^ ~e & s; case 1: return e ^ t ^ s; case 2: return e & t ^ e & s ^ t & s; case 3: return e ^ t ^ s } } function N1(i, e) { return i << e | i >>> 32 - e } function B8(i) { const e = [1518500249, 1859775393, 2400959708, 3395469782], t = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]; if (typeof i == "string") { const o = unescape(encodeURIComponent(i)); i = []; for (let a = 0; a < o.length; ++a)i.push(o.charCodeAt(a)) } else Array.isArray(i) || (i = Array.prototype.slice.call(i)); i.push(128); const s = i.length / 4 + 2, r = Math.ceil(s / 16), n = new Array(r); for (let o = 0; o < r; ++o) { const a = new Uint32Array(16); for (let l = 0; l < 16; ++l)a[l] = i[o * 64 + l * 4] << 24 | i[o * 64 + l * 4 + 1] << 16 | i[o * 64 + l * 4 + 2] << 8 | i[o * 64 + l * 4 + 3]; n[o] = a } n[r - 1][14] = (i.length - 1) * 8 / Math.pow(2, 32), n[r - 1][14] = Math.floor(n[r - 1][14]), n[r - 1][15] = (i.length - 1) * 8 & 4294967295; for (let o = 0; o < r; ++o) { const a = new Uint32Array(80); for (let f = 0; f < 16; ++f)a[f] = n[o][f]; for (let f = 16; f < 80; ++f)a[f] = N1(a[f - 3] ^ a[f - 8] ^ a[f - 14] ^ a[f - 16], 1); let l = t[0], c = t[1], h = t[2], d = t[3], p = t[4]; for (let f = 0; f < 80; ++f) { const g = Math.floor(f / 20), m = N1(l, 5) + P8(g, c, h, d) + p + e[g] + a[f] >>> 0; p = d, d = h, h = N1(c, 30) >>> 0, c = l, l = m } t[0] = t[0] + l >>> 0, t[1] = t[1] + c >>> 0, t[2] = t[2] + h >>> 0, t[3] = t[3] + d >>> 0, t[4] = t[4] + p >>> 0 } return [t[0] >> 24 & 255, t[0] >> 16 & 255, t[0] >> 8 & 255, t[0] & 255, t[1] >> 24 & 255, t[1] >> 16 & 255, t[1] >> 8 & 255, t[1] & 255, t[2] >> 24 & 255, t[2] >> 16 & 255, t[2] >> 8 & 255, t[2] & 255, t[3] >> 24 & 255, t[3] >> 16 & 255, t[3] >> 8 & 255, t[3] & 255, t[4] >> 24 & 255, t[4] >> 16 & 255, t[4] >> 8 & 255, t[4] & 255] } const k8 = R8("v5", 80, B8), Jk = k8; Zi.registerCallback(Jr.ContextCreated, i => { const e = i.context; i2(e), t2(e) }); const j0 = oe("debugcomponents"), Kk = "eff8ba80-635d-11ec-90d6-0242ac120003"; class Br { constructor(e) { u(this, "_originalSeed"), u(this, "_seed"), typeof e == "string" && (e = Br.hash(e)), this._originalSeed = e, this._seed = e } get seed() { return this._seed } set seed(e) { this._seed = e } reset() { this._seed = this._originalSeed } generateUUID(e) { if (typeof e == "string") return Jk(e, Kk); const t = this._seed; return this._seed -= 1, Jk(t.toString(), Kk) } initialize(e) { typeof e == "string" ? this._seed = Br.hash(e) : this._seed = e } static createFromString(e) { return new Br(this.hash(e)) } static hash(e) { let t = 0; for (let s = 0; s < e.length; s++)t = e.charCodeAt(s) + ((t << 5) - t); return t } } var Zk = (i => (i.NewInstanceCreated = "new-instance-created", i.InstanceDestroyed = "instance-destroyed", i))(Zk || {}); class $k { constructor(e) { u(this, "guid"), this.guid = e } } function Q0(i, e, t = !0) { if (!i) return; const s = i; if (ic(i, t), !e) { console.warn("Can not send destroy: No networking connection provided", i.guid); return } if (!e.isConnected) { console.warn("Can not send destroy: not connected", i.guid); return } let r = i.guid; if (!r && s.uuid && (r = s.uuid), !r) { console.warn("Can not send destroy: failed to find guid", i); return } const n = new $k(r); e.send("instance-destroyed", n, Lr.Queued) } function e2(i, e) { const t = new $k(i); e.send("instance-destroyed", t, Lr.Queued) } function t2(i) { i.connection.beginListen("instance-destroyed", e => { j0 && console.log("[Remote] Destroyed", i.scene, e); const t = ug(e.guid, i.scene); t && ic(t) }) } class D8 { constructor(e, t, s) { u(this, "filename"), u(this, "hash"), u(this, "size"), this.filename = e, this.hash = t, this.size = s } } class O8 { constructor(e, t) { u(this, "guid"), u(this, "originalGuid"), u(this, "seed"), u(this, "visible"), u(this, "hostData"), u(this, "dontSave"), u(this, "parent"), u(this, "position"), u(this, "rotation"), u(this, "scale"), this.originalGuid = e, this.guid = t } } function z1(i, e, t, s) { var r; const n = i; if (!n.guid) return console.warn("Can not instantiate: No guid", n), null; if (e.context || (e.context = _t.Current), !e.context) return console.error("Missing network instantiate options / reference to network connection in sync instantiate"), null; const o = e ? { ...e } : null, { instance: a, seed: l } = L8(n, e); if (a) { const c = a; if (c.guid) { j0 && console.log("[Local] new instance", "gameobject:", a?.guid); const h = new O8(n.guid, c.guid); h.seed = l, o && (o.position && (h.position = { x: o.position.x, y: o.position.y, z: o.position.z }), o.rotation && (h.rotation = { x: o.rotation.x, y: o.rotation.y, z: o.rotation.z, w: o.rotation.w }), o.scale && (h.scale = { x: o.scale.x, y: o.scale.y, z: o.scale.z })), h.position || (h.position = { x: c.position.x, y: c.position.y, z: c.position.z }), h.rotation || (h.rotation = { x: c.quaternion.x, y: c.quaternion.y, z: c.quaternion.z, w: c.quaternion.w }), h.scale || (h.scale = { x: c.scale.x, y: c.scale.y, z: c.scale.z }), h.visible = n.visible, o != null && o.parent && (typeof o.parent == "string" ? h.parent = o.parent : h.parent = o.parent.guid), h.hostData = t, s === !1 && (h.dontSave = !0), (r = e?.context) == null || r.connection.send("new-instance-created", h) } else console.warn("Missing guid, can not send new instance event", c) } return a } function G0() { return Math.random() * 9999999 } function i2(i) { i.connection.beginListen("new-instance-created", async e => { const t = await F8(e.originalGuid, i.scene); if (!t) { console.warn("could not find object that was instantiated: " + e.guid); return } const s = new No; e.position && (s.position = new S(e.position.x, e.position.y, e.position.z)), e.rotation && (s.rotation = new we(e.rotation.x, e.rotation.y, e.rotation.z, e.rotation.w)), e.scale && (s.scale = new S(e.scale.x, e.scale.y, e.scale.z)), s.parent = e.parent, e.seed && (s.idProvider = new Br(e.seed)), s.visible = e.visible, s.context = i, j0 && i.alias && console.log("[Remote] instantiate in: " + i.alias); const r = dg(t, s); r && (e.parent === "scene" && i.scene.add(r), j0 && console.log("[Remote] new instance", "gameobject:", r?.guid, t)) }) } function L8(i, e) { const t = G0(), s = e ?? new No; s.idProvider = new Br(t); const r = dg(i, s); return { seed: t, instance: r } } const s2 = {}; function r2(i, e) { s2[i] = e } async function F8(i, e) { const t = s2[i]; if (t != null) { const s = await t(i); if (s) return s } return n2(i, e) } function n2(i, e) { if (e === null || !i) return null; if (e.guid === i) return e; if (e.children) for (const t of e.children) { const s = n2(i, t); if (s) return s } return null } const o2 = new Map; function U8(i, e) { if (!i) return; if (!e) { console.warn("No prototype found", i, i.prototype, i.constructor); return } let t = o2.get(e); t && t.apply(i) } function N8(i) { const e = z8(i.prototype); o2.set(i, e) } function z8(i) { return new j8(i) } class j8 { constructor(e) { u(this, "$symbol"), u(this, "extensions"), u(this, "descriptors"), this.$symbol = Symbol("prototype-extension"), this.extensions = Object.keys(e), this.descriptors = new Array; for (let t = 0; t < this.extensions.length; t++) { const s = this.extensions[t], r = Object.getOwnPropertyDescriptor(e, s); r && this.descriptors.push(r) } } apply(e) { if (!e[this.$symbol]) { e[this.$symbol] = !0; for (let t = 0; t < this.extensions.length; t++) { const s = this.extensions[t], r = this.descriptors[t]; r && Object.defineProperty(e, s, r) } } } } var ig = (i => (i.Added = "component-added", i.Removing = "removing-component", i))(ig || {}); const a2 = oe("debugcomponentevents"); class sg { static addComponentLifecylceEventListener(e, t) { this.eventListeners.has(e) && this.eventListeners.set(e, []); let s = this.eventListeners.get(e); s || (s = []), s.push(t), this.eventListeners.set(e, s), a2 && console.log("Added event listener for " + e, this.eventListeners) } static removeComponentLifecylceEventListener(e, t) { const s = this.eventListeners.get(e); if (!s) return; const r = s.indexOf(t); r < 0 || s.splice(r, 1) } static dispatchComponentLifecycleEvent(e, t) { const s = this.eventListeners.get(e); if (a2 && console.log("Dispatching event " + e, s), !!s) for (const r of s) r(t) } } u(sg, "eventListeners", new Map); const j1 = oe("debuggetcomponent"); function Q8(i) { return i == null || i.isObject3D ? i : i.object && i.object.isObject3D ? i.object : i } function Q1(i, e) { if (!i || !i.userData.components) return; const t = i.userData.components.indexOf(e); t < 0 || (sg.dispatchComponentLifecycleEvent(ig.Removing, e), e.gameObject = null, i.userData.components.splice(t, 1)) } function G1(i, e) { const t = md(i, e); if (t) return t; const s = new e; return tc(i, s) } const l2 = new Br("addComponentIdProvider"); function tc(i, e, t = !0) { i.userData || (i.userData = {}), i.userData.components || (i.userData.components = []), i.userData.components.push(e), e.gameObject = i, (e.guid === void 0 || e.guid === "invalid") && (e.guid = l2.generateUUID()), V0(i), ly(e); try { t && e.__internalAwake && (fg(i), e.__internalAwake()), sg.dispatchComponentLifecycleEvent(ig.Added, e) } catch (s) { console.error(s) } return e } function H1(i, e) { if (e.gameObject === i) return e; if (e.gameObject && e.gameObject.userData.components) { const t = e.gameObject.userData.components.indexOf(e); e.gameObject.userData.components.splice(t, 1) } if (!i.userData.components) i.userData.components = []; else if (i.userData.components.includes(e)) return e; return i.userData.components.push(e), e.gameObject = i, (e.guid === void 0 || e.guid === "invalid") && (e.guid = l2.generateUUID()), ly(e), e } function c2(i) { if (i.gameObject && i.gameObject.userData.components) { const e = i.gameObject.userData.components.indexOf(i); i.gameObject.userData.components.splice(e, 1) } i.__internalDisable && i.__internalDisable(), i.onDestroy && i.onDestroy(), qa(i, i.context ?? _t.Current), i.__internalDestroy(), i.gameObject = null } let h2 = !1; function u2(i, e, t) {
  var s; if (i != null) {
    if (!i.isObject3D) { console.error("Object is not object3D"); return } if (!((s = i?.userData) != null && s.components)) return null; if (typeof e == "string" && (h2 || (h2 = !0, console.warn(`Accessing components by name is not supported.
Please use the component type instead. This may keep working in local development but it will fail when bundling your application.

You can import other modules your main module to get access to types
or if you use npmdefs you can make types available globally using globalThis:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis`, e))), j1 && console.log("FIND", e), e != null) { for (let r = 0; r < i.userData.components.length; r++) { const n = i.userData.components[r]; if (e === null || n.constructor.name === e.name || n.constructor.name === e) if (j1 && console.log("MATCH BY NAME", n), t) t.push(n); else return n } for (let r = 0; r < i.userData.components.length; r++) { const n = i.userData.components[r]; let o = Object.getPrototypeOf(n.constructor); do { if (o === e) if (j1 && console.log("MATCH BY PROTOYPE", o), t) t.push(n); else return n; o = Object.getPrototypeOf(o) } while (o) } return t }
  }
} function md(i, e) { return u2(i, e) } function rg(i, e, t) { return t || (t = []), u2(i, e, t), t } function vd(i, e, t) { var s; const r = md(i, e); if (t === !1 && r?.enabled === !1) return null; if (r) return r; for (let n = 0; n < ((s = i?.children) == null ? void 0 : s.length); n++) { const o = vd(i.children[n], e); if (o) return o } return null } function ng(i, e, t) { var s; t || (t = []), rg(i, e, t); for (let r = 0; r < ((s = i?.children) == null ? void 0 : s.length); r++)ng(i.children[r], e, t); return t } function og(i, e) { if (!i) return null; if (Array.isArray(i)) { for (let s = 0; s < i.length; s++) { const r = Q8(i[s]), n = og(r, e); if (n) return n } return null } return md(i, e) || (i.parent ? og(i.parent, e) : null) } function H0(i, e, t) { return t || (t = []), i ? (rg(i, e, t), i.parent ? H0(i.parent, e, t) : t) : t } function d2(i, e, t) { if (!i) return null; if (!e && (e = _t.Current, !e)) return console.error("Can not search object without any needle context or scene!!!"), null; let s = e; if (s.isScene || (s = e?.scene), !s) return null; for (const r in s.children) { const n = s.children[r]; if (t === !1 && n[Ma] === !1) continue; if (n.constructor == i) return n; const o = vd(n, i); if (o) return o } return null } function p2(i, e, t) { if (!i) return e; if (!t && (t = _t.Current, !t)) return console.error("Can not search object without any needle context or scene!!!"), e; const s = t.isScene === !0 || t.isObject3D === !0 ? t : t?.scene; if (!s) return e; for (const r in s.children) { const n = s.children[r]; if (n.constructor == i) return n; ng(n, i, e) } return e } function V0(i) { i && i.isObject3D === !0 && U8(i, Me) } Me.prototype.SetActive = function (i) { this.visible = i }, Me.prototype.setActive = function (i) { this.visible = i }, Me.prototype.destroy = function () { ic(this) }, Me.prototype.addComponent = function (i) { return H1(this, i) }, Me.prototype.addNewComponent = function (i) { return tc(this, new i) }, Me.prototype.removeComponent = function (i) { return Q1(this, i) }, Me.prototype.getOrAddComponent = function (i) { return G1(this, i) }, Me.prototype.getComponent = function (i) { return md(this, i) }, Me.prototype.getComponents = function (i, e) { return rg(this, i, e) }, Me.prototype.getComponentInChildren = function (i) { return vd(this, i) }, Me.prototype.getComponentsInChildren = function (i, e) { return ng(this, i, e) }, Me.prototype.getComponentInParent = function (i) { return og(this, i) }, Me.prototype.getComponentsInParent = function (i, e) { return H0(this, i, e) }, Object.getOwnPropertyDescriptor(Me.prototype, "activeSelf") || Object.defineProperty(Me.prototype, "activeSelf", { get: function () { return Ad(this) }, set: function (i) { hg(this, i) } }), Object.getOwnPropertyDescriptor(Me.prototype, "transform") || Object.defineProperty(Me.prototype, "transform", { get: function () { return this } }), N8(Me); const ag = Symbol("NEEDLE_NEED_UPDATE_INSTANCE"), f2 = Symbol("isUsingInstancing"); class Xr { static isUsingInstancing(e) { return e[f2] === !0 } static markDirty(e, t = !0) { if (e && (this.isUsingInstancing(e) && (e[ag] = !0, e.matrixWorldNeedsUpdate = !0), t)) for (const s of e.children) Xr.markDirty(s, !0) } } const g2 = Symbol("gltf-loader-internal-usage-tracker"), G8 = oe("debugusers"), W0 = class { constructor(i) { u(this, "parser"), u(this, "_getDependency"), u(this, "_loadingId"), u(this, "_loadedObjects", new Set), this.parser = i, this._getDependency = this.parser.getDependency, this._loadingId = Date.now().toString() } static isLoading(i) { return W0._loadingProcesses > 0 } beforeRoot() { W0._loadingProcesses++; const i = this, e = this._getDependency; return this.parser.getDependency = function (t, s) { const r = e.call(this, t, s); return r.then(n => (n && (i._loadedObjects.add(n), n[g2] = i._loadingId), n)), r }, null } afterRoot(i) { W0._loadingProcesses--, this.parser.getDependency = this._getDependency; for (const e of this._loadedObjects) delete e[g2], e instanceof Me && (e.parent || e instanceof ye && (G8 && console.warn("> GLTF LOADER: Mesh not used in scene!", e), e.material = null, e.geometry = null)); return null } }; let m2 = W0; u(m2, "_loadingProcesses", 0); function H8(i, e, t, s) { } function V8(i, e, t) { const s = q8(i, e); if (s) for (let r = s.length - 1; r >= 0; r--)s[r] === t && s.splice(r, 1) } const q0 = "Needle:Patches"; function W8() { return globalThis[q0] || (globalThis[q0] = new WeakMap), globalThis[q0] } function q8(i, e) { let t = W8().get(i); return t ? t.get(e) : null } class v2 {
  constructor() {
    window.addEventListener("unhandledrejection", e => {
      var t; if (e.defaultPrevented) return; const s = (t = e?.reason) == null ? void 0 : t.path; if (s) {
        const r = s[0]; r && r.tagName === "IMG" && (console.warn(`Could not load image:
`+ r.src), e.preventDefault())
      }
    })
  }
} const lg = oe("trackusage"); function X8() { return lg === "dispose" } let A2 = lg !== void 0 && lg !== !1 && lg !== 0; function Y8(i) { A2 = i } function y2() { return A2 } function uo(i) { var e; if (i) { if (i instanceof rd) uo(i.geometry), uo(i.material), uo(i.skeleton); else if (i instanceof ye) uo(i.geometry), uo(i.material); else if (i instanceof yt) { cg(i); for (const t of Object.keys(i.attributes)) { const s = i.attributes[t]; uo(s) } } else if (!(i instanceof nt || i instanceof El)) if (i instanceof Array) for (const t of i) t && uo(t); else if (i instanceof Tt) { for (const t of Object.keys(i)) { const s = i[t]; s instanceof Nt && uo(s) } cg(i) } else i instanceof Nt ? (cg(i), ((e = i.source) == null ? void 0 : e.data) instanceof ImageBitmap && cg(i.source.data)) : i instanceof Xp ? cg(i.boneTexture) : i instanceof Df || !(i instanceof Me) && _2 && console.warn("Unknown object type", i) } } function cg(i) { (_2 || X8() || lg) && console.warn("\u{1F9E8} FREE", i), i && (i instanceof ImageBitmap ? i.close() : i.dispose()) } function b2(i) { (i instanceof ye || i instanceof rd) && (i.material = null, i.geometry = null) } const J8 = new Set; function V1(i, e, t = null, s) { if (s || (s = J8, s.clear()), !i) return s; const r = i[Z8]; if (r) for (const n of r) s.has(n) || t?.call(null, n) !== !1 && (s.add(n), e && V1(n, !0, t, s)); return s } function K8(i) { return i[$8] } const _2 = oe("debugusers"), Z8 = Symbol("needle-users"), $8 = Symbol("needle-users-count"); ye.prototype, ye.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype, Tt.prototype; const X0 = oe("debuggetcomponent"), Y0 = oe("debuginstantiate"); var x2 = (i => (i[i.None = 0] = "None", i[i.HideInHierarchy = 1] = "HideInHierarchy", i[i.HideInInspector = 2] = "HideInInspector", i[i.DontSaveInEditor = 4] = "DontSaveInEditor", i[i.NotEditable = 8] = "NotEditable", i[i.DontSaveInBuild = 16] = "DontSaveInBuild", i[i.DontUnloadUnusedAsset = 32] = "DontUnloadUnusedAsset", i[i.DontSave = 52] = "DontSave", i[i.HideAndDontSave = 61] = "HideAndDontSave", i))(x2 || {}); class No { constructor() { u(this, "idProvider"), u(this, "parent"), u(this, "keepWorldPosition"), u(this, "position"), u(this, "rotation"), u(this, "scale"), u(this, "visible"), u(this, "context") } } function Ad(i) { return i.visible } function hg(i, e) { return typeof e == "number" && (e = e > .5), i.visible = e, i.visible } function w2(i) { return i[Ma] || J0(i) } function C2(i, e) { i[f2] = e } function J0(i) { return Xr.isUsingInstancing(i) } function ug(i, e) { return Cu(i, e, !0, !0) } const S2 = Symbol("isDestroyed"); function W1(i) { return i[S2] } function E2(i, e) { i[S2] = e } function ic(i, e = !0, t = !1) { M2(i, e, t, !0) } function M2(i, e = !0, t = !1, s = !0) { if (i == null) return; const r = i; if (r.isComponent) { r.__internalDisable(), r.__internalDestroy(); return } const n = i; if (E2(n, !0), t && uo(n), b2(n), X0 && console.log(n), e && n.children) for (const a of n.children) M2(a, e, t, !1); const o = n.userData.components; if (o) { let a = o.length; for (let l = 0; l < o.length; l++) { const c = o[l]; c.__internalDisable(), c.__internalDestroy(), o.length < a && (a = o.length, l--) } } s && n.removeFromParent() } function Dh(i, e, t = !0) { return I2(i, e, t) } function* q1(i, e, t = !1, s = 999, r = 0) { if (i != null && i.userData.components && !(r > s)) { for (const n of i.userData.components) e && n?.isComponent === !0 && n instanceof e ? yield n : yield n; if (t === !0) for (const n of i.children) yield* q1(n, e, !0, s, r + 1) } } function I2(i, e, t, s = 0) { var r; if (i) { if (i.isObject3D, s > 1e3) { console.warn("Failed to iterate components: too many levels"); return } if ((r = i.userData) != null && r.components) for (let n = 0; n < i.userData.components.length; n++) { const o = i.userData.components[n]; if (o?.isComponent === !0) { const a = e(o); if (a !== void 0) return a } } if (t && i.children) { const n = s + 1; for (let o = 0; o < i.children.length; o++) { const a = i.children[o]; if (!a) continue; const l = I2(a, e, t, n); if (l !== void 0) return l } } } } function dg(i, e = null) { if (i === null) return null; let t = null; e !== null && (e.x !== void 0 ? (t = new No, t.position = e) : t = e); let s = _t.Current; t != null && t.context && (s = t.context), X0 && s.alias && console.log("context", s.alias), t && !t.idProvider && (t.idProvider = new Br(Date.now())); const r = [], n = {}, o = {}, a = T2(s, i, t, r, n, o); a && (t9(n), e9(o, n)), X0 && (v0(i, !0), v0(a, !0)); const l = {}; for (const c in r) { const h = r[c], d = h.guid; t && t.idProvider && (h.guid = t.idProvider.generateUUID(), l[d] = h.guid, X0 && console.log(h.name, h.guid)), ly(h, s), h.__internalNewInstanceCreated && h.__internalNewInstanceCreated() } for (const c in r) { const h = r[c]; h.resolveGuids && h.resolveGuids(l), h.enabled !== !1 && (h.enabled = !0) } return pg(s), a } function T2(i, e, t, s, r, n) { var o; if (!e) return null; const a = e.userData; e.userData = {}; const l = e.children; e.children = []; let c; if (c = e.clone(!1), V0(c), e.userData = a, e.children = l, r[e.uuid] = { original: e, clone: c }, Y0 && console.log("ADD", e, c), e.type === "SkinnedMesh" && (n[e.uuid] = { original: e, clone: c }), t?.visible !== void 0 && (c.visible = t.visible), t != null && t.idProvider) { c.uuid = t.idProvider.generateUUID(); const d = c; d && (d.guid = c.uuid) } e.animations && e.animations.length > 0 && (c.animations = [...e.animations]); const h = e.parent; if (h && h.add(c), t != null && t.position ? ts(c, t.position) : c.position.copy(e.position), t != null && t.rotation ? Dr(c, t.rotation) : c.quaternion.copy(e.quaternion), t != null && t.scale ? c.scale.copy(t.scale) : c.scale.copy(e.scale), t != null && t.parent && t.parent !== "scene") { let d = null; if (typeof t.parent == "string" ? d = Cu(t.parent, i.scene, !0) : d = t.parent, d) { const p = t.keepWorldPosition === !0 ? d.attach : d.add; p ? p.call(d, c) : console.error("Invalid parent object", d, "received when instantiating:", e) } else console.warn("could not find parent:", t.parent) } for (const [d, p] of Object.entries(e.userData)) d !== "components" && (c.userData[d] = p); if ((o = e.userData) != null && o.components) { const d = e.userData.components, p = []; c.userData.components = p; for (let f = 0; f < d.length; f++) { const g = d[f], m = new g.constructor; Rh(m, g), g[af] !== void 0 && (m[af] = g[af]), p.push(m), m.gameObject = c, s.push(m), sg.dispatchComponentLifecycleEvent(ig.Added, m) } } t && (t.position = void 0, t.rotation = void 0, t.scale = void 0, t.parent = void 0); for (const d in e.children) { const p = e.children[d], f = T2(i, p, t, s, r, n); f && c.add(f) } return c } function e9(i, e) { for (const t in i) { const s = i[t], r = s.original, n = r.skeleton, o = s.clone; if (!n) { console.warn("Skinned mesh has no skeleton?", s); continue } const a = n.bones, l = o.skeleton.clone(); o.skeleton = l, o.bindMatrix.clone().copy(r.bindMatrix), o.bindMatrixInverse.copy(r.bindMatrixInverse); const c = []; l.bones = c; for (let h = 0; h < a.length; h++) { const d = a[h], p = e[d.uuid].clone; c.push(p) } } for (const t in i) { const s = i[t].clone; s.skeleton.update(), s.bind(s.skeleton, s.bindMatrix), s.updateMatrixWorld(!0) } } function t9(i) { var e; for (const t in i) { const s = i[t].clone; if ((e = s.userData) != null && e.components) for (let r = 0; r < s.userData.components.length; r++) { const n = s.userData.components[r], o = Object.entries(n); for (const [a, l] of o) if (Array.isArray(l)) { const c = []; n[a] = c; for (let h = 0; h < l.length; h++) { const d = l[h]; if (typeof d != "object") { c.push(d); continue } const p = R2(n, a, d, i); p !== void 0 ? c.push(p) : c.push(d) } } else if (typeof l == "object") { const c = R2(n, a, l, i); c !== void 0 && (n[a] = c) } } } } function R2(i, e, t, s) { var r, n; if (t != null) { if (t.isComponent === !0) { const o = t.gameObject; if (o) { const a = o.uuid, l = (r = s[a]) == null ? void 0 : r.clone; if (!l) { Y0 && console.log("reference did not change", e, i, t); return } const c = o.userData.components.indexOf(t); if (c >= 0) return Y0 && console.log(e, a), l.userData.components[c]; console.warn("could not find component", e, t) } } else if (t.isObject3D === !0) { if (e === "gameObject") return; const o = t; if (o) { const a = o.uuid, l = (n = s[a]) == null ? void 0 : n.clone; if (l) return Y0 && console.log(e, "old", t, "new", l), l } } else if (t.isVector4 || t.isVector3 || t.isVector2 || t.isQuaternion || t.isEuler) return t.clone() } } const i9 = oe("debugnewscripts"), s9 = oe("debughierarchy"), Fi = []; function pg(i) { if (!(i.new_scripts.length <= 0)) { if (i9 && console.log("Register new components", i.new_scripts.length, [...i.new_scripts], i.alias ? "element: " + i.alias : i.hash, i), i.new_scripts_pre_setup_callbacks.length > 0) { for (const e of i.new_scripts_pre_setup_callbacks) e && e(); i.new_scripts_pre_setup_callbacks.length = 0 } Fi.length = 0, i.new_scripts.length > 0 && Fi.push(...i.new_scripts), i.new_scripts.length = 0; for (let e = 0; e < Fi.length; e++)try { const t = Fi[e]; if (t.destroyed) continue; if (!t.gameObject) { console.error("MISSING GAMEOBJECT - will ignore", t), Fi.splice(e, 1), e--; continue } t.context = i, fg(t.gameObject), X1(t, i) } catch (t) { console.error(t), qa(Fi[e], i), Fi.splice(e, 1), e-- } for (let e = 0; e < Fi.length; e++)try { const t = Fi[e]; if (t.destroyed) { qa(Fi[e], i), Fi.splice(e, 1), e--; continue } if (t.registering) try { t.registering() } catch (s) { console.error(s) } t.__internalAwake !== void 0 && (t.gameObject || console.error("MISSING GAMEOBJECT", t, t.gameObject), fg(t.gameObject), t.activeAndEnabled && gd(t.__internalAwake.bind(t))) } catch (t) { console.error(t), qa(Fi[e], i), Fi.splice(e, 1), e-- } for (let e = 0; e < Fi.length; e++)try { const t = Fi[e]; if (t.destroyed || t.enabled === !1 || (fg(t.gameObject), t.activeAndEnabled === !1)) continue; t.__internalEnable !== void 0 && (t.enabled = !0, gd(t.__internalEnable.bind(t))) } catch (t) { console.error(t), qa(Fi[e], i), Fi.splice(e, 1), e-- } for (let e = 0; e < Fi.length; e++)try { const t = Fi[e]; if (t.destroyed || !t.gameObject) continue; i.new_script_start.push(t) } catch (t) { console.error(t), qa(Fi[e], i), Fi.splice(e, 1), e-- } Fi.length = 0; for (const e of i.new_scripts_post_setup_callbacks) e && e(); i.new_scripts_post_setup_callbacks.length = 0 } } function r9(i) { i && (i.__internalDisable(!0), qa(i, i.context)) } function P2(i, e) { for (let t = 0; t < i.new_script_start.length; t++)try { const s = i.new_script_start[t]; if (e !== void 0 && s.gameObject !== e || s.destroyed || s.activeAndEnabled === !1) continue; gd(s.__internalAwake.bind(s)), s.enabled && (gd(s.__internalEnable.bind(s)), gd(s.__internalStart.bind(s)), i.new_script_start.splice(t, 1), t--) } catch (s) { console.error(s), qa(i.new_script_start[t], i), i.new_script_start.splice(t, 1), t-- } } function X1(i, e) { e.scripts.indexOf(i) === -1 && (e.scripts.push(i), i.earlyUpdate && e.scripts_earlyUpdate.push(i), i.update && e.scripts_update.push(i), i.lateUpdate && e.scripts_lateUpdate.push(i), i.onBeforeRender && e.scripts_onBeforeRender.push(i), i.onAfterRender && e.scripts_onAfterRender.push(i), i.onPausedChanged && e.scripts_pausedChanged.push(i)) } function qa(i, e) { Xa(i, e.new_scripts), Xa(i, e.new_script_start), Xa(i, e.scripts), Xa(i, e.scripts_earlyUpdate), Xa(i, e.scripts_update), Xa(i, e.scripts_lateUpdate), Xa(i, e.scripts_onBeforeRender), Xa(i, e.scripts_onAfterRender), Xa(i, e.scripts_pausedChanged), e.stopAllCoroutinesFrom(i) } function Xa(i, e) { const t = e.indexOf(i); t >= 0 && e.splice(t, 1) } function K0(i) { if (i || (i = Zi.Current.scene), !i) { console.trace("Invalid call - no current context."); return } const e = Ad(i); B2(i, e, !0) || (console.error('Failed to update active state in hierarchy of "' + i.name + '"', i), console.warn(" \u2191 this error might be caused by circular references. Please make sure you don't have files with circular references (e.g. one GLB 1 is loading GLB 2 which is then loading GLB 1 again).")) } function B2(i, e, t, s = 0) { if (s > 1e3) return console.warn("Hierarchy is too deep (> 1000 level) - will abort updating active state"), !1; const r = Ad(i); if (e && (e = r, e && i.parent)) { const a = i.parent; e = a[Ma], e === void 0 && (a instanceof Cn || (e = !0)) } const n = i[Ma] !== e; i[Ma] = e, n && (s9 && console.warn("ACTIVE CHANGE", i.name, r, i.visible, e, "changed?" + n, i), t && n9(i, a => { e ? a.enabled && (gd(a.__internalAwake.bind(a)), a.enabled && (a.__didEnable = !0, a.onEnable())) : a.__didAwake && a.enabled && (a.__didEnable = !1, a.onDisable()) })); let o = !0; if (i.children) { const a = s + 1; for (const l of i.children) B2(l, e, t, a) === !1 && (o = !1) } return o } function fg(i) { let e = !0, t = i, s = !1; for (; t && t;) { if (t.type === "Scene" && (s = !0), !Ad(t)) { e = !1; break } t = t.parent } if (!i) { console.error("GO is null"); return } i[Ma] = e && s } function n9(i, e) { var t; if ((t = i.userData) != null && t.components) for (const s of i.userData.components) e(s) } const Z0 = new Map, k2 = Symbol("prewarmFlag"), Y1 = Symbol("waitingForPrewarm"), J1 = oe("debugprewarm"); function D2(i, e) { !i || i[k2] === !0 || i[Y1] === !0 || (Z0.has(e) || Z0.set(e, []), i[Y1] = !0, Z0.get(e).push(i), J1 && console.debug("register prewarm", i.name)) } let K1 = null, Z1 = null; function o9(i) { if (!i) return; const e = Z0.get(i); if (!(e != null && e.length)) return; const t = i.mainCamera; if (t) { J1 && console.log("prewarm", e.length, "objects", [...e]); const s = i.renderer; if (s.compile) { const r = i.scene; s.compile(r, t), K1 ?? (K1 = new bA(64)), Z1 ?? (Z1 = new aw(.001, 9999999, K1)), Z1.update(s, r); for (const n of e) n[k2] = !0, n[Y1] = !1; e.length = 0, J1 && console.log("prewarm done") } } }/**
 * postprocessing v6.30.2 build Fri Mar 31 2023
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2023 Raoul van Rüschen
 * @license Zlib
 */var yd = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}", a9 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`, $0 = class extends Vt { constructor(i = !1, e = !1) { super({ name: "BokehMaterial", defines: { PASS: i ? "2" : "1" }, uniforms: { inputBuffer: new Ce(null), cocBuffer: new Ce(null), texelSize: new Ce(new W), kernel64: new Ce(null), kernel16: new Ce(null), scale: new Ce(1) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: a9, vertexShader: yd }), this.toneMapped = !1, e && (this.defines.FOREGROUND = "1"), this.generateKernel() } set inputBuffer(i) { this.uniforms.inputBuffer.value = i } setInputBuffer(i) { this.uniforms.inputBuffer.value = i } set cocBuffer(i) { this.uniforms.cocBuffer.value = i } setCoCBuffer(i) { this.uniforms.cocBuffer.value = i } get scale() { return this.uniforms.scale.value } set scale(i) { this.uniforms.scale.value = i } getScale(i) { return this.scale } setScale(i) { this.scale = i } generateKernel() { const i = 2.39996323, e = new Float64Array(128), t = new Float64Array(32); let s = 0, r = 0; for (let n = 0, o = Math.sqrt(80); n < 80; ++n) { const a = n * i, l = Math.sqrt(n) / o, c = l * Math.cos(a), h = l * Math.sin(a); n % 5 === 0 ? (t[r++] = c, t[r++] = h) : (e[s++] = c, e[s++] = h) } this.uniforms.kernel64.value = e, this.uniforms.kernel16.value = t } setTexelSize(i, e) { this.uniforms.texelSize.value.set(i, e) } setSize(i, e) { this.uniforms.texelSize.value.set(1 / i, 1 / e) } }; function bd(i, e, t) { return i * (e - t) - e } function Oh(i, e, t) { return Math.min(Math.max((i + e) / (e - t), 0), 1) } var l9 = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`, c9 = class extends Vt { constructor(i) { super({ name: "CircleOfConfusionMaterial", defines: { DEPTH_PACKING: "0" }, uniforms: { depthBuffer: new Ce(null), focusDistance: new Ce(0), focusRange: new Ce(0), cameraNear: new Ce(.3), cameraFar: new Ce(1e3) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: l9, vertexShader: yd }), this.toneMapped = !1, this.uniforms.focalLength = this.uniforms.focusRange, this.copyCameraSettings(i) } get near() { return this.uniforms.cameraNear.value } get far() { return this.uniforms.cameraFar.value } set depthBuffer(i) { this.uniforms.depthBuffer.value = i } set depthPacking(i) { this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0 } setDepthBuffer(i, e = Os) { this.depthBuffer = i, this.depthPacking = e } get focusDistance() { return this.uniforms.focusDistance.value } set focusDistance(i) { this.uniforms.focusDistance.value = i } get worldFocusDistance() { return -bd(this.focusDistance, this.near, this.far) } set worldFocusDistance(i) { this.focusDistance = Oh(-i, this.near, this.far) } getFocusDistance(i) { this.uniforms.focusDistance.value = i } setFocusDistance(i) { this.uniforms.focusDistance.value = i } get focalLength() { return this.focusRange } set focalLength(i) { this.focusRange = i } get focusRange() { return this.uniforms.focusRange.value } set focusRange(i) { this.uniforms.focusRange.value = i } get worldFocusRange() { return -bd(this.focusRange, this.near, this.far) } set worldFocusRange(i) { this.focusRange = Oh(-i, this.near, this.far) } getFocalLength(i) { return this.focusRange } setFocalLength(i) { this.focusRange = i } adoptCameraSettings(i) { this.copyCameraSettings(i) } copyCameraSettings(i) { i && (this.uniforms.cameraNear.value = i.near, this.uniforms.cameraFar.value = i.far, i instanceof Xt ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } }, kt = { SKIP: 9, SET: 30, ADD: 0, ALPHA: 1, AVERAGE: 2, COLOR: 3, COLOR_BURN: 4, COLOR_DODGE: 5, DARKEN: 6, DIFFERENCE: 7, DIVIDE: 8, DST: 9, EXCLUSION: 10, HARD_LIGHT: 11, HARD_MIX: 12, HUE: 13, INVERT: 14, INVERT_RGB: 15, LIGHTEN: 16, LINEAR_BURN: 17, LINEAR_DODGE: 18, LINEAR_LIGHT: 19, LUMINOSITY: 20, MULTIPLY: 21, NEGATION: 22, NORMAL: 23, OVERLAY: 24, PIN_LIGHT: 25, REFLECT: 26, SATURATION: 27, SCREEN: 28, SOFT_LIGHT: 29, SRC: 30, SUBTRACT: 31, VIVID_LIGHT: 32 }, O2 = { RED: 0, GREEN: 1, BLUE: 2, ALPHA: 3 }, gg = { DEFAULT: 0, KEEP_MAX_DEPTH: 1, DISCARD_MAX_DEPTH: 2 }, $1 = { DEPTH: 0, LUMA: 1, COLOR: 2 }, nn = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 }, si = { FRAGMENT_HEAD: "FRAGMENT_HEAD", FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV", FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE", VERTEX_HEAD: "VERTEX_HEAD", VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT" }, Ya = { VERY_SMALL: 0, SMALL: 1, MEDIUM: 2, LARGE: 3, VERY_LARGE: 4, HUGE: 5 }, L2 = { DISCARD: 0, MULTIPLY: 1, MULTIPLY_RGB_SET_ALPHA: 2 }, h9 = { DISABLED: 0, DEPTH: 1, CUSTOM: 2 }, _d = { LOW: 0, MEDIUM: 1, HIGH: 2, ULTRA: 3 }, ey = { DEFAULT: 0, ESKIL: 1 }, u9 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
}`, d9 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}", p9 = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])], F2 = class extends Vt { constructor(i = new st) { super({ name: "KawaseBlurMaterial", uniforms: { inputBuffer: new Ce(null), texelSize: new Ce(new st), scale: new Ce(1), kernel: new Ce(0) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: u9, vertexShader: d9 }), this.toneMapped = !1, this.setTexelSize(i.x, i.y), this.kernelSize = Ya.MEDIUM } set inputBuffer(i) { this.uniforms.inputBuffer.value = i } setInputBuffer(i) { this.inputBuffer = i } get kernelSequence() { return p9[this.kernelSize] } get scale() { return this.uniforms.scale.value } set scale(i) { this.uniforms.scale.value = i } getScale() { return this.uniforms.scale.value } setScale(i) { this.uniforms.scale.value = i } getKernel() { return null } get kernel() { return this.uniforms.kernel.value } set kernel(i) { this.uniforms.kernel.value = i } setKernel(i) { this.kernel = i } setTexelSize(i, e) { this.uniforms.texelSize.value.set(i, e, i * .5, e * .5) } setSize(i, e) { const t = 1 / i, s = 1 / e; this.uniforms.texelSize.value.set(t, s, t * .5, s * .5) } }, f9 = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
#include <dithering_fragment>
}`, U2 = class extends Vt { constructor() { super({ name: "CopyMaterial", uniforms: { inputBuffer: new Ce(null), opacity: new Ce(1) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: f9, vertexShader: yd }), this.toneMapped = !1 } set inputBuffer(i) { this.uniforms.inputBuffer.value = i } setInputBuffer(i) { this.uniforms.inputBuffer.value = i } getOpacity(i) { return this.uniforms.opacity.value } setOpacity(i) { this.uniforms.opacity.value = i } }, g9 = `#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[]=float[4](abs(c-samples[0]),abs(c-samples[1]),abs(c-samples[2]),abs(c-samples[3]));float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[]=float[4](readDepth(vUv0),readDepth(vUv1),readDepth(vUv2),readDepth(vUv3));int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[]=vec3[4](texture2D(normalBuffer,vUv0).rgb,texture2D(normalBuffer,vUv1).rgb,texture2D(normalBuffer,vUv2).rgb,texture2D(normalBuffer,vUv3).rgb);
#else
vec3 n[]=vec3[4](vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));
#endif
gl_FragColor=vec4(n[index],d[index]);}`, m9 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}", v9 = class extends Vt { constructor() { super({ name: "DepthDownsamplingMaterial", defines: { DEPTH_PACKING: "0" }, uniforms: { depthBuffer: new Ce(null), normalBuffer: new Ce(null), texelSize: new Ce(new W) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: g9, vertexShader: m9 }), this.toneMapped = !1 } set depthBuffer(i) { this.uniforms.depthBuffer.value = i } set depthPacking(i) { this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0 } setDepthBuffer(i, e = Os) { this.depthBuffer = i, this.depthPacking = e } set normalBuffer(i) { this.uniforms.normalBuffer.value = i, i !== null ? this.defines.DOWNSAMPLE_NORMALS = "1" : delete this.defines.DOWNSAMPLE_NORMALS, this.needsUpdate = !0 } setNormalBuffer(i) { this.normalBuffer = i } setTexelSize(i, e) { this.uniforms.texelSize.value.set(i, e) } setSize(i, e) { this.uniforms.texelSize.value.set(1 / i, 1 / e) } }, A9 = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;
#else
uniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;
#endif
uniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}varying vec2 vUv;void main(){vec2 depth;
#if DEPTH_PACKING_0 == 3201
depth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));
#else
depth.x=texture2D(depthBuffer0,vUv).r;
#endif
#if DEPTH_PACKING_1 == 3201
depth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));
#else
depth.y=texture2D(depthBuffer1,vUv).r;
#endif
bool isMaxDepth=(depth.x==1.0);
#ifdef PERSPECTIVE_CAMERA
depth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);
#endif
#if DEPTH_TEST_STRATEGY == 0
bool keep=depthTest(depth.x,depth.y);
#elif DEPTH_TEST_STRATEGY == 1
bool keep=isMaxDepth||depthTest(depth.x,depth.y);
#else
bool keep=!isMaxDepth&&depthTest(depth.x,depth.y);
#endif
if(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}`, y9 = class extends Vt { constructor() { super({ name: "DepthMaskMaterial", defines: { DEPTH_EPSILON: "0.0001", DEPTH_PACKING_0: "0", DEPTH_PACKING_1: "0", DEPTH_TEST_STRATEGY: gg.KEEP_MAX_DEPTH }, uniforms: { inputBuffer: new Ce(null), depthBuffer0: new Ce(null), depthBuffer1: new Ce(null), cameraNearFar: new Ce(new W(1, 1)) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: A9, vertexShader: yd }), this.toneMapped = !1, this.depthMode = lf } set depthBuffer0(i) { this.uniforms.depthBuffer0.value = i } set depthPacking0(i) { this.defines.DEPTH_PACKING_0 = i.toFixed(0), this.needsUpdate = !0 } setDepthBuffer0(i, e = Os) { this.depthBuffer0 = i, this.depthPacking0 = e } set depthBuffer1(i) { this.uniforms.depthBuffer1.value = i } set depthPacking1(i) { this.defines.DEPTH_PACKING_1 = i.toFixed(0), this.needsUpdate = !0 } setDepthBuffer1(i, e = Os) { this.depthBuffer1 = i, this.depthPacking1 = e } get maxDepthStrategy() { return Number(this.defines.DEPTH_TEST_STRATEGY) } set maxDepthStrategy(i) { this.defines.DEPTH_TEST_STRATEGY = i.toFixed(0), this.needsUpdate = !0 } get keepFar() { return this.maxDepthStrategy } set keepFar(i) { this.maxDepthStrategy = i ? gg.KEEP_MAX_DEPTH : gg.DISCARD_MAX_DEPTH } getMaxDepthStrategy() { return this.maxDepthStrategy } setMaxDepthStrategy(i) { this.maxDepthStrategy = i } get epsilon() { return Number(this.defines.DEPTH_EPSILON) } set epsilon(i) { this.defines.DEPTH_EPSILON = i.toFixed(16), this.needsUpdate = !0 } getEpsilon() { return this.epsilon } setEpsilon(i) { this.epsilon = i } get depthMode() { return Number(this.defines.DEPTH_MODE) } set depthMode(i) { let e; switch (i) { case cx: e = "false"; break; case Uv: e = "true"; break; case Iu: e = "abs(d1 - d0) <= DEPTH_EPSILON"; break; case cf: e = "abs(d1 - d0) > DEPTH_EPSILON"; break; case lf: e = "d0 > d1"; break; case Mu: e = "d0 >= d1"; break; case Nv: e = "d0 <= d1"; break; case zv: default: e = "d0 < d1"; break }this.defines.DEPTH_MODE = i.toFixed(0), this.defines["depthTest(d0, d1)"] = e, this.needsUpdate = !0 } getDepthMode() { return this.depthMode } setDepthMode(i) { this.depthMode = i } adoptCameraSettings(i) { this.copyCameraSettings(i) } copyCameraSettings(i) { i && (this.uniforms.cameraNearFar.value.set(i.near, i.far), i instanceof Xt ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } }, b9 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <encodings_fragment>
}`, _9 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}", x9 = class extends Vt { constructor() { super({ name: "DownsamplingMaterial", uniforms: { inputBuffer: new Ce(null), texelSize: new Ce(new W) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: b9, vertexShader: _9 }), this.toneMapped = !1 } set inputBuffer(i) { this.uniforms.inputBuffer.value = i } setSize(i, e) { this.uniforms.texelSize.value.set(1 / i, 1 / e) } }, w9 = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`, C9 = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`, S9 = class extends Vt { constructor(i = new W, e = $1.COLOR) { super({ name: "EdgeDetectionMaterial", defines: { THREE_REVISION: th.replace(/\D+/g, ""), LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0", EDGE_THRESHOLD: "0.1", DEPTH_THRESHOLD: "0.01", PREDICATION_MODE: "0", PREDICATION_THRESHOLD: "0.01", PREDICATION_SCALE: "2.0", PREDICATION_STRENGTH: "1.0", DEPTH_PACKING: "0" }, uniforms: { inputBuffer: new Ce(null), depthBuffer: new Ce(null), predicationBuffer: new Ce(null), texelSize: new Ce(i) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: w9, vertexShader: C9 }), this.toneMapped = !1, this.edgeDetectionMode = e } set depthBuffer(i) { this.uniforms.depthBuffer.value = i } set depthPacking(i) { this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0 } setDepthBuffer(i, e = Os) { this.depthBuffer = i, this.depthPacking = e } get edgeDetectionMode() { return Number(this.defines.EDGE_DETECTION_MODE) } set edgeDetectionMode(i) { this.defines.EDGE_DETECTION_MODE = i.toFixed(0), this.needsUpdate = !0 } getEdgeDetectionMode() { return this.edgeDetectionMode } setEdgeDetectionMode(i) { this.edgeDetectionMode = i } get localContrastAdaptationFactor() { return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR) } set localContrastAdaptationFactor(i) { this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = i.toFixed("6"), this.needsUpdate = !0 } getLocalContrastAdaptationFactor() { return this.localContrastAdaptationFactor } setLocalContrastAdaptationFactor(i) { this.localContrastAdaptationFactor = i } get edgeDetectionThreshold() { return Number(this.defines.EDGE_THRESHOLD) } set edgeDetectionThreshold(i) { this.defines.EDGE_THRESHOLD = i.toFixed("6"), this.defines.DEPTH_THRESHOLD = (i * .1).toFixed("6"), this.needsUpdate = !0 } getEdgeDetectionThreshold() { return this.edgeDetectionThreshold } setEdgeDetectionThreshold(i) { this.edgeDetectionThreshold = i } get predicationMode() { return Number(this.defines.PREDICATION_MODE) } set predicationMode(i) { this.defines.PREDICATION_MODE = i.toFixed(0), this.needsUpdate = !0 } getPredicationMode() { return this.predicationMode } setPredicationMode(i) { this.predicationMode = i } set predicationBuffer(i) { this.uniforms.predicationBuffer.value = i } setPredicationBuffer(i) { this.uniforms.predicationBuffer.value = i } get predicationThreshold() { return Number(this.defines.PREDICATION_THRESHOLD) } set predicationThreshold(i) { this.defines.PREDICATION_THRESHOLD = i.toFixed("6"), this.needsUpdate = !0 } getPredicationThreshold() { return this.predicationThreshold } setPredicationThreshold(i) { this.predicationThreshold = i } get predicationScale() { return Number(this.defines.PREDICATION_SCALE) } set predicationScale(i) { this.defines.PREDICATION_SCALE = i.toFixed("6"), this.needsUpdate = !0 } getPredicationScale() { return this.predicationScale } setPredicationScale(i) { this.predicationScale = i } get predicationStrength() { return Number(this.defines.PREDICATION_STRENGTH) } set predicationStrength(i) { this.defines.PREDICATION_STRENGTH = i.toFixed("6"), this.needsUpdate = !0 } getPredicationStrength() { return this.predicationStrength } setPredicationStrength(i) { this.predicationStrength = i } setSize(i, e) { this.uniforms.texelSize.value.set(1 / i, 1 / e) } }, E9 = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`, M9 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}", I9 = class extends Vt { constructor(i, e, t, s, r = !1) { super({ name: "EffectMaterial", defines: { THREE_REVISION: th.replace(/\D+/g, ""), DEPTH_PACKING: "0", ENCODE_OUTPUT: "1" }, uniforms: { inputBuffer: new Ce(null), depthBuffer: new Ce(null), resolution: new Ce(new W), texelSize: new Ce(new W), cameraNear: new Ce(.3), cameraFar: new Ce(1e3), aspect: new Ce(1), time: new Ce(0) }, blending: Ri, depthWrite: !1, depthTest: !1, dithering: r }), this.toneMapped = !1, i && this.setShaderParts(i), e && this.setDefines(e), t && this.setUniforms(t), this.copyCameraSettings(s) } set inputBuffer(i) { this.uniforms.inputBuffer.value = i } setInputBuffer(i) { this.uniforms.inputBuffer.value = i } get depthBuffer() { return this.uniforms.depthBuffer.value } set depthBuffer(i) { this.uniforms.depthBuffer.value = i } get depthPacking() { return Number(this.defines.DEPTH_PACKING) } set depthPacking(i) { this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0 } setDepthBuffer(i, e = Os) { this.depthBuffer = i, this.depthPacking = e } setShaderData(i) { this.setShaderParts(i.shaderParts), this.setDefines(i.defines), this.setUniforms(i.uniforms), this.setExtensions(i.extensions) } setShaderParts(i) { var e, t, s, r, n; return this.fragmentShader = E9.replace(si.FRAGMENT_HEAD, (e = i.get(si.FRAGMENT_HEAD)) != null ? e : "").replace(si.FRAGMENT_MAIN_UV, (t = i.get(si.FRAGMENT_MAIN_UV)) != null ? t : "").replace(si.FRAGMENT_MAIN_IMAGE, (s = i.get(si.FRAGMENT_MAIN_IMAGE)) != null ? s : ""), this.vertexShader = M9.replace(si.VERTEX_HEAD, (r = i.get(si.VERTEX_HEAD)) != null ? r : "").replace(si.VERTEX_MAIN_SUPPORT, (n = i.get(si.VERTEX_MAIN_SUPPORT)) != null ? n : ""), this.needsUpdate = !0, this } setDefines(i) { for (const e of i.entries()) this.defines[e[0]] = e[1]; return this.needsUpdate = !0, this } setUniforms(i) { for (const e of i.entries()) this.uniforms[e[0]] = e[1]; return this } setExtensions(i) { this.extensions = {}; for (const e of i) this.extensions[e] = !0; return this } get encodeOutput() { return this.defines.ENCODE_OUTPUT !== void 0 } set encodeOutput(i) { this.encodeOutput !== i && (i ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0) } isOutputEncodingEnabled(i) { return this.encodeOutput } setOutputEncodingEnabled(i) { this.encodeOutput = i } get time() { return this.uniforms.time.value } set time(i) { this.uniforms.time.value = i } setDeltaTime(i) { this.uniforms.time.value += i } adoptCameraSettings(i) { this.copyCameraSettings(i) } copyCameraSettings(i) { i && (this.uniforms.cameraNear.value = i.near, this.uniforms.cameraFar.value = i.far, i instanceof Xt ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } setSize(i, e) { const t = this.uniforms; t.resolution.value.set(i, e), t.texelSize.value.set(1 / i, 1 / e), t.aspect.value = i / e } static get Section() { return si } }, T9 = `#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`, R9 = class extends Vt { constructor(i = !1, e = null) { super({ name: "LuminanceMaterial", defines: { THREE_REVISION: th.replace(/\D+/g, "") }, uniforms: { inputBuffer: new Ce(null), threshold: new Ce(0), smoothing: new Ce(1), range: new Ce(null) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: T9, vertexShader: yd }), this.toneMapped = !1, this.colorOutput = i, this.luminanceRange = e } set inputBuffer(i) { this.uniforms.inputBuffer.value = i } setInputBuffer(i) { this.uniforms.inputBuffer.value = i } get threshold() { return this.uniforms.threshold.value } set threshold(i) { this.smoothing > 0 || i > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = i } getThreshold() { return this.threshold } setThreshold(i) { this.threshold = i } get smoothing() { return this.uniforms.smoothing.value } set smoothing(i) { this.threshold > 0 || i > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = i } getSmoothingFactor() { return this.smoothing } setSmoothingFactor(i) { this.smoothing = i } get useThreshold() { return this.threshold > 0 || this.smoothing > 0 } set useThreshold(i) { } get colorOutput() { return this.defines.COLOR !== void 0 } set colorOutput(i) { i ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0 } isColorOutputEnabled(i) { return this.colorOutput } setColorOutputEnabled(i) { this.colorOutput = i } get useRange() { return this.luminanceRange !== null } set useRange(i) { this.luminanceRange = null } get luminanceRange() { return this.uniforms.range.value } set luminanceRange(i) { i !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = i, this.needsUpdate = !0 } getLuminanceRange() { return this.luminanceRange } setLuminanceRange(i) { this.luminanceRange = i } }, P9 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`, B9 = class extends Vt { constructor(i = null) { super({ name: "MaskMaterial", uniforms: { maskTexture: new Ce(i), inputBuffer: new Ce(null), strength: new Ce(1) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: P9, vertexShader: yd }), this.toneMapped = !1, this.setColorChannel(O2.RED), this.setMaskFunction(L2.DISCARD) } set inputBuffer(i) { this.uniforms.inputBuffer.value = i } setInputBuffer(i) { this.uniforms.inputBuffer.value = i } set maskTexture(i) { this.uniforms.maskTexture.value = i, delete this.defines.MASK_PRECISION_HIGH, i.type !== ui && (this.defines.MASK_PRECISION_HIGH = "1"), this.needsUpdate = !0 } setMaskTexture(i) { this.maskTexture = i } set colorChannel(i) { this.defines.COLOR_CHANNEL = i.toFixed(0), this.needsUpdate = !0 } setColorChannel(i) { this.colorChannel = i } set maskFunction(i) { this.defines.MASK_FUNCTION = i.toFixed(0), this.needsUpdate = !0 } setMaskFunction(i) { this.maskFunction = i } get inverted() { return this.defines.INVERTED !== void 0 } set inverted(i) { this.inverted && !i ? delete this.defines.INVERTED : i && (this.defines.INVERTED = "1"), this.needsUpdate = !0 } isInverted() { return this.inverted } setInverted(i) { this.inverted = i } get strength() { return this.uniforms.strength.value } set strength(i) { this.uniforms.strength.value = i } getStrength() { return this.strength } setStrength(i) { this.strength = i } }, k9 = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`, D9 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}", O9 = class extends Vt { constructor(i = new W, e = new W) { super({ name: "SMAAWeightsMaterial", defines: { MAX_SEARCH_STEPS_INT: "16", MAX_SEARCH_STEPS_FLOAT: "16.0", MAX_SEARCH_STEPS_DIAG_INT: "8", MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0", CORNER_ROUNDING: "25", CORNER_ROUNDING_NORM: "0.25", AREATEX_MAX_DISTANCE: "16.0", AREATEX_MAX_DISTANCE_DIAG: "20.0", AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))", AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)", SEARCHTEX_SIZE: "vec2(66.0, 33.0)", SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)" }, uniforms: { inputBuffer: new Ce(null), searchTexture: new Ce(null), areaTexture: new Ce(null), resolution: new Ce(e), texelSize: new Ce(i) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: k9, vertexShader: D9 }), this.toneMapped = !1 } set inputBuffer(i) { this.uniforms.inputBuffer.value = i } setInputBuffer(i) { this.uniforms.inputBuffer.value = i } get searchTexture() { return this.uniforms.searchTexture.value } set searchTexture(i) { this.uniforms.searchTexture.value = i } get areaTexture() { return this.uniforms.areaTexture.value } set areaTexture(i) { this.uniforms.areaTexture.value = i } setLookupTextures(i, e) { this.searchTexture = i, this.areaTexture = e } get orthogonalSearchSteps() { return Number(this.defines.MAX_SEARCH_STEPS_INT) } set orthogonalSearchSteps(i) { const e = Math.min(Math.max(i, 0), 112); this.defines.MAX_SEARCH_STEPS_INT = e.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = e.toFixed("1"), this.needsUpdate = !0 } setOrthogonalSearchSteps(i) { this.orthogonalSearchSteps = i } get diagonalSearchSteps() { return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT) } set diagonalSearchSteps(i) { const e = Math.min(Math.max(i, 0), 20); this.defines.MAX_SEARCH_STEPS_DIAG_INT = e.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = e.toFixed("1"), this.needsUpdate = !0 } setDiagonalSearchSteps(i) { this.diagonalSearchSteps = i } get diagonalDetection() { return this.defines.DISABLE_DIAG_DETECTION === void 0 } set diagonalDetection(i) { i ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0 } isDiagonalDetectionEnabled() { return this.diagonalDetection } setDiagonalDetectionEnabled(i) { this.diagonalDetection = i } get cornerRounding() { return Number(this.defines.CORNER_ROUNDING) } set cornerRounding(i) { const e = Math.min(Math.max(i, 0), 100); this.defines.CORNER_ROUNDING = e.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (e / 100).toFixed("4"), this.needsUpdate = !0 } setCornerRounding(i) { this.cornerRounding = i } get cornerDetection() { return this.defines.DISABLE_CORNER_DETECTION === void 0 } set cornerDetection(i) { i ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0 } isCornerRoundingEnabled() { return this.cornerDetection } setCornerRoundingEnabled(i) { this.cornerDetection = i } setSize(i, e) { const t = this.uniforms; t.texelSize.value.set(1 / i, 1 / e), t.resolution.value.set(i, e) } }, L9 = `#include <common>
#include <packing>
#ifdef NORMAL_DEPTH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
float readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}
#else
uniform lowp sampler2D normalBuffer;
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
uniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);
#ifdef PERSPECTIVE_CAMERA
float linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);
#else
float linearSampleDepth=sampleDepth;
#endif
float proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){
#ifdef NORMAL_DEPTH
vec4 normalDepth=texture2D(normalDepthBuffer,vUv);
#else
vec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));
#endif
float ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);
#ifdef PERSPECTIVE_CAMERA
float linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);
#else
float linearDepth=depth;
#endif
if(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);
#ifdef LEGACY_INTENSITY
ao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);
#endif
}gl_FragColor.r=ao;}`, F9 = "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}", U9 = class extends Vt { constructor(i) { super({ name: "SSAOMaterial", defines: { SAMPLES_INT: "0", INV_SAMPLES_FLOAT: "0.0", SPIRAL_TURNS: "0.0", RADIUS: "1.0", RADIUS_SQ: "1.0", DISTANCE_SCALING: "1", DEPTH_PACKING: "0" }, uniforms: { depthBuffer: new Ce(null), normalBuffer: new Ce(null), normalDepthBuffer: new Ce(null), noiseTexture: new Ce(null), inverseProjectionMatrix: new Ce(new He), projectionMatrix: new Ce(new He), texelSize: new Ce(new W), cameraNearFar: new Ce(new W), distanceCutoff: new Ce(new W), proximityCutoff: new Ce(new W), noiseScale: new Ce(new W), minRadiusScale: new Ce(.33), intensity: new Ce(1), fade: new Ce(.01), bias: new Ce(0) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: L9, vertexShader: F9 }), this.toneMapped = !1, this.copyCameraSettings(i), this.resolution = new W, this.r = 1 } get near() { return this.uniforms.cameraNearFar.value.x } get far() { return this.uniforms.cameraNearFar.value.y } set normalDepthBuffer(i) { this.uniforms.normalDepthBuffer.value = i, i !== null ? this.defines.NORMAL_DEPTH = "1" : delete this.defines.NORMAL_DEPTH, this.needsUpdate = !0 } setNormalDepthBuffer(i) { this.normalDepthBuffer = i } set normalBuffer(i) { this.uniforms.normalBuffer.value = i } setNormalBuffer(i) { this.uniforms.normalBuffer.value = i } set depthBuffer(i) { this.uniforms.depthBuffer.value = i } set depthPacking(i) { this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0 } setDepthBuffer(i, e = Os) { this.depthBuffer = i, this.depthPacking = e } set noiseTexture(i) { this.uniforms.noiseTexture.value = i } setNoiseTexture(i) { this.uniforms.noiseTexture.value = i } get samples() { return Number(this.defines.SAMPLES_INT) } set samples(i) { this.defines.SAMPLES_INT = i.toFixed(0), this.defines.INV_SAMPLES_FLOAT = (1 / i).toFixed(9), this.needsUpdate = !0 } getSamples() { return this.samples } setSamples(i) { this.samples = i } get rings() { return Number(this.defines.SPIRAL_TURNS) } set rings(i) { this.defines.SPIRAL_TURNS = i.toFixed(1), this.needsUpdate = !0 } getRings() { return this.rings } setRings(i) { this.rings = i } get intensity() { return this.uniforms.intensity.value } set intensity(i) { this.uniforms.intensity.value = i, this.defines.LEGACY_INTENSITY === void 0 && (this.defines.LEGACY_INTENSITY = "1", this.needsUpdate = !0) } getIntensity() { return this.uniforms.intensity.value } setIntensity(i) { this.uniforms.intensity.value = i } get fade() { return this.uniforms.fade.value } set fade(i) { this.uniforms.fade.value = i } getFade() { return this.uniforms.fade.value } setFade(i) { this.uniforms.fade.value = i } get bias() { return this.uniforms.bias.value } set bias(i) { this.uniforms.bias.value = i } getBias() { return this.uniforms.bias.value } setBias(i) { this.uniforms.bias.value = i } get minRadiusScale() { return this.uniforms.minRadiusScale.value } set minRadiusScale(i) { this.uniforms.minRadiusScale.value = i } getMinRadiusScale() { return this.uniforms.minRadiusScale.value } setMinRadiusScale(i) { this.uniforms.minRadiusScale.value = i } updateRadius() { const i = this.r * this.resolution.height; this.defines.RADIUS = i.toFixed(11), this.defines.RADIUS_SQ = (i * i).toFixed(11), this.needsUpdate = !0 } get radius() { return this.r } set radius(i) { this.r = Math.min(Math.max(i, 1e-6), 1), this.updateRadius() } getRadius() { return this.radius } setRadius(i) { this.radius = i } get distanceScaling() { return !0 } set distanceScaling(i) { } isDistanceScalingEnabled() { return this.distanceScaling } setDistanceScalingEnabled(i) { this.distanceScaling = i } get distanceThreshold() { return this.uniforms.distanceCutoff.value.x } set distanceThreshold(i) { this.uniforms.distanceCutoff.value.set(Math.min(Math.max(i, 0), 1), Math.min(Math.max(i + this.distanceFalloff, 0), 1)) } get worldDistanceThreshold() { return -bd(this.distanceThreshold, this.near, this.far) } set worldDistanceThreshold(i) { this.distanceThreshold = Oh(-i, this.near, this.far) } get distanceFalloff() { return this.uniforms.distanceCutoff.value.y - this.distanceThreshold } set distanceFalloff(i) { this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + i, 0), 1) } get worldDistanceFalloff() { return -bd(this.distanceFalloff, this.near, this.far) } set worldDistanceFalloff(i) { this.distanceFalloff = Oh(-i, this.near, this.far) } setDistanceCutoff(i, e) { this.uniforms.distanceCutoff.value.set(Math.min(Math.max(i, 0), 1), Math.min(Math.max(i + e, 0), 1)) } get proximityThreshold() { return this.uniforms.proximityCutoff.value.x } set proximityThreshold(i) { this.uniforms.proximityCutoff.value.set(Math.min(Math.max(i, 0), 1), Math.min(Math.max(i + this.proximityFalloff, 0), 1)) } get worldProximityThreshold() { return -bd(this.proximityThreshold, this.near, this.far) } set worldProximityThreshold(i) { this.proximityThreshold = Oh(-i, this.near, this.far) } get proximityFalloff() { return this.uniforms.proximityCutoff.value.y - this.proximityThreshold } set proximityFalloff(i) { this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + i, 0), 1) } get worldProximityFalloff() { return -bd(this.proximityFalloff, this.near, this.far) } set worldProximityFalloff(i) { this.proximityFalloff = Oh(-i, this.near, this.far) } setProximityCutoff(i, e) { this.uniforms.proximityCutoff.value.set(Math.min(Math.max(i, 0), 1), Math.min(Math.max(i + e, 0), 1)) } setTexelSize(i, e) { this.uniforms.texelSize.value.set(i, e) } adoptCameraSettings(i) { this.copyCameraSettings(i) } copyCameraSettings(i) { i && (this.uniforms.cameraNearFar.value.set(i.near, i.far), this.uniforms.projectionMatrix.value.copy(i.projectionMatrix), this.uniforms.inverseProjectionMatrix.value.copy(i.projectionMatrix).invert(), i instanceof Xt ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } setSize(i, e) { const t = this.uniforms, s = t.noiseTexture.value; s !== null && t.noiseScale.value.set(i / s.image.width, e / s.image.height), t.texelSize.value.set(1 / i, 1 / e), this.resolution.set(i, e), this.updateRadius() } }, N9 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;
#include <encodings_fragment>
}`, z9 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}", j9 = class extends F2 { constructor({ kernelSize: i = Ya.MEDIUM, offset: e = 0, rotation: t = 0, focusArea: s = .4, feather: r = .3 } = {}) { super(), this.fragmentShader = N9, this.vertexShader = z9, this.kernelSize = i, this.uniforms.aspect = new Ce(1), this.uniforms.rotation = new Ce(new W), this.uniforms.maskParams = new Ce(new st), this._offset = e, this._focusArea = s, this._feather = r, this.rotation = t, this.updateParams() } updateParams() { const i = this.uniforms.maskParams.value, e = Math.max(this.focusArea, 0), t = Math.max(e - this.feather, 0); i.set(this.offset - e, this.offset - t, this.offset + e, this.offset + t) } get rotation() { return Math.acos(this.uniforms.rotation.value.x) } set rotation(i) { this.uniforms.rotation.value.set(Math.cos(i), Math.sin(i)) } get offset() { return this._offset } set offset(i) { this._offset = i, this.updateParams() } get focusArea() { return this._focusArea } set focusArea(i) { this._focusArea = i, this.updateParams() } get feather() { return this._feather } set feather(i) { this._feather = i, this.updateParams() } setSize(i, e) { super.setSize(i, e), this.uniforms.aspect.value = i / e } }, Q9 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <encodings_fragment>
}`, G9 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}", H9 = class extends Vt { constructor() { super({ name: "UpsamplingMaterial", uniforms: { inputBuffer: new Ce(null), supportBuffer: new Ce(null), texelSize: new Ce(new W), radius: new Ce(.85) }, blending: Ri, depthWrite: !1, depthTest: !1, fragmentShader: Q9, vertexShader: G9 }), this.toneMapped = !1 } set inputBuffer(i) { this.uniforms.inputBuffer.value = i } set supportBuffer(i) { this.uniforms.supportBuffer.value = i } get radius() { return this.uniforms.radius.value } set radius(i) { this.uniforms.radius.value = i } setSize(i, e) { this.uniforms.texelSize.value.set(1 / i, 1 / e) } }, V9 = new gh, sc = null; function W9() { if (sc === null) { const i = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), e = new Float32Array([0, 0, 2, 0, 0, 2]); sc = new yt, sc.setAttribute !== void 0 ? (sc.setAttribute("position", new nt(i, 3)), sc.setAttribute("uv", new nt(e, 2))) : (sc.addAttribute("position", new nt(i, 3)), sc.addAttribute("uv", new nt(e, 2))) } return sc } var nr = class { constructor(i = "Pass", e = new Cn, t = V9) { this.name = i, this.renderer = null, this.scene = e, this.camera = t, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0 } get renderToScreen() { return !this.rtt } set renderToScreen(i) { if (this.rtt === i) { const e = this.fullscreenMaterial; e !== null && (e.needsUpdate = !0), this.rtt = !i } } set mainScene(i) { } set mainCamera(i) { } setRenderer(i) { this.renderer = i } isEnabled() { return this.enabled } setEnabled(i) { this.enabled = i } get fullscreenMaterial() { return this.screen !== null ? this.screen.material : null } set fullscreenMaterial(i) { let e = this.screen; e !== null ? e.material = i : (e = new ye(W9(), i), e.frustumCulled = !1, this.scene === null && (this.scene = new Cn), this.scene.add(e), this.screen = e) } getFullscreenMaterial() { return this.fullscreenMaterial } setFullscreenMaterial(i) { this.fullscreenMaterial = i } getDepthTexture() { return null } setDepthTexture(i, e = Os) { } render(i, e, t, s, r) { throw new Error("Render method not implemented!") } setSize(i, e) { } initialize(i, e, t) { } dispose() { for (const i of Object.keys(this)) { const e = this[i]; (e instanceof ri || e instanceof Tt || e instanceof Nt || e instanceof nr) && this[i].dispose() } } }, q9 = class extends nr { constructor(i, e = !0) { super("CopyPass"), this.fullscreenMaterial = new U2, this.needsSwap = !1, this.renderTarget = i, i === void 0 && (this.renderTarget = new ri(1, 1, { minFilter: Qt, magFilter: Qt, stencilBuffer: !1, depthBuffer: !1 }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = e } get resize() { return this.autoResize } set resize(i) { this.autoResize = i } get texture() { return this.renderTarget.texture } getTexture() { return this.renderTarget.texture } setAutoResizeEnabled(i) { this.autoResize = i } render(i, e, t, s, r) { this.fullscreenMaterial.inputBuffer = e.texture, i.setRenderTarget(this.renderToScreen ? null : this.renderTarget), i.render(this.scene, this.camera) } setSize(i, e) { this.autoResize && this.renderTarget.setSize(i, e) } initialize(i, e, t) { t !== void 0 && (this.renderTarget.texture.type = t, t !== ui ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : i.outputEncoding === Xe && (this.renderTarget.texture.encoding = Xe)) } }, X9 = class extends nr { constructor() { super("ClearMaskPass", null, null), this.needsSwap = !1 } render(i, e, t, s, r) { const n = i.state.buffers.stencil; n.setLocked(!1), n.setTest(!1) } }, N2 = new xe, ty = class extends nr { constructor(i = !0, e = !0, t = !1) { super("ClearPass", null, null), this.needsSwap = !1, this.color = i, this.depth = e, this.stencil = t, this.overrideClearColor = null, this.overrideClearAlpha = -1 } setClearFlags(i, e, t) { this.color = i, this.depth = e, this.stencil = t } getOverrideClearColor() { return this.overrideClearColor } setOverrideClearColor(i) { this.overrideClearColor = i } getOverrideClearAlpha() { return this.overrideClearAlpha } setOverrideClearAlpha(i) { this.overrideClearAlpha = i } render(i, e, t, s, r) { const n = this.overrideClearColor, o = this.overrideClearAlpha, a = i.getClearAlpha(), l = n !== null, c = o >= 0; l ? (i.getClearColor(N2), i.setClearColor(n, c ? o : a)) : c && i.setClearAlpha(o), i.setRenderTarget(this.renderToScreen ? null : e), i.clear(this.color, this.depth, this.stencil), l ? i.setClearColor(N2, a) : c && i.setClearAlpha(a) } }, rc = -1, ai = class extends ms { constructor(i, e = rc, t = rc, s = 1) { super(), this.resizable = i, this.baseSize = new W(1, 1), this.preferredSize = new W(e, t), this.target = this.preferredSize, this.s = s, this.effectiveSize = new W, this.addEventListener("change", () => this.updateEffectiveSize()), this.updateEffectiveSize() } updateEffectiveSize() { const i = this.baseSize, e = this.preferredSize, t = this.effectiveSize, s = this.scale; e.width !== rc ? t.width = e.width : e.height !== rc ? t.width = Math.round(e.height * (i.width / Math.max(i.height, 1))) : t.width = Math.round(i.width * s), e.height !== rc ? t.height = e.height : e.width !== rc ? t.height = Math.round(e.width / Math.max(i.width / Math.max(i.height, 1), 1)) : t.height = Math.round(i.height * s) } get width() { return this.effectiveSize.width } set width(i) { this.preferredWidth = i } get height() { return this.effectiveSize.height } set height(i) { this.preferredHeight = i } getWidth() { return this.width } getHeight() { return this.height } get scale() { return this.s } set scale(i) { this.s !== i && (this.s = i, this.preferredSize.setScalar(rc), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getScale() { return this.scale } setScale(i) { this.scale = i } get baseWidth() { return this.baseSize.width } set baseWidth(i) { this.baseSize.width !== i && (this.baseSize.width = i, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getBaseWidth() { return this.baseWidth } setBaseWidth(i) { this.baseWidth = i } get baseHeight() { return this.baseSize.height } set baseHeight(i) { this.baseSize.height !== i && (this.baseSize.height = i, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getBaseHeight() { return this.baseHeight } setBaseHeight(i) { this.baseHeight = i } setBaseSize(i, e) { (this.baseSize.width !== i || this.baseSize.height !== e) && (this.baseSize.set(i, e), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } get preferredWidth() { return this.preferredSize.width } set preferredWidth(i) { this.preferredSize.width !== i && (this.preferredSize.width = i, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getPreferredWidth() { return this.preferredWidth } setPreferredWidth(i) { this.preferredWidth = i } get preferredHeight() { return this.preferredSize.height } set preferredHeight(i) { this.preferredSize.height !== i && (this.preferredSize.height = i, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getPreferredHeight() { return this.preferredHeight } setPreferredHeight(i) { this.preferredHeight = i } setPreferredSize(i, e) { (this.preferredSize.width !== i || this.preferredSize.height !== e) && (this.preferredSize.set(i, e), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } copy(i) { this.s = i.scale, this.baseSize.set(i.baseWidth, i.baseHeight), this.preferredSize.set(i.preferredWidth, i.preferredHeight), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height) } static get AUTO_SIZE() { return rc } }, eC = !1, z2 = class { constructor(i = null) { this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(i), this.meshCount = 0, this.replaceMaterial = e => { if (e.isMesh) { let t; if (e.material.flatShading) switch (e.material.side) { case yi: t = this.materialsFlatShadedDoubleSide; break; case fs: t = this.materialsFlatShadedBackSide; break; default: t = this.materialsFlatShaded; break } else switch (e.material.side) { case yi: t = this.materialsDoubleSide; break; case fs: t = this.materialsBackSide; break; default: t = this.materials; break }this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount } } } cloneMaterial(i) { if (!(i instanceof Vt)) return i.clone(); const e = i.uniforms, t = new Map; for (const r in e) { const n = e[r].value; n.isRenderTargetTexture && (e[r].value = null, t.set(r, n)) } const s = i.clone(); for (const r of t) e[r[0]].value = r[1], s.uniforms[r[0]].value = r[1]; return s } setMaterial(i) { if (this.disposeMaterials(), this.material = i, i !== null) { const e = this.materials = [this.cloneMaterial(i), this.cloneMaterial(i), this.cloneMaterial(i)]; for (const t of e) t.uniforms = Object.assign({}, i.uniforms), t.side = pr; e[2].skinning = !0, this.materialsBackSide = e.map(t => { const s = this.cloneMaterial(t); return s.uniforms = Object.assign({}, i.uniforms), s.side = fs, s }), this.materialsDoubleSide = e.map(t => { const s = this.cloneMaterial(t); return s.uniforms = Object.assign({}, i.uniforms), s.side = yi, s }), this.materialsFlatShaded = e.map(t => { const s = this.cloneMaterial(t); return s.uniforms = Object.assign({}, i.uniforms), s.flatShading = !0, s }), this.materialsFlatShadedBackSide = e.map(t => { const s = this.cloneMaterial(t); return s.uniforms = Object.assign({}, i.uniforms), s.flatShading = !0, s.side = fs, s }), this.materialsFlatShadedDoubleSide = e.map(t => { const s = this.cloneMaterial(t); return s.uniforms = Object.assign({}, i.uniforms), s.flatShading = !0, s.side = yi, s }) } } render(i, e, t) { const s = i.shadowMap.enabled; if (i.shadowMap.enabled = !1, eC) { const r = this.originalMaterials; this.meshCount = 0, e.traverse(this.replaceMaterial), i.render(e, t); for (const n of r) n[0].material = n[1]; this.meshCount !== r.size && r.clear() } else { const r = e.overrideMaterial; e.overrideMaterial = this.material, i.render(e, t), e.overrideMaterial = r } i.shadowMap.enabled = s } disposeMaterials() { if (this.material !== null) { const i = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide); for (const e of i) e.dispose() } } dispose() { this.originalMaterials.clear(), this.disposeMaterials() } static get workaroundEnabled() { return eC } static set workaroundEnabled(i) { eC = i } }, iy = class extends nr { constructor(i, e, t = null) { super("RenderPass", i, e), this.needsSwap = !1, this.clearPass = new ty, this.overrideMaterialManager = t === null ? null : new z2(t), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null } set mainScene(i) { this.scene = i } set mainCamera(i) { this.camera = i } get renderToScreen() { return super.renderToScreen } set renderToScreen(i) { super.renderToScreen = i, this.clearPass.renderToScreen = i } get overrideMaterial() { const i = this.overrideMaterialManager; return i !== null ? i.material : null } set overrideMaterial(i) { const e = this.overrideMaterialManager; i !== null ? e !== null ? e.setMaterial(i) : this.overrideMaterialManager = new z2(i) : e !== null && (e.dispose(), this.overrideMaterialManager = null) } getOverrideMaterial() { return this.overrideMaterial } setOverrideMaterial(i) { this.overrideMaterial = i } get clear() { return this.clearPass.enabled } set clear(i) { this.clearPass.enabled = i } getSelection() { return this.selection } setSelection(i) { this.selection = i } isBackgroundDisabled() { return this.ignoreBackground } setBackgroundDisabled(i) { this.ignoreBackground = i } isShadowMapDisabled() { return this.skipShadowMapUpdate } setShadowMapDisabled(i) { this.skipShadowMapUpdate = i } getClearPass() { return this.clearPass } render(i, e, t, s, r) { const n = this.scene, o = this.camera, a = this.selection, l = o.layers.mask, c = n.background, h = i.shadowMap.autoUpdate, d = this.renderToScreen ? null : e; a !== null && o.layers.set(a.getLayer()), this.skipShadowMapUpdate && (i.shadowMap.autoUpdate = !1), (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (n.background = null), this.clearPass.enabled && this.clearPass.render(i, e), i.setRenderTarget(d), this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(i, n, o) : i.render(n, o), o.layers.mask = l, n.background = c, i.shadowMap.autoUpdate = h } }, Y9 = class extends nr { constructor(i, e, { renderTarget: t, resolutionScale: s = 1, width: r = ai.AUTO_SIZE, height: n = ai.AUTO_SIZE, resolutionX: o = r, resolutionY: a = n } = {}) { super("DepthPass"), this.needsSwap = !1, this.renderPass = new iy(i, e, new MA({ depthPacking: $v })); const l = this.renderPass; l.skipShadowMapUpdate = !0, l.ignoreBackground = !0; const c = l.getClearPass(); c.overrideClearColor = new xe(16777215), c.overrideClearAlpha = 1, this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new ri(1, 1, { minFilter: Zt, magFilter: Zt }), this.renderTarget.texture.name = "DepthPass.Target"); const h = this.resolution = new ai(this, o, a, s); h.addEventListener("change", d => this.setSize(h.baseWidth, h.baseHeight)) } set mainScene(i) { this.renderPass.mainScene = i } set mainCamera(i) { this.renderPass.mainCamera = i } get texture() { return this.renderTarget.texture } getTexture() { return this.renderTarget.texture } getResolution() { return this.resolution } getResolutionScale() { return this.resolution.scale } setResolutionScale(i) { this.resolution.scale = i } render(i, e, t, s, r) { const n = this.renderToScreen ? null : this.renderTarget; this.renderPass.render(i, n) } setSize(i, e) { const t = this.resolution; t.setBaseSize(i, e), this.renderTarget.setSize(t.width, t.height) } }, tC = class extends nr { constructor({ normalBuffer: i = null, resolutionScale: e = .5, width: t = ai.AUTO_SIZE, height: s = ai.AUTO_SIZE, resolutionX: r = t, resolutionY: n = s } = {}) { super("DepthDownsamplingPass"); const o = new v9; o.normalBuffer = i, this.fullscreenMaterial = o, this.needsDepthTexture = !0, this.needsSwap = !1, this.renderTarget = new ri(1, 1, { minFilter: Zt, magFilter: Zt, depthBuffer: !1, type: $i }), this.renderTarget.texture.name = "DepthDownsamplingPass.Target", this.renderTarget.texture.generateMipmaps = !1; const a = this.resolution = new ai(this, r, n, e); a.addEventListener("change", l => this.setSize(a.baseWidth, a.baseHeight)) } get texture() { return this.renderTarget.texture } getTexture() { return this.renderTarget.texture } getResolution() { return this.resolution } setDepthTexture(i, e = Os) { this.fullscreenMaterial.depthBuffer = i, this.fullscreenMaterial.depthPacking = e } render(i, e, t, s, r) { i.setRenderTarget(this.renderToScreen ? null : this.renderTarget), i.render(this.scene, this.camera) } setSize(i, e) { const t = this.resolution; t.setBaseSize(i, e), this.renderTarget.setSize(t.width, t.height), this.fullscreenMaterial.setSize(i, e) } initialize(i, e, t) { const s = i.getContext(); if (!(s.getExtension("EXT_color_buffer_float") || s.getExtension("EXT_color_buffer_half_float"))) throw new Error("Rendering to float texture is not supported.") } }; function j2(i, e, t) { for (const s of e) { const r = "$1" + i + s.charAt(0).toUpperCase() + s.slice(1), n = new RegExp("([^\\.])(\\b" + s + "\\b)", "g"); for (const o of t.entries()) o[1] !== null && t.set(o[0], o[1].replace(n, r)) } } function J9(i, e, t) {
  var s, r, n, o, a; let l = e.getFragmentShader(), c = e.getVertexShader(); const h = l !== void 0 && /mainImage/.test(l), d = l !== void 0 && /mainUv/.test(l); if (t.attributes |= e.getAttributes(), l === void 0) throw new Error(`Missing fragment shader (${e.name})`); if (d && t.attributes & nn.CONVOLUTION) throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`); if (!h && !d) throw new Error(`Could not find mainImage or mainUv function (${e.name})`); {
    const p = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g, f = t.shaderParts; let g = (s = f.get(si.FRAGMENT_HEAD)) != null ? s : "", m = (r = f.get(si.FRAGMENT_MAIN_UV)) != null ? r : "", v = (n = f.get(si.FRAGMENT_MAIN_IMAGE)) != null ? n : "", A = (o = f.get(si.VERTEX_HEAD)) != null ? o : "", b = (a = f.get(si.VERTEX_MAIN_SUPPORT)) != null ? a : ""; const y = new Set, _ = new Set; if (d && (m += `	${i}MainUv(UV);
`, t.uvTransformation = !0), c !== null && /mainSupport/.test(c)) {
      const P = /mainSupport *\([\w\s]*?uv\s*?\)/.test(c); b += `	${i}MainSupport(`, b += P ? `vUv);
`: `);
`; for (const C of c.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g)) for (const R of C[1].split(/\s*,\s*/)) t.varyings.add(R), y.add(R), _.add(R); for (const C of c.matchAll(p)) _.add(C[1])
    } for (const P of l.matchAll(p)) _.add(P[1]); for (const P of e.defines.keys()) _.add(P.replace(/\([\w\s,]*\)/g, "")); for (const P of e.uniforms.keys()) _.add(P); _.delete("while"), _.delete("for"), _.delete("if"), e.uniforms.forEach((P, C) => t.uniforms.set(i + C.charAt(0).toUpperCase() + C.slice(1), P)), e.defines.forEach((P, C) => t.defines.set(i + C.charAt(0).toUpperCase() + C.slice(1), P)); const w = new Map([["fragment", l], ["vertex", c]]); j2(i, _, t.defines), j2(i, _, w), l = w.get("fragment"), c = w.get("vertex"); const E = e.blendMode; if (t.blendModes.set(E.blendFunction, E), h) {
      e.inputColorSpace !== null && e.inputColorSpace !== t.colorSpace && (v += e.inputColorSpace === Xe ? `color0 = LinearTosRGB(color0);
	`: `color0 = sRGBToLinear(color0);
	`), e.outputColorSpace !== null ? t.colorSpace = e.outputColorSpace : e.inputColorSpace !== null && (t.colorSpace = e.inputColorSpace); const P = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/; v += `${i}MainImage(color0, UV, `, t.attributes & nn.DEPTH && P.test(l) && (v += "depth, ", t.readDepth = !0), v += `color1);
	`; const C = i + "BlendOpacity"; t.uniforms.set(C, E.opacity), v += `color0 = blend${E.blendFunction}(color0, color1, ${C});

	`, g += `uniform float ${C};

`} if (g += l + `
`, c !== null && (A += c + `
`), f.set(si.FRAGMENT_HEAD, g), f.set(si.FRAGMENT_MAIN_UV, m), f.set(si.FRAGMENT_MAIN_IMAGE, v), f.set(si.VERTEX_HEAD, A), f.set(si.VERTEX_MAIN_SUPPORT, b), e.extensions !== null) for (const P of e.extensions) t.extensions.add(P)
  }
} var Q2 = class extends nr {
  constructor(i, ...e) { super("EffectPass"), this.fullscreenMaterial = new I9(null, null, null, i), this.listener = t => this.handleEvent(t), this.effects = [], this.setEffects(e), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1 } set mainScene(i) { for (const e of this.effects) e.mainScene = i } set mainCamera(i) { this.fullscreenMaterial.copyCameraSettings(i); for (const e of this.effects) e.mainCamera = i } get encodeOutput() { return this.fullscreenMaterial.encodeOutput } set encodeOutput(i) { this.fullscreenMaterial.encodeOutput = i } get dithering() { return this.fullscreenMaterial.dithering } set dithering(i) { const e = this.fullscreenMaterial; e.dithering = i, e.needsUpdate = !0 } setEffects(i) { for (const e of this.effects) e.removeEventListener("change", this.listener); this.effects = i.sort((e, t) => t.attributes - e.attributes); for (const e of this.effects) e.addEventListener("change", this.listener) } updateMaterial() {
    const i = new sW; let e = 0; for (const o of this.effects) if (o.blendMode.blendFunction === kt.DST) i.attributes |= o.getAttributes() & nn.DEPTH; else { if (i.attributes & o.getAttributes() & nn.CONVOLUTION) throw new Error(`Convolution effects cannot be merged (${o.name})`); J9("e" + e++, o, i) } let t = i.shaderParts.get(si.FRAGMENT_HEAD), s = i.shaderParts.get(si.FRAGMENT_MAIN_IMAGE), r = i.shaderParts.get(si.FRAGMENT_MAIN_UV); const n = /\bblend\b/g; for (const o of i.blendModes.values()) t += o.getShaderCode().replace(n, `blend${o.blendFunction}`) + `
`; i.attributes & nn.DEPTH ? (i.readDepth && (s = `float depth = readDepth(UV);

	`+ s), this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1, i.colorSpace === Xe && (s += `color0 = sRGBToLinear(color0);
	`), i.uvTransformation ? (r = `vec2 transformedUv = vUv;
`+ r, i.defines.set("UV", "transformedUv")) : i.defines.set("UV", "vUv"), i.shaderParts.set(si.FRAGMENT_HEAD, t), i.shaderParts.set(si.FRAGMENT_MAIN_IMAGE, s), i.shaderParts.set(si.FRAGMENT_MAIN_UV, r), i.shaderParts.forEach((o, a, l) => l.set(a, o?.trim().replace(/^#/, `
#`))), this.skipRendering = e === 0, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(i)
  } recompile() { this.updateMaterial() } getDepthTexture() { return this.fullscreenMaterial.depthBuffer } setDepthTexture(i, e = Os) { this.fullscreenMaterial.depthBuffer = i, this.fullscreenMaterial.depthPacking = e; for (const t of this.effects) t.setDepthTexture(i, e) } render(i, e, t, s, r) { for (const n of this.effects) n.update(i, e, s); if (!this.skipRendering || this.renderToScreen) { const n = this.fullscreenMaterial; n.inputBuffer = e.texture, n.time += s * this.timeScale, i.setRenderTarget(this.renderToScreen ? null : t), i.render(this.scene, this.camera) } } setSize(i, e) { this.fullscreenMaterial.setSize(i, e); for (const t of this.effects) t.setSize(i, e) } initialize(i, e, t) { this.renderer = i; for (const s of this.effects) s.initialize(i, e, t); this.updateMaterial(), t !== void 0 && t !== ui && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } dispose() { super.dispose(); for (const i of this.effects) i.removeEventListener("change", this.listener), i.dispose() } handleEvent(i) { switch (i.type) { case "change": this.recompile(); break } }
}, iC = class extends nr { constructor({ kernelSize: i = Ya.MEDIUM, resolutionScale: e = .5, width: t = ai.AUTO_SIZE, height: s = ai.AUTO_SIZE, resolutionX: r = t, resolutionY: n = s } = {}) { super("KawaseBlurPass"), this.renderTargetA = new ri(1, 1, { depthBuffer: !1 }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B"; const o = this.resolution = new ai(this, r, n, e); o.addEventListener("change", a => this.setSize(o.baseWidth, o.baseHeight)), this._blurMaterial = new F2, this._blurMaterial.kernelSize = i, this.copyMaterial = new U2 } getResolution() { return this.resolution } get blurMaterial() { return this._blurMaterial } set blurMaterial(i) { this._blurMaterial = i } get dithering() { return this.copyMaterial.dithering } set dithering(i) { this.copyMaterial.dithering = i } get kernelSize() { return this.blurMaterial.kernelSize } set kernelSize(i) { this.blurMaterial.kernelSize = i } get width() { return this.resolution.width } set width(i) { this.resolution.preferredWidth = i } get height() { return this.resolution.height } set height(i) { this.resolution.preferredHeight = i } get scale() { return this.blurMaterial.scale } set scale(i) { this.blurMaterial.scale = i } getScale() { return this.blurMaterial.scale } setScale(i) { this.blurMaterial.scale = i } getKernelSize() { return this.kernelSize } setKernelSize(i) { this.kernelSize = i } getResolutionScale() { return this.resolution.scale } setResolutionScale(i) { this.resolution.scale = i } render(i, e, t, s, r) { const n = this.scene, o = this.camera, a = this.renderTargetA, l = this.renderTargetB, c = this.blurMaterial, h = c.kernelSequence; let d = e; this.fullscreenMaterial = c; for (let p = 0, f = h.length; p < f; ++p) { const g = p & 1 ? l : a; c.kernel = h[p], c.inputBuffer = d.texture, i.setRenderTarget(g), i.render(n, o), d = g } this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = d.texture, i.setRenderTarget(this.renderToScreen ? null : t), i.render(n, o) } setSize(i, e) { const t = this.resolution; t.setBaseSize(i, e); const s = t.width, r = t.height; this.renderTargetA.setSize(s, r), this.renderTargetB.setSize(s, r), this.blurMaterial.setSize(i, e) } initialize(i, e, t) { t !== void 0 && (this.renderTargetA.texture.type = t, this.renderTargetB.texture.type = t, t !== ui ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : i.outputEncoding === Xe && (this.renderTargetA.texture.encoding = Xe, this.renderTargetB.texture.encoding = Xe)) } static get AUTO_SIZE() { return ai.AUTO_SIZE } }, K9 = class extends nr { constructor({ renderTarget: i, luminanceRange: e, colorOutput: t, resolutionScale: s = 1, width: r = ai.AUTO_SIZE, height: n = ai.AUTO_SIZE, resolutionX: o = r, resolutionY: a = n } = {}) { super("LuminancePass"), this.fullscreenMaterial = new R9(t, e), this.needsSwap = !1, this.renderTarget = i, this.renderTarget === void 0 && (this.renderTarget = new ri(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "LuminancePass.Target"); const l = this.resolution = new ai(this, o, a, s); l.addEventListener("change", c => this.setSize(l.baseWidth, l.baseHeight)) } get texture() { return this.renderTarget.texture } getTexture() { return this.renderTarget.texture } getResolution() { return this.resolution } render(i, e, t, s, r) { const n = this.fullscreenMaterial; n.inputBuffer = e.texture, i.setRenderTarget(this.renderToScreen ? null : this.renderTarget), i.render(this.scene, this.camera) } setSize(i, e) { const t = this.resolution; t.setBaseSize(i, e), this.renderTarget.setSize(t.width, t.height) } initialize(i, e, t) { t !== void 0 && t !== ui && (this.renderTarget.texture.type = t, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } }, Z9 = class extends nr { constructor(i, e) { super("MaskPass", i, e), this.needsSwap = !1, this.clearPass = new ty(!1, !1, !0), this.inverse = !1 } set mainScene(i) { this.scene = i } set mainCamera(i) { this.camera = i } get inverted() { return this.inverse } set inverted(i) { this.inverse = i } get clear() { return this.clearPass.enabled } set clear(i) { this.clearPass.enabled = i } getClearPass() { return this.clearPass } isInverted() { return this.inverted } setInverted(i) { this.inverted = i } render(i, e, t, s, r) { const n = i.getContext(), o = i.state.buffers, a = this.scene, l = this.camera, c = this.clearPass, h = this.inverted ? 0 : 1, d = 1 - h; o.color.setMask(!1), o.depth.setMask(!1), o.color.setLocked(!0), o.depth.setLocked(!0), o.stencil.setTest(!0), o.stencil.setOp(n.REPLACE, n.REPLACE, n.REPLACE), o.stencil.setFunc(n.ALWAYS, h, 4294967295), o.stencil.setClear(d), o.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? c.render(i, null) : (c.render(i, e), c.render(i, t))), this.renderToScreen ? (i.setRenderTarget(null), i.render(a, l)) : (i.setRenderTarget(e), i.render(a, l), i.setRenderTarget(t), i.render(a, l)), o.color.setLocked(!1), o.depth.setLocked(!1), o.stencil.setLocked(!1), o.stencil.setFunc(n.EQUAL, 1, 4294967295), o.stencil.setOp(n.KEEP, n.KEEP, n.KEEP), o.stencil.setLocked(!0) } }, $9 = class extends nr { constructor() { super("MipmapBlurPass"), this.needsSwap = !1, this.renderTarget = new ri(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "Upsampling.Mipmap0", this.downsamplingMipmaps = [], this.upsamplingMipmaps = [], this.downsamplingMaterial = new x9, this.upsamplingMaterial = new H9, this.resolution = new W } get texture() { return this.renderTarget.texture } get levels() { return this.downsamplingMipmaps.length } set levels(i) { if (this.levels !== i) { const e = this.renderTarget; this.dispose(), this.downsamplingMipmaps = [], this.upsamplingMipmaps = []; for (let t = 0; t < i; ++t) { const s = e.clone(); s.texture.name = "Downsampling.Mipmap" + t, this.downsamplingMipmaps.push(s) } this.upsamplingMipmaps.push(e); for (let t = 1, s = i - 1; t < s; ++t) { const r = e.clone(); r.texture.name = "Upsampling.Mipmap" + t, this.upsamplingMipmaps.push(r) } this.setSize(this.resolution.x, this.resolution.y) } } get radius() { return this.upsamplingMaterial.radius } set radius(i) { this.upsamplingMaterial.radius = i } render(i, e, t, s, r) { const { scene: n, camera: o } = this, { downsamplingMaterial: a, upsamplingMaterial: l } = this, { downsamplingMipmaps: c, upsamplingMipmaps: h } = this; let d = e; this.fullscreenMaterial = a; for (let p = 0, f = c.length; p < f; ++p) { const g = c[p]; a.setSize(d.width, d.height), a.inputBuffer = d.texture, i.setRenderTarget(g), i.render(n, o), d = g } this.fullscreenMaterial = l; for (let p = h.length - 1; p >= 0; --p) { const f = h[p]; l.setSize(d.width, d.height), l.inputBuffer = d.texture, l.supportBuffer = c[p].texture, i.setRenderTarget(f), i.render(n, o), d = f } } setSize(i, e) { const t = this.resolution; t.set(i, e); let s = t.width, r = t.height; for (let n = 0, o = this.downsamplingMipmaps.length; n < o; ++n)s = Math.round(s * .5), r = Math.round(r * .5), this.downsamplingMipmaps[n].setSize(s, r), n < this.upsamplingMipmaps.length && this.upsamplingMipmaps[n].setSize(s, r) } initialize(i, e, t) { if (t !== void 0) { const s = this.downsamplingMipmaps.concat(this.upsamplingMipmaps); for (const r of s) r.texture.type = t; if (t !== ui) this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"; else if (i.outputEncoding === Xe) for (const r of s) r.texture.encoding = Xe } } dispose() { super.dispose(); for (const i of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) i.dispose() } }, G2 = class extends nr { constructor(i, e, { renderTarget: t, resolutionScale: s = 1, width: r = ai.AUTO_SIZE, height: n = ai.AUTO_SIZE, resolutionX: o = r, resolutionY: a = n } = {}) { super("NormalPass"), this.needsSwap = !1, this.renderPass = new iy(i, e, new zw); const l = this.renderPass; l.ignoreBackground = !0, l.skipShadowMapUpdate = !0; const c = l.getClearPass(); c.overrideClearColor = new xe(7829503), c.overrideClearAlpha = 1, this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new ri(1, 1, { minFilter: Zt, magFilter: Zt }), this.renderTarget.texture.name = "NormalPass.Target"); const h = this.resolution = new ai(this, o, a, s); h.addEventListener("change", d => this.setSize(h.baseWidth, h.baseHeight)) } set mainScene(i) { this.renderPass.mainScene = i } set mainCamera(i) { this.renderPass.mainCamera = i } get texture() { return this.renderTarget.texture } getTexture() { return this.renderTarget.texture } getResolution() { return this.resolution } getResolutionScale() { return this.resolution.scale } setResolutionScale(i) { this.resolution.scale = i } render(i, e, t, s, r) { const n = this.renderToScreen ? null : this.renderTarget; this.renderPass.render(i, n, n) } setSize(i, e) { const t = this.resolution; t.setBaseSize(i, e), this.renderTarget.setSize(t.width, t.height) } }, zo = class extends nr { constructor(i, e = "inputBuffer") { super("ShaderPass"), this.fullscreenMaterial = i, this.input = e } setInput(i) { this.input = i } render(i, e, t, s, r) { const n = this.fullscreenMaterial.uniforms; e !== null && n !== void 0 && n[this.input] !== void 0 && (n[this.input].value = e.texture), i.setRenderTarget(this.renderToScreen ? null : t), i.render(this.scene, this.camera) } initialize(i, e, t) { t !== void 0 && t !== ui && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } }, eW = class extends iC { constructor({ offset: i = 0, rotation: e = 0, focusArea: t = .4, feather: s = .3, kernelSize: r = Ya.MEDIUM, resolutionScale: n = .5, resolutionX: o = ai.AUTO_SIZE, resolutionY: a = ai.AUTO_SIZE } = {}) { super({ kernelSize: r, resolutionScale: n, resolutionX: o, resolutionY: a }), this.blurMaterial = new j9({ kernelSize: r, offset: i, rotation: e, focusArea: t, feather: s }) } }, sC = 1 / 1e3, tW = 1e3, iW = class { constructor() { this.startTime = performance.now(), this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = !1, this._autoReset = !1 } get autoReset() { return this._autoReset } set autoReset(i) { typeof document < "u" && document.hidden !== void 0 && (i ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = i) } get delta() { return this._delta * sC } get fixedDelta() { return this._fixedDelta * sC } set fixedDelta(i) { this._fixedDelta = i * tW } get elapsed() { return this._elapsed * sC } update(i) { this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = (i !== void 0 ? i : performance.now()) - this.startTime, this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta } reset() { this._delta = 0, this._elapsed = 0, this.currentTime = performance.now() - this.startTime } handleEvent(i) { document.hidden || (this.currentTime = performance.now() - this.startTime) } dispose() { this.autoReset = !1 } }, rC = class { constructor(i = null, { depthBuffer: e = !0, stencilBuffer: t = !1, multisampling: s = 0, frameBufferType: r } = {}) { this.renderer = null, this.inputBuffer = this.createBuffer(e, t, r, s), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new q9, this.depthTexture = null, this.passes = [], this.timer = new iW, this.autoRenderToScreen = !0, this.setRenderer(i) } get multisampling() { return this.inputBuffer.samples || 0 } set multisampling(i) { const e = this.inputBuffer, t = this.multisampling; t > 0 && i > 0 ? (this.inputBuffer.samples = i, this.outputBuffer.samples = i, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : t !== i && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, i), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone()) } getTimer() { return this.timer } getRenderer() { return this.renderer } setRenderer(i) { if (this.renderer = i, i !== null) { const e = i.getSize(new W), t = i.getContext().getContextAttributes().alpha, s = this.inputBuffer.texture.type; s === ui && i.outputEncoding === Xe && (this.inputBuffer.texture.encoding = Xe, this.outputBuffer.texture.encoding = Xe, this.inputBuffer.dispose(), this.outputBuffer.dispose()), i.autoClear = !1, this.setSize(e.width, e.height); for (const r of this.passes) r.initialize(i, t, s) } } replaceRenderer(i, e = !0) { const t = this.renderer, s = t.domElement.parentNode; return this.setRenderer(i), e && s !== null && (s.removeChild(t.domElement), s.appendChild(i.domElement)), t } createDepthTexture() { const i = this.depthTexture = new IA; return this.inputBuffer.depthTexture = i, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (i.format = Ll, i.type = Dl) : i.type = Ra, i } deleteDepthTexture() { if (this.depthTexture !== null) { this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose(); for (const i of this.passes) i.setDepthTexture(null) } } createBuffer(i, e, t, s) { const r = this.renderer, n = r === null ? new W : r.getDrawingBufferSize(new W), o = { minFilter: Qt, magFilter: Qt, stencilBuffer: e, depthBuffer: i, type: t }, a = new ri(n.width, n.height, o); return s > 0 && (a.ignoreDepthForMultisampleCopy = !1, a.samples = s), t === ui && r !== null && r.outputEncoding === Xe && (a.texture.encoding = Xe), a.texture.name = "EffectComposer.Buffer", a.texture.generateMipmaps = !1, a } setMainScene(i) { for (const e of this.passes) e.mainScene = i } setMainCamera(i) { for (const e of this.passes) e.mainCamera = i } addPass(i, e) { const t = this.passes, s = this.renderer, r = s.getDrawingBufferSize(new W), n = s.getContext().getContextAttributes().alpha, o = this.inputBuffer.texture.type; if (i.setRenderer(s), i.setSize(r.width, r.height), i.initialize(s, n, o), this.autoRenderToScreen && (t.length > 0 && (t[t.length - 1].renderToScreen = !1), i.renderToScreen && (this.autoRenderToScreen = !1)), e !== void 0 ? t.splice(e, 0, i) : t.push(i), this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0), i.needsDepthTexture || this.depthTexture !== null) if (this.depthTexture === null) { const a = this.createDepthTexture(); for (i of t) i.setDepthTexture(a) } else i.setDepthTexture(this.depthTexture) } removePass(i) { const e = this.passes, t = e.indexOf(i); if (t !== -1 && e.splice(t, 1).length > 0) { if (this.depthTexture !== null) { const s = (r, n) => r || n.needsDepthTexture; e.reduce(s, !1) || (i.getDepthTexture() === this.depthTexture && i.setDepthTexture(null), this.deleteDepthTexture()) } this.autoRenderToScreen && t === e.length && (i.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0)) } } removeAllPasses() { const i = this.passes; this.deleteDepthTexture(), i.length > 0 && (this.autoRenderToScreen && (i[i.length - 1].renderToScreen = !1), this.passes = []) } render(i) { const e = this.renderer, t = this.copyPass; let s = this.inputBuffer, r = this.outputBuffer, n = !1, o, a, l; i === void 0 && (this.timer.update(), i = this.timer.delta); for (const c of this.passes) c.enabled && (c.render(e, s, r, i, n), c.needsSwap && (n && (t.renderToScreen = c.renderToScreen, o = e.getContext(), a = e.state.buffers.stencil, a.setFunc(o.NOTEQUAL, 1, 4294967295), t.render(e, s, r, i, n), a.setFunc(o.EQUAL, 1, 4294967295)), l = s, s = r, r = l), c instanceof Z9 ? n = !0 : c instanceof X9 && (n = !1)) } setSize(i, e, t) { const s = this.renderer, r = s.getSize(new W); (i === void 0 || e === void 0) && (i = r.width, e = r.height), (r.width !== i || r.height !== e) && s.setSize(i, e, t); const n = s.getDrawingBufferSize(new W); this.inputBuffer.setSize(n.width, n.height), this.outputBuffer.setSize(n.width, n.height); for (const o of this.passes) o.setSize(n.width, n.height) } reset() { const i = this.timer.autoReset; this.dispose(), this.autoRenderToScreen = !0, this.timer.autoReset = i } dispose() { for (const i of this.passes) i.dispose(); this.passes = [], this.inputBuffer !== null && this.inputBuffer.dispose(), this.outputBuffer !== null && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose() } }, sW = class { constructor() { this.shaderParts = new Map([[si.FRAGMENT_HEAD, null], [si.FRAGMENT_MAIN_UV, null], [si.FRAGMENT_MAIN_IMAGE, null], [si.VERTEX_HEAD, null], [si.VERTEX_MAIN_SUPPORT, null]]), this.defines = new Map, this.uniforms = new Map, this.blendModes = new Map, this.extensions = new Set, this.attributes = nn.NONE, this.varyings = new Set, this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = Qi } }, rW = class extends Set { constructor(i, e = 10) { super(), this.l = e, this.exclusive = !1, i !== void 0 && this.set(i) } get layer() { return this.l } set layer(i) { const e = this.l; for (const t of this) t.layers.disable(e), t.layers.enable(i); this.l = i } getLayer() { return this.layer } setLayer(i) { this.layer = i } isExclusive() { return this.exclusive } setExclusive(i) { this.exclusive = i } clear() { const i = this.layer; for (const e of this) e.layers.disable(i); return super.clear() } set(i) { this.clear(); for (const e of i) this.add(e); return this } indexOf(i) { return this.has(i) ? 0 : -1 } add(i) { return this.exclusive ? i.layers.set(this.layer) : i.layers.enable(this.layer), super.add(i) } delete(i) { return this.has(i) && i.layers.disable(this.layer), super.delete(i) } toggle(i) { let e; return this.has(i) ? (this.delete(i), e = !1) : (this.add(i), e = !0), e } setVisible(i) { for (const e of this) i ? e.layers.enable(0) : e.layers.disable(0); return this } }, nW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}", oW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}", aW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}", lW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", cW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}", hW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}", uW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}", dW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}", pW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}", fW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}", gW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}", mW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}", vW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}", AW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}", yW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}", bW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}", _W = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}", xW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}", wW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}", CW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", SW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}", EW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}", MW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}", IW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}", TW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}", RW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}", PW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", BW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}", kW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}", DW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}", OW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}", LW = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}", FW = new Map([[kt.ADD, nW], [kt.ALPHA, oW], [kt.AVERAGE, aW], [kt.COLOR, lW], [kt.COLOR_BURN, cW], [kt.COLOR_DODGE, hW], [kt.DARKEN, uW], [kt.DIFFERENCE, dW], [kt.DIVIDE, pW], [kt.DST, null], [kt.EXCLUSION, fW], [kt.HARD_LIGHT, gW], [kt.HARD_MIX, mW], [kt.HUE, vW], [kt.INVERT, AW], [kt.INVERT_RGB, yW], [kt.LIGHTEN, bW], [kt.LINEAR_BURN, _W], [kt.LINEAR_DODGE, xW], [kt.LINEAR_LIGHT, wW], [kt.LUMINOSITY, CW], [kt.MULTIPLY, SW], [kt.NEGATION, EW], [kt.NORMAL, MW], [kt.OVERLAY, IW], [kt.PIN_LIGHT, TW], [kt.REFLECT, RW], [kt.SATURATION, PW], [kt.SCREEN, BW], [kt.SOFT_LIGHT, kW], [kt.SRC, DW], [kt.SUBTRACT, OW], [kt.VIVID_LIGHT, LW]]), UW = class extends ms { constructor(i, e = 1) { super(), this._blendFunction = i, this.opacity = new Ce(e) } getOpacity() { return this.opacity.value } setOpacity(i) { this.opacity.value = i } get blendFunction() { return this._blendFunction } set blendFunction(i) { this._blendFunction = i, this.dispatchEvent({ type: "change" }) } getBlendFunction() { return this.blendFunction } setBlendFunction(i) { this.blendFunction = i } getShaderCode() { return FW.get(this.blendFunction) } }, po = class extends ms { constructor(i, e, { attributes: t = nn.NONE, blendFunction: s = kt.NORMAL, defines: r = new Map, uniforms: n = new Map, extensions: o = null, vertexShader: a = null } = {}) { super(), this.name = i, this.renderer = null, this.attributes = t, this.fragmentShader = e, this.vertexShader = a, this.defines = r, this.uniforms = n, this.extensions = o, this.blendMode = new UW(s), this.blendMode.addEventListener("change", l => this.setChanged()), this._inputColorSpace = Qi, this._outputColorSpace = null } get inputColorSpace() { return this._inputColorSpace } set inputColorSpace(i) { this._inputColorSpace = i, this.setChanged() } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(i) { this._outputColorSpace = i, this.setChanged() } set mainScene(i) { } set mainCamera(i) { } getName() { return this.name } setRenderer(i) { this.renderer = i } getDefines() { return this.defines } getUniforms() { return this.uniforms } getExtensions() { return this.extensions } getBlendMode() { return this.blendMode } getAttributes() { return this.attributes } setAttributes(i) { this.attributes = i, this.setChanged() } getFragmentShader() { return this.fragmentShader } setFragmentShader(i) { this.fragmentShader = i, this.setChanged() } getVertexShader() { return this.vertexShader } setVertexShader(i) { this.vertexShader = i, this.setChanged() } setChanged() { this.dispatchEvent({ type: "change" }) } setDepthTexture(i, e = Os) { } update(i, e, t) { } setSize(i, e) { } initialize(i, e, t) { } dispose() { for (const i of Object.keys(this)) { const e = this[i]; (e instanceof ri || e instanceof Tt || e instanceof Nt || e instanceof nr) && this[i].dispose() } } }, NW = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv)*intensity;}`, nC = class extends po { constructor({ blendFunction: i = kt.SCREEN, luminanceThreshold: e = .9, luminanceSmoothing: t = .025, mipmapBlur: s = !1, intensity: r = 1, radius: n = .85, levels: o = 8, kernelSize: a = Ya.LARGE, resolutionScale: l = .5, width: c = ai.AUTO_SIZE, height: h = ai.AUTO_SIZE, resolutionX: d = c, resolutionY: p = h } = {}) { super("BloomEffect", NW, { blendFunction: i, uniforms: new Map([["map", new Ce(null)], ["intensity", new Ce(r)]]) }), this.renderTarget = new ri(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "Bloom.Target", this.blurPass = new iC({ kernelSize: a }), this.luminancePass = new K9({ colorOutput: !0 }), this.luminanceMaterial.threshold = e, this.luminanceMaterial.smoothing = t, this.mipmapBlurPass = new $9, this.mipmapBlurPass.enabled = s, this.mipmapBlurPass.radius = n, this.mipmapBlurPass.levels = o, this.uniforms.get("map").value = s ? this.mipmapBlurPass.texture : this.renderTarget.texture; const f = this.resolution = new ai(this, d, p, l); f.addEventListener("change", g => this.setSize(f.baseWidth, f.baseHeight)) } get texture() { return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture } getTexture() { return this.texture } getResolution() { return this.resolution } getBlurPass() { return this.blurPass } getLuminancePass() { return this.luminancePass } get luminanceMaterial() { return this.luminancePass.fullscreenMaterial } getLuminanceMaterial() { return this.luminancePass.fullscreenMaterial } get width() { return this.resolution.width } set width(i) { this.resolution.preferredWidth = i } get height() { return this.resolution.height } set height(i) { this.resolution.preferredHeight = i } get dithering() { return this.blurPass.dithering } set dithering(i) { this.blurPass.dithering = i } get kernelSize() { return this.blurPass.kernelSize } set kernelSize(i) { this.blurPass.kernelSize = i } get distinction() { return console.warn(this.name, "distinction was removed"), 1 } set distinction(i) { console.warn(this.name, "distinction was removed") } get intensity() { return this.uniforms.get("intensity").value } set intensity(i) { this.uniforms.get("intensity").value = i } getIntensity() { return this.intensity } setIntensity(i) { this.intensity = i } getResolutionScale() { return this.resolution.scale } setResolutionScale(i) { this.resolution.scale = i } update(i, e, t) { const s = this.renderTarget, r = this.luminancePass; r.enabled ? (r.render(i, e), this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(i, r.renderTarget) : this.blurPass.render(i, r.renderTarget, s)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(i, e) : this.blurPass.render(i, e, s) } setSize(i, e) { const t = this.resolution; t.setBaseSize(i, e), this.renderTarget.setSize(t.width, t.height), this.blurPass.resolution.copy(t), this.luminancePass.setSize(i, e), this.mipmapBlurPass.setSize(i, e) } initialize(i, e, t) { this.blurPass.initialize(i, e, t), this.luminancePass.initialize(i, e, t), this.mipmapBlurPass.initialize(i, e, t), t !== void 0 && (this.renderTarget.texture.type = t, i.outputEncoding === Xe && (this.renderTarget.texture.encoding = Xe)) } }, zW = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}", H2 = class extends po { constructor({ blendFunction: i = kt.SRC, brightness: e = 0, contrast: t = 0 } = {}) { super("BrightnessContrastEffect", zW, { blendFunction: i, uniforms: new Map([["brightness", new Ce(e)], ["contrast", new Ce(t)]]) }), this.inputColorSpace = Xe } get brightness() { return this.uniforms.get("brightness").value } set brightness(i) { this.uniforms.get("brightness").value = i } getBrightness(i) { return this.brightness } setBrightness(i) { this.brightness = i } get contrast() { return this.uniforms.get("contrast").value } set contrast(i) { this.uniforms.get("contrast").value = i } getContrast(i) { return this.contrast } setContrast(i) { this.contrast = i } }, jW = `#ifdef RADIAL_MODULATION
uniform float modulationOffset;
#endif
varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;
#ifdef RADIAL_MODULATION
const vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}
#else
if(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}
#endif
outputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}`, QW = "uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}", V2 = class extends po { constructor({ offset: i = new W(.001, 5e-4), radialModulation: e = !1, modulationOffset: t = .15 } = {}) { super("ChromaticAberrationEffect", jW, { vertexShader: QW, attributes: nn.CONVOLUTION, uniforms: new Map([["offset", new Ce(i)], ["modulationOffset", new Ce(t)]]) }), this.radialModulation = e } get offset() { return this.uniforms.get("offset").value } set offset(i) { this.uniforms.get("offset").value = i } get radialModulation() { return this.defines.has("RADIAL_MODULATION") } set radialModulation(i) { i ? this.defines.set("RADIAL_MODULATION", "1") : this.defines.delete("RADIAL_MODULATION"), this.setChanged() } get modulationOffset() { return this.uniforms.get("modulationOffset").value } set modulationOffset(i) { this.uniforms.get("modulationOffset").value = i } getOffset() { return this.offset } setOffset(i) { this.offset = i } }, GW = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float cocNear=texture2D(nearCoCBuffer,uv).r;cocNear=min(cocNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,cocNear);outputColor=result;}`, W2 = class extends po { constructor(i, { blendFunction: e, worldFocusDistance: t, worldFocusRange: s, focusDistance: r = 0, focalLength: n = .1, focusRange: o = n, bokehScale: a = 1, resolutionScale: l = 1, width: c = ai.AUTO_SIZE, height: h = ai.AUTO_SIZE, resolutionX: d = c, resolutionY: p = h } = {}) { super("DepthOfFieldEffect", GW, { blendFunction: e, attributes: nn.DEPTH, uniforms: new Map([["nearColorBuffer", new Ce(null)], ["farColorBuffer", new Ce(null)], ["nearCoCBuffer", new Ce(null)], ["scale", new Ce(1)]]) }), this.camera = i, this.renderTarget = new ri(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.name = "DoF.CoC", this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture, this.cocPass = new zo(new c9(i)); const f = this.cocMaterial; f.focusDistance = r, f.focusRange = o, t !== void 0 && (f.worldFocusDistance = t), s !== void 0 && (f.worldFocusRange = s), this.blurPass = new iC({ resolutionScale: l, resolutionX: d, resolutionY: p, kernelSize: Ya.MEDIUM }), this.maskPass = new zo(new B9(this.renderTargetCoC.texture)); const g = this.maskPass.fullscreenMaterial; g.maskFunction = L2.MULTIPLY, g.colorChannel = O2.GREEN, this.bokehNearBasePass = new zo(new $0(!1, !0)), this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehNearFillPass = new zo(new $0(!0, !0)), this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehFarBasePass = new zo(new $0(!1, !1)), this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.bokehFarFillPass = new zo(new $0(!0, !1)), this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.target = null; const m = this.resolution = new ai(this, d, p, l); m.addEventListener("change", v => this.setSize(m.baseWidth, m.baseHeight)), this.bokehScale = a } set mainCamera(i) { this.camera = i, this.cocMaterial.copyCameraSettings(i) } get cocTexture() { return this.renderTargetCoC.texture } get cocMaterial() { return this.cocPass.fullscreenMaterial } get circleOfConfusionMaterial() { return this.cocMaterial } getCircleOfConfusionMaterial() { return this.circleOfConfusionMaterial } getBlurPass() { return this.blurPass } getResolution() { return this.resolution } get bokehScale() { return this.uniforms.get("scale").value } set bokehScale(i) { this.bokehNearBasePass.fullscreenMaterial.scale = i, this.bokehNearFillPass.fullscreenMaterial.scale = i, this.bokehFarBasePass.fullscreenMaterial.scale = i, this.bokehFarFillPass.fullscreenMaterial.scale = i, this.maskPass.fullscreenMaterial.strength = i, this.uniforms.get("scale").value = i } getBokehScale() { return this.bokehScale } setBokehScale(i) { this.bokehScale = i } getTarget() { return this.target } setTarget(i) { this.target = i } calculateFocusDistance(i) { const e = this.camera, t = e.position.distanceTo(i); return Oh(-t, e.near, e.far) } setDepthTexture(i, e = Os) { this.circleOfConfusionMaterial.depthBuffer = i, this.circleOfConfusionMaterial.depthPacking = e } update(i, e, t) { const s = this.renderTarget, r = this.renderTargetCoC, n = this.renderTargetCoCBlurred, o = this.renderTargetMasked; if (this.target !== null) { const a = this.calculateFocusDistance(this.target); this.cocMaterial.focusDistance = a } this.cocPass.render(i, null, r), this.blurPass.render(i, r, n), this.maskPass.render(i, e, o), this.bokehFarBasePass.render(i, o, s), this.bokehFarFillPass.render(i, s, this.renderTargetFar), this.bokehNearBasePass.render(i, e, s), this.bokehNearFillPass.render(i, s, this.renderTargetNear) } setSize(i, e) { const t = this.resolution; t.setBaseSize(i, e); const s = t.width, r = t.height; this.cocPass.setSize(i, e), this.blurPass.setSize(i, e), this.maskPass.setSize(i, e), this.renderTargetCoC.setSize(i, e), this.renderTargetMasked.setSize(i, e), this.renderTarget.setSize(s, r), this.renderTargetNear.setSize(s, r), this.renderTargetFar.setSize(s, r), this.renderTargetCoCBlurred.setSize(s, r), this.bokehNearBasePass.fullscreenMaterial.setSize(i, e), this.bokehNearFillPass.fullscreenMaterial.setSize(i, e), this.bokehFarBasePass.fullscreenMaterial.setSize(i, e), this.bokehFarFillPass.fullscreenMaterial.setSize(i, e) } initialize(i, e, t) { this.cocPass.initialize(i, e, t), this.maskPass.initialize(i, e, t), this.bokehNearBasePass.initialize(i, e, t), this.bokehNearFillPass.initialize(i, e, t), this.bokehFarBasePass.initialize(i, e, t), this.bokehFarFillPass.initialize(i, e, t), this.blurPass.initialize(i, e, ui), t !== void 0 && (this.renderTarget.texture.type = t, this.renderTargetNear.texture.type = t, this.renderTargetFar.texture.type = t, this.renderTargetMasked.texture.type = t, i.outputEncoding === Xe && (this.renderTarget.texture.encoding = Xe, this.renderTargetNear.texture.encoding = Xe, this.renderTargetFar.texture.encoding = Xe, this.renderTargetMasked.texture.encoding = Xe)) } }; function HW(i, e, t) { const s = new Map([[Qv, 1], [Fl, 1], [oh, 2], [_i, 4]]); let r; if (s.has(e) || console.error("Invalid noise texture format"), t === ui) { r = new Uint8Array(i * s.get(e)); for (let n = 0, o = r.length; n < o; ++n)r[n] = Math.random() * 255 + .5 } else { r = new Float32Array(i * s.get(e)); for (let n = 0, o = r.length; n < o; ++n)r[n] = Math.random() } return r } var VW = class extends no { constructor(i, e, t = Qv, s = ui) { super(HW(i * e, t, s), i, e, t, s), this.needsUpdate = !0 } }; new S, new He; var WW = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}", q2 = class extends po { constructor({ blendFunction: i = kt.SRC, hue: e = 0, saturation: t = 0 } = {}) { super("HueSaturationEffect", WW, { blendFunction: i, uniforms: new Map([["hue", new Ce(new S)], ["saturation", new Ce(t)]]) }), this.hue = e } get saturation() { return this.uniforms.get("saturation").value } set saturation(i) { this.uniforms.get("saturation").value = i } getSaturation() { return this.saturation } setSaturation(i) { this.saturation = i } get hue() { const i = this.uniforms.get("hue").value; return Math.acos((i.x * 3 - 1) / 2) } set hue(i) { const e = Math.sin(i), t = Math.cos(i); this.uniforms.get("hue").value.set((2 * t + 1) / 3, (-Math.sqrt(3) * e - t + 1) / 3, (Math.sqrt(3) * e - t + 1) / 3) } getHue() { return this.hue } setHue(i) { this.hue = i } }; new xe; var qW = "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}", X2 = class extends po { constructor(i = 30) { super("PixelationEffect", qW, { uniforms: new Map([["active", new Ce(!1)], ["d", new Ce(new st)]]) }), this.resolution = new W, this._granularity = 0, this.granularity = i } get granularity() { return this._granularity } set granularity(i) { let e = Math.floor(i); e % 2 > 0 && (e += 1), this._granularity = e, this.uniforms.get("active").value = e > 0, this.setSize(this.resolution.width, this.resolution.height) } getGranularity() { return this.granularity } setGranularity(i) { this.granularity = i } setSize(i, e) { const t = this.resolution; t.set(i, e); const s = this.granularity, r = s / t.x, n = s / t.y; this.uniforms.get("d").value.set(r, n, 1 / r, 1 / n) } }; new S, new S; var Y2 = class extends nC { constructor(i, e, t) { super(t), this.setAttributes(this.getAttributes() | nn.DEPTH), this.camera = e, this.depthPass = new Y9(i, e), this.clearPass = new ty(!0, !1, !1), this.clearPass.overrideClearColor = new xe(0), this.depthMaskPass = new zo(new y9); const s = this.depthMaskMaterial; s.copyCameraSettings(e), s.depthBuffer1 = this.depthPass.texture, s.depthPacking1 = $v, s.depthMode = Iu, this.renderTargetMasked = new ri(1, 1, { depthBuffer: !1 }), this.renderTargetMasked.texture.name = "Bloom.Masked", this.selection = new rW, this.selection.layer = 11, this._inverted = !1, this._ignoreBackground = !1 } set mainScene(i) { this.depthPass.mainScene = i } set mainCamera(i) { this.camera = i, this.depthPass.mainCamera = i, this.depthMaskMaterial.copyCameraSettings(i) } getSelection() { return this.selection } get depthMaskMaterial() { return this.depthMaskPass.fullscreenMaterial } get inverted() { return this._inverted } set inverted(i) { this._inverted = i, this.depthMaskMaterial.depthMode = i ? cf : Iu } isInverted() { return this.inverted } setInverted(i) { this.inverted = i } get ignoreBackground() { return this._ignoreBackground } set ignoreBackground(i) { this._ignoreBackground = i, this.depthMaskMaterial.maxDepthStrategy = i ? gg.DISCARD_MAX_DEPTH : gg.KEEP_MAX_DEPTH } isBackgroundDisabled() { return this.ignoreBackground } setBackgroundDisabled(i) { this.ignoreBackground = i } setDepthTexture(i, e = Os) { this.depthMaskMaterial.depthBuffer0 = i, this.depthMaskMaterial.depthPacking0 = e } update(i, e, t) { const s = this.camera, r = this.selection, n = this.inverted; let o = e; if (this.ignoreBackground || !n || r.size > 0) { const a = s.layers.mask; s.layers.set(r.layer), this.depthPass.render(i), s.layers.mask = a, o = this.renderTargetMasked, this.clearPass.render(i, o), this.depthMaskPass.render(i, e, o) } super.update(i, o, t) } setSize(i, e) { super.setSize(i, e), this.renderTargetMasked.setSize(i, e), this.depthPass.setSize(i, e) } initialize(i, e, t) { super.initialize(i, e, t), this.clearPass.initialize(i, e, t), this.depthPass.initialize(i, e, t), this.depthMaskPass.initialize(i, e, t), t !== void 0 && (this.renderTargetMasked.texture.type = t, i.outputEncoding === Xe && (this.renderTargetMasked.texture.encoding = Xe)) } }, J2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC", K2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC", XW = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", YW = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}", JW = class extends po { constructor({ blendFunction: i = kt.SRC, preset: e = _d.MEDIUM, edgeDetectionMode: t = $1.COLOR, predicationMode: s = h9.DISABLED } = {}) { super("SMAAEffect", XW, { vertexShader: YW, blendFunction: i, attributes: nn.CONVOLUTION | nn.DEPTH, uniforms: new Map([["weightMap", new Ce(null)]]) }); let r, n; arguments.length > 1 && (r = arguments[0], n = arguments[1], arguments.length > 2 && (e = arguments[2]), arguments.length > 3 && (t = arguments[3])), this.renderTargetEdges = new ri(1, 1, { depthBuffer: !1 }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new ty(!0, !1, !1), this.clearPass.overrideClearColor = new xe(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new zo(new S9), this.edgeDetectionMaterial.edgeDetectionMode = t, this.edgeDetectionMaterial.predicationMode = s, this.weightsPass = new zo(new O9); const o = new XA; o.onLoad = () => { const a = new Nt(r); a.name = "SMAA.Search", a.magFilter = Zt, a.minFilter = Zt, a.generateMipmaps = !1, a.needsUpdate = !0, a.flipY = !0, this.weightsMaterial.searchTexture = a; const l = new Nt(n); l.name = "SMAA.Area", l.magFilter = Qt, l.minFilter = Qt, l.generateMipmaps = !1, l.needsUpdate = !0, l.flipY = !1, this.weightsMaterial.areaTexture = l, this.dispatchEvent({ type: "load" }) }, o.itemStart("search"), o.itemStart("area"), r !== void 0 && n !== void 0 ? (o.itemEnd("search"), o.itemEnd("area")) : typeof Image < "u" && (r = new Image, n = new Image, r.addEventListener("load", () => o.itemEnd("search")), n.addEventListener("load", () => o.itemEnd("area")), r.src = J2, n.src = K2), this.applyPreset(e) } get edgesTexture() { return this.renderTargetEdges.texture } getEdgesTexture() { return this.edgesTexture } get weightsTexture() { return this.renderTargetWeights.texture } getWeightsTexture() { return this.weightsTexture } get edgeDetectionMaterial() { return this.edgeDetectionPass.fullscreenMaterial } get colorEdgesMaterial() { return this.edgeDetectionMaterial } getEdgeDetectionMaterial() { return this.edgeDetectionMaterial } get weightsMaterial() { return this.weightsPass.fullscreenMaterial } getWeightsMaterial() { return this.weightsMaterial } setEdgeDetectionThreshold(i) { this.edgeDetectionMaterial.edgeDetectionThreshold = i } setOrthogonalSearchSteps(i) { this.weightsMaterial.orthogonalSearchSteps = i } applyPreset(i) { const e = this.edgeDetectionMaterial, t = this.weightsMaterial; switch (i) { case _d.LOW: e.edgeDetectionThreshold = .15, t.orthogonalSearchSteps = 4, t.diagonalDetection = !1, t.cornerDetection = !1; break; case _d.MEDIUM: e.edgeDetectionThreshold = .1, t.orthogonalSearchSteps = 8, t.diagonalDetection = !1, t.cornerDetection = !1; break; case _d.HIGH: e.edgeDetectionThreshold = .1, t.orthogonalSearchSteps = 16, t.diagonalSearchSteps = 8, t.cornerRounding = 25, t.diagonalDetection = !0, t.cornerDetection = !0; break; case _d.ULTRA: e.edgeDetectionThreshold = .05, t.orthogonalSearchSteps = 32, t.diagonalSearchSteps = 16, t.cornerRounding = 25, t.diagonalDetection = !0, t.cornerDetection = !0; break } } setDepthTexture(i, e = Os) { this.edgeDetectionMaterial.depthBuffer = i, this.edgeDetectionMaterial.depthPacking = e } update(i, e, t) { this.clearPass.render(i, this.renderTargetEdges), this.edgeDetectionPass.render(i, e, this.renderTargetEdges), this.weightsPass.render(i, this.renderTargetEdges, this.renderTargetWeights) } setSize(i, e) { this.edgeDetectionMaterial.setSize(i, e), this.weightsMaterial.setSize(i, e), this.renderTargetEdges.setSize(i, e), this.renderTargetWeights.setSize(i, e) } dispose() { const { searchTexture: i, areaTexture: e } = this.weightsMaterial; i !== null && e !== null && (i.dispose(), e.dispose()), super.dispose() } static get searchImageDataURL() { return J2 } static get areaImageDataURL() { return K2 } }, KW = `uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
#endif
#ifdef COLORIZE
uniform vec3 color;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;
#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300
vec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);
#else
float ao=aoLinear;
#endif
float l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);
#ifdef COLORIZE
outputColor=vec4(1.0-ao*(1.0-color),inputColor.a);
#else
outputColor=vec4(vec3(1.0-ao),inputColor.a);
#endif
}`, Z2 = 64, $2 = class extends po { constructor(i, e, { blendFunction: t = kt.MULTIPLY, samples: s = 9, rings: r = 7, normalDepthBuffer: n = null, depthAwareUpsampling: o = !0, worldDistanceThreshold: a, worldDistanceFalloff: l, worldProximityThreshold: c, worldProximityFalloff: h, distanceThreshold: d = .97, distanceFalloff: p = .03, rangeThreshold: f = 5e-4, rangeFalloff: g = .001, minRadiusScale: m = .1, luminanceInfluence: v = .7, radius: A = .1825, intensity: b = 1, bias: y = .025, fade: _ = .01, color: w = null, resolutionScale: E = 1, width: P = ai.AUTO_SIZE, height: C = ai.AUTO_SIZE, resolutionX: R = P, resolutionY: T = C } = {}) { super("SSAOEffect", KW, { blendFunction: t, attributes: nn.DEPTH, defines: new Map([["THRESHOLD", "0.997"]]), uniforms: new Map([["aoBuffer", new Ce(null)], ["normalDepthBuffer", new Ce(n)], ["luminanceInfluence", new Ce(v)], ["color", new Ce(null)], ["intensity", new Ce(b)], ["scale", new Ce(0)]]) }), this.renderTarget = new ri(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "AO.Target", this.uniforms.get("aoBuffer").value = this.renderTarget.texture; const z = this.resolution = new ai(this, R, T, E); z.addEventListener("change", F => this.setSize(z.baseWidth, z.baseHeight)), this.camera = i, this.depthDownsamplingPass = new tC({ normalBuffer: e, resolutionScale: E }), this.depthDownsamplingPass.enabled = n === null, this.ssaoPass = new zo(new U9(i)); const H = new VW(Z2, Z2, _i); H.wrapS = H.wrapT = yn; const N = this.ssaoMaterial; N.normalBuffer = e, N.noiseTexture = H, N.minRadiusScale = m, N.samples = s, N.radius = A, N.rings = r, N.fade = _, N.bias = y, N.distanceThreshold = d, N.distanceFalloff = p, N.proximityThreshold = f, N.proximityFalloff = g, a !== void 0 && (N.worldDistanceThreshold = a), l !== void 0 && (N.worldDistanceFalloff = l), c !== void 0 && (N.worldProximityThreshold = c), h !== void 0 && (N.worldProximityFalloff = h), n !== null && (this.ssaoMaterial.normalDepthBuffer = n, this.defines.set("NORMAL_DEPTH", "1")), this.depthAwareUpsampling = o, this.color = w } set mainCamera(i) { this.camera = i, this.ssaoMaterial.copyCameraSettings(i) } get normalBuffer() { return this.ssaoMaterial.normalBuffer } set normalBuffer(i) { this.ssaoMaterial.normalBuffer = i, this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = i } getResolution() { return this.resolution } get ssaoMaterial() { return this.ssaoPass.fullscreenMaterial } getSSAOMaterial() { return this.ssaoMaterial } get samples() { return this.ssaoMaterial.samples } set samples(i) { this.ssaoMaterial.samples = i } get rings() { return this.ssaoMaterial.rings } set rings(i) { this.ssaoMaterial.rings = i } get radius() { return this.ssaoMaterial.radius } set radius(i) { this.ssaoMaterial.radius = i } get depthAwareUpsampling() { return this.defines.has("DEPTH_AWARE_UPSAMPLING") } set depthAwareUpsampling(i) { this.depthAwareUpsampling !== i && (i ? this.defines.set("DEPTH_AWARE_UPSAMPLING", "1") : this.defines.delete("DEPTH_AWARE_UPSAMPLING"), this.setChanged()) } isDepthAwareUpsamplingEnabled() { return this.depthAwareUpsampling } setDepthAwareUpsamplingEnabled(i) { this.depthAwareUpsampling = i } get distanceScaling() { return !0 } set distanceScaling(i) { } get color() { return this.uniforms.get("color").value } set color(i) { const e = this.uniforms, t = this.defines; i !== null ? t.has("COLORIZE") ? e.get("color").value.set(i) : (t.set("COLORIZE", "1"), e.get("color").value = new xe(i), this.setChanged()) : t.has("COLORIZE") && (t.delete("COLORIZE"), e.get("color").value = null, this.setChanged()) } get luminanceInfluence() { return this.uniforms.get("luminanceInfluence").value } set luminanceInfluence(i) { this.uniforms.get("luminanceInfluence").value = i } get intensity() { return this.uniforms.get("intensity").value } set intensity(i) { this.uniforms.get("intensity").value = i } getColor() { return this.color } setColor(i) { this.color = i } setDistanceCutoff(i, e) { this.ssaoMaterial.distanceThreshold = i, this.ssaoMaterial.distanceFalloff = e } setProximityCutoff(i, e) { this.ssaoMaterial.proximityThreshold = i, this.ssaoMaterial.proximityFalloff = e } setDepthTexture(i, e = Os) { this.depthDownsamplingPass.setDepthTexture(i, e), this.ssaoMaterial.depthBuffer = i, this.ssaoMaterial.depthPacking = e } update(i, e, t) { const s = this.renderTarget; this.depthDownsamplingPass.enabled && this.depthDownsamplingPass.render(i), this.ssaoPass.render(i, null, s) } setSize(i, e) { const t = this.resolution; t.setBaseSize(i, e); const s = t.width, r = t.height; this.ssaoMaterial.copyCameraSettings(this.camera), this.ssaoMaterial.setSize(s, r), this.renderTarget.setSize(s, r), this.depthDownsamplingPass.resolution.scale = t.scale, this.depthDownsamplingPass.setSize(i, e) } initialize(i, e, t) { try { let s = this.uniforms.get("normalDepthBuffer").value; s === null && (this.depthDownsamplingPass.initialize(i, e, t), s = this.depthDownsamplingPass.texture, this.uniforms.get("normalDepthBuffer").value = s, this.ssaoMaterial.normalDepthBuffer = s, this.defines.set("NORMAL_DEPTH", "1")) } catch { this.depthDownsamplingPass.enabled = !1 } } }, ZW = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform vec2 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return step(maskParams.x,x)-step(maskParams.y,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}`, $W = "uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}", eq = class extends po { constructor({ blendFunction: i, offset: e = 0, rotation: t = 0, focusArea: s = .4, feather: r = .3, kernelSize: n = Ya.MEDIUM, resolutionScale: o = .5, resolutionX: a = ai.AUTO_SIZE, resolutionY: l = ai.AUTO_SIZE } = {}) { super("TiltShiftEffect", ZW, { vertexShader: $W, blendFunction: i, uniforms: new Map([["rotation", new Ce(new W)], ["maskParams", new Ce(new W)], ["map", new Ce(null)]]) }), this._offset = e, this._focusArea = s, this._feather = r, this.renderTarget = new ri(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "TiltShift.Target", this.uniforms.get("map").value = this.renderTarget.texture, this.blurPass = new eW({ kernelSize: n, resolutionScale: o, resolutionX: a, resolutionY: l, offset: e, rotation: t, focusArea: s, feather: r }); const c = this.resolution = new ai(this, a, l, o); c.addEventListener("change", h => this.setSize(c.baseWidth, c.baseHeight)), this.rotation = t, this.updateParams() } updateParams() { const i = this.uniforms.get("maskParams").value, e = Math.max(this.focusArea - this.feather, 0); i.set(this.offset - e, this.offset + e) } get rotation() { return Math.acos(this.uniforms.get("rotation").value.x) } set rotation(i) { this.uniforms.get("rotation").value.set(Math.cos(i), Math.sin(i)), this.blurPass.blurMaterial.rotation = i } get offset() { return this._offset } set offset(i) { this._offset = i, this.blurPass.blurMaterial.offset = i, this.updateParams() } get focusArea() { return this._focusArea } set focusArea(i) { this._focusArea = i, this.blurPass.blurMaterial.focusArea = i, this.updateParams() } get feather() { return this._feather } set feather(i) { this._feather = i, this.blurPass.blurMaterial.feather = i, this.updateParams() } get bias() { return 0 } set bias(i) { } update(i, e, t) { this.blurPass.render(i, e, this.renderTarget) } setSize(i, e) { const t = this.resolution; t.setBaseSize(i, e), this.renderTarget.setSize(t.width, t.height), this.blurPass.resolution.copy(t) } initialize(i, e, t) { this.blurPass.initialize(i, e, t), t !== void 0 && (this.renderTarget.texture.type = t, i.outputEncoding === Xe && (this.renderTarget.texture.encoding = Xe)) } }, tq = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`, eD = class extends po { constructor({ blendFunction: i, technique: e = ey.DEFAULT, eskil: t = !1, offset: s = .5, darkness: r = .5 } = {}) { super("VignetteEffect", tq, { blendFunction: i, defines: new Map([["VIGNETTE_TECHNIQUE", e.toFixed(0)]]), uniforms: new Map([["offset", new Ce(s)], ["darkness", new Ce(r)]]) }) } get technique() { return Number(this.defines.get("VIGNETTE_TECHNIQUE")) } set technique(i) { this.technique !== i && (this.defines.set("VIGNETTE_TECHNIQUE", i.toFixed(0)), this.setChanged()) } get eskil() { return this.technique === ey.ESKIL } set eskil(i) { this.technique = i ? ey.ESKIL : ey.DEFAULT } getTechnique() { return this.technique } setTechnique(i) { this.technique = i } get offset() { return this.uniforms.get("offset").value } set offset(i) { this.uniforms.get("offset").value = i } getOffset() { return this.offset } setOffset(i) { this.offset = i } get darkness() { return this.uniforms.get("darkness").value } set darkness(i) { this.uniforms.get("darkness").value = i } getDarkness() { return this.darkness } setDarkness(i) { this.darkness = i } }, mg = function () { var i = 0, e = document.createElement("div"); e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", function (h) { h.preventDefault(), s(++i % e.children.length) }, !1); function t(h) { return e.appendChild(h.dom), h } function s(h) { for (var d = 0; d < e.children.length; d++)e.children[d].style.display = d === h ? "block" : "none"; i = h } var r = (performance || Date).now(), n = r, o = 0, a = t(new mg.Panel("FPS", "#0ff", "#002")), l = t(new mg.Panel("MS", "#0f0", "#020")); if (self.performance && self.performance.memory) var c = t(new mg.Panel("MB", "#f08", "#201")); return s(0), { REVISION: 16, dom: e, addPanel: t, showPanel: s, begin: function () { r = (performance || Date).now() }, end: function () { o++; var h = (performance || Date).now(); if (l.update(h - r, 200), h >= n + 1e3 && (a.update(o * 1e3 / (h - n), 100), n = h, o = 0, c)) { var d = performance.memory; c.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576) } return h }, update: function () { r = this.end() }, domElement: e, setMode: s } }; mg.Panel = function (i, e, t) { var s = 1 / 0, r = 0, n = Math.round, o = n(window.devicePixelRatio || 1), a = 80 * o, l = 48 * o, c = 3 * o, h = 2 * o, d = 3 * o, p = 15 * o, f = 74 * o, g = 30 * o, m = document.createElement("canvas"); m.width = a, m.height = l, m.style.cssText = "width:80px;height:48px"; var v = m.getContext("2d"); return v.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif", v.textBaseline = "top", v.fillStyle = t, v.fillRect(0, 0, a, l), v.fillStyle = e, v.fillText(i, c, h), v.fillRect(d, p, f, g), v.fillStyle = t, v.globalAlpha = .9, v.fillRect(d, p, f, g), { dom: m, update: function (A, b) { s = Math.min(s, A), r = Math.max(r, A), v.fillStyle = t, v.globalAlpha = 1, v.fillRect(0, 0, a, p), v.fillStyle = e, v.fillText(n(A) + " " + i + " (" + n(s) + "-" + n(r) + ")", c, h), v.drawImage(m, d + o, p, f - o, g, d, p, f - o, g), v.fillRect(d + f - o, p, o, g), v.fillStyle = t, v.globalAlpha = .9, v.fillRect(d + f - o, p, o, n((1 - A / b) * g)) } } }; const iq = mg; class sq { static fromCubeTexture(e) { let t = 0; const s = new S, r = new S, n = new xe, o = [0, 0, 0, 0, 0, 0, 0, 0, 0], a = new ld, l = a.coefficients; for (let h = 0; h < 6; h++) { const d = e.image[h], p = d.width, f = d.height, g = document.createElement("canvas"); g.width = p, g.height = f; const m = g.getContext("2d"); m.drawImage(d, 0, 0, p, f); const v = m.getImageData(0, 0, p, f), A = v.data, b = v.width, y = 2 / b; for (let _ = 0, w = A.length; _ < w; _ += 4) { n.setRGB(A[_] / 255, A[_ + 1] / 255, A[_ + 2] / 255), tD(n, e.encoding); const E = _ / 4, P = -1 + (E % b + .5) * y, C = 1 - (Math.floor(E / b) + .5) * y; switch (h) { case 0: s.set(-1, C, -P); break; case 1: s.set(1, C, P); break; case 2: s.set(-P, 1, -C); break; case 3: s.set(-P, -1, C); break; case 4: s.set(-P, C, 1); break; case 5: s.set(P, C, -1); break }const R = s.lengthSq(), T = 4 / (Math.sqrt(R) * R); t += T, r.copy(s).normalize(), ld.getBasisAt(r, o); for (let z = 0; z < 9; z++)l[z].x += o[z] * n.r * T, l[z].y += o[z] * n.g * T, l[z].z += o[z] * n.b * T } } const c = 4 * Math.PI / t; for (let h = 0; h < 9; h++)l[h].x *= c, l[h].y *= c, l[h].z *= c; return new cd(a) } static fromCubeRenderTarget(e, t) { let s = 0; const r = new S, n = new S, o = new xe, a = [0, 0, 0, 0, 0, 0, 0, 0, 0], l = new ld, c = l.coefficients; for (let d = 0; d < 6; d++) { const p = t.width, f = new Uint8Array(p * p * 4); e.readRenderTargetPixels(t, 0, 0, p, p, f, d); const g = 2 / p; for (let m = 0, v = f.length; m < v; m += 4) { o.setRGB(f[m] / 255, f[m + 1] / 255, f[m + 2] / 255), tD(o, t.texture.encoding); const A = m / 4, b = -1 + (A % p + .5) * g, y = 1 - (Math.floor(A / p) + .5) * g; switch (d) { case 0: r.set(1, y, -b); break; case 1: r.set(-1, y, b); break; case 2: r.set(b, 1, -y); break; case 3: r.set(b, -1, y); break; case 4: r.set(b, y, 1); break; case 5: r.set(-b, y, -1); break }const _ = r.lengthSq(), w = 4 / (Math.sqrt(_) * _); s += w, n.copy(r).normalize(), ld.getBasisAt(n, a); for (let E = 0; E < 9; E++)c[E].x += a[E] * o.r * w, c[E].y += a[E] * o.g * w, c[E].z += a[E] * o.b * w } } const h = 4 * Math.PI / s; for (let d = 0; d < 9; d++)c[d].x *= h, c[d].y *= h, c[d].z *= h; return new cd(l) } } function tD(i, e) { switch (e) { case Xe: i.convertSRGBToLinear(); break; case Qi: break; default: console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding."); break }return i } new bs; const vg = new Uint8Array(4); vg[0] = 255, vg[1] = 255, vg[2] = 255, vg[3] = 255; const rq = new no(vg, 1, 1, _i); function iD(i, e = 1) { const t = "alpha" in i, s = e * e, r = new Uint8Array(4 * s), n = Math.floor(i.r * 255), o = Math.floor(i.g * 255), a = Math.floor(i.b * 255); for (let c = 0; c < s; c++) { const h = c * 4; r[h + 0] = n, r[h + 1] = o, r[h + 2] = a, t ? r[h + 3] = Math.floor(i.alpha * 255) : r[h + 3] = 255 } const l = new no(r, e, e); return l.needsUpdate = !0, l } function nq(i, e, t, s = 1, r = 3) { const n = s * r, o = [i, e, t], a = o.length, l = new Uint8Array(4 * a * n), c = new xe; for (let d = 0; d < r; d++) { const p = Math.floor(d / r * a), f = Ke.clamp(p + 1, 0, a - 1), g = o[p], m = o[f], v = d / r * a % 1; c.lerpColors(g, m, v); const A = Math.floor(c.r * 255), b = Math.floor(c.g * 255), y = Math.floor(c.b * 255); for (let _ = 0; _ < s; _++) { const w = (d * s + _) * 4; l[w + 0] = A, l[w + 1] = b, l[w + 2] = y, l[w + 3] = 255 } } const h = new no(l, s, r); return h.needsUpdate = !0, h } function sy(i, e) { const t = i.elements; e || (e = []), e.length = 0; for (let s = 0; s < 16; s += 4) { const r = t[s], n = t[s + 1], o = t[s + 2], a = t[s + 3], l = new st(r, n, o, a); e.push(l) } return e } const oC = [], sD = []; function rD(i, e) { if (oC.length === 0) for (let t = 0; t < 27; t++)oC.push(0); e || (e = oC); for (let t = 0; t < 27; t++)sD[t] = e[t]; e = sD, i.unity_SHAr = { value: new st(e[9], e[3], e[6], e[0]) }, i.unity_SHBr = { value: new st(e[12], e[15], e[18], e[21]) }, i.unity_SHAg = { value: new st(e[10], e[4], e[7], e[1]) }, i.unity_SHBg = { value: new st(e[13], e[16], e[19], e[22]) }, i.unity_SHAb = { value: new st(e[11], e[5], e[8], e[2]) }, i.unity_SHBb = { value: new st(e[14], e[17], e[20], e[23]) }, i.unity_SHC = { value: new st(e[24], e[25], e[26], 1) } } class oq { constructor(e, t, s) { u(this, "vertexShader"), u(this, "fragmentShader"), u(this, "technique"), this.vertexShader = e, this.fragmentShader = t, this.technique = s } } async function aq(i, e) { if (!i) return console.error("Can not find technique: no shader data"), null; const t = i.programs[e], s = t.vertexShader, r = t.fragmentShader; if (s !== void 0 && r !== void 0) { const n = i.shaders[s], o = i.shaders[r]; if (n.uri && o.uri || n.code && o.code) { if (!n.code && n.uri && await nD(n), !o.code && o.uri && await nD(o), !n.code || !o.code) return null; const a = i.techniques[e]; return new oq(n.code, o.code, a) } } return console.error("Shader technique not found", e), null } async function nD(i) { const e = i.uri; if (e) if (e.endsWith(".glsl")) { const t = await new bs().loadAsync(e); i.code = t.toString() } else i.code = lq(i.uri) } function lq(i) { return decodeURIComponent(Array.prototype.map.call(atob(i), function (e) { return "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2) }).join("")) } var oD = { exports: {} }, aD = { exports: {} }; (function () { var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = { rotl: function (t, s) { return t << s | t >>> 32 - s }, rotr: function (t, s) { return t << 32 - s | t >>> s }, endian: function (t) { if (t.constructor == Number) return e.rotl(t, 8) & 16711935 | e.rotl(t, 24) & 4278255360; for (var s = 0; s < t.length; s++)t[s] = e.endian(t[s]); return t }, randomBytes: function (t) { for (var s = []; t > 0; t--)s.push(Math.floor(Math.random() * 256)); return s }, bytesToWords: function (t) { for (var s = [], r = 0, n = 0; r < t.length; r++, n += 8)s[n >>> 5] |= t[r] << 24 - n % 32; return s }, wordsToBytes: function (t) { for (var s = [], r = 0; r < t.length * 32; r += 8)s.push(t[r >>> 5] >>> 24 - r % 32 & 255); return s }, bytesToHex: function (t) { for (var s = [], r = 0; r < t.length; r++)s.push((t[r] >>> 4).toString(16)), s.push((t[r] & 15).toString(16)); return s.join("") }, hexToBytes: function (t) { for (var s = [], r = 0; r < t.length; r += 2)s.push(parseInt(t.substr(r, 2), 16)); return s }, bytesToBase64: function (t) { for (var s = [], r = 0; r < t.length; r += 3)for (var n = t[r] << 16 | t[r + 1] << 8 | t[r + 2], o = 0; o < 4; o++)r * 8 + o * 6 <= t.length * 8 ? s.push(i.charAt(n >>> 6 * (3 - o) & 63)) : s.push("="); return s.join("") }, base64ToBytes: function (t) { t = t.replace(/[^A-Z0-9+\/]/ig, ""); for (var s = [], r = 0, n = 0; r < t.length; n = ++r % 4)n != 0 && s.push((i.indexOf(t.charAt(r - 1)) & Math.pow(2, -2 * n + 8) - 1) << n * 2 | i.indexOf(t.charAt(r)) >>> 6 - n * 2); return s } }; aD.exports = e })(); var cq = aD.exports, aC = { utf8: { stringToBytes: function (i) { return aC.bin.stringToBytes(unescape(encodeURIComponent(i))) }, bytesToString: function (i) { return decodeURIComponent(escape(aC.bin.bytesToString(i))) } }, bin: { stringToBytes: function (i) { for (var e = [], t = 0; t < i.length; t++)e.push(i.charCodeAt(t) & 255); return e }, bytesToString: function (i) { for (var e = [], t = 0; t < i.length; t++)e.push(String.fromCharCode(i[t])); return e.join("") } } }, lD = aC;/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */var hq = function (i) { return i != null && (cD(i) || uq(i) || !!i._isBuffer) }; function cD(i) { return !!i.constructor && typeof i.constructor.isBuffer == "function" && i.constructor.isBuffer(i) } function uq(i) { return typeof i.readFloatLE == "function" && typeof i.slice == "function" && cD(i.slice(0, 0)) } (function () { var i = cq, e = lD.utf8, t = hq, s = lD.bin, r = function (n, o) { n.constructor == String ? o && o.encoding === "binary" ? n = s.stringToBytes(n) : n = e.stringToBytes(n) : t(n) ? n = Array.prototype.slice.call(n, 0) : !Array.isArray(n) && n.constructor !== Uint8Array && (n = n.toString()); for (var a = i.bytesToWords(n), l = n.length * 8, c = 1732584193, h = -271733879, d = -1732584194, p = 271733878, f = 0; f < a.length; f++)a[f] = (a[f] << 8 | a[f] >>> 24) & 16711935 | (a[f] << 24 | a[f] >>> 8) & 4278255360; a[l >>> 5] |= 128 << l % 32, a[(l + 64 >>> 9 << 4) + 14] = l; for (var g = r._ff, m = r._gg, v = r._hh, A = r._ii, f = 0; f < a.length; f += 16) { var b = c, y = h, _ = d, w = p; c = g(c, h, d, p, a[f + 0], 7, -680876936), p = g(p, c, h, d, a[f + 1], 12, -389564586), d = g(d, p, c, h, a[f + 2], 17, 606105819), h = g(h, d, p, c, a[f + 3], 22, -1044525330), c = g(c, h, d, p, a[f + 4], 7, -176418897), p = g(p, c, h, d, a[f + 5], 12, 1200080426), d = g(d, p, c, h, a[f + 6], 17, -1473231341), h = g(h, d, p, c, a[f + 7], 22, -45705983), c = g(c, h, d, p, a[f + 8], 7, 1770035416), p = g(p, c, h, d, a[f + 9], 12, -1958414417), d = g(d, p, c, h, a[f + 10], 17, -42063), h = g(h, d, p, c, a[f + 11], 22, -1990404162), c = g(c, h, d, p, a[f + 12], 7, 1804603682), p = g(p, c, h, d, a[f + 13], 12, -40341101), d = g(d, p, c, h, a[f + 14], 17, -1502002290), h = g(h, d, p, c, a[f + 15], 22, 1236535329), c = m(c, h, d, p, a[f + 1], 5, -165796510), p = m(p, c, h, d, a[f + 6], 9, -1069501632), d = m(d, p, c, h, a[f + 11], 14, 643717713), h = m(h, d, p, c, a[f + 0], 20, -373897302), c = m(c, h, d, p, a[f + 5], 5, -701558691), p = m(p, c, h, d, a[f + 10], 9, 38016083), d = m(d, p, c, h, a[f + 15], 14, -660478335), h = m(h, d, p, c, a[f + 4], 20, -405537848), c = m(c, h, d, p, a[f + 9], 5, 568446438), p = m(p, c, h, d, a[f + 14], 9, -1019803690), d = m(d, p, c, h, a[f + 3], 14, -187363961), h = m(h, d, p, c, a[f + 8], 20, 1163531501), c = m(c, h, d, p, a[f + 13], 5, -1444681467), p = m(p, c, h, d, a[f + 2], 9, -51403784), d = m(d, p, c, h, a[f + 7], 14, 1735328473), h = m(h, d, p, c, a[f + 12], 20, -1926607734), c = v(c, h, d, p, a[f + 5], 4, -378558), p = v(p, c, h, d, a[f + 8], 11, -2022574463), d = v(d, p, c, h, a[f + 11], 16, 1839030562), h = v(h, d, p, c, a[f + 14], 23, -35309556), c = v(c, h, d, p, a[f + 1], 4, -1530992060), p = v(p, c, h, d, a[f + 4], 11, 1272893353), d = v(d, p, c, h, a[f + 7], 16, -155497632), h = v(h, d, p, c, a[f + 10], 23, -1094730640), c = v(c, h, d, p, a[f + 13], 4, 681279174), p = v(p, c, h, d, a[f + 0], 11, -358537222), d = v(d, p, c, h, a[f + 3], 16, -722521979), h = v(h, d, p, c, a[f + 6], 23, 76029189), c = v(c, h, d, p, a[f + 9], 4, -640364487), p = v(p, c, h, d, a[f + 12], 11, -421815835), d = v(d, p, c, h, a[f + 15], 16, 530742520), h = v(h, d, p, c, a[f + 2], 23, -995338651), c = A(c, h, d, p, a[f + 0], 6, -198630844), p = A(p, c, h, d, a[f + 7], 10, 1126891415), d = A(d, p, c, h, a[f + 14], 15, -1416354905), h = A(h, d, p, c, a[f + 5], 21, -57434055), c = A(c, h, d, p, a[f + 12], 6, 1700485571), p = A(p, c, h, d, a[f + 3], 10, -1894986606), d = A(d, p, c, h, a[f + 10], 15, -1051523), h = A(h, d, p, c, a[f + 1], 21, -2054922799), c = A(c, h, d, p, a[f + 8], 6, 1873313359), p = A(p, c, h, d, a[f + 15], 10, -30611744), d = A(d, p, c, h, a[f + 6], 15, -1560198380), h = A(h, d, p, c, a[f + 13], 21, 1309151649), c = A(c, h, d, p, a[f + 4], 6, -145523070), p = A(p, c, h, d, a[f + 11], 10, -1120210379), d = A(d, p, c, h, a[f + 2], 15, 718787259), h = A(h, d, p, c, a[f + 9], 21, -343485551), c = c + b >>> 0, h = h + y >>> 0, d = d + _ >>> 0, p = p + w >>> 0 } return i.endian([c, h, d, p]) }; r._ff = function (n, o, a, l, c, h, d) { var p = n + (o & a | ~o & l) + (c >>> 0) + d; return (p << h | p >>> 32 - h) + o }, r._gg = function (n, o, a, l, c, h, d) { var p = n + (o & l | a & ~l) + (c >>> 0) + d; return (p << h | p >>> 32 - h) + o }, r._hh = function (n, o, a, l, c, h, d) { var p = n + (o ^ a ^ l) + (c >>> 0) + d; return (p << h | p >>> 32 - h) + o }, r._ii = function (n, o, a, l, c, h, d) { var p = n + (a ^ (o | ~l)) + (c >>> 0) + d; return (p << h | p >>> 32 - h) + o }, r._blocksize = 16, r._digestsize = 16, oD.exports = function (n, o) { if (n == null) throw new Error("Illegal argument " + n); var a = i.wordsToBytes(r(n, o)); return o && o.asBytes ? a : o && o.asString ? s.bytesToString(a) : i.bytesToHex(a) } })(); var dq = oD.exports; const pq = y0(dq); class lC { constructor(e, t, s, r) { u(this, "success"), u(this, "filename"), u(this, "hash"), u(this, "size"), u(this, "url"), this.success = e, this.filename = t, this.hash = s, this.size = r } } async function hD(i, e) { const t = await i.arrayBuffer(), s = cC(t), r = i.name.split(".").pop(), n = s + "." + r, o = i.name.split(".").shift(); console.assert(o !== void 0); const a = { alias: o, filename: n }, l = await (await fetch(e + "/exists", { method: "POST", body: JSON.stringify(a) })).json(); if (l.success || console.warn("exists check did fail"), l.exists) return console.log("file already exists", s), new lC(!0, n, s, i.size); console.log("begin uploading file", o, i.size); const c = new FormData; c.append("file", i); const h = {}; h.filesize = i.size, o && (h.alias = o); const d = await (await fetch(e + "/upload/file", { method: "POST", body: c, headers: h })).json(); if (d?.success === !1) return d.message !== void 0 ? console.error("Upload failed:", d.message) : console.error("Upload failed"), null; console.assert(d.hash_sum === s, "hash sum did not match", "received:", d.hash_sum, "expected:", s), d.success && console.log("successfully uploaded", s, d.id); const p = new lC(d.success, n, s, i.size); return p.url = e, p } function cC(i) { return pq(new Uint8Array(i)) } async function hC(i, e, t, s, r = !1) { try { const n = await fetch(s + "/download/file", { method: "POST", body: i }); if (n.status !== 200) return console.error("download failed", n), null; const o = await n.blob(), a = await o.arrayBuffer(); r || console.assert(o.size === t, "size mismatch", "expected:", t, "got:", o.size); const l = cC(a); return r || console.assert(l === e, "hash mismatch, downloaded file is invalid"), o.arrayBuffer() } catch (n) { console.error(n) } return null } async function uD(i, e) { var t; const s = await fetch(i), r = (t = s.body) == null ? void 0 : t.getReader(), n = s.headers.get("Content-Length"), o = n ? parseInt(n) : 0; if (!r) return null; let a = 0, l = []; for (; ;) { const { done: d, value: p } = await r.read(); if (p && (l.push(p), a += p.length, e.call(null, new ProgressEvent("progress", { loaded: a, total: o }))), d) break } const c = new Uint8Array(a); let h = 0; for (let d of l) c.set(d, h), h += d.length; return c } let dD, pD = null; function fo() { return dD } function uC(i) { if (i == null) { console.warn("Oh no: someone tried registering a non-existend gltf-loader. When you see this log it might mean that needle-engine is being imported multiple times. Please check your project setup."); return } pD !== i && (pD = i, dD = new i) } const nc = oe("debugaddressables"); class fD { constructor(e) { u(this, "_context"), u(this, "_assetReferences", {}), this._context = e, this._context.pre_update_callbacks.push(this.preUpdate.bind(this)) } preUpdate() { } findAssetReference(e) { return this._assetReferences[e] || null } registerAssetReference(e) { return e.uri && (this._assetReferences[e.uri] ? console.warn("Asset reference already registered", e) : this._assetReferences[e.uri] = e), e } } const Ag = class { constructor(i, e, t = null) { u(this, "_loading"), u(this, "_asset"), u(this, "_glbRoot"), u(this, "_url"), u(this, "_progressListeners", []), u(this, "_hash"), u(this, "_hashedUri"), u(this, "_isLoadingRawBinary", !1), u(this, "_rawBinary"), this._url = i, this._hash = e, i.includes("?v=") ? this._hashedUri = i : this._hashedUri = e ? i + "?v=" + e : i, t !== null && (this.asset = t), r2(this._url, this.onResolvePrefab.bind(this)) } static getOrCreate(i, e, t) { const s = Pl(i, e); nc && console.log("GetOrCreate Addressable from", i, e, "FinalPath=", s); const r = t.addressables, n = r.findAssetReference(s); if (n) return n; const o = new Ag(s, t.hash); return r.registerAssetReference(o), o } get asset() { return this._glbRoot ?? this._asset } set asset(i) { this._asset = i } get uri() { return this._url } get rawAsset() { return this._asset } async onResolvePrefab(i) { return i === this.uri && (this.mustLoad && await this.loadAssetAsync(), this.asset) ? this.asset : null } get mustLoad() { return !this.asset || this.asset.__destroyed === !0 || W1(this.asset) === !0 } isLoaded() { return this._rawBinary || this.asset !== void 0 } unload() { this.asset && (nc && console.log("Unload", this.asset), this.asset.scene ? ic(this.asset.scene, !0, !0) : ic(this.asset, !0, !0)), this.asset = null, this._rawBinary = void 0 } async preload() { if (!this.mustLoad || this._isLoadingRawBinary) return null; if (this._rawBinary !== void 0) return this._rawBinary; this._isLoadingRawBinary = !0, nc && console.log("Preload", this._hashedUri); const i = await uD(this._hashedUri, e => { this.raiseProgressEvent(e) }); return this._rawBinary = i?.buffer ?? null, this._isLoadingRawBinary = !1, this._rawBinary } async loadAssetAsync(i) { if (nc && console.log("loadAssetAsync", this.uri), !this.mustLoad) return this.asset; if (i && this._progressListeners.push(i), this._loading !== void 0) return this._loading; const e = _t.Current; this._rawBinary ? (this._loading = fo().parseSync(e, this._rawBinary, this.uri, null), this.raiseProgressEvent(new ProgressEvent("progress", { loaded: this._rawBinary.byteLength, total: this._rawBinary.byteLength }))) : (nc && console.log("Load async", this.uri), this._loading = fo().loadSync(e, this._hashedUri, this.uri, null, s => { this.raiseProgressEvent(s) })); const t = await this._loading; if (this._progressListeners.length = 0, this._glbRoot = this.tryGetActualGameObjectRoot(t), this._loading = void 0, t) return pg(e), t.scene !== void 0 && (this.asset = t), this.asset } async instantiate(i) { return this.onInstantiate(i, !1) } async instantiateSynced(i, e = !0) { return this.onInstantiate(i, !0, e) } beginListenDownload(i) { this._progressListeners.indexOf(i) < 0 && this._progressListeners.push(i) } endListenDownload(i) { const e = this._progressListeners.indexOf(i); e >= 0 && this._progressListeners.splice(e, 1) } raiseProgressEvent(i) { for (const e of this._progressListeners) e(this, i) } async onInstantiate(i, e = !1, t) { const s = _t.Current; if (i || (i = s.scene), this.mustLoad && await this.loadAssetAsync(), nc && console.log("Instantiate", this.uri, "parent:", i), this.asset) { nc && console.log("Add to scene", this.asset); let r = i instanceof No ? i : null; r || (r = new No), typeof i == "object" && (i instanceof Me ? r.parent = i : Object.assign(r, i)); let n = Ag.currentlyInstantiating.get(this.uri); if (n !== void 0 && n >= 1e4) return console.error("Recursive or too many instantiations of " + this.uri + " in the same frame (" + n + ")"), null; try { if (n === void 0 && (n = 0), n += 1, Ag.currentlyInstantiating.set(this.uri, n), e) { r.context = s; const o = this.asset; o.guid = this.uri; const a = z1(o, r, void 0, t); if (a) return a } else { const o = dg(this.asset, r); if (o) return o } } finally { s.post_render_callbacks.push(() => { n === void 0 || n < 0 ? n = 0 : n -= 1, Ag.currentlyInstantiating.set(this.uri, n) }) } } else nc && console.warn("Failed to load asset", this.uri); return null } tryGetActualGameObjectRoot(i) { if (i && i.scene) { const e = i.scene; return e.isGroup && e.children.length === 1 && e.children[0].name + "glb" === e.name ? e.children[0] : e } return null } }; let or = Ag; u(or, "currentlyInstantiating", new Map); class fq extends $l { constructor() { super([or]) } onSerialize(e, t) { if (e && e.uri !== void 0 && typeof e.uri == "string") return e.uri } onDeserialize(e, t) { if (typeof e == "string") return t.context ? t.gltfId ? or.getOrCreate(t.gltfId, e, t.context) : (console.error("Missing source id"), null) : (console.error("Missing context"), null); if (e instanceof Me) { if (!t.context) return console.error("Missing context"), null; if (!t.gltfId) return console.error("Missing source id"), null; const s = e, r = t.context, n = s.guid ?? s.uuid, o = r.addressables.findAssetReference(n); if (o) return o; const a = new or(n, void 0, s); return r.addressables.registerAssetReference(a), a } return null } } new fq; const gq = Promise.resolve(null), ry = class { constructor(i) { u(this, "url"), u(this, "_bitmap"), u(this, "_bitmapObject"), u(this, "loader", null), this.url = i } static getOrCreate(i) { let e = ry.imageReferences.get(i); return e || (e = new ry(i), ry.imageReferences.set(i, e)), e } dispose() { this._bitmapObject && this._bitmapObject.close(), this._bitmap = void 0 } createHTMLImage() { const i = new Image; return i.src = this.url, i } createTexture() { return this.url ? (this.loader || (this.loader = new Yl), this.loader.setCrossOrigin("anonymous"), this.loader.loadAsync(this.url)) : gq } getBitmap() { return this._bitmap ? this._bitmap : (this._bitmap = new Promise((i, e) => { const t = document.createElement("img"); t.addEventListener("load", () => { this._bitmap = createImageBitmap(t).then(s => (this._bitmapObject = s, i(s), s)) }), t.addEventListener("error", s => { console.error("Failed to load image:" + this.url, s), i(null) }), t.src = this.url }), this._bitmap) } }; let ny = ry; u(ny, "imageReferences", new Map); class gD extends $l { constructor() { super([ny]) } onSerialize(e, t) { return null } onDeserialize(e, t) { if (typeof e == "string") { const s = Pl(t.gltfId, e); return ny.getOrCreate(s) } } } new gD; const Tn = oe("debugenvlight"); var xd = (i => (i[i.Skybox = 0] = "Skybox", i[i.Trilight = 1] = "Trilight", i[i.Flat = 3] = "Flat", i[i.Custom = 4] = "Custom", i))(xd || {}), oy = (i => (i[i.Skybox = 0] = "Skybox", i[i.Custom = 1] = "Custom", i))(oy || {}); class mD { constructor(e) { u(this, "context"), u(this, "_currentLightSettingsId"), u(this, "_sceneLightSettings"), u(this, "_timevec4", new st), u(this, "__currentReflectionId", null), u(this, "_waitPromise"), u(this, "_lighting", {}), this.context = e, this.context.pre_update_callbacks.push(this.preUpdate.bind(this)) } preUpdate() { const e = this.context.time; this._timevec4.x = e.time, this._timevec4.y = Math.sin(e.time), this._timevec4.z = Math.cos(e.time), this._timevec4.w = e.deltaTime } get timeVec4() { return this._timevec4 } get environmentIntensity() { if (!this._sceneLightSettings || !this._currentLightSettingsId) return 1; const e = this._sceneLightSettings.get(this._currentLightSettingsId); return e ? e.ambientIntensity : 1 } get sceneLightSettings() { var e; return (e = this._sceneLightSettings) == null ? void 0 : e.values() } enable(e) { var t; e instanceof or && (e = e.uri); const s = (t = this._sceneLightSettings) == null ? void 0 : t.get(e); return s ? (Tn && console.log("Enable scene light settings", e, s), e !== this._currentLightSettingsId && this._currentLightSettingsId && this.disable(this._currentLightSettingsId), this._currentLightSettingsId = e, s.enabled = !0, !0) : !1 } disable(e) { var t; if (e instanceof or && (e = e.uri), e == null) return !1; const s = (t = this._sceneLightSettings) == null ? void 0 : t.get(e); return s ? (Tn && console.log("Disable scene light settings", e, s), s.enabled = !1, !0) : !1 } disableCurrent() { if (this._currentLightSettingsId) { const e = this._currentLightSettingsId; return this.disable(this._currentLightSettingsId), e } return null } internalRegisterSceneLightSettings(e) { const t = e.sourceId; if (!t) { console.error("Missing source id for scene light settings, can not register:", e); return } Tn && console.log("Register " + e?.sourceId + " lighting", e), this._sceneLightSettings || (this._sceneLightSettings = new Map), this._sceneLightSettings.set(t, e) } internalUnregisterSceneLightSettings(e) { const t = e.sourceId; if (!t) { console.error("Missing source id for scene light settings, can not unregister:", e); return } Tn && console.log("Unregister " + e?.sourceId + " lighting", e), this._sceneLightSettings && this._sceneLightSettings.delete(t) } internalRegisterReflection(e, t) { Tn && console.log("Register reflection", e, t); const s = new vD(this.context, t, 1); this._lighting[e] = s } internalGetReflection(e) { return this._lighting[e] } internalEnableReflection(e) { var t; this.__currentReflectionId = e; const s = (t = this._sceneLightSettings) == null ? void 0 : t.get(e); switch (Tn && console.log("Enable reflection", e, s ? xd[s.ambientMode] : "Unknown ambient mode"), s?.ambientMode) { case 0: case 4: const r = this.internalGetReflection(e); if (r && r.Source) { Tn && console.log("Setting environment reflection", r); const n = this.context.scene, o = r.Source; o.encoding = Xe, o.mapping = An, n.environment = o; return } else Tn && console.warn("Could not find reflection for source", e); break }if (s?.environmentReflectionSource === 1) switch (s?.ambientMode) { case 1: if (s.ambientTrilight) { const r = s.ambientTrilight, n = nq(r[0], r[1], r[2], 64, 64); n.encoding = Xe, n.mapping = An, this.context.scene.environment = n } else console.error("Missing ambient trilight", s.sourceId); return; case 3: if (s.ambientLight) { const r = iD(s.ambientLight, 64); r.encoding = Xe, r.mapping = An, this.context.scene.environment = r } else console.error("Missing ambientlight", s.sourceId); return; default: return } } internalDisableReflection(e) { if (e && e !== this.__currentReflectionId) { Tn && console.log("Not disabling reflection for", e, "because it is not the current light settings id", this.__currentReflectionId); return } Tn && console.log("Disable reflection", e); const t = this.context.scene; t.environment = null } async internalGetSceneLightingData(e) { return Tn && console.log("GET SCENE LIGHT DATA", e), this._waitPromise ? this._waitPromise : (this._waitPromise = new Promise((t, s) => { let r = setInterval(async () => { const n = this.internalGetReflection(e); n && (clearInterval(r), t(n.getSphericalHarmonicsArray(this.environmentIntensity ?? 1))) }, 10) }), this._waitPromise) } } class vD { constructor(e, t, s = 1) { u(this, "_context"), u(this, "_source"), u(this, "_sphericalHarmonics", null), u(this, "_sphericalHarmonicsArray"), u(this, "_ambientScale", 1), u(this, "_lightProbe"), this._context = e, this._source = t, this._ambientScale = s, t.mapping = An, t.encoding = Xe } get Source() { return this._source } get Array() { return this._sphericalHarmonicsArray } getSphericalHarmonicsArray(e = 1) { var t; if ((t = this._sphericalHarmonicsArray) != null && t.length && this._source) return { array: this._sphericalHarmonicsArray, texture: this._source, lightProbe: this._lightProbe }; try { const s = this._source; let r = null; if (s) { Tn && console.log("GENERATING LIGHT PROBE", s, this.Source); const n = Math.min(s.image.width, 512); r = new bA(n).fromEquirectangularTexture(this._context.renderer, s) } if (this._sphericalHarmonicsArray = [], r) { const n = sq.fromCubeRenderTarget(this._context.renderer, r); this._lightProbe = n; const o = this._ambientScale * (e * e * Math.PI * .5) - 1; if (this._sphericalHarmonics = n.sh, this._sphericalHarmonicsArray = this._sphericalHarmonics.toArray(), this._sphericalHarmonicsArray) { const a = e / (Math.PI * .5); for (let l = 0; l < this._sphericalHarmonicsArray.length; l++)this._sphericalHarmonicsArray[l] *= a; if (n.sh.scale(o), this._source) return { array: this._sphericalHarmonicsArray, texture: this._source, lightProbe: n } } } } catch (s) { console.error(s) } return null } } var ay = (i => (i.Visible = "application-visible", i.Hidden = "application-hidden", i.MuteChanged = "application-mutechanged", i))(ay || {}); class AD extends EventTarget { constructor(e) { super(), u(this, "_mute", !1), u(this, "context"), u(this, "_isVisible", !0), this.context = e, window.addEventListener("visibilitychange", this.onVisiblityChanged.bind(this), !1) } get muted() { return this._mute } set muted(e) { e !== this._mute && (this._mute = e, this.dispatchEvent(new Event("application-mutechanged"))) } get hasFocus() { return document.hasFocus() } get isVisible() { return this._isVisible } onVisiblityChanged(e) { switch (e.target.visibilityState) { case "hidden": this._isVisible = !1, this.dispatchEvent(new Event("application-hidden")); break; case "visible": this._isVisible = !0, this.dispatchEvent(new Event("application-visible")); break } } } const yD = "NEEDLE_lightmaps", mq = oe("debuglightmapsextension"); var oc = (i => (i[i.Lightmap = 0] = "Lightmap", i[i.Skybox = 1] = "Skybox", i[i.Reflection = 2] = "Reflection", i))(oc || {}); class vq { constructor(e, t, s) { u(this, "parser"), u(this, "registry"), u(this, "source"), this.parser = e, this.registry = t, this.source = s } get name() { return yD } afterRoot(e) { const t = this.parser.json.extensions; if (t) { const s = t[yD]; if (s) { const r = s.textures; return r != null && r.length ? (mq && console.log(s), new Promise(async (n, o) => { const a = []; for (const l of r) if (l.pointer) { const c = h1(this.parser, l.pointer).then(h => { const d = h; d != null && d.isTexture && (this.registry ? (l.type !== 0 ? d.encoding = Xe : d.encoding = Qi, this.registry.registerTexture(this.source, l.type, d, l.index)) : console.log(oc[l.type], l.pointer, d)) }); a.push(c) } await Promise.all(a), n() })) : null } } return null } } const bD = !!oe("debuglightmaps"); class Aq { constructor(e) { u(this, "_context"), u(this, "_lightmaps", new Map), this._context = e } registerTexture(e, t, s, r) { bD && console.log("Registering ", oc[t] + ' "' + e + '"', s), this._lightmaps.has(e) || this._lightmaps.set(e, new Map); const n = this._lightmaps.get(e), o = n?.get(t) ?? []; o.length < r && (o.length = r + 1), o[r] = s, n?.set(t, o) } tryGetLightmap(e, t = 0) { return this.tryGet(e, oc.Lightmap, t) } tryGetSkybox(e) { return this.tryGet(e, oc.Skybox, 0) } tryGetReflection(e) { return this.tryGet(e, oc.Reflection, 0) } tryGet(e, t, s) { var r; if (!e) return bD && console.warn("Missing source id"), null; const n = ((r = this._lightmaps.get(e)) == null ? void 0 : r.get(t)) ?? null; return !(n != null && n.length) || n.length <= s ? null : n[s] } } Mt.lights_fragment_maps = Mt.lights_fragment_maps.replace("vec4 lightMapTexel = texture2D( lightMap, vUv2 );", `

    vec2 lUv = vUv2.xy * lightmapScaleOffset.xy + vec2(lightmapScaleOffset.z, (1. - (lightmapScaleOffset.y + lightmapScaleOffset.w)));
    vec4 lightMapTexel = texture2D( lightMap, lUv);
    // The range of RGBM lightmaps goes from 0 to 34.49 (5^2.2) in linear space, and from 0 to 5 in gamma space.
    lightMapTexel.rgb *= lightMapTexel.a * 8.; // no idea where that "8" comes from... heuristically derived
    lightMapTexel.a = 1.;
    lightMapTexel = conv_sRGBToLinear(lightMapTexel);
    `), Mt.lightmap_pars_fragment = `
    #ifdef USE_LIGHTMAP
        uniform sampler2D lightMap;
        uniform float lightMapIntensity;
        uniform vec4 lightmapScaleOffset;
        
        // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
        vec4 conv_sRGBToLinear( in vec4 value ) {
            return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
        }
    #endif
    `, Mt.lights_fragment_begin = Mt.lights_fragment_begin.replace("irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );", `
#if defined(USE_LIGHTMAP)
irradiance += 0.;
#else
irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
#endif`), Ye.lightmap.lightmapScaleOffset = { value: new st(1, 1, 0, 0) }; const yq = oe("debugplayerview"); var jo = (i => (i.Browser = "browser", i.Headset = "headset", i.Handheld = "handheld", i))(jo || {}); class _D { constructor(e, t) { u(this, "userId"), u(this, "context"), u(this, "viewDevice", "browser"), u(this, "removed", !1), u(this, "_object"), this.userId = e, this.context = t } get currentObject() { return this._object } set currentObject(e) { this._object = e } get isConnected() { return this.context.connection.userIsInRoom(this.userId) } } class xD { constructor(e) { u(this, "context"), u(this, "playerViews", new Map), this.context = e } setPlayerView(e, t, s) { let r = this.playerViews.get(e); r || (r = new _D(e, this.context), this.playerViews.set(e, r)), r.viewDevice = s, r.currentObject = t, r.removed = !1 } getPlayerView(e) { if (!!e) { if (!this.context.connection.userIsInRoom(e)) { this.playerViews.delete(e); return } return this.playerViews.get(e) } } removePlayerView(e, t) { const s = this.playerViews.get(e); s?.viewDevice === t && (yq && console.log("REMOVE", e), s.removed = !0, this.playerViews.delete(e)) } } const bq = oe("debugSetup"), _q = oe("stats"), xq = oe("debugactive"), wq = oe("debugframerate"), Cq = oe("debugcoroutine"), Sq = {}; class Eq { constructor(e) { u(this, "name"), u(this, "alias"), u(this, "domElement"), u(this, "renderer"), u(this, "hash"), this.domElement = e ?? document.body } } var on = (i => (i[i.EarlyUpdate = 0] = "EarlyUpdate", i[i.Update = 1] = "Update", i[i.LateUpdate = 2] = "LateUpdate", i[i.OnBeforeRender = 3] = "OnBeforeRender", i[i.OnAfterRender = 4] = "OnAfterRender", i[i.PrePhysicsStep = 9] = "PrePhysicsStep", i[i.PostPhysicsStep = 10] = "PostPhysicsStep", i[i.Undefined = -1] = "Undefined", i))(on || {}), yg = (i => (i.ImmersiveVR = "immersive-vr", i.ImmersiveAR = "immersive-ar", i))(yg || {}); function ly(i, e) { if (!i) return; const t = e?.new_scripts ?? _t.Current.new_scripts; t.includes(i) || t.push(i) } class _t { constructor(e) { u(this, "name"), u(this, "alias"), u(this, "isManagedExternally", !1), u(this, "isPaused", !1), u(this, "runInBackground", !1), u(this, "targetFrameRate"), u(this, "hash"), u(this, "domElement"), u(this, "_resolutionScaleFactor", 1), u(this, "_boundingClientRectFrame", -1), u(this, "_boundingClientRect", null), u(this, "_domX"), u(this, "_domY"), u(this, "xrSessionMode"), u(this, "_xrFrame", null), u(this, "_currentFrameEvent", -1), u(this, "scene"), u(this, "renderer"), u(this, "composer", null), u(this, "scripts", []), u(this, "scripts_pausedChanged", []), u(this, "scripts_earlyUpdate", []), u(this, "scripts_update", []), u(this, "scripts_lateUpdate", []), u(this, "scripts_onBeforeRender", []), u(this, "scripts_onAfterRender", []), u(this, "scripts_WithCorroutines", []), u(this, "coroutines", {}), u(this, "mainCameraComponent"), u(this, "post_setup_callbacks", []), u(this, "pre_update_callbacks", []), u(this, "pre_render_callbacks", []), u(this, "post_render_callbacks", []), u(this, "new_scripts", []), u(this, "new_script_start", []), u(this, "new_scripts_pre_setup_callbacks", []), u(this, "new_scripts_post_setup_callbacks", []), u(this, "application"), u(this, "time"), u(this, "input"), u(this, "physics"), u(this, "connection"), u(this, "assets"), u(this, "mainLight", null), u(this, "sceneLighting"), u(this, "addressables"), u(this, "lightmaps"), u(this, "players"), u(this, "_sizeChanged", !1), u(this, "_isCreated", !1), u(this, "_isVisible", !1), u(this, "_stats", _q ? iq() : null), u(this, "_intersectionObserver", null), u(this, "_disposeCallbacks", []), u(this, "_cameraStack", []), u(this, "_onBeforeRenderListeners", new Map), u(this, "_onAfterRenderListeners", new Map), u(this, "_requireDepthTexture", !1), u(this, "_requireColorTexture", !1), u(this, "_renderTarget"), u(this, "_isRendering", !1), u(this, "_accumulatedTime", 0), u(this, "_framerateClock", new e0), u(this, "_wasPaused", !1), this.name = e?.name || "", this.alias = e?.alias, this.domElement = e?.domElement || document.body, this.hash = e?.hash, e != null && e.renderer ? (this.renderer = e.renderer, this.isManagedExternally = !0) : (this.renderer = new $u({ antialias: !0 }), this.renderer.toneMappingExposure = 1, this.renderer.toneMapping = fr, this.renderer.setClearColor(new xe("lightgrey"), 0), this.renderer.antialias = !0, this.renderer.alpha = !1, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = ix, this.renderer.setSize(this.domWidth, this.domHeight), this.renderer.outputEncoding = Xe, this.renderer.physicallyCorrectLights = !0), this.scene = new Cn, Zi.register(this), this.application = new AD(this), this.time = new MB, this.input = new dB(this), this.physics = new SB(this), this.connection = new Yk(this), this.assets = new v2, this.sceneLighting = new mD(this), this.addressables = new fD(this), this.lightmaps = new Aq(this), this.players = new xD(this); const t = () => this._sizeChanged = !0; window.addEventListener("resize", t), this._disposeCallbacks.push(() => window.removeEventListener("resize", t)); const s = new ResizeObserver(r => this._sizeChanged = !0); s.observe(this.domElement), this._disposeCallbacks.push(() => s.disconnect()), this._intersectionObserver = new IntersectionObserver(r => { this._isVisible = r[0].isIntersecting }), this._disposeCallbacks.push(() => { var r; return (r = this._intersectionObserver) == null ? void 0 : r.disconnect() }) } get version() { return $_ } static get Current() { return Zi.Current } static set Current(e) { Zi.Current = e } get resolutionScaleFactor() { return this._resolutionScaleFactor } set resolutionScaleFactor(e) { if (e !== this._resolutionScaleFactor && typeof e == "number") { if (e <= 0) { console.error("Invalid resolution scale factor", e); return } this._resolutionScaleFactor = e, this.updateSize() } } calculateBoundingClientRect() { if (this.isInAR) { this._domX = 0, this._domY = 0; return } this._boundingClientRectFrame !== this.time.frame && (this._boundingClientRectFrame = this.time.frame, this._boundingClientRect = this.domElement.getBoundingClientRect(), this._domX = this._boundingClientRect.x, this._domY = this._boundingClientRect.y) } get domWidth() { return this.isInAR ? window.innerWidth : this.domElement.clientWidth } get domHeight() { return this.isInAR ? window.innerHeight : this.domElement.clientHeight } get domX() { return this.calculateBoundingClientRect(), this._domX } get domY() { return this.calculateBoundingClientRect(), this._domY } get isInXR() { var e; return ((e = this.renderer.xr) == null ? void 0 : e.isPresenting) || !1 } get isInVR() { return this.xrSessionMode === "immersive-vr" } get isInAR() { return this.xrSessionMode === "immersive-ar" } get xrSession() { var e; return (e = this.renderer.xr) == null ? void 0 : e.getSession() } get xrFrame() { return this._xrFrame } get arOverlayElement() { const e = this.domElement; return typeof e.getAROverlayContainer == "function" ? e.getAROverlayContainer() : this.domElement } get currentFrameEvent() { return this._currentFrameEvent } get mainCamera() { if (this.mainCameraComponent) { const e = this.mainCameraComponent; return e.cam || e.buildCamera(), e.cam } return null } get rendererData() { return this.sceneLighting } get isCreated() { return this._isCreated } internalOnUpdateVisible() { var e, t; (e = this._intersectionObserver) == null || e.disconnect(), (t = this._intersectionObserver) == null || t.observe(this.domElement) } updateSize() { var e, t, s; if (!this.isManagedExternally && ((e = this.renderer.xr) == null ? void 0 : e.isPresenting) === !1) { this._sizeChanged = !1; const r = this.resolutionScaleFactor, n = this.domWidth * r, o = this.domHeight * r, a = this.mainCamera; this.updateAspect(a), this.renderer.setSize(n, o), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%", this.composer && ((t = this.composer.setSize) == null || t.call(this.composer, n, o), "setPixelRatio" in this.composer && typeof this.composer.setPixelRatio == "function" && ((s = this.composer.setPixelRatio) == null || s.call(this.composer, window.devicePixelRatio))) } } updateAspect(e, t, s) { if (!e) return; t === void 0 && (t = this.domWidth), s === void 0 && (s = this.domHeight); const r = e.aspect; e.aspect = t / s, r !== e.aspect && e.updateProjectionMatrix() } async onCreate(e, t) { return this._isCreated ? (console.warn("Context already created"), null) : (this._isCreated = !0, await nf(1), this.internalOnCreate(e, t)) } onDestroy() { var e, t, s; if (this._isCreated) { this._isCreated = !1, ic(this.scene, !0), (e = this.renderer) == null || e.setAnimationLoop(null), this.isManagedExternally || (t = this.renderer) == null || t.dispose(); for (const r of this._disposeCallbacks) try { r() } catch (n) { console.error("Error in on dispose callback:", n, r) } (s = this.domElement) != null && s.parentElement && this.domElement.parentElement.removeChild(this.domElement), Zi.dispatchCallback(Jr.ContextDestroyed, this), Zi.unregister(this) } } registerCoroutineUpdate(e, t, s) { return this.coroutines[s] || (this.coroutines[s] = []), this.coroutines[s].push({ comp: e, main: t }), t } unregisterCoroutineUpdate(e, t) { if (!this.coroutines[t]) return; const s = this.coroutines[t].findIndex(r => r.main === e); s >= 0 && this.coroutines[t].splice(s, 1) } stopAllCoroutinesFrom(e) { for (const t in this.coroutines) { const s = this.coroutines[t]; for (let r = s.length - 1; r >= 0; r--)s[r].comp === e && s.splice(r, 1) } } setCurrentCamera(e) { var t; if (!e) return; if (e.cam || e.buildCamera(), !e.cam) { console.warn("Camera component is missing camera", e); return } const s = this._cameraStack.indexOf(e); s >= 0 && this._cameraStack.splice(s, 1), this._cameraStack.push(e), this.mainCameraComponent = e; const r = e.cam; r.isPerspectiveCamera && this.updateAspect(r), (t = this.mainCameraComponent) == null || t.applyClearFlagsIfIsActiveCamera() } removeCamera(e) { if (!e) return; const t = this._cameraStack.indexOf(e); if (t >= 0 && this._cameraStack.splice(t, 1), this.mainCameraComponent === e && (this.mainCameraComponent = void 0, this._cameraStack.length > 0)) { const s = this._cameraStack[this._cameraStack.length - 1]; this.setCurrentCamera(s) } } addBeforeRenderListener(e, t) { var s; this._onBeforeRenderListeners.has(e.uuid) || (this._onBeforeRenderListeners.set(e.uuid, []), e.onBeforeRender = this._createRenderCallbackWrapper(e, this._onBeforeRenderListeners)), (s = this._onBeforeRenderListeners.get(e.uuid)) == null || s.push(t) } removeBeforeRenderListener(e, t) { if (this._onBeforeRenderListeners.has(e.uuid)) { const s = this._onBeforeRenderListeners.get(e.uuid), r = s.indexOf(t); r >= 0 && s.splice(r, 1) } } addAfterRenderListener(e, t) { var s; this._onAfterRenderListeners.has(e.uuid) || (this._onAfterRenderListeners.set(e.uuid, []), e.onAfterRender = this._createRenderCallbackWrapper(e, this._onAfterRenderListeners)), (s = this._onAfterRenderListeners.get(e.uuid)) == null || s.push(t) } removeAfterRenderListener(e, t) { if (this._onAfterRenderListeners.has(e.uuid)) { const s = this._onAfterRenderListeners.get(e.uuid), r = s.indexOf(t); r >= 0 && s.splice(r, 1) } } _createRenderCallbackWrapper(e, t) { return (s, r, n, o, a, l) => { const c = t.get(e.uuid); if (c) for (let h = 0; h < c.length; h++) { const d = c[h]; d(s, r, n, o, a, l) } } } get isRendering() { return this._isRendering } setRequireDepth(e) { this._requireDepthTexture = e } setRequireColor(e) { this._requireColorTexture = e } get depthTexture() { var e; return ((e = this._renderTarget) == null ? void 0 : e.depthTexture) || null } get opaqueColorTexture() { var e; return ((e = this._renderTarget) == null ? void 0 : e.texture) || null } get isVisibleToUser() { if (this.isInXR) return !0; if (!this._isVisible) return !1; const e = getComputedStyle(this.domElement); return e.visibility !== "hidden" && e.display !== "none" && e.opacity !== "0" } async internalOnCreate(e, t) { _t.Current = this, await Zi.dispatchCallback(Jr.ContextCreationStart, this); let s = !0; try { _t.Current = this, e && await e(this, t) } catch (r) { console.error(r), s = !1 } if (!s) return !1; this.internalOnUpdateVisible(), this.isManagedExternally || this.domElement.prepend(this.renderer.domElement), _t.Current = this, _t.Current = this; for (let r = 0; r < this.new_scripts.length; r++) { const n = this.new_scripts[r]; if (n.gameObject !== void 0 && n.gameObject !== null) { n.gameObject.userData === void 0 && (n.gameObject.userData = {}), n.gameObject.userData.components === void 0 && (n.gameObject.userData.components = []); const o = n.gameObject.userData.components; o.includes(n) || o.push(n) } } if (this.post_setup_callbacks) for (let r = 0; r < this.post_setup_callbacks.length; r++)_t.Current = this, await this.post_setup_callbacks[r](this); if (!this.mainCamera) { _t.Current = this; let r = null; Dh(this.scene, n => { const o = n; if (o != null && o.isCamera) { if (fg(o.gameObject), !o.activeAndEnabled) return; if (o.tag === "MainCamera") return r = o, !0; r = o } }), r ? this.setCurrentCamera(r) : (Zi.dispatchCallback(Jr.MissingCamera, this), !this.mainCamera && !this.isManagedExternally && console.warn("Missing camera in main scene", this)) } if (_t.Current = this, pg(this), !this.isManagedExternally && this.composer && this.mainCamera) { const r = new iy(this.scene, this.mainCamera); this.renderer.setSize(this.domWidth, this.domHeight), this.composer.addPass(r), this.composer.setSize(this.domWidth, this.domHeight) } return this._sizeChanged = !0, this._stats && (this._stats.showPanel(1), this.domElement.appendChild(this._stats.dom)), this.renderer.setAnimationLoop(this.render.bind(this)), bq && v0(this.scene, !0), Zi.dispatchCallback(Jr.ContextCreated, this) } render(e, t) { var s, r; if (this._xrFrame = t, this._currentFrameEvent = -1, this.isInXR === !1 && this.targetFrameRate !== void 0) { if (this._accumulatedTime += this._framerateClock.getDelta(), this._accumulatedTime < 1 / this.targetFrameRate) return; this._accumulatedTime = 0 } if ((s = this._stats) == null || s.begin(), _t.Current = this, !this.onHandlePaused()) { for (_t.Current = this, this.time.update(), wq && console.log("FPS", this.time.smoothedFps.toFixed(0)), pg(this), K0(this.scene), P2(this); this._cameraStack.length > 0 && (!this.mainCameraComponent || this.mainCameraComponent.destroyed);) { this._cameraStack.splice(this._cameraStack.length - 1, 1); const n = this._cameraStack[this._cameraStack.length - 1]; this.setCurrentCamera(n) } if (this.pre_update_callbacks) for (const n in this.pre_update_callbacks) this.pre_update_callbacks[n](); this._currentFrameEvent = 0; for (let n = 0; n < this.scripts_earlyUpdate.length; n++) { const o = this.scripts_earlyUpdate[n]; o.activeAndEnabled && o.earlyUpdate !== void 0 && (_t.Current = this, o.earlyUpdate()) } if (this.executeCoroutines(0), !this.onHandlePaused()) { this._currentFrameEvent = 1; for (let n = 0; n < this.scripts_update.length; n++) { const o = this.scripts_update[n]; o.activeAndEnabled && o.update !== void 0 && (_t.Current = this, o.update()) } if (this.executeCoroutines(1), !this.onHandlePaused()) { this._currentFrameEvent = 2; for (let n = 0; n < this.scripts_lateUpdate.length; n++) { const o = this.scripts_lateUpdate[n]; o.activeAndEnabled && o.lateUpdate !== void 0 && (_t.Current = this, o.lateUpdate()) } if (this.executeCoroutines(2), !this.onHandlePaused()) { if (this.physics.engine) { const n = this.time.deltaTime / 1; for (let o = 0; o < 1; o++)this._currentFrameEvent = 9, this.executeCoroutines(9), this.physics.engine.step(n), this._currentFrameEvent = 10, this.executeCoroutines(10); this.physics.engine.postStep() } if (!this.onHandlePaused()) { if (this.isVisibleToUser) { this._currentFrameEvent = 3; for (let n = 0; n < this.scripts_onBeforeRender.length; n++) { const o = this.scripts_onBeforeRender[n]; o.activeAndEnabled && o.onBeforeRender !== void 0 && (_t.Current = this, o.onBeforeRender(t)) } if (this.executeCoroutines(3), this._sizeChanged && this.updateSize(), this.pre_render_callbacks) for (const n in this.pre_render_callbacks) this.pre_render_callbacks[n](); this.isManagedExternally || (o9(this), this._currentFrameEvent = -1, this.renderNow(), this._currentFrameEvent = 4); for (let n = 0; n < this.scripts_onAfterRender.length; n++) { const o = this.scripts_onAfterRender[n]; o.activeAndEnabled && o.onAfterRender !== void 0 && (_t.Current = this, o.onAfterRender()) } if (this.executeCoroutines(4), this.post_render_callbacks) for (const n in this.post_render_callbacks) this.post_render_callbacks[n]() } this._currentFrameEvent = -1, this.connection.sendBufferedMessagesNow(), (r = this._stats) == null || r.end(), this.time.frame === 1 && this.domElement.dispatchEvent(new CustomEvent("ready")) } } } } } } renderNow(e) { return !e && (e = this.mainCamera, !e) ? !1 : (this._isRendering = !0, this.renderRequiredTextures(), this.composer && !this.isInXR ? this.composer.render(this.time.deltaTime) : e && this.renderer.render(this.scene, e), this._isRendering = !1, !0) } onHandlePaused() { const e = this.evaluatePaused(); if (this._wasPaused !== e) { xq && console.log("Paused?", e, "context:" + this.alias); for (let t = 0; t < this.scripts_pausedChanged.length; t++) { const s = this.scripts_pausedChanged[t]; s.activeAndEnabled && s.onPausedChanged !== void 0 && (_t.Current = this, s.onPausedChanged(e, this._wasPaused)) } } return this._wasPaused = e, e } evaluatePaused() { return this.isInXR ? !1 : this.isPaused ? !0 : this.runInBackground ? !1 : !this.isVisibleToUser } renderRequiredTextures() { if (!this.mainCamera || !this._requireDepthTexture && !this._requireColorTexture) return; if (!this._renderTarget) { if (this._renderTarget = new ri(this.domWidth, this.domHeight), this._requireDepthTexture) { const s = new IA(this.domWidth, this.domHeight); this._renderTarget.depthTexture = s } this._requireColorTexture && (this._renderTarget.texture = new Nt, this._renderTarget.texture.generateMipmaps = !1, this._renderTarget.texture.minFilter = Zt, this._renderTarget.texture.magFilter = Zt, this._renderTarget.texture.format = _i) } const e = this._renderTarget; e.texture && (e.texture.encoding = this.renderer.outputEncoding); const t = this.renderer.getRenderTarget(); this.renderer.setRenderTarget(e), this.renderer.render(this.scene, this.mainCamera), this.renderer.setRenderTarget(t) } executeCoroutines(e) { if (this.coroutines[e]) { const s = this.coroutines[e]; for (let r = 0; r < s.length; r++)try { const n = s[r]; if (!n.comp || n.comp.destroyed || !n.main || n.comp.enabled === !1) { Cq && console.log("Removing coroutine", n.comp, n.comp.enabled), s.splice(r, 1), --r; continue } const o = n.chained; if (o && o.length > 0) { const c = o[o.length - 1].next(); if (c.done && o.pop(), t(c) && (n.chained || (n.chained = []), n.chained.push(c.value)), !c.done) continue } const a = n.main.next(); if (a.done === !0) { s.splice(r, 1), --r; continue } const l = a.value; if (t(l)) { if (l.next().done) continue; n.chained || (n.chained = []), n.chained.push(l) } } catch (n) { console.error(n) } } function t(s) { return !!(s && s.next && s.return) } } } const Mq = oe("debugaroverlay"), Lh = "ar", wD = "quit-ar"; class Iq { constructor() { u(this, "arContainer", null), u(this, "closeARCallback"), u(this, "currentSession", null), u(this, "registeredCloseEventElements", []), u(this, "_createdAROnlyElements", []), u(this, "_reparentedObjects", []), this.closeARCallback = this.onRequestedEndAR.bind(this) } get ARContainer() { return this.arContainer } requestEndAR() { this.onRequestedEndAR() } onBegin(e, t, s) { this.currentSession = s, this.arContainer = t, e.domElement.querySelectorAll(`.${Lh}`).forEach(n => { var o; n && n !== this.arContainer && (this._reparentedObjects.push({ el: n, previousParent: n.parentElement }), (o = this.arContainer) == null || o.appendChild(n)) }); const r = t.getElementsByClassName(wD); if (!r || r.length <= 0) console.warn(`Missing quit AR elements, creating fallback X button. Use class name '${wD}' to override.`), this.createFallbackCloseARButton(this.arContainer); else for (let n = 0; n < r.length; n++) { const o = r[n]; o && (o.addEventListener("click", this.closeARCallback), this.registeredCloseEventElements.push(o)) } } onEnd(e) { var t; for (const s of this._createdAROnlyElements) s.remove && s.remove(); for (const s of this._reparentedObjects) { const r = s.el; (t = s.previousParent) == null || t.appendChild(r) } this._reparentedObjects.length = 0, X_() && setTimeout(() => { const s = e.renderer.domElement; s && e.domElement.insertBefore(s, e.domElement.firstChild); const r = document.querySelectorAll("*"); for (var n = 0; n < r.length; n++) { const o = r[n]; o && o._displayChanged !== void 0 && o._displayWas !== void 0 && (o.style.display = o._displayWas) } }, 10) } findOrCreateARContainer(e) { if (e.classList.contains(Lh)) return e; if (e.children) for (let r = 0; r < e.children.length; r++) { const n = e.children[r]; if (!(!n || !n.classList) && n.classList.contains(Lh)) return n } const t = document.getElementsByClassName(Lh); if (t && t.length > 0) return t[0]; Mq && console.log("No overlay container found in document - generating new ony"); const s = document.createElement("div"); return s.classList.add(Lh), s.style.position = "absolute", s.style.width = "100%", s.style.height = "100%", s.style.display = "flex", s.style.visibility = "visible", e.appendChild(s) } onRequestedEndAR() { if (this.currentSession) { this.currentSession.end(), this.currentSession = null; for (const e of this.registeredCloseEventElements) e.removeEventListener("click", this.closeARCallback); this.registeredCloseEventElements.length = 0 } } createFallbackCloseARButton(e) { var t = document.createElementNS("http://www.w3.org/2000/svg", "svg"); t.setAttribute("width", "38px"), t.setAttribute("height", "38px"), t.style.position = "absolute", t.style.right = "20px", t.style.top = "40px", t.style.zIndex = "9999", t.style.pointerEvents = "auto", t.addEventListener("click", this.closeARCallback), e.appendChild(t), this._createdAROnlyElements.push(t); var s = document.createElementNS("http://www.w3.org/2000/svg", "path"); s.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), s.setAttribute("stroke", "#ddd"), s.setAttribute("stroke-width", "3px"), t.appendChild(s), this._createdAROnlyElements.push(s) } } class $ extends Me { constructor() { super(...arguments), u(this, "guid") } static isDestroyed(e) { return W1(e) } static setActive(e, t, s = !0) { e && (hg(e, t), K0(e), t && s && P2(_t.Current, e)) } static isActiveSelf(e) { return Ad(e) } static isActiveInHierarchy(e) { return w2(e) } static markAsInstancedRendered(e, t) { C2(e, t) } static isUsingInstancing(e) { return J0(e) } static foreachComponent(e, t, s = !0) { return Dh(e, t, s) } static instantiateSynced(e, t) { return e ? z1(e, t) : null } static instantiate(e, t = null) { return dg(e, t) } static destroySynced(e, t, s = !0) { if (!e) return; const r = e; t = t ?? _t.Current, Q0(r, t.connection, s) } static destroy(e, t = !0, s = !0) { return ic(e, t, s) } static add(e, t, s) { if (!(!e || !t)) { if (e === t) { console.warn("Can not add object to self", e); return } s || (s = _t.Current), t.add(e), hg(e, !0), K0(e), s ? $.foreachComponent(e, r => { X1(r, s), !r.__internalDidAwakeAndStart && s.new_script_start.includes(r) === !1 && s.new_script_start.push(r) }, !0) : console.warn("Missing context") } } static remove(e) { var t; e && ((t = e.parent) == null || t.remove(e), hg(e, !1), K0(e), $.foreachComponent(e, s => { r9(s) }, !0)) } static invokeOnChildren(e, t, ...s) { this.invoke(e, t, !0, s) } static invoke(e, t, s = !1, ...r) { e && this.foreachComponent(e, n => { const o = n[t]; o && typeof o == "function" && o?.call(n, ...r) }, s) } static addNewComponent(e, t, s = !0) { const r = new t; return tc(e, r, s), r } static addComponent(e, t) { return this.moveComponent(e, t) } static moveComponent(e, t) { H1(e, t) } static removeComponent(e) { return Q1(e.gameObject, e), e } static getOrAddComponent(e, t) { return G1(e, t) } static getComponent(e, t) { return e === null ? null : md(e, t) } static getComponents(e, t, s = null) { return e === null ? s ?? [] : rg(e, t, s) } static findByGuid(e, t) { return ug(e, t) } static findObjectOfType(e, t, s = !0) { return d2(e, t ?? _t.Current, s) } static findObjectsOfType(e, t) { const s = []; return p2(e, s, t), s } static getComponentInChildren(e, t) { return vd(e, t) } static getComponentsInChildren(e, t, s = null) { return ng(e, t, s ?? void 0) } static getComponentInParent(e, t) { return og(e, t) } static getComponentsInParent(e, t, s = null) { return H0(e, t, s) } static getAllComponents(e) { var t; return [...(t = e.userData) == null ? void 0 : t.components] } static *iterateComponents(e) { var t; const s = (t = e?.userData) == null ? void 0 : t.components; if (s && Array.isArray(s)) for (let r = 0; r < s.length; r++)yield s[r] } } var is; let ac = (is = class { constructor() { u(this, "__context"), u(this, "__name"), u(this, "gameObject"), u(this, "guid", "invalid"), u(this, "sourceId"), u(this, "__didAwake", !1), u(this, "__didStart", !1), u(this, "__didEnable", !1), u(this, "__isEnabled"), u(this, "__destroyed", !1), u(this, "_worldPosition"), u(this, "_worldQuaternion"), u(this, "_worldEuler"), u(this, "_worldRotation"), u(this, "_eventListeners", new Map), this.__internalNewInstanceCreated() } get isComponent() { return !0 } get context() { return this.__context ?? _t.Current } set context(i) { this.__context = i } get scene() { return this.context.scene } get layer() { var i, e; return (e = (i = this.gameObject) == null ? void 0 : i.userData) == null ? void 0 : e.layer } get name() { var i; return (i = this.gameObject) == null ? void 0 : i.userData.name } set name(i) { this.gameObject ? (this.gameObject.userData || (this.gameObject.userData = {}), this.gameObject.userData.name = i, this.__name = i) : this.__name = i } get tag() { var i; return (i = this.gameObject) == null ? void 0 : i.userData.tag } set tag(i) { this.gameObject && (this.gameObject.userData.tag = i) } get static() { var i; return (i = this.gameObject) == null ? void 0 : i.userData.static } get hideFlags() { var i; return (i = this.gameObject) == null ? void 0 : i.userData.hideFlags } get activeAndEnabled() { return !(this.destroyed || this.__isEnabled === !1 || !this.__isActiveInHierarchy) } get __isActive() { return this.gameObject.visible } get __isActiveInHierarchy() { if (!this.gameObject) return !1; const i = this.gameObject[Ma]; return i === void 0 ? !0 : i } set __isActiveInHierarchy(i) { this.gameObject && (this.gameObject[Ma] = i) } awake() { } onEnable() { } onDisable() { } onDestroy() { this.__destroyed = !0 } startCoroutine(i, e = on.Update) { return this.context.registerCoroutineUpdate(this, i, e) } stopCoroutine(i, e = on.Update) { this.context.unregisterCoroutineUpdate(i, e) } get destroyed() { return this.__destroyed } destroy() { this.__destroyed || this.__internalDestroy() } get __internalDidAwakeAndStart() { return this.__didAwake && this.__didStart } __internalNewInstanceCreated() { this.__didAwake = !1, this.__didStart = !1, this.__didEnable = !1, this.__isEnabled = void 0, this.__destroyed = !1 } __internalAwake() { this.__didAwake || (this.__didAwake = !0, this.awake()) } __internalStart() { this.__didStart || (this.__didStart = !0, this.start && this.start()) } __internalEnable(i) { return this.__destroyed ? (Mn() && console.warn("[Needle Engine Dev] Trying to enable destroyed component"), !1) : this.__didAwake ? this.__didEnable ? (i !== !0 && (this.__isEnabled = !0), !1) : (this.__didEnable = !0, this.__isEnabled = !0, this.onEnable(), !0) : !1 } __internalDisable(i) { if (this.__didAwake) { if (!this.__didEnable) { i !== !0 && (this.__isEnabled = !1); return } this.__didEnable = !1, this.__isEnabled = !1, this.onDisable() } } __internalDestroy() { var i; this.__destroyed || (this.__destroyed = !0, (i = this.destroy) == null || i.call(this), c2(this)) } get enabled() { return typeof this.__isEnabled == "boolean" ? this.__isEnabled : !0 } set enabled(i) { if (this.__destroyed) { Mn() && console.warn(`[Needle Engine Dev] Trying to ${i ? "enable" : "disable"} destroyed component`); return } if (typeof i == "number" && (i >= .5 ? i = !0 : i = !1), !this.__didAwake) { this.__isEnabled = i; return } i ? this.__internalEnable() : this.__internalDisable() } get worldPosition() { return this._worldPosition || (this._worldPosition = new S), xt(this.gameObject, this._worldPosition), this._worldPosition } set worldPosition(i) { ts(this.gameObject, i) } setWorldPosition(i, e, t) { is._worldPositionBuffer.set(i, e, t), this.worldPosition = is._worldPositionBuffer } get worldQuaternion() { return this._worldQuaternion || (this._worldQuaternion = new we), _s(this.gameObject, this._worldQuaternion) } set worldQuaternion(i) { Dr(this.gameObject, i) } setWorldQuaternion(i, e, t, s) { is._worldQuaternionBuffer.set(i, e, t, s), this.worldQuaternion = is._worldQuaternionBuffer } get worldEuler() { return this._worldEuler || (this._worldEuler = new ps), this._worldEuler.setFromQuaternion(this.worldQuaternion), this._worldEuler } set worldEuler(i) { var e; this._worldQuaternion || (this._worldQuaternion = new we), (e = this._worldQuaternion) == null || e.setFromEuler(i), this.worldQuaternion = this._worldQuaternion } get worldRotation() { const i = this.worldEuler; this._worldRotation || (this._worldRotation = new S); const e = this._worldRotation; return e.set(i.x, i.y, i.z), e.x = Ke.toDegrees(e.x), e.y = Ke.toDegrees(e.y), e.z = Ke.toDegrees(e.z), e } set worldRotation(i) { this.setWorldRotation(i.x, i.y, i.z, !0) } setWorldRotation(i, e, t, s = !0) { s && (i = Ke.toRadians(i), e = Ke.toRadians(e), t = Ke.toRadians(t)), is._worldEulerBuffer.set(i, e, t), is._worldQuaternionBuffer.setFromEuler(is._worldEulerBuffer), this.worldQuaternion = is._worldQuaternionBuffer } get forward() { return is._forward.set(0, 0, -1).applyQuaternion(this.worldQuaternion) } get right() { return is._right.set(1, 0, 0).applyQuaternion(this.worldQuaternion) } get up() { return is._up.set(0, 1, 0).applyQuaternion(this.worldQuaternion) } addEventListener(i, e) { this._eventListeners[i] = this._eventListeners[i] || [], this._eventListeners[i].push(e) } removeEventListener(i, e) { if (!this._eventListeners[i]) return; const t = this._eventListeners[i].indexOf(e); t >= 0 && this._eventListeners[i].splice(t, 1) } dispatchEvent(i) { if (!this._eventListeners[i.type]) return !1; const e = this._eventListeners[i.type]; for (let t = 0; t < e.length; t++)e[t](i); return !1 } }, u(is, "_worldPositionBuffer", new S), u(is, "_worldQuaternionBuffer", new we), u(is, "_worldEulerBuffer", new ps), u(is, "_tempQuaternionBuffer2", new we), u(is, "_forward", new S), u(is, "_right", new S), u(is, "_up", new S), is); class Ee extends ac { } const Tq = Object.freeze(Object.defineProperty({ __proto__: null, Behaviour: Ee, Component: ac, GameObject: $ }, Symbol.toStringTag, { value: "Module" })), Rq = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJFYmVuZV8zIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTYwIDE4Ny43NCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOnVybCgjVW5iZW5hbm50ZXJfVmVybGF1Zl8xMjIpO30uY2xzLTJ7ZmlsbDojZjNlNjAwO30uY2xzLTN7ZmlsbDp1cmwoI1VuYmVuYW5udGVyX1ZlcmxhdWZfMTEzKTt9LmNscy00e2ZpbGw6dXJsKCNncmFkaWVudC02KTt9LmNscy01e2ZpbGw6dXJsKCNVbmJlbmFubnRlcl9WZXJsYXVmXzExMCk7fS5jbHMtNntmaWxsOnVybCgjVW5iZW5hbm50ZXJfVmVybGF1Zl8xMDEpO30uY2xzLTd7ZmlsbDojOWMzO30uY2xzLTh7ZmlsbDojZmZlMTEzO30uY2xzLTl7ZmlsbDp1cmwoI2dyYWRpZW50LTUpO308L3N0eWxlPjxsaW5lYXJHcmFkaWVudCBpZD0iVW5iZW5hbm50ZXJfVmVybGF1Zl8xMTMiIHgxPSI4OS42NCIgeTE9IjE4NC44MSIgeDI9IjkwLjQ4IiB5Mj0iMjEuODUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMCkiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiM2MmQzOTkiLz48c3RvcCBvZmZzZXQ9Ii41MSIgc3RvcC1jb2xvcj0iI2FjZDg0MiIvPjxzdG9wIG9mZnNldD0iLjkiIHN0b3AtY29sb3I9IiNkN2RiMGEiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iVW5iZW5hbm50ZXJfVmVybGF1Zl8xMTAiIHgxPSI2OS42OCIgeTE9IjE3OC45IiB4Mj0iNjguMDgiIHkyPSIxNi43NyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzBiYTM5OCIvPjxzdG9wIG9mZnNldD0iLjUiIHN0b3AtY29sb3I9IiM0Y2EzNTIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM3NmEzMGEiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iVW5iZW5hbm50ZXJfVmVybGF1Zl8xMDEiIHgxPSIzNi42IiB5MT0iMTUyLjE3IiB4Mj0iMzQuNyIgeTI9Ijg0LjE5IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agb2Zmc2V0PSIuMTkiIHN0b3AtY29sb3I9IiMzNmEzODIiLz48c3RvcCBvZmZzZXQ9Ii41NCIgc3RvcC1jb2xvcj0iIzQ5YTQ1OSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzc2YTMwYiIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJVbmJlbmFubnRlcl9WZXJsYXVmXzEyMiIgeDE9IjE1LjgyIiB5MT0iMTUzLjI0IiB4Mj0iMTgiIHkyPSI5MC44NiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzI2Nzg4MCIvPjxzdG9wIG9mZnNldD0iLjUxIiBzdG9wLWNvbG9yPSIjNDU3YTVjIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjNzE3NTE2Ii8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9ImdyYWRpZW50LTYiIHgxPSIxMzUuMDgiIHkxPSIxMzUuNDMiIHgyPSIxNDguOTMiIHkyPSI2My40NyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2IwZDkzOSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI2VhZGIwNCIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkaWVudC01IiB4MT0iLTQxNjMuMjUiIHkxPSIyMjg1LjEyIiB4Mj0iLTQxNjAuODEiIHkyPSIyMjE1LjM0IiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDQ4MDEuMTUgLTU5NS4yNSkgcm90YXRlKDIwKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iLjE3IiBzdG9wLWNvbG9yPSIjNzRhZjUyIi8+PHN0b3Agb2Zmc2V0PSIuNDgiIHN0b3AtY29sb3I9IiM5OWJlMzIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNjMGM0MGEiLz48L2xpbmVhckdyYWRpZW50PjxzeW1ib2wgaWQ9Im5lZWRsZS1pY29uIiB2aWV3Qm94PSIwIDAgMTYwIDE4Ny43NCI+PGc+PHBvbHlnb24gY2xhc3M9ImNscy0zIiBwb2ludHM9Ijc5LjMyIDM2Ljk4IDc5LjMyIDE4Ny43NCA5NSAxNzQuNTQgMTAxLjU5IDE4LjIzIDc5LjMyIDM2Ljk4Ii8+PHBvbHlnb24gY2xhc3M9ImNscy01IiBwb2ludHM9Ijc5LjMyIDM2Ljk4IDU3LjA1IDE4LjIzIDYzLjY0IDE3NC41NCA3OS4zMiAxODcuNzQgNzkuMzIgMzYuOTgiLz48cG9seWdvbiBjbGFzcz0iY2xzLTYiIHBvaW50cz0iMjUuMTkgMTA0LjgzIDMzLjgyIDE1My44NyA0Ni4zMiAxMzguOTIgNDMuODYgODIuNSAyNS4xOSAxMDQuODMiLz48cG9seWdvbiBjbGFzcz0iY2xzLTEiIHBvaW50cz0iMjUuMTkgMTA0LjgzIDAgOTAuMjQgMTYuOTcgMTQ0LjEgMzMuODIgMTUzLjg3IDI1LjE5IDEwNC44MyIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtNyIgcG9pbnRzPSI0My44NiA4Mi41IDE4LjY5IDY3Ljk4IDAgOTAuMjQgMjUuMTggMTA0LjgzIDQzLjg2IDgyLjUiLz48cG9seWdvbiBjbGFzcz0iY2xzLTQiIHBvaW50cz0iMTM0LjgyIDc4LjY5IDEyNC44NSAxMzUuMTkgMTQwLjQzIDEyNi4xNSAxNjAgNjQuMSAxMzQuODIgNzguNjkiLz48cG9seWdvbiBjbGFzcz0iY2xzLTkiIHBvaW50cz0iMTM0LjgyIDc4LjY5IDExNi4xNCA1Ni4zNiAxMTMuMjggMTIxLjM2IDEyNC44NSAxMzUuMTkgMTM0LjgyIDc4LjY5Ii8+PHBvbHlnb24gY2xhc3M9ImNscy04IiBwb2ludHM9IjE2MCA2NC4xIDE0MS4zMSA0MS44NCAxMTYuMTQgNTYuMzYgMTM0LjgxIDc4LjY5IDE2MCA2NC4xIi8+PHBvbHlnb24gY2xhc3M9ImNscy0yIiBwb2ludHM9IjEwMS41OSAxOC4yMyA3OS4zMiAwIDU3LjA1IDE4LjIzIDc5LjMyIDM2Ljk4IDEwMS41OSAxOC4yMyIvPjwvZz48L3N5bWJvbD48L2RlZnM+PHVzZSB3aWR0aD0iMTYwIiBoZWlnaHQ9IjE4Ny43NCIgeGxpbms6aHJlZj0iI25lZWRsZS1pY29uIi8+PC9zdmc+", CD = Rq, Fh = oe("debuglicense"), dC = "basic"; Fh && console.log("License Type: " + dC); function lc() { switch (dC) { case "pro": case "enterprise": return !0 }return !1 } function Pq() { switch (dC) { case "indie": return !0 }return !1 } function pC() { return lc() || Pq() } Zi.registerCallback(Jr.ContextRegistered, i => { Bq(i.context) }); async function Bq(i) { try { if (lc() !== !0) return mC(i) } catch (e) { return Fh && console.log("License check failed", e), mC(i) } Fh && mC(i) } const SD = "needle-license-element", fC = 5e3, gC = 200; function mC(i) { setTimeout(() => kq(i), 2e3), Fq() } function kq(i) { const e = Oq(), t = Lq(), s = setInterval(() => { e && e.parentElement !== i.domElement && (i.domElement.appendChild(e), t && i.domElement.appendChild(t)) }, 100); pC() || Dq(); let r = `<img class="logo" src="${CD}" style="width: 40px; height: 40px; margin-right: 2px; vertical-align: middle; margin-bottom: 2px;"/>`; const n = document.createElement("div"); n.innerHTML = r, n.classList.add("logo"), e.appendChild(n); const o = document.createElement("div"); o.classList.add("text"), e.appendChild(o), e.title = "Needle Engine", pC() || (e.title += " non commercial version"), e.addEventListener("click", () => { globalThis.open("https://needle.tools", "_blank") }); const a = fC + gC; setTimeout(() => { clearInterval(s), e?.remove(), t?.remove() }, a) } async function Dq(i) {
  console.log("%cNeedle Engine \u2014 non commercial version", `
        font-size: 18px;
        background-size: 20px;
        background-position: left top;
        background-repeat:no-repeat;
        background-image:url('data:image/webp;base64,UklGRrABAABXRUJQVlA4WAoAAAAQAAAAHwAAHwAAQUxQSKEAAAARN6CmbSM4WR7vdARON11EBDq3fLiNbVtVzpMCPlKAEzsx0Y/x+Ovuv4dn0EFE/ydAvz6YggXzgh5sVgXM/zOC/4sii7qgGvB5N7hmuQYwkvazWAu1JPW41FXSHq6pnaQWvqYH18Fc0j1hO/BFTtIeSBlJi5w6qIIO7IOrwhFsB2Yxukif0FTRLpXswHR8MxbslKe9VZsn/Ub5C7YFOpqSTABWUDgg6AAAAFAGAJ0BKiAAIAA+7VyoTqmkpCI3+qgBMB2JbACdMt69DwMIQBLhkTO6XwY00UEDK6cNIDnuNibPf0EgAP7Y1myuiQHLDsF/0h5unrGh6WAbv7aegg2ZMd3uRKfT/3SJztcaujYfTvMXspfCTmYcoO6a+vhC3ss4M8uM58t4siiu59I4aOl59e9Sr6xoxYlHf2v+NnBNpJYeJf8jABQAId/PXuBkLEFkiCucgSGEcfhvajql/j3reCGl0M5/9gQWy7ayNPs+wlvIxFnNfSlfuND4CZOCyxOHhRqOmHN4ULHo3tCSrUNvgAA=');
        background-max-size: 40px;
        padding-left: 30px;
        margin-bottom: 2px;
        margin-bottom: 5px;
    `)
} function Oq() { const i = document.createElement("div"); i.setAttribute(SD, ""), i.style.position = "fixed", i.style.bottom = "12px", i.style.right = "15px"; const e = 2147483647; return i.style.zIndex = `${e}`, i } function Lq() {
  const i = document.createElement("style"), e = `div[${SD}]`; return i.innerHTML = `
    ${e} {
        font-family: 'Roboto', sans-serif !important;
        font-weight: 300;
        transition: all 0.1s ease-in-out !important;
        pointer-events: all;
    }

    ${e}:hover {
        cursor: pointer;
        transition: all 0.1s ease-in-out !important;
    }

    ${e}, ${e} > * {
        display: inline-block !important;
        visibility: visible !important;
        background: none !important;
        border: none !important;
        text-decoration: none !important;
        vertical-align: middle !important;
    }
    
    @keyframes license-animation {
        1% {
            opacity: 0;
        }
        2.5% {
            opacity: 1;
        }
        98% {
            opacity: 1;
        }
        99% {
            opacity: 0;
        }
    }
    ${e} .text {
        opacity: 0;
        animation: license-animation;
        animation-iteration-count: 1;
        animation-duration: ${fC / 1e3}s;
        animation-delay: ${gC / 1e3}s;
        animation-easing: ease-in-out;
        mix-blend-mode: difference;
        color: rgb(0, 0, 0); 
        mix-blend-mode: difference;
        line-height: 1em;
        margin-left: -3px;
        text-shadow: 0 0 2px rgba(200,200,200, .5);
    }

    ${e} .text .non-commercial {
        font-size: 0.8em;
        font-weight: 600;
        text-transform: uppercase;
    }
    
    @keyframes logo-animation {
        0% {
            transform: translate(0px, 10px);
            pointer-events: none;
        }
        8% {
            transform: translate(0, 0px);
            pointer-events: all;
            opacity: 1;
            transform: scale(1.1)
        }
        20% {
            transform: scale(1)
        }
        90% {
            opacity: 1;
            pointer-events: all;
            transform: scale(1)
        }
        100% {
            pointer-events: none;
            opacity: 0;
        }
    }

    ${e} .logo {
        opacity: 0;
        pointer-events: none;
        animation: logo-animation;
        animation-iteration-count: 1;
        animation-duration: ${fC / 1e3}s;
        animation-delay: ${gC / 1e3}s;
        animation-easing: ease-in-out;
    }

    ${e} .logo {
        position: relative !important;
        display: inline-block !important;
        border-radius: 50% !important;
        background-color: transparent !important;
        padding: 5px !important;
        transition: all 0.1s ease-in-out !important;
    }

    ${e}:hover .logo {
        transition: all 0.1s ease-in-out !important;
        transform: scale(1.1) !important;
        cursor: pointer !important;
    }
    `, i
} async function Fq() { try { let i = await (await fetch("https://urls.needle.tools/analytics-endpoint")).text(); if (i) { Fh && console.log("Analytics backend url", i); const e = window.location.href; let t = "api/v1/register/web-request"; i.endsWith("/") || (t = "/" + t); const s = lc() ? "commercial" : "non-commercial", r = `${i}${t}?type=${s}&url=${encodeURIComponent(e)}&hostname=${encodeURIComponent(window.location.hostname)}&pathname=${encodeURIComponent(window.location.pathname)}&search=${encodeURIComponent(window.location.search)}&hash=${encodeURIComponent(window.location.hash)}`; Fh && console.log("Sending non-commercial usage message to analytics backend", r), fetch(r, { mode: "no-cors" }).catch(n => { Fh && console.log("Failed to send non-commercial usage message to analytics backend", n) }) } } catch (i) { Fh && console.log("Failed to send non-commercial usage message to analytics backend", i) } } const Uh = oe("debugloadingbar"), bg = oe("debugloadingbarrendering"); class Uq { constructor() { u(this, "className"), u(this, "additionalClasses") } } let _g = 0, ED; function vC(i) { Uh && console.log(i.progress.loaded.toFixed(0) + "/" + i.progress.total.toFixed(0), i); const e = i.count, t = i.progress.total; t === 0 || t === void 0 ? (ED !== i.name && (_g = 0), ED = i.name, _g += (1 - _g) * .001, Uh && ao("Loading " + i.name + " did not report total size")) : _g = i.progress.loaded / t; const s = i.index / e + _g / e; return Ke.clamp01(s) } const AC = class { constructor(i, e) { u(this, "loadingProgress", 0), u(this, "_element"), u(this, "_progress", 0), u(this, "_allowCustomLoadingElement", !0), u(this, "_loadingElement"), u(this, "_loadingTextContainer", null), u(this, "_loadingBar", null), u(this, "_messageContainer", null), u(this, "_loadingElementOptions"), u(this, "_progressLoop"), this._element = i, this._loadingElementOptions = e } onLoadingBegin(i) { if (Uh && console.warn("Begin Loading"), !this._loadingElement) { for (let e = 0; e < this._element.children.length; e++) { const t = this._element.children[e]; if (t.classList.contains(AC.LoadingContainerClassName)) { if (!this._allowCustomLoadingElement) { Uh && console.warn("Remove custom loading container"), this._element.removeChild(t); continue } this._loadingElement = this.createLoadingElement(t) } } this._loadingElement || (this._loadingElement = this.createLoadingElement()) } this._progress = 0, this.loadingProgress = 0, this._loadingElement.style.display = "flex", this._element.appendChild(this._loadingElement), this.smoothProgressLoop(), this.setMessage(i ?? "") } onLoadingUpdate(i, e) { var t; if (!((t = this._loadingElement) != null && t.parentElement)) return; let s = 0; typeof i == "number" ? s = i : ("index" in i && (s = vC(i)), !e && "name" in i && this.setMessage("loading " + i.name)), this.loadingProgress = s, e && this.setMessage(e), this.updateDisplay() } onLoadingFinished() { Uh && console.warn("Finished Loading"), bg || (this.loadingProgress = 1, this.onDoneLoading()) } setMessage(i) { this._messageContainer && (this._messageContainer.innerText = i) } smoothProgressLoop() { if (this._progressLoop) return; let i = 1 / 12; bg && (i = 1 / 500, typeof bg == "number" && (i *= bg)), this._progressLoop = setInterval(() => { this.loadingProgress >= .95 && !bg && (i = .9), this._progress = Ke.lerp(this._progress, this.loadingProgress, i * this.loadingProgress), this.updateDisplay() }, i) } onDoneLoading() { this._loadingElement && (Uh && console.log("Hiding loading element"), this._loadingElement.style.display = "none", this._loadingElement.remove()), this._progressLoop && clearInterval(this._progressLoop), this._progressLoop = null } updateDisplay() { const i = this._progress, e = (i * 100).toFixed(0) + "%"; this._loadingBar && (this._loadingBar.style.width = i * 100 + "%"), this._loadingTextContainer && (this._loadingTextContainer.textContent = e) } createLoadingElement(i) { var e, t; Uh && !i && console.log("Creating loading element"), this._loadingElement = i || document.createElement("div"); const s = this._element.getAttribute("loading-style"), r = lc(); if (!i && (this._loadingElement.style.position = "fixed", this._loadingElement.style.width = "100%", this._loadingElement.style.height = "100%", this._loadingElement.style.left = "0", this._loadingElement.style.top = "0", s === "light" ? this._loadingElement.style.backgroundColor = "#ddd" : this._loadingElement.style.backgroundColor = "#222", this._loadingElement.style.display = "flex", this._loadingElement.style.alignItems = "center", this._loadingElement.style.justifyContent = "center", this._loadingElement.style.zIndex = "1000", this._loadingElement.style.flexDirection = "column", this._loadingElement.style.pointerEvents = "none", this._loadingElement.style.color = "white", s === "light" ? this._loadingElement.style.color = "rgba(0,0,0,.8)" : this._loadingElement.style.color = "rgba(255,255,255,.5)", r && this._element)) { const p = this._element.getAttribute("loading-background-color"); p && (this._loadingElement.style.backgroundColor = p); const f = this._element.getAttribute("loading-text-color"); f && (this._loadingElement.style.color = f) } const n = ((e = this._loadingElementOptions) == null ? void 0 : e.className) ?? AC.LoadingContainerClassName; if (this._loadingElement.classList.add(n), (t = this._loadingElementOptions) != null && t.additionalClasses) for (const p of this._loadingElementOptions.additionalClasses) this._loadingElement.classList.add(p); const o = document.createElement("div"), a = 30; o.style.display = "flex", o.style.width = a + "%", o.style.height = "2px", s === "light" ? o.style.backgroundColor = "rgba(0,0,0,.2)" : o.style.backgroundColor = "rgba(255,255,255,.2)", this._loadingElement.appendChild(o); const l = document.createElement("img"), c = 64; if (l.style.width = `${c}px`, l.style.height = `${c}px`, l.style.position = "absolute", l.style.left = "50%", l.style.transform = `translate(-${c * .5}px, -${c + 32}px)`, l.addEventListener("click", () => window.open("https://needle.tools", "_blank")), l.style.cursor = "pointer", l.style.userSelect = "none", l.style.pointerEvents = "all", l.style.objectFit = "contain", l.src = CD, r && this._element) { const p = this._element.getAttribute("loading-logo-src"); p && (l.src = p) } o.appendChild(l), this._loadingBar = document.createElement("div"), o.appendChild(this._loadingBar); const h = function (p) { return Ke.lerp(a * .5, 100 - a * .5, p) + "%" }; if (this._loadingBar.style.background = `linear-gradient(90deg, #02022B ${h(0)}, #0BA398 ${h(.4)}, #99CC33 ${h(.5)}, #D7DB0A ${h(1)})`, this._loadingBar.style.backgroundAttachment = "fixed", this._loadingBar.style.width = "0%", this._loadingBar.style.height = "100%", r && this._element) { const p = this._element.getAttribute("primary-color"), f = this._element.getAttribute("secondary-color"); p && f ? this._loadingBar.style.background = `linear-gradient(90deg, ${p} ${h(0)}, ${f} ${h(1)})` : p ? this._loadingBar.style.background = p : f && (this._loadingBar.style.background = f) } this._loadingTextContainer = document.createElement("div"), this._loadingTextContainer.style.display = "flex", this._loadingTextContainer.style.justifyContent = "center", this._loadingTextContainer.style.marginTop = "1.2em", this._loadingElement.appendChild(this._loadingTextContainer); const d = document.createElement("div"); if (this._messageContainer = d, d.style.display = "flex", d.style.fontSize = ".8em", d.style.paddingTop = ".5em", d.style.fontWeight = "200", d.style.fontFamily = "Roboto, sans-serif, Arial", d.style.justifyContent = "center", this._loadingElement.appendChild(d), r && this._element) { const p = this._element.getAttribute("loading-text-color"); p && (d.style.color = p) } if (!pC()) { const p = document.createElement("div"); p.style.paddingTop = ".6em", p.style.fontSize = ".8em", p.innerText = "NON COMMERCIAL", this._loadingElement.appendChild(p) } return this._loadingElement } }; let yC = AC; u(yC, "LoadingContainerClassName", "loading"); const bC = new WeakMap; class _C extends tr {
  constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, t, s, r) { const n = new bs(this.manager); n.setPath(this.path), n.setResponseType("arraybuffer"), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials), n.load(e, o => { this.decodeDracoFile(o, t).catch(r) }, s, r) } decodeDracoFile(e, t, s, r) { const n = { attributeIDs: s || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!s }; return this.decodeGeometry(e, n).then(t) } decodeGeometry(e, t) { const s = JSON.stringify(t); if (bC.has(e)) { const l = bC.get(e); if (l.key === s) return l.promise; if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let r; const n = this.workerNextTaskID++, o = e.byteLength, a = this._getWorker(n, o).then(l => (r = l, new Promise((c, h) => { r._callbacks[n] = { resolve: c, reject: h }, r.postMessage({ type: "decode", id: n, taskConfig: t, buffer: e }, [e]) }))).then(l => this._createGeometry(l.geometry)); return a.catch(() => !0).then(() => { r && n && this._releaseTask(r, n) }), bC.set(e, { key: s, promise: a }), a } _createGeometry(e) { const t = new yt; e.index && t.setIndex(new nt(e.index.array, 1)); for (let s = 0; s < e.attributes.length; s++) { const r = e.attributes[s], n = r.name, o = r.array, a = r.itemSize; t.setAttribute(n, new nt(o, a)) } return t } _loadLibrary(e, t) { const s = new bs(this.manager); return s.setPath(this.decoderPath), s.setResponseType(t), s.setWithCredentials(this.withCredentials), new Promise((r, n) => { s.load(e, r, void 0, n) }) } preload() { return this._initDecoder(), this } _initDecoder() {
    if (this.decoderPending) return this.decoderPending; const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(s => {
      const r = s[0]; e || (this.decoderConfig.wasmBinary = s[1]); const n = Nq.toString(), o = ["/* draco decoder */", r, "", "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([o]))
    }), this.decoderPending
  } _getWorker(e, t) { return this._initDecoder().then(() => { if (this.workerPool.length < this.workerLimit) { const r = new Worker(this.workerSourceURL); r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({ type: "init", decoderConfig: this.decoderConfig }), r.onmessage = function (n) { const o = n.data; switch (o.type) { case "decode": r._callbacks[o.id].resolve(o); break; case "error": r._callbacks[o.id].reject(o); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"') } }, this.workerPool.push(r) } else this.workerPool.sort(function (r, n) { return r._taskLoad > n._taskLoad ? -1 : 1 }); const s = this.workerPool[this.workerPool.length - 1]; return s._taskCosts[e] = t, s._taskLoad += t, s }) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { console.log("Task load: ", this.workerPool.map(e => e._taskLoad)) } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this }
} function Nq() { let i, e; onmessage = function (o) { const a = o.data; switch (a.type) { case "init": i = a.decoderConfig, e = new Promise(function (h) { i.onModuleLoaded = function (d) { h({ draco: d }) }, DracoDecoderModule(i) }); break; case "decode": const l = a.buffer, c = a.taskConfig; e.then(h => { const d = h.draco, p = new d.Decoder, f = new d.DecoderBuffer; f.Init(new Int8Array(l), l.byteLength); try { const g = t(d, p, f, c), m = g.attributes.map(v => v.array.buffer); g.index && m.push(g.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: g }, m) } catch (g) { console.error(g), self.postMessage({ type: "error", id: a.id, error: g.message }) } finally { d.destroy(f), d.destroy(p) } }); break } }; function t(o, a, l, c) { const h = c.attributeIDs, d = c.attributeTypes; let p, f; const g = a.GetEncodedGeometryType(l); if (g === o.TRIANGULAR_MESH) p = new o.Mesh, f = a.DecodeBufferToMesh(l, p); else if (g === o.POINT_CLOUD) p = new o.PointCloud, f = a.DecodeBufferToPointCloud(l, p); else throw new Error("THREE.DRACOLoader: Unexpected geometry type."); if (!f.ok() || p.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg()); const m = { index: null, attributes: [] }; for (const v in h) { const A = self[d[v]]; let b, y; if (c.useUniqueIDs) y = h[v], b = a.GetAttributeByUniqueId(p, y); else { if (y = a.GetAttributeId(p, o[h[v]]), y === -1) continue; b = a.GetAttribute(p, y) } m.attributes.push(r(o, a, p, v, A, b)) } return g === o.TRIANGULAR_MESH && (m.index = s(o, a, p)), o.destroy(p), m } function s(o, a, l) { const c = l.num_faces() * 3, h = c * 4, d = o._malloc(h); a.GetTrianglesUInt32Array(l, h, d); const p = new Uint32Array(o.HEAPF32.buffer, d, c).slice(); return o._free(d), { array: p, itemSize: 1 } } function r(o, a, l, c, h, d) { const p = d.num_components(), f = l.num_points() * p, g = f * h.BYTES_PER_ELEMENT, m = n(o, h), v = o._malloc(g); a.GetAttributeDataArrayForAllPoints(l, d, m, g, v); const A = new h(o.HEAPF32.buffer, v, f).slice(); return o._free(v), { name: c, array: A, itemSize: p } } function n(o, a) { switch (a) { case Float32Array: return o.DT_FLOAT32; case Int8Array: return o.DT_INT8; case Int16Array: return o.DT_INT16; case Int32Array: return o.DT_INT32; case Uint8Array: return o.DT_UINT8; case Uint16Array: return o.DT_UINT16; case Uint32Array: return o.DT_UINT32 } } } class zq { constructor(e = 4) { this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0 } _initWorker(e) { if (!this.workers[e]) { const t = this.workerCreator(); t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t } } _getIdleWorker() { for (let e = 0; e < this.pool; e++)if (!(this.workerStatus & 1 << e)) return e; return -1 } _onMessage(e, t) { const s = this.workersResolve[e]; if (s && s(t), this.queue.length) { const { resolve: r, msg: n, transfer: o } = this.queue.shift(); this.workersResolve[e] = r, this.workers[e].postMessage(n, o) } else this.workerStatus ^= 1 << e } setWorkerCreator(e) { this.workerCreator = e } setWorkerLimit(e) { this.pool = e } postMessage(e, t) { return new Promise(s => { const r = this._getIdleWorker(); r !== -1 ? (this._initWorker(r), this.workerStatus |= 1 << r, this.workersResolve[r] = s, this.workers[r].postMessage(e, t)) : this.queue.push({ resolve: s, msg: e, transfer: t }) }) } dispose() { this.workers.forEach(e => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0 } } const jq = 0, Qq = 2, Gq = 1, Hq = 2, Vq = 0, MD = 9, xC = 15, ID = 16, wC = 22, TD = 37, CC = 43, RD = 76, PD = 83, BD = 97, kD = 100, DD = 103, OD = 109; class Wq { constructor() { this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null } } class xg { constructor(e, t, s, r) { this._dataView = new DataView(e.buffer, e.byteOffset + t, s), this._littleEndian = r, this._offset = 0 } _nextUint8() { const e = this._dataView.getUint8(this._offset); return this._offset += 1, e } _nextUint16() { const e = this._dataView.getUint16(this._offset, this._littleEndian); return this._offset += 2, e } _nextUint32() { const e = this._dataView.getUint32(this._offset, this._littleEndian); return this._offset += 4, e } _nextUint64() { const e = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian); return this._offset += 8, e } _nextInt32() { const e = this._dataView.getInt32(this._offset, this._littleEndian); return this._offset += 4, e } _skip(e) { return this._offset += e, this } _scan(e, t = 0) { const s = this._offset; let r = 0; for (; this._dataView.getUint8(this._offset) !== t && r < e;)r++, this._offset++; return r < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + s, r) } } const yr = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10]; function LD(i) { return typeof TextDecoder < "u" ? new TextDecoder().decode(i) : Buffer.from(i).toString("utf8") } function qq(i) { const e = new Uint8Array(i.buffer, i.byteOffset, yr.length); if (e[0] !== yr[0] || e[1] !== yr[1] || e[2] !== yr[2] || e[3] !== yr[3] || e[4] !== yr[4] || e[5] !== yr[5] || e[6] !== yr[6] || e[7] !== yr[7] || e[8] !== yr[8] || e[9] !== yr[9] || e[10] !== yr[10] || e[11] !== yr[11]) throw new Error("Missing KTX 2.0 identifier."); const t = new Wq, s = 17 * Uint32Array.BYTES_PER_ELEMENT, r = new xg(i, yr.length, s, !0); t.vkFormat = r._nextUint32(), t.typeSize = r._nextUint32(), t.pixelWidth = r._nextUint32(), t.pixelHeight = r._nextUint32(), t.pixelDepth = r._nextUint32(), t.layerCount = r._nextUint32(), t.faceCount = r._nextUint32(); const n = r._nextUint32(); t.supercompressionScheme = r._nextUint32(); const o = r._nextUint32(), a = r._nextUint32(), l = r._nextUint32(), c = r._nextUint32(), h = r._nextUint64(), d = r._nextUint64(), p = new xg(i, yr.length + s, 3 * n * 8, !0); for (let re = 0; re < n; re++)t.levels.push({ levelData: new Uint8Array(i.buffer, i.byteOffset + p._nextUint64(), p._nextUint64()), uncompressedByteLength: p._nextUint64() }); const f = new xg(i, o, a, !0), g = { vendorId: f._skip(4)._nextUint16(), descriptorType: f._nextUint16(), versionNumber: f._nextUint16(), descriptorBlockSize: f._nextUint16(), colorModel: f._nextUint8(), colorPrimaries: f._nextUint8(), transferFunction: f._nextUint8(), flags: f._nextUint8(), texelBlockDimension: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()], bytesPlane: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()], samples: [] }, m = (g.descriptorBlockSize / 4 - 6) / 4; for (let re = 0; re < m; re++) { const Z = { bitOffset: f._nextUint16(), bitLength: f._nextUint8(), channelType: f._nextUint8(), samplePosition: [f._nextUint8(), f._nextUint8(), f._nextUint8(), f._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 }; 64 & Z.channelType ? (Z.sampleLower = f._nextInt32(), Z.sampleUpper = f._nextInt32()) : (Z.sampleLower = f._nextUint32(), Z.sampleUpper = f._nextUint32()), g.samples[re] = Z } t.dataFormatDescriptor.length = 0, t.dataFormatDescriptor.push(g); const v = new xg(i, l, c, !0); for (; v._offset < c;) { const re = v._nextUint32(), Z = v._scan(re), fe = LD(Z), ae = v._scan(re - Z.byteLength); t.keyValue[fe] = fe.match(/^ktx/i) ? LD(ae) : ae, v._offset % 4 && v._skip(4 - v._offset % 4) } if (d <= 0) return t; const A = new xg(i, h, d, !0), b = A._nextUint16(), y = A._nextUint16(), _ = A._nextUint32(), w = A._nextUint32(), E = A._nextUint32(), P = A._nextUint32(), C = []; for (let re = 0; re < n; re++)C.push({ imageFlags: A._nextUint32(), rgbSliceByteOffset: A._nextUint32(), rgbSliceByteLength: A._nextUint32(), alphaSliceByteOffset: A._nextUint32(), alphaSliceByteLength: A._nextUint32() }); const R = h + A._offset, T = R + _, z = T + w, H = z + E, N = new Uint8Array(i.buffer, i.byteOffset + R, _), F = new Uint8Array(i.buffer, i.byteOffset + T, w), X = new Uint8Array(i.buffer, i.byteOffset + z, E), te = new Uint8Array(i.buffer, i.byteOffset + H, P); return t.globalData = { endpointCount: b, selectorCount: y, imageDescs: C, endpointsData: N, selectorsData: F, tablesData: X, extendedData: te }, t } let SC, Ja, EC; const MC = { env: { emscripten_notify_memory_growth: function (i) { EC = new Uint8Array(Ja.exports.memory.buffer) } } }; class Xq { init() { return SC || (SC = typeof fetch < "u" ? fetch("data:application/wasm;base64," + FD).then(e => e.arrayBuffer()).then(e => WebAssembly.instantiate(e, MC)).then(this._init) : WebAssembly.instantiate(Buffer.from(FD, "base64"), MC).then(this._init), SC) } _init(e) { Ja = e.instance, MC.env.emscripten_notify_memory_growth(0) } decode(e, t = 0) { if (!Ja) throw new Error("ZSTDDecoder: Await .init() before decoding."); const s = e.byteLength, r = Ja.exports.malloc(s); EC.set(e, r), t = t || Number(Ja.exports.ZSTD_findDecompressedSize(r, s)); const n = Ja.exports.malloc(t), o = Ja.exports.ZSTD_decompress(n, t, r, s), a = EC.slice(n, n + o); return Ja.exports.free(r), Ja.exports.free(n), a } } const FD = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", IC = new WeakMap; let TC = 0, RC; class Io extends tr {
  constructor(e) { super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new zq, this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.') } setTranscoderPath(e) { return this.transcoderPath = e, this } setWorkerLimit(e) { return this.workerPool.setWorkerLimit(e), this } detectSupport(e) { return this.workerConfig = { astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: e.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1), this } init() {
    if (!this.transcoderPending) {
      const e = new bs(this.manager); e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials); const t = e.loadAsync("basis_transcoder.js"), s = new bs(this.manager); s.setPath(this.transcoderPath), s.setResponseType("arraybuffer"), s.setWithCredentials(this.withCredentials); const r = s.loadAsync("basis_transcoder.wasm"); this.transcoderPending = Promise.all([t, r]).then(([n, o]) => {
        const a = Io.BasisWorker.toString(), l = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Io.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Io.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Io.BasisFormat), "/* basis_transcoder.js */", n, "/* worker */", a.substring(a.indexOf("{") + 1, a.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([l])), this.transcoderBinary = o, this.workerPool.setWorkerCreator(() => { const c = new Worker(this.workerSourceURL), h = this.transcoderBinary.slice(0); return c.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: h }, [h]), c })
      }), TC > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), TC++
    } return this.transcoderPending
  } load(e, t, s, r) { if (this.workerConfig === null) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."); const n = new bs(this.manager); n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials), n.load(e, o => { if (IC.has(o)) return IC.get(o).promise.then(t).catch(r); this._createTexture(o).then(a => t ? t(a) : null).catch(r) }, s, r) } _createTextureFrom(e, t) { const { mipmaps: s, width: r, height: n, format: o, type: a, error: l, dfdTransferFn: c, dfdFlags: h } = e; if (a === "error") return Promise.reject(l); const d = t.layerCount > 1 ? new KR(s, r, n, t.layerCount, o, ui) : new Na(s, r, n, o, ui); return d.minFilter = s.length === 1 ? Qt : eo, d.magFilter = Qt, d.generateMipmaps = !1, d.needsUpdate = !0, d.encoding = c === Hq ? Xe : Qi, d.premultiplyAlpha = !!(h & Gq), d } async _createTexture(e, t = {}) { const s = qq(new Uint8Array(e)); if (s.vkFormat !== Vq) return Jq(s); const r = t, n = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e, taskConfig: r }, [e])).then(o => this._createTextureFrom(o.data, s)); return IC.set(e, { promise: n }), n } dispose() { return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), TC--, this }
} Io.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }, Io.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }, Io.EngineFormat = { RGBAFormat: _i, RGBA_ASTC_4x4_Format: Yv, RGBA_BPTC_Format: Jv, RGBA_ETC2_EAC_Format: Xv, RGBA_PVRTC_4BPPV1_Format: Wv, RGBA_S3TC_DXT5_Format: ff, RGB_ETC1_Format: gx, RGB_ETC2_Format: qv, RGB_PVRTC_4BPPV1_Format: Vv, RGB_S3TC_DXT1_Format: pf }, Io.BasisWorker = function () { let i, e, t; const s = _EngineFormat, r = _TranscoderFormat, n = _BasisFormat; self.addEventListener("message", function (g) { const m = g.data; switch (m.type) { case "init": i = m.config, o(m.transcoderBinary); break; case "transcode": e.then(() => { try { const { width: v, height: A, hasAlpha: b, mipmaps: y, format: _, dfdTransferFn: w, dfdFlags: E } = a(m.buffer), P = []; for (let C = 0; C < y.length; ++C)P.push(y[C].data.buffer); self.postMessage({ type: "transcode", id: m.id, width: v, height: A, hasAlpha: b, mipmaps: y, format: _, dfdTransferFn: w, dfdFlags: E }, P) } catch (v) { console.error(v), self.postMessage({ type: "error", id: m.id, error: v.message }) } }); break } }); function o(g) { e = new Promise(m => { t = { wasmBinary: g, onRuntimeInitialized: m }, BASIS(t) }).then(() => { t.initializeBasis(), t.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.") }) } function a(g) { const m = new t.KTX2File(new Uint8Array(g)); function v() { m.close(), m.delete() } if (!m.isValid()) throw v(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file"); const A = m.isUASTC() ? n.UASTC_4x4 : n.ETC1S, b = m.getWidth(), y = m.getHeight(), _ = m.getLayers() || 1, w = m.getLevels(), E = m.getHasAlpha(), P = m.getDFDTransferFunc(), C = m.getDFDFlags(), { transcoderFormat: R, engineFormat: T } = d(A, b, y, E); if (!b || !y || !w) throw v(), new Error("THREE.KTX2Loader:	Invalid texture"); if (!m.startTranscoding()) throw v(), new Error("THREE.KTX2Loader: .startTranscoding failed"); const z = []; for (let H = 0; H < w; H++) { const N = []; let F, X; for (let te = 0; te < _; te++) { const re = m.getImageLevelInfo(H, te, 0); F = re.origWidth, X = re.origHeight; const Z = new Uint8Array(m.getImageTranscodedSizeInBytes(H, te, 0, R)); if (!m.transcodeImage(Z, H, te, 0, R, 0, -1, -1)) throw v(), new Error("THREE.KTX2Loader: .transcodeImage failed."); N.push(Z) } z.push({ data: f(N), width: F, height: X }) } return v(), { width: b, height: y, hasAlpha: E, mipmaps: z, format: T, dfdTransferFn: P, dfdFlags: C } } const l = [{ if: "astcSupported", basisFormat: [n.UASTC_4x4], transcoderFormat: [r.ASTC_4x4, r.ASTC_4x4], engineFormat: [s.RGBA_ASTC_4x4_Format, s.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: !1 }, { if: "bptcSupported", basisFormat: [n.ETC1S, n.UASTC_4x4], transcoderFormat: [r.BC7_M5, r.BC7_M5], engineFormat: [s.RGBA_BPTC_Format, s.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: !1 }, { if: "dxtSupported", basisFormat: [n.ETC1S, n.UASTC_4x4], transcoderFormat: [r.BC1, r.BC3], engineFormat: [s.RGB_S3TC_DXT1_Format, s.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: !1 }, { if: "etc2Supported", basisFormat: [n.ETC1S, n.UASTC_4x4], transcoderFormat: [r.ETC1, r.ETC2], engineFormat: [s.RGB_ETC2_Format, s.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: !1 }, { if: "etc1Supported", basisFormat: [n.ETC1S, n.UASTC_4x4], transcoderFormat: [r.ETC1], engineFormat: [s.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: !1 }, { if: "pvrtcSupported", basisFormat: [n.ETC1S, n.UASTC_4x4], transcoderFormat: [r.PVRTC1_4_RGB, r.PVRTC1_4_RGBA], engineFormat: [s.RGB_PVRTC_4BPPV1_Format, s.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: !0 }], c = l.sort(function (g, m) { return g.priorityETC1S - m.priorityETC1S }), h = l.sort(function (g, m) { return g.priorityUASTC - m.priorityUASTC }); function d(g, m, v, A) { let b, y; const _ = g === n.ETC1S ? c : h; for (let w = 0; w < _.length; w++) { const E = _[w]; if (i[E.if] && E.basisFormat.includes(g) && !(A && E.transcoderFormat.length < 2) && !(E.needsPowerOfTwo && !(p(m) && p(v)))) return b = E.transcoderFormat[A ? 1 : 0], y = E.engineFormat[A ? 1 : 0], { transcoderFormat: b, engineFormat: y } } return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), b = r.RGBA32, y = s.RGBAFormat, { transcoderFormat: b, engineFormat: y } } function p(g) { return g <= 2 ? !0 : (g & g - 1) === 0 && g !== 0 } function f(g) { let m = 0; for (const b of g) m += b.byteLength; const v = new Uint8Array(m); let A = 0; for (const b of g) v.set(b, A), A += b.byteLength; return v } }; const UD = { [OD]: _i, [BD]: _i, [TD]: _i, [CC]: _i, [DD]: oh, [PD]: oh, [ID]: oh, [wC]: oh, [kD]: Fl, [RD]: Fl, [xC]: Fl, [MD]: Fl }, PC = { [OD]: $i, [BD]: gs, [TD]: ui, [CC]: ui, [DD]: $i, [PD]: gs, [ID]: ui, [wC]: ui, [kD]: $i, [RD]: gs, [xC]: ui, [MD]: ui }, Yq = { [CC]: Xe, [wC]: Xe, [xC]: Xe }; async function Jq(i) { const { vkFormat: e, pixelWidth: t, pixelHeight: s, pixelDepth: r } = i; if (UD[e] === void 0) throw new Error("THREE.KTX2Loader: Unsupported vkFormat."); const n = i.levels[0]; let o, a; if (i.supercompressionScheme === jq) o = n.levelData; else if (i.supercompressionScheme === Qq) RC || (RC = new Promise(async c => { const h = new Xq; await h.init(), c(h) })), o = (await RC).decode(n.levelData, n.uncompressedByteLength); else throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme."); PC[e] === $i ? a = new Float32Array(o.buffer, o.byteOffset, o.byteLength / Float32Array.BYTES_PER_ELEMENT) : PC[e] === gs ? a = new Uint16Array(o.buffer, o.byteOffset, o.byteLength / Uint16Array.BYTES_PER_ELEMENT) : a = o; const l = r === 0 ? new no(a, t, s) : new wf(a, t, s, r); return l.type = PC[e], l.format = UD[e], l.encoding = Yq[e] || Qi, l.needsUpdate = !0, Promise.resolve(l) } var Kq = function () { var i = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", e = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), s = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]); if (typeof WebAssembly != "object") return { supported: !1 }; var r = WebAssembly.validate(t) ? e : i, n, o = WebAssembly.instantiate(a(r), {}).then(function (A) { n = A.instance, n.exports.__wasm_call_ctors() }); function a(A) { for (var b = new Uint8Array(A.length), y = 0; y < A.length; ++y) { var _ = A.charCodeAt(y); b[y] = _ > 96 ? _ - 97 : _ > 64 ? _ - 39 : _ + 4 } for (var w = 0, y = 0; y < A.length; ++y)b[w++] = b[y] < 60 ? s[b[y]] : (b[y] - 60) * 64 + b[++y]; return b.buffer.slice(0, w) } function l(A, b, y, _, w, E) { var P = n.exports.sbrk, C = y + 3 & -4, R = P(C * _), T = P(w.length), z = new Uint8Array(n.exports.memory.buffer); z.set(w, T); var H = A(R, y, _, T, w.length); if (H == 0 && E && E(R, C, _), b.set(z.subarray(R, R + y * _)), P(R - P(0)), H != 0) throw new Error("Malformed buffer data: " + H) } var c = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, h = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }, d = [], p = 0; function f(A) { var b = { object: new Worker(A), pending: 0, requests: {} }; return b.object.onmessage = function (y) { var _ = y.data; b.pending -= _.count, b.requests[_.id][_.action](_.value), delete b.requests[_.id] }, b } function g(A) { for (var b = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(a(r)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + l.toString() + v.toString(), y = new Blob([b], { type: "text/javascript" }), _ = URL.createObjectURL(y), w = 0; w < A; ++w)d[w] = f(_); URL.revokeObjectURL(_) } function m(A, b, y, _, w) { for (var E = d[0], P = 1; P < d.length; ++P)d[P].pending < E.pending && (E = d[P]); return new Promise(function (C, R) { var T = new Uint8Array(y), z = p++; E.pending += A, E.requests[z] = { resolve: C, reject: R }, E.object.postMessage({ id: z, count: A, size: b, source: T, mode: _, filter: w }, [T.buffer]) }) } function v(A) { o.then(function () { var b = A.data; try { var y = new Uint8Array(b.count * b.size); l(n.exports[b.mode], y, b.count, b.size, b.source, n.exports[b.filter]), self.postMessage({ id: b.id, count: b.count, action: "resolve", value: y }, [y.buffer]) } catch (_) { self.postMessage({ id: b.id, count: b.count, action: "reject", value: _ }) } }) } return { ready: o, supported: !0, useWorkers: function (A) { g(A) }, decodeVertexBuffer: function (A, b, y, _, w) { l(n.exports.meshopt_decodeVertexBuffer, A, b, y, _, n.exports[c[w]]) }, decodeIndexBuffer: function (A, b, y, _) { l(n.exports.meshopt_decodeIndexBuffer, A, b, y, _) }, decodeIndexSequence: function (A, b, y, _) { l(n.exports.meshopt_decodeIndexSequence, A, b, y, _) }, decodeGltfBuffer: function (A, b, y, _, w, E) { l(n.exports[h[w]], A, b, y, _, n.exports[c[E]]) }, decodeGltfBufferAsync: function (A, b, y, _, w) { return d.length > 0 ? m(A, b, y, h[_], c[w]) : o.then(function () { var E = new Uint8Array(A * b); return l(n.exports[h[_]], E, A, b, y, n.exports[c[w]]), E }) } } }(); const wd = oe("debugdecoders"), ND = "https://www.gstatic.com/draco/versioned/decoders/1.4.1/", zD = "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/"; let go, BC, cc; function jD(i) { i !== void 0 && typeof i == "string" && (go || (go = new _C), wd && console.log("Setting draco decoder path to", i), go.setDecoderPath(i)) } function QD(i) { i !== void 0 && typeof i == "string" && (go || (go = new _C), wd && console.log("Setting draco decoder type to", i), go.setDecoderConfig({ type: i })) } function GD(i) { i !== void 0 && typeof i == "string" && (cc || (cc = new Io), wd && console.log("Setting ktx2 transcoder path to", i), cc.setTranscoderPath(i)) } function wg(i, e) { go || (go = new _C, go.setDecoderPath(ND), go.setDecoderConfig({ type: "js" }), wd && console.log("Setting draco decoder path to", ND)), cc || (cc = new Io, cc.setTranscoderPath(zD), wd && console.log("Setting ktx2 transcoder path to", zD), e.renderer && cc.detectSupport(e.renderer)), BC || (BC = Kq, wd && console.log("Using the default meshopt decoder")), i.setDRACOLoader(go), i.setKTX2Loader(cc), i.setMeshoptDecoder(BC) } class Zq { constructor() { u(this, "_context") } get context() { return this._context ?? _t.Current } get isStateMachineBehaviour() { return !0 } } class cy { constructor(e, t, s, r) { u(this, "_name"), u(this, "_nameHash"), u(this, "_normalizedTime"), u(this, "_length"), u(this, "_speed"), this._name = e.name, this._nameHash = e.hash, this._normalizedTime = t, this._length = s, this._speed = r } get name() { return this._name } get nameHash() { return this._nameHash } get normalizedTime() { return this._normalizedTime } get length() { return this._length } get speed() { return this._speed } } function HD(i, e) { return { name: "", isLooping: !1, guid: e?.generateUUID() ?? kr.generateUUID(), index: -1, clip: new En(i, 1, []) } } var hc = (i => (i[i.If = 1] = "If", i[i.IfNot = 2] = "IfNot", i[i.Greater = 3] = "Greater", i[i.Less = 4] = "Less", i[i.Equals = 6] = "Equals", i[i.NotEqual = 7] = "NotEqual", i))(hc || {}), kC = (i => (i[i.Float = 1] = "Float", i[i.Int = 3] = "Int", i[i.Bool = 4] = "Bool", i[i.Trigger = 9] = "Trigger", i))(kC || {}); const Qo = oe("debuganimatorcontroller"), hy = oe("debugrootmotion"); class xu { constructor(e) { u(this, "normalizedStartOffset", 0), u(this, "_speed", 1), u(this, "animator"), u(this, "model"), u(this, "_mixer"), u(this, "_activeState"), u(this, "_activeStates", []), u(this, "rootMotionHandler"), this.model = e, Qo && console.log(this) } play(e, t = -1, s = Number.NEGATIVE_INFINITY, r = 0) { if (t < 0) t = 0; else if (t >= this.model.layers.length) { console.warn("invalid layer"); return } const n = this.model.layers[t].stateMachine; for (const o of n.states) if (o.name === e || o.hash === e) { Qo && console.log("transition to ", o), this.transitionTo(o, r, s); return } console.warn("Could not find " + e + " to play") } reset() { this.setStartTransition() } setBool(e, t) { var s, r; const n = typeof e == "string" ? "name" : "hash"; return (r = (s = this.model) == null ? void 0 : s.parameters) == null ? void 0 : r.filter(o => o[n] === e).forEach(o => o.value = t) } getBool(e) { var t, s, r; const n = typeof e == "string" ? "name" : "hash"; return ((r = (s = (t = this.model) == null ? void 0 : t.parameters) == null ? void 0 : s.find(o => o[n] === e)) == null ? void 0 : r.value) ?? !1 } setFloat(e, t) { var s, r; const n = typeof e == "string" ? "name" : "hash"; return (r = (s = this.model) == null ? void 0 : s.parameters) == null ? void 0 : r.filter(o => o[n] === e).forEach(o => o.value = t) } getFloat(e) { var t, s, r; const n = typeof e == "string" ? "name" : "hash"; return ((r = (s = (t = this.model) == null ? void 0 : t.parameters) == null ? void 0 : s.find(o => o[n] === e)) == null ? void 0 : r.value) ?? 0 } setInteger(e, t) { var s, r; const n = typeof e == "string" ? "name" : "hash"; return (r = (s = this.model) == null ? void 0 : s.parameters) == null ? void 0 : r.filter(o => o[n] === e).forEach(o => o.value = t) } getInteger(e) { var t, s, r; const n = typeof e == "string" ? "name" : "hash"; return ((r = (s = (t = this.model) == null ? void 0 : t.parameters) == null ? void 0 : s.find(o => o[n] === e)) == null ? void 0 : r.value) ?? 0 } setTrigger(e) { var t, s; Qo && console.log("SET TRIGGER", e); const r = typeof e == "string" ? "name" : "hash"; return (s = (t = this.model) == null ? void 0 : t.parameters) == null ? void 0 : s.filter(n => n[r] === e).forEach(n => n.value = !0) } resetTrigger(e) { var t, s; const r = typeof e == "string" ? "name" : "hash"; return (s = (t = this.model) == null ? void 0 : t.parameters) == null ? void 0 : s.filter(n => n[r] === e).forEach(n => n.value = !1) } isInTransition() { return this._activeStates.length > 1 } setSpeed(e) { this._speed = e } FindState(e) { return this.findState(e) } findState(e) { if (!e) return null; if (Array.isArray(this.model.layers)) { for (const t of this.model.layers) for (const s of t.stateMachine.states) if (s.name === e) return s } return null } get context() { var e; return (e = this.animator) == null ? void 0 : e.context } bind(e) { this.animator = e, this._mixer = new i0(this.animator.gameObject), this.createActions(this.animator) } clone() { if (typeof this.model == "string") return console.warn("AnimatorController has not been resolved, can not create model from string", this.model), null; const e = Ov(this.model, (t, s, r) => r == null ? !0 : !(r.type === "Object3D" || r.isObject3D === !0 || _B(r) || r.tracks !== void 0)); return console.assert(e !== this.model), new xu(e) } update() { var e, t; if (!this.animator || (this.evaluateTransitions(), this.updateActiveStates(), !this._activeState)) return; const s = this.animator.context.time.deltaTime; this.animator.applyRootMotion && ((e = this.rootMotionHandler) == null || e.onBeforeUpdate()), this._mixer.update(s), this.animator.applyRootMotion && ((t = this.rootMotionHandler) == null || t.onAfterUpdate()) } updateActiveStates() { for (let e = 0; e < this._activeStates.length; e++) { const t = this._activeStates[e], s = t.motion; if (!s.action) this._activeStates.splice(e, 1), e--; else { const r = s.action; r.getEffectiveWeight() <= 0 && !r.isRunning() && (Qo && console.debug("REMOVE", t.name, r.getEffectiveWeight(), r.isRunning(), r.isScheduled()), this._activeStates.splice(e, 1), e--) } } } setStartTransition() { for (const e of this.model.layers) { const t = e.stateMachine; t.defaultState === void 0 && (Qo && console.warn("AnimatorController default state is undefined, will assign state 0 as default", e), t.defaultState = 0); const s = t.states[t.defaultState]; this.transitionTo(s, 0, this.normalizedStartOffset) } } evaluateTransitions() { var e; let t = !1; if (!this._activeState) { if (this.setStartTransition(), !this._activeState) return; t = !0 } const s = this._activeState, r = s.motion.action; for (const o of s.transitions) { if (!o.hasExitTime && o.conditions.length <= 0) continue; let a = !0; for (const l of o.conditions) if (!this.evaluateCondition(l)) { a = !1; break } if (a) { for (const l of o.conditions) { const c = this.model.parameters.find(h => h.name === l.parameter); c?.type === kC.Trigger && (c.value = !1) } if (r) { const l = s.motion.clip.duration, c = l <= 0 ? 1 : Math.abs(r.time / l); let h = !1; if (o.hasExitTime ? r.timeScale > 0 ? h = c >= o.exitTime : r.timeScale < 0 && (h = 1 - c >= o.exitTime) : h = !0, h) { r.clampWhenFinished = !0, Qo && console.log("transition to " + o.destinationState, o, c, o.exitTime, o.hasExitTime), this.transitionTo(o.destinationState, o.duration, o.offset); return } } else { this.transitionTo(o.destinationState, o.duration, o.offset); return } } } let n = !1; if (s.motion.isLooping && r && (r.time >= r.getClip().duration ? (n = !0, r.reset(), r.time = 0, r.play()) : r.time <= 0 && r.timeScale < 0 && (n = !0, r.reset(), r.time = r.getClip().duration, r.play())), !n && s && !t && r && this.animator && s.behaviours) { const o = r?.getClip().duration, a = r.time / o, l = new cy(this._activeState, a, o, this._speed); for (const c of s.behaviours) c.instance && ((e = c.instance.onStateUpdate) == null || e.call(c.instance, this.animator, l, 0)) } } getState(e, t) { return typeof e == "number" && (e == -1 && (e = this.model.layers[t].stateMachine.defaultState, e === void 0 && (Qo && console.warn("AnimatorController default state is undefined: ", this.model, "Layer: " + t), e = 0)), e = this.model.layers[t].stateMachine.states[e]), e } transitionTo(e, t, s) { var r, n, o, a, l, c, h, d; if (!this.animator) return; const p = 0; if (e = this.getState(e, p), !(e != null && e.motion) || !e.motion.clip) return; const f = this._activeState === e; if (f) { const A = e.motion; !A.action_loopback && A.clip && (this._mixer.uncacheAction(A.clip, this.animator.gameObject), A.action_loopback = this.createAction(A.clip)) } if ((r = this._activeState) != null && r.behaviours && this._activeState.motion.action) { const A = (n = this._activeState) == null ? void 0 : n.motion.clip.duration, b = this._activeState.motion.action.time / A, y = new cy(this._activeState, b, A, this._speed); for (const _ of this._activeState.behaviours) (a = (o = _.instance) == null ? void 0 : o.onStateExit) == null || a.call(_.instance, this.animator, y, p) } const g = (l = this._activeState) == null ? void 0 : l.motion.action; g && g.fadeOut(t), f && (e.motion.action = e.motion.action_loopback, e.motion.action_loopback = g); const m = this._activeState; this._activeState = e; const v = (c = e.motion) == null ? void 0 : c.action; if (v) { s = Math.max(0, Math.min(1, s)), v.isRunning() && v.stop(), v.reset(), v.timeScale = this._speed, e.speed !== void 0 && (v.timeScale *= e.speed), v.enabled = !0; const A = e.motion.clip.duration; if (v.time = s * A, v.timeScale < 0 && (v.time = A - v.time), v.clampWhenFinished = !0, v.setLoop(gf, 0), t > 0 ? v.fadeIn(t) : v.setEffectiveWeight(1), v.play(), this.rootMotionHandler && this.rootMotionHandler.onStart(v), this._activeStates.includes(e) || this._activeStates.push(e), this._activeState.behaviours) { const b = new cy(e, s, A, this._speed); for (const y of this._activeState.behaviours) (d = (h = y.instance) == null ? void 0 : h.onStateEnter) == null || d.call(y.instance, this.animator, b, p) } } else Qo && (e.__warned_no_motion || (e.__warned_no_motion = !0, console.warn("No action", e.motion, this))); Qo && console.log("TRANSITION FROM " + m?.name + " TO " + e.name, t, g, v, v?.getEffectiveTimeScale(), v?.getEffectiveWeight(), v?.isRunning(), v?.isScheduled(), v?.paused) } createAction(e) { var t, s; if (this._mixer.existingAction(e) && this._mixer.uncacheAction(e, (t = this.animator) == null ? void 0 : t.gameObject), (s = this.animator) != null && s.applyRootMotion) { this.rootMotionHandler || (this.rootMotionHandler = new $q(this)); const r = this.animator.gameObject; return this.rootMotionHandler.createClip(this._mixer, r, e) } else return this._mixer.clipAction(e) } evaluateCondition(e) { const t = this.model.parameters.find(s => s.name === e.parameter); if (!t) return !1; switch (e.mode) { case hc.If: return t.value === !0; case hc.IfNot: return t.value === !1; case hc.Greater: return t.value > e.threshold; case hc.Less: return t.value < e.threshold; case hc.Equals: return t.value === e.threshold; case hc.NotEqual: return t.value !== e.threshold }return !1 } createActions(e) { var t, s; for (const r of this.model.layers) { const n = r.stateMachine; for (let o = 0; o < n.states.length; o++) { const a = n.states[o]; a.transitions || (a.transitions = []); for (const l of a.transitions) l.conditions || (l.conditions = []); if (a.motion || (a.motion = HD(a.name)), this.animator && a.motion.clips) { const l = (t = a.motion.clips) == null ? void 0 : t.find(c => { var h, d; return c.node.name === ((d = (h = this.animator) == null ? void 0 : h.gameObject) == null ? void 0 : d.name) }); a.motion.clip = l?.clip } if (!a.motion.clip) { const l = new En(void 0, void 0, []); a.motion.clip = l } if ((s = a.motion) != null && s.clip) { const l = a.motion.clip, c = this.createAction(l); a.motion.action = c } if (a.behaviours && Array.isArray(a.behaviours)) for (const l of a.behaviours) { if (!(l != null && l.typeName)) continue; const c = Q.get(l.typeName), h = new c; h.isStateMachineBehaviour && (h._context = this.context ?? void 0, Rh(h, l.properties), l.instance = h), Qo && console.log("Created animator controller behaviour", a.name, l.typeName, l.properties, h) } } } } *enumerateActions() { for (const e of this.model.layers) { const t = e.stateMachine; for (let s = 0; s < t.states.length; s++) { const r = t.states[s]; r != null && r.motion && (r.motion.action && (yield r.motion.action), r.motion.action_loopback && (yield r.motion.action_loopback)) } } } } class VD { constructor(e, t) { u(this, "track"), u(this, "createdInterpolant"), u(this, "originalEvaluate"), u(this, "customEvaluate"), this.track = e; const s = e, r = s.createInterpolant.bind(e); s.createInterpolant = () => (s.createInterpolant = r, this.createdInterpolant = r(), this.originalEvaluate = this.createdInterpolant.evaluate.bind(this.createdInterpolant), this.customEvaluate = n => { if (!this.originalEvaluate) return; const o = this.originalEvaluate(n); return t(n, o) }, this.createdInterpolant.evaluate = this.customEvaluate, this.createdInterpolant) } evaluate(e) { this.customEvaluate && this.customEvaluate(e) } dispose() { this.createdInterpolant && this.originalEvaluate && (this.createdInterpolant.evaluate = this.originalEvaluate), this.track = void 0, this.createdInterpolant = null, this.originalEvaluate = void 0, this.customEvaluate = void 0 } } const xs = class { constructor(i, e, t, s, r) { if (u(this, "_action"), u(this, "root"), u(this, "clip"), u(this, "positionWrapper", null), u(this, "rotationWrapper", null), u(this, "context"), u(this, "positionChange", new S), u(this, "rotationChange", new we), this.context = i, this.root = e, this.clip = t, xs.firstKeyframeRotation[t.uuid] || (xs.firstKeyframeRotation[t.uuid] = new we), r) { const n = r.values; xs.firstKeyframeRotation[t.uuid].set(n[0], n[1], n[2], n[3]) } xs.spaceRotation[t.uuid] || (xs.spaceRotation[t.uuid] = new we), xs.effectiveSpaceRotation[t.uuid] || (xs.effectiveSpaceRotation[t.uuid] = new we), xs.clipOffsetRotation[t.uuid] = new we, r && xs.clipOffsetRotation[t.uuid].set(r.values[0], r.values[1], r.values[2], r.values[3]).invert(), this.handlePosition(t, s), this.handleRotation(t, r) } set action(i) { this._action = i } get action() { return this._action } onStart(i) { if (i.getClip() !== this.clip) return; const e = xs.lastObjRotation[this.root.uuid]; if (xs.spaceRotation[this.clip.uuid].copy(e), hy) { const t = new ps().setFromQuaternion(e); console.log("START", this.clip.name, Ke.toDegrees(t.y)) } } getClipRotationOffset() { return xs.clipOffsetRotation[this.clip.uuid] } handlePosition(i, e) { if (e) { const t = this.root; hy && t.add(new ud), xs.lastObjPosition[t.uuid] || (xs.lastObjPosition[t.uuid] = new S); const s = new S, r = new S; let n = 0; this.positionWrapper = new VD(e, (o, a) => { const l = this.action.getEffectiveWeight(); if (hy && t.position.length() > 8 && t.position.set(0, t.position.y, 0), o > n) { s.set(a[0], a[1], a[2]), s.sub(r), s.multiplyScalar(l), s.applyQuaternion(this.getClipRotationOffset()); const c = this.clip.uuid; s.applyQuaternion(xs.spaceRotation[c]), this.positionChange.copy(s) } return r.fromArray(a), n = o, a[0] = 0, a[1] = 0, a[2] = 0, a }) } } handleRotation(i, e) { if (e) { if (hy) { const o = e.values, a = new ps().setFromQuaternion(new we(o[0], o[1], o[2], o[3])); console.log(i.name, e.name, "FIRST ROTATION IN TRACK", Ke.toDegrees(a.y)); const l = e.values.length - 4, c = new we().set(o[l], o[l + 1], o[l + 2], o[l + 3]), h = new ps().setFromQuaternion(c); console.log(i.name, e.name, "LAST ROTATION IN TRACK", Ke.toDegrees(h.y)) } const t = this.root; xs.lastObjRotation[t.uuid] || (xs.lastObjRotation[t.uuid] = new we); let s = 0; const r = new we, n = new we; this.rotationWrapper = new VD(e, (o, a) => (o > s && (n.set(a[0], a[1], a[2], a[3]), r.invert(), n.multiply(r), this.rotationChange.copy(n)), r.fromArray(a), s = o, a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a)) } } onBeforeUpdate() { this.positionChange.set(0, 0, 0), this.rotationChange.set(0, 0, 0, 1) } onAfterUpdate() { if (!this.action) return; const i = this.action.getEffectiveWeight(); this.positionChange.multiplyScalar(i), this.rotationChange.slerp(xs.identityQuaternion, 1 - i) } }; let Ka = xs; u(Ka, "lastObjPosition", {}), u(Ka, "lastObjRotation", {}), u(Ka, "firstKeyframeRotation", {}), u(Ka, "spaceRotation", {}), u(Ka, "effectiveSpaceRotation", {}), u(Ka, "clipOffsetRotation", {}), u(Ka, "identityQuaternion", new we); class $q { constructor(e) { u(this, "controller"), u(this, "handler", []), u(this, "root"), u(this, "summedPosition", new S), u(this, "summedRotation", new we), this.controller = e } createClip(e, t, s) { this.root = t, t && "name" in t && t.name; const r = this.findRootTrack(s, ".position"), n = this.findRootTrack(s, ".quaternion"), o = new Ka(this.controller.context, t, s, r, n); this.handler.push(o); const a = e.clipAction(s); return o.action = a, a } onStart(e) { for (const t of this.handler) t.onStart(e) } onBeforeUpdate() { for (const e of this.handler) e.onBeforeUpdate() } onAfterUpdate() { this.summedPosition.set(0, 0, 0), this.summedRotation.set(0, 0, 0, 1); for (const e of this.handler) e.onAfterUpdate(), this.summedPosition.add(e.positionChange), this.summedRotation.multiply(e.rotationChange); this.root.position.add(this.summedPosition), this.root.quaternion.multiply(this.summedRotation), Ka.lastObjRotation[this.root.uuid].copy(this.root.quaternion) } findRootTrack(e, t) { const s = e.tracks; if (!s) return null; for (const r of s) if (r.name.endsWith(t)) return r; return null } } const Cd = function (i) { return x(i) }, x = function (i) { if (i === void 0 && (i = null), !Array.isArray(i)) i = WD(i); else for (let e = 0; e < i.length; e++) { const t = i[e]; i[e] = WD(t) } return function (e, t) { Object.getOwnPropertyDescriptor(e, "$serializedTypes") || (e.$serializedTypes = {}); const s = e.$serializedTypes = e.$serializedTypes || {}; s[t] = i } }; function WD(i) { var e, t; switch ((t = (e = i?.prototype) == null ? void 0 : e.constructor) == null ? void 0 : t.name) { case "Number": case "String": case "Boolean": return null }return i } var e7 = Object.defineProperty, t7 = Object.getOwnPropertyDescriptor, uy = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? t7(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && e7(e, t, r), r }; const DC = oe("debuganimator"); class Fr extends Ee { constructor() { super(...arguments), u(this, "applyRootMotion", !1), u(this, "hasRootMotion", !1), u(this, "keepAnimatorControllerStateOnDisable", !1), u(this, "speed", 1), u(this, "normalizedStartOffset", 0), u(this, "_animatorController", null) } set runtimeAnimatorController(e) { this._animatorController && this._animatorController.model === e || (e ? e instanceof xu ? this._animatorController = e : (DC && console.log("Assign animator controller", e, this), this._animatorController = new xu(e)) : this._animatorController = null) } get runtimeAnimatorController() { return this._animatorController } Play(e, t = -1, s = Number.NEGATIVE_INFINITY, r = 0) { this.play(e, t, s, r) } play(e, t = -1, s = Number.NEGATIVE_INFINITY, r = 0) { var n; (n = this.runtimeAnimatorController) == null || n.play(e, t, s, r) } Reset() { this.reset() } reset() { var e; (e = this._animatorController) == null || e.reset() } SetBool(e, t) { this.setBool(e, t) } setBool(e, t) { var s; (s = this.runtimeAnimatorController) == null || s.setBool(e, t) } GetBool(e) { return this.getBool(e) } getBool(e) { var t; return ((t = this.runtimeAnimatorController) == null ? void 0 : t.getBool(e)) ?? !1 } SetFloat(e, t) { this.setFloat(e, t) } setFloat(e, t) { var s; (s = this.runtimeAnimatorController) == null || s.setFloat(e, t) } GetFloat(e) { return this.getFloat(e) } getFloat(e) { var t; return ((t = this.runtimeAnimatorController) == null ? void 0 : t.getFloat(e)) ?? -1 } SetInteger(e, t) { this.setInteger(e, t) } setInteger(e, t) { var s; (s = this.runtimeAnimatorController) == null || s.setInteger(e, t) } GetInteger(e) { return this.getInteger(e) } getInteger(e) { var t; return ((t = this.runtimeAnimatorController) == null ? void 0 : t.getInteger(e)) ?? -1 } SetTrigger(e) { this.setTrigger(e) } setTrigger(e) { var t; DC && console.log("SetTrigger", e), (t = this.runtimeAnimatorController) == null || t.setTrigger(e) } ResetTrigger(e) { this.resetTrigger(e) } resetTrigger(e) { var t; (t = this.runtimeAnimatorController) == null || t.resetTrigger(e) } IsInTransition() { return this.isInTransition() } isInTransition() { var e; return ((e = this.runtimeAnimatorController) == null ? void 0 : e.isInTransition()) ?? !1 } SetSpeed(e) { return this.setSpeed(e) } setSpeed(e) { var t; e !== this.speed && (this.speed = e, (t = this._animatorController) == null || t.setSpeed(e)) } set minMaxSpeed(e) { this.speed = Ke.lerp(e.x, e.y, Math.random()) } set minMaxOffsetNormalized(e) { this.normalizedStartOffset = Ke.lerp(e.x, e.y, Math.random()), this.runtimeAnimatorController && (this.runtimeAnimatorController.normalizedStartOffset = this.normalizedStartOffset) } awake() { if (DC && console.log("ANIMATOR", this.name, this), !!this.gameObject && this.runtimeAnimatorController) { const e = this.runtimeAnimatorController.clone(); e ? (console.assert(this.runtimeAnimatorController !== e), this.runtimeAnimatorController = e, console.assert(this.runtimeAnimatorController === e), this.runtimeAnimatorController.bind(this), this.runtimeAnimatorController.setSpeed(this.speed), this.runtimeAnimatorController.normalizedStartOffset = this.normalizedStartOffset) : console.warn("Could not clone animator controller", this.runtimeAnimatorController) } } onDisable() { var e; this.keepAnimatorControllerStateOnDisable || (e = this._animatorController) == null || e.reset() } onBeforeRender() { this._animatorController && this._animatorController.update() } } uy([x()], Fr.prototype, "applyRootMotion", 2), uy([x()], Fr.prototype, "hasRootMotion", 2), uy([x()], Fr.prototype, "keepAnimatorControllerStateOnDisable", 2), uy([x()], Fr.prototype, "runtimeAnimatorController", 1); var i7 = Object.defineProperty, s7 = Object.getOwnPropertyDescriptor, Cg = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? s7(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && i7(e, t, r), r }; const uc = oe("debuganimation"); class mo extends Ee { constructor() { super(...arguments), u(this, "playAutomatically", !0), u(this, "randomStartTime", !0), u(this, "minMaxSpeed"), u(this, "minMaxOffsetNormalized"), u(this, "loop", !0), u(this, "clampWhenFinished", !1), u(this, "_tempAnimationClipBeforeGameObjectExisted", null), u(this, "mixer"), u(this, "_actions", []), u(this, "_currentActions", []), u(this, "_handles", []), u(this, "_didInit", !1) } get clip() { var e; return (e = this.animations) != null && e.length ? this.animations[0] : null } set clip(e) { if (!this.__didAwake) { uc && console.log("Assign clip during serialization", e), this._tempAnimationClipBeforeGameObjectExisted = e; return } e && (uc && console.log("Assign clip", e, !!this.gameObject), this.gameObject.animations || (this.gameObject.animations = []), !this.animations.includes(e) && (this.animations.length > 0 ? this.animations.splice(0, 0, e) : this.animations.push(e))) } set clips(e) { this.animations = e } set animations(e) { uc && console.log("assign animations", e), this.gameObject.animations = e } get animations() { return this.gameObject.animations } get currentAction() { return this._currentActions[0] } get currentActions() { return this._currentActions } get actions() { return this._actions } set actions(e) { this._actions = e } awake() { uc && console.log(this), this._tempAnimationClipBeforeGameObjectExisted && (this.clip = this._tempAnimationClipBeforeGameObjectExisted, this._tempAnimationClipBeforeGameObjectExisted = null), this.playAutomatically && this.init() } onEnable() { var e; if (this.playAutomatically && ((e = this.animations) == null ? void 0 : e.length) > 0 && this.currentActions.length <= 0) { const t = Math.floor(Math.random() * this.actions.length); this.play(t) } } start() { this.randomStartTime && this.currentAction && (this.currentAction.time = Math.random() * this.currentAction.getClip().duration) } update() { this.mixer && this.mixer.update(this.context.time.deltaTime) } getAction(e) { var t; return (t = this.actions) == null ? void 0 : t.find(s => s.getClip().name === e) } get isPlaying() { for (let e = 0; e < this._currentActions.length; e++)if (this._currentActions[e].isRunning()) return !0; return !1 } play(e = 0, t) { if (uc && console.log("PLAY", e), this.init(), !this.mixer) { uc && console.warn("Missing mixer", this); return } e === void 0 && (e = 0); let s = e; if (typeof e == "number") { if (e >= this.animations.length) { uc && console.log("No animation at index", e); return } s = this.animations[e] } else typeof e == "string" && (s = this.animations.find(n => n.name === e)); if (!s) { console.error("Could not find clip", e); return } t || (t = {}), t.minMaxOffsetNormalized || (t.minMaxOffsetNormalized = this.minMaxOffsetNormalized), t.minMaxSpeed || (t.minMaxSpeed = this.minMaxSpeed), t.loop === void 0 && (t.loop = this.loop), t.clampWhenFinished === void 0 && (t.clampWhenFinished = this.clampWhenFinished); for (const n of this.actions) if (n.getClip() === s) return this.internalOnPlay(n, t); if (!(s instanceof En)) { console.warn("Clip is no AnimationClip", s, "on object: " + this.name); return } const r = this.mixer.clipAction(s); return this.actions.push(r), this.internalOnPlay(r, t) } internalOnPlay(e, t) { var s = this.currentAction; if (s === e && s.isRunning() && s.time < s.getClip().duration) { const a = this.tryFindHandle(e); if (a) return a.getPromise() } const r = t?.exclusive ?? !0; t != null && t.fadeDuration ? (r && s?.fadeOut(t.fadeDuration), e.fadeIn(t.fadeDuration)) : r && s?.stop(), e.reset(), e.enabled = !0, e.time = 0, e.timeScale = 1; const n = e.getClip(); t != null && t.minMaxOffsetNormalized && (e.time = Ke.lerp(t.minMaxOffsetNormalized.x, t.minMaxOffsetNormalized.y, Math.random()) * n.duration), t != null && t.minMaxSpeed && (e.timeScale = Ke.lerp(t.minMaxSpeed.x, t.minMaxSpeed.y, Math.random())), t != null && t.clampWhenFinished && (e.clampWhenFinished = !0), t?.startTime !== void 0 && (e.time = t.startTime), t?.loop !== void 0 ? e.loop = t.loop ? Tx : gf : e.loop = gf, e.play(), uc && console.log("PLAY", e.getClip().name, e); const o = new r7(e, this.mixer, t, a => { this._handles.splice(this._handles.indexOf(o), 1) }); return this._handles.push(o), o.getPromise() } tryFindHandle(e) { for (const t of this._handles) if (t.action === e) return t } init() { this._didInit || (this._didInit = !0, this.gameObject && (this.actions = [], this.mixer = new i0(this.gameObject))) } } Cg([x()], mo.prototype, "playAutomatically", 2), Cg([x()], mo.prototype, "randomStartTime", 2), Cg([x()], mo.prototype, "loop", 2), Cg([x()], mo.prototype, "clampWhenFinished", 2), Cg([x(En)], mo.prototype, "clips", 1); class r7 { constructor(e, t, s, r) { u(this, "mixer"), u(this, "action"), u(this, "promise", null), u(this, "resolve", null), u(this, "reject", null), u(this, "_options"), u(this, "_resolveCallback", null), u(this, "_rejectCallback", null), u(this, "_loopCallback"), u(this, "_finishedCallback"), u(this, "_resolvedOrRejectedCallback"), this.action = e, this.mixer = t, this._resolvedOrRejectedCallback = r, this._options = s } getPromise() { return this.promise ? this.promise : (this.promise = new Promise((e, t) => { this._resolveCallback = e, this._rejectCallback = t, this.resolve = this.onResolve.bind(this), this.reject = this.onReject.bind(this) }), this._loopCallback = this.onLoop.bind(this), this._finishedCallback = this.onFinished.bind(this), this.mixer.addEventListener("loop", this._loopCallback), this.mixer.addEventListener("finished", this._finishedCallback), this.promise) } _update() { this._options && this._options.endTime !== void 0 && this.action.time > this._options.endTime && (this._options.loop === !0 ? this.action.time = this._options.startTime ?? 0 : (this.action.time = this._options.endTime, this.action.timeScale = 0, this.onResolve())) } onResolve() { var e, t; this.dispose(), (e = this._resolvedOrRejectedCallback) == null || e.call(this, this), (t = this._resolveCallback) == null || t.call(this, this.action) } onReject(e) { var t, s; this.dispose(), (t = this._resolvedOrRejectedCallback) == null || t.call(this, this), (s = this._rejectCallback) == null || s.call(this, e) } onLoop(e) { } onFinished(e) { e.action === this.action && this.onResolve() } dispose() { this._loopCallback && this.mixer.removeEventListener("loop", this._loopCallback), this._finishedCallback && this.mixer.removeEventListener("finished", this._finishedCallback), this._loopCallback = void 0, this._finishedCallback = void 0 } } class Sd extends tr { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.animationPointerResolver = null, this.pluginCallbacks = [], this.register(function (t) { return new c7(t) }), this.register(function (t) { return new v7(t) }), this.register(function (t) { return new A7(t) }), this.register(function (t) { return new d7(t) }), this.register(function (t) { return new p7(t) }), this.register(function (t) { return new f7(t) }), this.register(function (t) { return new g7(t) }), this.register(function (t) { return new l7(t) }), this.register(function (t) { return new m7(t) }), this.register(function (t) { return new u7(t) }), this.register(function (t) { return new o7(t) }), this.register(function (t) { return new y7(t) }), this.register(function (t) { return new b7(t) }), this.register(function (t) { return new h7(t) }) } load(e, t, s, r) { const n = this; let o; this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = Do.extractUrlBase(e), this.manager.itemStart(e); const a = function (c) { r ? r(c) : console.error(c), n.manager.itemError(e), n.manager.itemEnd(e) }, l = new bs(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (c) { try { n.parse(c, o, function (h) { t(h), n.manager.itemEnd(e) }, a) } catch (h) { a(h) } }, s, a) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } setAnimationPointerResolver(e) { return this.animationPointerResolver = e, this } register(e) { return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this } unregister(e) { return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, s, r) { let n; const o = {}, a = {}; if (typeof e == "string") n = JSON.parse(e); else if (e instanceof ArrayBuffer) if (Do.decodeText(new Uint8Array(e, 0, 4)) === qD) { try { o[Ft.KHR_BINARY_GLTF] = new _7(e) } catch (c) { r && r(c); return } n = JSON.parse(o[Ft.KHR_BINARY_GLTF].content) } else n = JSON.parse(Do.decodeText(new Uint8Array(e))); else n = e; if (n.asset === void 0 || n.asset.version[0] < 2) { r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); return } const l = new B7(n, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder, animationPointerResolver: this.animationPointerResolver }); l.fileLoader.setRequestHeader(this.requestHeader); for (let c = 0; c < this.pluginCallbacks.length; c++) { const h = this.pluginCallbacks[c](l); a[h.name] = h, o[h.name] = !0 } if (n.extensionsUsed) for (let c = 0; c < n.extensionsUsed.length; ++c) { const h = n.extensionsUsed[c], d = n.extensionsRequired || []; switch (h) { case Ft.KHR_MATERIALS_UNLIT: o[h] = new a7; break; case Ft.KHR_DRACO_MESH_COMPRESSION: o[h] = new x7(n, this.dracoLoader); break; case Ft.KHR_TEXTURE_TRANSFORM: o[h] = new w7; break; case Ft.KHR_MESH_QUANTIZATION: o[h] = new C7; break; default: d.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".') } } l.setExtensions(o), l.setPlugins(a), l.parse(s, r) } parseAsync(e, t) { const s = this; return new Promise(function (r, n) { s.parse(e, t, r, n) }) } } function n7() { let i = {}; return { get: function (e) { return i[e] }, add: function (e, t) { i[e] = t }, remove: function (e) { delete i[e] }, removeAll: function () { i = {} } } } const Ft = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", KHR_ANIMATION_POINTER: "KHR_animation_pointer", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class o7 { constructor(e) { this.parser = e, this.name = Ft.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let s = 0, r = t.length; s < r; s++) { const n = t[s]; n.extensions && n.extensions[this.name] && n.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, n.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, s = "light:" + e; let r = t.cache.get(s); if (r) return r; const n = t.json, o = ((n.extensions && n.extensions[this.name] || {}).lights || [])[e]; let a; const l = new xe(16777215); o.color !== void 0 && l.fromArray(o.color); const c = o.range !== void 0 ? o.range : 0; switch (o.type) { case "directional": a = new KA(l), a.target.position.set(0, 0, -1), a.add(a.target); break; case "point": a = new JA(l), a.distance = c; break; case "spot": a = new YA(l), a.distance = c, o.spot = o.spot || {}, o.spot.innerConeAngle = o.spot.innerConeAngle !== void 0 ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = o.spot.outerConeAngle !== void 0 ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type) }return a.position.set(0, 0, 0), a.decay = 2, pc(a, o), o.intensity !== void 0 && (a.intensity = o.intensity), a.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(a), t.cache.add(s, r), r } getDependency(e, t) { if (e === "light") return this._loadLight(t) } createNodeAttachment(e) { const t = this, s = this.parser, r = s.json.nodes[e], n = (r.extensions && r.extensions[this.name] || {}).light; return n === void 0 ? null : this._loadLight(n).then(function (o) { return s._getNodeRef(t.cache, n, o) }) } } let a7 = class { constructor() { this.name = Ft.KHR_MATERIALS_UNLIT } getMaterialType() { return di } extendParams(i, e, t) { const s = []; i.color = new xe(1, 1, 1), i.opacity = 1; const r = e.pbrMetallicRoughness; if (r) { if (Array.isArray(r.baseColorFactor)) { const n = r.baseColorFactor; i.color.fromArray(n), i.opacity = n[3] } r.baseColorTexture !== void 0 && s.push(t.assignTexture(i, "map", r.baseColorTexture, Xe)) } return Promise.all(s) } }; class l7 { constructor(e) { this.parser = e, this.name = Ft.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, t) { const s = this.parser.json.materials[e]; if (!s.extensions || !s.extensions[this.name]) return Promise.resolve(); const r = s.extensions[this.name].emissiveStrength; return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve() } } let c7 = class { constructor(i) { this.parser = i, this.name = Ft.KHR_MATERIALS_CLEARCOAT } getMaterialType(i) { const e = this.parser.json.materials[i]; return !e.extensions || !e.extensions[this.name] ? null : Bo } extendMaterialParams(i, e) { const t = this.parser, s = t.json.materials[i]; if (!s.extensions || !s.extensions[this.name]) return Promise.resolve(); const r = [], n = s.extensions[this.name]; if (n.clearcoatFactor !== void 0 && (e.clearcoat = n.clearcoatFactor), n.clearcoatTexture !== void 0 && r.push(t.assignTexture(e, "clearcoatMap", n.clearcoatTexture)), n.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = n.clearcoatRoughnessFactor), n.clearcoatRoughnessTexture !== void 0 && r.push(t.assignTexture(e, "clearcoatRoughnessMap", n.clearcoatRoughnessTexture)), n.clearcoatNormalTexture !== void 0 && (r.push(t.assignTexture(e, "clearcoatNormalMap", n.clearcoatNormalTexture)), n.clearcoatNormalTexture.scale !== void 0)) { const o = n.clearcoatNormalTexture.scale; e.clearcoatNormalScale = new W(o, o) } return Promise.all(r) } }; class h7 { constructor(e) { u(this, "ANIMATION_TARGET_TYPE", { node: "node", material: "material", camera: "camera", light: "light" }), u(this, "_animationPointerDebug", !1), u(this, "_havePatchedPropertyBindings", !1), this.parser = e, this.name = Ft.KHR_ANIMATION_POINTER } _patchPropertyBindingFindNode() { if (this._havePatchedPropertyBindings) return; this._havePatchedPropertyBindings = !0; const e = zt.findNode; zt.findNode = (t, s) => { if (s.startsWith(".materials.")) { this._animationPointerDebug && console.log("FIND", s); const r = s.substring(11).substring(s.indexOf(".")), n = r.indexOf("."), o = n < 0 ? r : r.substring(0, n); let a = null; return t.traverse(l => { var c, h; a !== null || l.type !== "Mesh" || (((c = l.material) == null ? void 0 : c.uuid) === o || ((h = l.material) == null ? void 0 : h.name) === o) && (a = l.material, this._animationPointerDebug && console.log(a, r), a !== null && (r.endsWith(".map") ? a = a.map : r.endsWith(".emissiveMap") && (a = a.emissiveMap))) }), a } else if (s.startsWith(".nodes.") || s.startsWith(".lights.") || s.startsWith(".cameras.")) { const r = s.split("."); let n; for (let o = 1; o < r.length; o++) { const a = r[o]; if (a.length == 36) n = t.getObjectByProperty("uuid", a); else if (n && n[a]) { const l = Number.parseInt(a); let c = a; l >= 0 && (c = l), n = n[c], this._animationPointerDebug && console.log(n) } else { const l = t.getObjectByName(a); l && (n = l) } } if (!n) { const o = e(t, r[2]); return o || console.warn(Ft.KHR_ANIMATION_POINTER + ": Property binding not found", s, t, t.name, r), o } return this._animationPointerDebug && console.log("NODE", s, n), n } return e(t, s) } } loadAnimationTargetFromChannel(e) { this._havePatchedPropertyBindings || this._patchPropertyBindingFindNode(); const t = e.target, s = t.extensions && t.extensions[Ft.KHR_ANIMATION_POINTER] && t.path && t.path === "pointer"; if (!s) return null; let r, n = this.ANIMATION_TARGET_TYPE.node, o; if (s) { const l = t.extensions[Ft.KHR_ANIMATION_POINTER]; let c = l.pointer; if (this._animationPointerDebug && console.log("Original path: " + c, t), !c) { console.warn("Invalid path", l, t); return } if (c.startsWith("/materials/") ? n = this.ANIMATION_TARGET_TYPE.material : c.startsWith("/extensions/KHR_lights_punctual/lights/") ? n = this.ANIMATION_TARGET_TYPE.light : c.startsWith("/cameras/") && (n = this.ANIMATION_TARGET_TYPE.camera), o = this._tryResolveTargetId(c, n), o === null || isNaN(o)) { console.warn("Failed resolving animation node id: " + o, c); return } else this._animationPointerDebug && console.log("Resolved node ID for " + n, o); switch (n) { case this.ANIMATION_TARGET_TYPE.material: const d = ("/materials/" + o.toString() + "/").length, p = c.substring(0, d); switch (r = c.substring(d), r) { case "pbrMetallicRoughness/baseColorFactor": r = "color"; break; case "pbrMetallicRoughness/roughnessFactor": r = "roughness"; break; case "pbrMetallicRoughness/metallicFactor": r = "metalness"; break; case "emissiveFactor": r = "emissive"; break; case "alphaCutoff": r = "alphaTest"; break; case "occlusionTexture/strength": r = "aoMapIntensity"; break; case "normalTexture/scale": r = "normalScale"; break; case "pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale": r = "map/repeat"; break; case "pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset": r = "map/offset"; break; case "emissiveTexture/extensions/KHR_texture_transform/scale": r = "emissiveMap/repeat"; break; case "emissiveTexture/extensions/KHR_texture_transform/offset": r = "emissiveMap/offset"; break; case "extensions/KHR_materials_emissive_strength/emissiveStrength": r = "emissiveIntensity"; break; case "extensions/KHR_materials_transmission/transmissionFactor": r = "transmission"; break; case "extensions/KHR_materials_ior/ior": r = "ior"; break; case "extensions/KHR_materials_volume/thicknessFactor": r = "thickness"; break; case "extensions/KHR_materials_volume/attenuationColor": r = "attenuationColor"; break; case "extensions/KHR_materials_volume/attenuationDistance": r = "attenuationDistance"; break; case "extensions/KHR_materials_iridescence/iridescenceFactor": r = "iridescence"; break; case "extensions/KHR_materials_iridescence/iridescenceIor": r = "iridescenceIOR"; break; case "extensions/KHR_materials_iridescence/iridescenceThicknessMinimum": r = "iridescenceThicknessRange[0]"; break; case "extensions/KHR_materials_iridescence/iridescenceThicknessMaximum": r = "iridescenceThicknessRange[1]"; break; case "extensions/KHR_materials_clearcoat/clearcoatFactor": r = "clearcoat"; break; case "extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor": r = "clearcoatRoughness"; break; case "extensions/KHR_materials_sheen/sheenColorFactor": r = "sheenColor"; break; case "extensions/KHR_materials_sheen/sheenRoughnessFactor": r = "sheenRoughness"; break; case "extensions/KHR_materials_specular/specularFactor": r = "specularIntensity"; break; case "extensions/KHR_materials_specular/specularColorFactor": r = "specularColor"; break }c = p + r, this._animationPointerDebug && console.log("PROPERTY PATH", p, r, c); break; case this.ANIMATION_TARGET_TYPE.node: const f = ("/nodes/" + o.toString() + "/").length, g = c.substring(0, f); switch (r = c.substring(f), r) { case "translation": r = "position"; break; case "rotation": r = "quaternion"; break; case "scale": r = "scale"; break; case "weights": r = "morphTargetInfluences"; break }c = g + r; break; case this.ANIMATION_TARGET_TYPE.light: const m = ("/extensions/KHR_lights_punctual/lights/" + o.toString() + "/").length; switch (r = c.substring(m), r) { case "color": break; case "intensity": break; case "spot/innerConeAngle": r = "penumbra"; break; case "spot/outerConeAngle": r = "angle"; break; case "range": r = "distance"; break }c = "/lights/" + o.toString() + "/" + r; break; case this.ANIMATION_TARGET_TYPE.camera: const v = ("/cameras/" + o.toString() + "/").length, A = c.substring(0, v); switch (r = c.substring(v), r) { case "perspective/yfov": r = "fov"; break; case "perspective/znear": case "orthographic/znear": r = "near"; break; case "perspective/zfar": case "orthographic/zfar": r = "far"; break; case "perspective/aspect": r = "aspect"; break; case "orthographic/xmag": r = "zoom"; break; case "orthographic/ymag": r = "zoom"; break }c = A + r; break }const h = this.parser.options.animationPointerResolver; h && h.resolvePath && (c = h.resolvePath(c)), t.extensions[Ft.KHR_ANIMATION_POINTER].pointer = c } if (o === null || isNaN(o)) { console.warn("Failed resolving animation node id: " + o, t); return } let a; return n === this.ANIMATION_TARGET_TYPE.node ? a = this.parser.getDependency("node", o) : n === this.ANIMATION_TARGET_TYPE.material ? a = this.parser.getDependency("material", o) : n === this.ANIMATION_TARGET_TYPE.light ? a = this.parser.getDependency("light", o) : n === this.ANIMATION_TARGET_TYPE.camera ? a = this.parser.getDependency("camera", o) : console.error("Unhandled type", n), a } createAnimationTracks(e, t, s, r, n) { if (!(n.extensions && n.extensions[Ft.KHR_ANIMATION_POINTER] && n.path && n.path === "pointer")) return null; let o = n.extensions[Ft.KHR_ANIMATION_POINTER].pointer; if (!o) return null; const a = []; o = o.replaceAll("/", "."); const l = o.split("."); l[2] = e.name ?? e.uuid, o = l.join("."), this._animationPointerDebug && console.log(e, t, s, n, o); let c; switch (s.itemSize) { case 1: c = ql; break; case 2: case 3: c = Xl; break; case 4: o.endsWith(".quaternion") ? c = ko : c = Qf; break }const h = r.interpolation !== void 0 ? ZD[r.interpolation] : Pa; let d = eO(s); o.endsWith(".fov") && (d = d.map(f => f / Math.PI * 180)); const p = new c(o, t.array, d, h); if (h === "CUBICSPLINE" && NC(p), a.push(p), o && s.itemSize === 4 && o.startsWith(".materials.") && o.endsWith(".color")) { const f = new Float32Array(d.length / 4); for (let m = 0, v = d.length / 4; m < v; m += 1)f[m] = d[m * 4 + 3]; const g = new c(o.replace(".color", ".opacity"), t.array, f, h); h === "CUBICSPLINE" && NC(p), a.push(g) } return a } _tryResolveTargetId(e, t) { let s = ""; return t === "node" ? s = e.substring(7) : t === "material" ? s = e.substring(11) : t === "light" ? s = e.substring(39) : t === "camera" && (s = e.substring(9)), s = s.substring(0, s.indexOf("/")), Number.parseInt(s) } } let u7 = class { constructor(i) { this.parser = i, this.name = Ft.KHR_MATERIALS_IRIDESCENCE } getMaterialType(i) { const e = this.parser.json.materials[i]; return !e.extensions || !e.extensions[this.name] ? null : Bo } extendMaterialParams(i, e) { const t = this.parser, s = t.json.materials[i]; if (!s.extensions || !s.extensions[this.name]) return Promise.resolve(); const r = [], n = s.extensions[this.name]; return n.iridescenceFactor !== void 0 && (e.iridescence = n.iridescenceFactor), n.iridescenceTexture !== void 0 && r.push(t.assignTexture(e, "iridescenceMap", n.iridescenceTexture)), n.iridescenceIor !== void 0 && (e.iridescenceIOR = n.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [100, 400]), n.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = n.iridescenceThicknessMinimum), n.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = n.iridescenceThicknessMaximum), n.iridescenceThicknessTexture !== void 0 && r.push(t.assignTexture(e, "iridescenceThicknessMap", n.iridescenceThicknessTexture)), Promise.all(r) } }; class d7 { constructor(e) { this.parser = e, this.name = Ft.KHR_MATERIALS_SHEEN } getMaterialType(e) { const t = this.parser.json.materials[e]; return !t.extensions || !t.extensions[this.name] ? null : Bo } extendMaterialParams(e, t) { const s = this.parser, r = s.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const n = []; t.sheenColor = new xe(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const o = r.extensions[this.name]; return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor), o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && n.push(s.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Xe)), o.sheenRoughnessTexture !== void 0 && n.push(s.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(n) } } let p7 = class { constructor(i) { this.parser = i, this.name = Ft.KHR_MATERIALS_TRANSMISSION } getMaterialType(i) { const e = this.parser.json.materials[i]; return !e.extensions || !e.extensions[this.name] ? null : Bo } extendMaterialParams(i, e) { const t = this.parser, s = t.json.materials[i]; if (!s.extensions || !s.extensions[this.name]) return Promise.resolve(); const r = [], n = s.extensions[this.name]; return n.transmissionFactor !== void 0 && (e.transmission = n.transmissionFactor), n.transmissionTexture !== void 0 && r.push(t.assignTexture(e, "transmissionMap", n.transmissionTexture)), Promise.all(r) } }, f7 = class { constructor(i) { this.parser = i, this.name = Ft.KHR_MATERIALS_VOLUME } getMaterialType(i) { const e = this.parser.json.materials[i]; return !e.extensions || !e.extensions[this.name] ? null : Bo } extendMaterialParams(i, e) { const t = this.parser, s = t.json.materials[i]; if (!s.extensions || !s.extensions[this.name]) return Promise.resolve(); const r = [], n = s.extensions[this.name]; e.thickness = n.thicknessFactor !== void 0 ? n.thicknessFactor : 0, n.thicknessTexture !== void 0 && r.push(t.assignTexture(e, "thicknessMap", n.thicknessTexture)), e.attenuationDistance = n.attenuationDistance || 1 / 0; const o = n.attenuationColor || [1, 1, 1]; return e.attenuationColor = new xe(o[0], o[1], o[2]), Promise.all(r) } }; class g7 { constructor(e) { this.parser = e, this.name = Ft.KHR_MATERIALS_IOR } getMaterialType(e) { const t = this.parser.json.materials[e]; return !t.extensions || !t.extensions[this.name] ? null : Bo } extendMaterialParams(e, t) { const s = this.parser.json.materials[e]; if (!s.extensions || !s.extensions[this.name]) return Promise.resolve(); const r = s.extensions[this.name]; return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve() } } class m7 { constructor(e) { this.parser = e, this.name = Ft.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const t = this.parser.json.materials[e]; return !t.extensions || !t.extensions[this.name] ? null : Bo } extendMaterialParams(e, t) { const s = this.parser, r = s.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const n = [], o = r.extensions[this.name]; t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && n.push(s.assignTexture(t, "specularIntensityMap", o.specularTexture)); const a = o.specularColorFactor || [1, 1, 1]; return t.specularColor = new xe(a[0], a[1], a[2]), o.specularColorTexture !== void 0 && n.push(s.assignTexture(t, "specularColorMap", o.specularColorTexture, Xe)), Promise.all(n) } } class v7 { constructor(e) { this.parser = e, this.name = Ft.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, s = t.json, r = s.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; const n = r.extensions[this.name], o = t.options.ktx2Loader; if (!o) { if (s.extensionsRequired && s.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, n.source, o) } } class A7 { constructor(e) { this.parser = e, this.name = Ft.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, s = this.parser, r = s.json, n = r.textures[e]; if (!n.extensions || !n.extensions[t]) return null; const o = n.extensions[t], a = r.images[o.source]; let l = s.textureLoader; if (a.uri) { const c = s.options.manager.getHandler(a.uri); c !== null && (l = c) } return this.detectSupport().then(function (c) { if (c) return s.loadTextureImage(e, o.source, l); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return s.loadTexture(e) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(t.height === 1) } })), this.isSupported } } class y7 { constructor(e) { this.name = Ft.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, s = t.bufferViews[e]; if (s.extensions && s.extensions[this.name]) { const r = s.extensions[this.name], n = this.parser.getDependency("buffer", r.buffer), o = this.parser.options.meshoptDecoder; if (!o || !o.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return n.then(function (a) { const l = r.byteOffset || 0, c = r.byteLength || 0, h = r.count, d = r.byteStride, p = new Uint8Array(a, l, c); return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(h, d, p, r.mode, r.filter).then(function (f) { return f.buffer }) : o.ready.then(function () { const f = new ArrayBuffer(h * d); return o.decodeGltfBuffer(new Uint8Array(f), h, d, p, r.mode, r.filter), f }) }) } else return null } } class b7 { constructor(e) { this.name = Ft.EXT_MESH_GPU_INSTANCING, this.parser = e } createNodeMesh(e) { const t = this.parser.json, s = t.nodes[e]; if (!s.extensions || !s.extensions[this.name] || s.mesh === void 0) return null; const r = t.meshes[s.mesh]; for (const l of r.primitives) if (l.mode !== Rn.TRIANGLES && l.mode !== Rn.TRIANGLE_STRIP && l.mode !== Rn.TRIANGLE_FAN && l.mode !== void 0) return null; const n = s.extensions[this.name].attributes, o = [], a = {}; for (const l in n) o.push(this.parser.getDependency("accessor", n[l]).then(c => (a[l] = c, a[l]))); return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then(l => { const c = l.pop(), h = c.isGroup ? c.children : [c], d = l[0].count, p = []; for (const f of h) { const g = new He, m = new S, v = new we, A = new S(1, 1, 1), b = new DA(f.geometry, f.material, d); for (let y = 0; y < d; y++)a.TRANSLATION && m.fromBufferAttribute(a.TRANSLATION, y), a.ROTATION && v.fromBufferAttribute(a.ROTATION, y), a.SCALE && A.fromBufferAttribute(a.SCALE, y), b.setMatrixAt(y, g.compose(m, v, A)); for (const y in a) y !== "TRANSLATION" && y !== "ROTATION" && y !== "SCALE" && f.geometry.setAttribute(y, a[y]); Me.prototype.copy.call(b, f), b.frustumCulled = !1, this.parser.assignFinalMaterial(b), p.push(b) } return c.isGroup ? (c.clear(), c.add(...p), c) : p[0] })) } } const qD = "glTF", Sg = 12, XD = { JSON: 1313821514, BIN: 5130562 }; class _7 { constructor(e) { this.name = Ft.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, Sg); if (this.header = { magic: Do.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== qD) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const s = this.header.length - Sg, r = new DataView(e, Sg); let n = 0; for (; n < s;) { const o = r.getUint32(n, !0); n += 4; const a = r.getUint32(n, !0); if (n += 4, a === XD.JSON) { const l = new Uint8Array(e, Sg + n, o); this.content = Do.decodeText(l) } else if (a === XD.BIN) { const l = Sg + n; this.body = e.slice(l, l + o) } n += o } if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class x7 { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = Ft.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const s = this.json, r = this.dracoLoader, n = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, a = {}, l = {}, c = {}; for (const h in o) { const d = LC[h] || h.toLowerCase(); a[d] = o[h] } for (const h in e.attributes) { const d = LC[h] || h.toLowerCase(); if (o[h] !== void 0) { const p = s.accessors[e.attributes[h]], f = Ed[p.componentType]; c[d] = f.name, l[d] = p.normalized === !0 } } return t.getDependency("bufferView", n).then(function (h) { return new Promise(function (d) { r.decodeDracoFile(h, function (p) { for (const f in p.attributes) { const g = p.attributes[f], m = l[f]; m !== void 0 && (g.normalized = m) } d(p) }, a, c) }) }) } } class w7 { constructor() { this.name = Ft.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e } } class C7 { constructor() { this.name = Ft.KHR_MESH_QUANTIZATION } } class YD extends ad { constructor(e, t, s, r) { super(e, t, s, r) } copySampleValue_(e) { const t = this.resultBuffer, s = this.sampleValues, r = this.valueSize, n = e * r * 3 + r; for (let o = 0; o !== r; o++)t[o] = s[n + o]; return t } interpolate_(e, t, s, r) { const n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, h = r - t, d = (s - t) / h, p = d * d, f = p * d, g = e * c, m = g - c, v = -2 * f + 3 * p, A = f - p, b = 1 - v, y = A - p + d; for (let _ = 0; _ !== a; _++) { const w = o[m + _ + a], E = o[m + _ + l] * h, P = o[g + _ + a], C = o[g + _] * h; n[_] = b * w + y * E + v * P + A * C } return n } } const S7 = new we; class E7 extends YD { interpolate_(e, t, s, r) { const n = super.interpolate_(e, t, s, r); return S7.fromArray(n).normalize().toArray(n), n } } const Rn = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, Ed = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, JD = { 9728: Zt, 9729: Qt, 9984: Pu, 9985: df, 9986: Bu, 9987: eo }, KD = { 33071: Ss, 33648: Ta, 10497: yn }, OC = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, LC = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, dc = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, ZD = { CUBICSPLINE: void 0, LINEAR: Pa, STEP: ah }, FC = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }; function M7(i) { return i.DefaultMaterial === void 0 && (i.DefaultMaterial = new od({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: pr })), i.DefaultMaterial } function Eg(i, e, t) { for (const s in t.extensions) i[s] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[s] = t.extensions[s]) } function pc(i, e) { e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(i.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) } function I7(i, e, t) { let s = !1, r = !1, n = !1; for (let c = 0, h = e.length; c < h; c++) { const d = e[c]; if (d.POSITION !== void 0 && (s = !0), d.NORMAL !== void 0 && (r = !0), d.COLOR_0 !== void 0 && (n = !0), s && r && n) break } if (!s && !r && !n) return Promise.resolve(i); const o = [], a = [], l = []; for (let c = 0, h = e.length; c < h; c++) { const d = e[c]; if (s) { const p = d.POSITION !== void 0 ? t.getDependency("accessor", d.POSITION) : i.attributes.position; o.push(p) } if (r) { const p = d.NORMAL !== void 0 ? t.getDependency("accessor", d.NORMAL) : i.attributes.normal; a.push(p) } if (n) { const p = d.COLOR_0 !== void 0 ? t.getDependency("accessor", d.COLOR_0) : i.attributes.color; l.push(p) } } return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (c) { const h = c[0], d = c[1], p = c[2]; return s && (i.morphAttributes.position = h), r && (i.morphAttributes.normal = d), n && (i.morphAttributes.color = p), i.morphTargetsRelative = !0, i }) } function T7(i, e) { if (i.updateMorphTargets(), e.weights !== void 0) for (let t = 0, s = e.weights.length; t < s; t++)i.morphTargetInfluences[t] = e.weights[t]; if (e.extras && Array.isArray(e.extras.targetNames)) { const t = e.extras.targetNames; if (i.morphTargetInfluences.length === t.length) { i.morphTargetDictionary = {}; for (let s = 0, r = t.length; s < r; s++)i.morphTargetDictionary[t[s]] = s } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function R7(i) { const e = i.extensions && i.extensions[Ft.KHR_DRACO_MESH_COMPRESSION]; let t; return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + $D(e.attributes) : t = i.indices + ":" + $D(i.attributes) + ":" + i.mode, t } function $D(i) { let e = ""; const t = Object.keys(i).sort(); for (let s = 0, r = t.length; s < r; s++)e += t[s] + ":" + i[t[s]] + ";"; return e } function UC(i) { switch (i) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } function eO(i) { let e = i.array; if (i.normalized) { const t = UC(e.constructor), s = new Float32Array(e.length); for (let r = 0, n = e.length; r < n; r++)s[r] = e[r] * t; e = s } return e } function NC(i) { i.createInterpolant = function (e) { const t = this instanceof ko ? E7 : YD; return new t(this.times, this.values, this.getValueSize() / 3, e) }, i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0 } function P7(i) { return i.search(/\.jpe?g($|\?)/i) > 0 || i.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : i.search(/\.webp($|\?)/i) > 0 || i.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png" } class B7 { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new n7, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let s = !1, r = !1, n = -1; typeof navigator < "u" && (s = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, r = navigator.userAgent.indexOf("Firefox") > -1, n = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || s || r && n < 98 ? this.textureLoader = new Yl(this.options.manager) : this.textureLoader = new PP(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new bs(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const s = this, r = this.json, n = this.extensions; this.cache.removeAll(), this._invokeAll(function (o) { return o._markDefs && o._markDefs() }), Promise.all(this._invokeAll(function (o) { return o.beforeRoot && o.beforeRoot() })).then(function () { return Promise.all([s.getDependencies("scene"), s.getDependencies("animation"), s.getDependencies("camera")]) }).then(function (o) { const a = { scene: o[0][r.scene || 0], scenes: o[0], animations: o[1], cameras: o[2], asset: r.asset, parser: s, userData: {} }; Eg(n, a, r), pc(a, r), Promise.all(s._invokeAll(function (l) { return l.afterRoot && l.afterRoot(a) })).then(function () { e(a) }) }).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], s = this.json.meshes || []; for (let r = 0, n = t.length; r < n; r++) { const o = t[r].joints; for (let a = 0, l = o.length; a < l; a++)e[o[a]].isBone = !0 } for (let r = 0, n = e.length; r < n; r++) { const o = e[r]; o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (s[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera) } } _addNodeRef(e, t) { t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, s) { if (e.refs[t] <= 1) return s; const r = s.clone(), n = (o, a) => { const l = this.associations.get(o); l != null && this.associations.set(a, l); for (const [c, h] of o.children.entries()) n(h, a.children[c]) }; return n(s, r), r.name += "_instance_" + e.uses[t]++, r } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let s = 0; s < t.length; s++) { const r = e(t[s]); if (r) return r } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const s = []; for (let r = 0; r < t.length; r++) { const n = e(t[r]); n && s.push(n) } return s } getDependency(e, t) { const s = e + ":" + t; let r = this.cache.get(s); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this._invokeOne(function (n) { return n.loadMesh && n.loadMesh(t) }); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne(function (n) { return n.loadBufferView && n.loadBufferView(t) }); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne(function (n) { return n.loadMaterial && n.loadMaterial(t) }); break; case "texture": r = this._invokeOne(function (n) { return n.loadTexture && n.loadTexture(t) }); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this._invokeOne(function (n) { return n.loadAnimation && n.loadAnimation(t) }); break; case "camera": r = this.loadCamera(t); break; case "light": r = this._invokeOne(function (n) { return n._loadLight && n._loadLight(t) }); break; default: if (r = this._invokeOne(function (n) { return n != this && n.getDependency && n.getDependency(e, t) }), !r) throw new Error("Unknown type: " + e); break }this.cache.add(s, r) } return r } getDependencies(e) { let t = this.cache.get(e); if (!t) { const s = this, r = this.json[e + (e === "mesh" ? "es" : "s")] || []; t = Promise.all(r.map(function (n, o) { return s.getDependency(e, o) })), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], s = this.fileLoader; if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[Ft.KHR_BINARY_GLTF].body); const r = this.options; return new Promise(function (n, o) { s.load(Do.resolveURL(t.uri, r.path), n, void 0, function () { o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) }) }) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then(function (s) { const r = t.byteLength || 0, n = t.byteOffset || 0; return s.slice(n, n + r) }) } loadAccessor(e) { const t = this, s = this.json, r = this.json.accessors[e]; if (r.bufferView === void 0 && r.sparse === void 0) { const o = OC[r.type], a = Ed[r.componentType], l = r.normalized === !0, c = new a(r.count * o); return Promise.resolve(new nt(c, o, l)) } const n = []; return r.bufferView !== void 0 ? n.push(this.getDependency("bufferView", r.bufferView)) : n.push(null), r.sparse !== void 0 && (n.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), n.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(n).then(function (o) { const a = o[0], l = OC[r.type], c = Ed[r.componentType], h = c.BYTES_PER_ELEMENT, d = h * l, p = r.byteOffset || 0, f = r.bufferView !== void 0 ? s.bufferViews[r.bufferView].byteStride : void 0, g = r.normalized === !0; let m, v; if (f && f !== d) { const A = Math.floor(p / f), b = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + A + ":" + r.count; let y = t.cache.get(b); y || (m = new c(a, A * f, r.count * f / h), y = new Rf(m, f / h), t.cache.add(b, y)), v = new El(y, l, p % f / h, g) } else a === null ? m = new c(r.count * l) : m = new c(a, p, r.count * l), v = new nt(m, l, g); if (r.sparse !== void 0) { const A = OC.SCALAR, b = Ed[r.sparse.indices.componentType], y = r.sparse.indices.byteOffset || 0, _ = r.sparse.values.byteOffset || 0, w = new b(o[1], y, r.sparse.count * A), E = new c(o[2], _, r.sparse.count * l); a !== null && (v = new nt(v.array.slice(), v.itemSize, v.normalized)); for (let P = 0, C = w.length; P < C; P++) { const R = w[P]; if (v.setX(R, E[P * l]), l >= 2 && v.setY(R, E[P * l + 1]), l >= 3 && v.setZ(R, E[P * l + 2]), l >= 4 && v.setW(R, E[P * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return v }) } loadTexture(e) { const t = this.json, s = this.options, r = t.textures[e].source, n = t.images[r]; let o = this.textureLoader; if (n.uri) { const a = s.manager.getHandler(n.uri); a !== null && (o = a) } return this.loadTextureImage(e, r, o) } loadTextureImage(e, t, s) { const r = this, n = this.json, o = n.textures[e], a = n.images[t], l = (a.uri || a.bufferView) + ":" + o.sampler; if (this.textureCache[l]) return this.textureCache[l]; const c = this.loadImageSource(t, s).then(function (h) { h.flipY = !1, h.name = o.name || a.name || ""; const d = (n.samplers || {})[o.sampler] || {}; return h.magFilter = JD[d.magFilter] || Qt, h.minFilter = JD[d.minFilter] || eo, h.wrapS = KD[d.wrapS] || yn, h.wrapT = KD[d.wrapT] || yn, h.anisotropy = 4, r.associations.set(h, { textures: e }), h }).catch(function () { return null }); return this.textureCache[l] = c, c } loadImageSource(e, t) { const s = this, r = this.json, n = this.options; if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(d => d.clone()); const o = r.images[e], a = self.URL || self.webkitURL; let l = o.uri || "", c = !1; if (o.bufferView !== void 0) l = s.getDependency("bufferView", o.bufferView).then(function (d) { c = !0; const p = new Blob([d], { type: o.mimeType }); return l = a.createObjectURL(p), l }); else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const h = Promise.resolve(l).then(function (d) { return new Promise(function (p, f) { let g = p; t.isImageBitmapLoader === !0 && (g = function (m) { const v = new Nt(m); v.needsUpdate = !0, p(v) }), t.load(Do.resolveURL(d, n.path), g, void 0, f) }) }).then(function (d) { return c === !0 && a.revokeObjectURL(l), d.userData.mimeType = o.mimeType || P7(o.uri), d }).catch(function (d) { throw console.error("THREE.GLTFLoader: Couldn't load texture", l), d }); return this.sourceCache[e] = h, h } assignTexture(e, t, s, r) { const n = this; return this.getDependency("texture", s.index).then(function (o) { if (s.texCoord !== void 0 && s.texCoord != 0 && !(t === "aoMap" && s.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + s.texCoord + " for texture " + t + " not yet supported."), n.extensions[Ft.KHR_TEXTURE_TRANSFORM]) { const a = s.extensions !== void 0 ? s.extensions[Ft.KHR_TEXTURE_TRANSFORM] : void 0; if (a) { const l = n.associations.get(o); o = n.extensions[Ft.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), n.associations.set(o, l) } } return r !== void 0 && o && (o.encoding = r), e[t] = o, o }) } assignFinalMaterial(e) { const t = e.geometry; let s = e.material; const r = t.attributes.tangent === void 0, n = t.attributes.color !== void 0, o = t.attributes.normal === void 0; if (e.isPoints) { const a = "PointsMaterial:" + s.uuid; let l = this.cache.get(a); l || (l = new LA, Tt.prototype.copy.call(l, s), l.color.copy(s.color), l.map = s.map, l.sizeAttenuation = !1, this.cache.add(a, l)), s = l } else if (e.isLine) { const a = "LineBasicMaterial:" + s.uuid; let l = this.cache.get(a); l || (l = new Hi, Tt.prototype.copy.call(l, s), l.color.copy(s.color), this.cache.add(a, l)), s = l } if (r || n || o) { let a = "ClonedMaterial:" + s.uuid + ":"; r && (a += "derivative-tangents:"), n && (a += "vertex-colors:"), o && (a += "flat-shading:"); let l = this.cache.get(a); l || (l = s.clone(), n && (l.vertexColors = !0), o && (l.flatShading = !0), r && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(s))), s = l } s.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv), e.material = s } getMaterialType() { return od } loadMaterial(e) { const t = this, s = this.json, r = this.extensions, n = s.materials[e]; let o; const a = {}, l = n.extensions || {}, c = []; if (l[Ft.KHR_MATERIALS_UNLIT]) { const d = r[Ft.KHR_MATERIALS_UNLIT]; o = d.getMaterialType(), c.push(d.extendParams(a, n, t)) } else { const d = n.pbrMetallicRoughness || {}; if (a.color = new xe(1, 1, 1), a.opacity = 1, Array.isArray(d.baseColorFactor)) { const p = d.baseColorFactor; a.color.fromArray(p), a.opacity = p[3] } d.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", d.baseColorTexture, Xe)), a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1, a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1, d.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture))), o = this._invokeOne(function (p) { return p.getMaterialType && p.getMaterialType(e) }), c.push(Promise.all(this._invokeAll(function (p) { return p.extendMaterialParams && p.extendMaterialParams(e, a) }))) } n.doubleSided === !0 && (a.side = yi); const h = n.alphaMode || FC.OPAQUE; if (h === FC.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, h === FC.MASK && (a.alphaTest = n.alphaCutoff !== void 0 ? n.alphaCutoff : .5)), n.normalTexture !== void 0 && o !== di && (c.push(t.assignTexture(a, "normalMap", n.normalTexture)), a.normalScale = new W(1, 1), n.normalTexture.scale !== void 0)) { const d = n.normalTexture.scale; a.normalScale.set(d, d) } return n.occlusionTexture !== void 0 && o !== di && (c.push(t.assignTexture(a, "aoMap", n.occlusionTexture)), n.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = n.occlusionTexture.strength)), n.emissiveFactor !== void 0 && o !== di && (a.emissive = new xe().fromArray(n.emissiveFactor)), n.emissiveTexture !== void 0 && o !== di && c.push(t.assignTexture(a, "emissiveMap", n.emissiveTexture, Xe)), Promise.all(c).then(function () { const d = new o(a); return n.name && (d.name = n.name), pc(d, n), t.associations.set(d, { materials: e }), n.extensions && Eg(r, d, n), d }) } createUniqueName(e) { const t = zt.sanitizeNodeName(e || ""); let s = t; for (let r = 1; this.nodeNamesUsed[s]; ++r)s = t + "_" + r; return this.nodeNamesUsed[s] = !0, s } loadGeometries(e) { const t = this, s = this.extensions, r = this.primitiveCache; function n(a) { return s[Ft.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function (l) { return iO(l, a, t) }) } const o = []; for (let a = 0, l = e.length; a < l; a++) { const c = e[a], h = R7(c), d = r[h]; if (d) o.push(d.promise); else { let p; c.extensions && c.extensions[Ft.KHR_DRACO_MESH_COMPRESSION] ? p = n(c) : p = iO(new yt, c, t), r[h] = { primitive: c, promise: p }, o.push(p) } } return Promise.all(o) } loadMesh(e) { const t = this, s = this.json, r = this.extensions, n = s.meshes[e], o = n.primitives, a = []; for (let l = 0, c = o.length; l < c; l++) { const h = o[l].material === void 0 ? M7(this.cache) : this.getDependency("material", o[l].material); a.push(h) } return a.push(t.loadGeometries(o)), Promise.all(a).then(function (l) { const c = l.slice(0, l.length - 1), h = l[l.length - 1], d = []; for (let f = 0, g = h.length; f < g; f++) { const m = h[f], v = o[f]; let A; const b = c[f]; if (v.mode === Rn.TRIANGLES || v.mode === Rn.TRIANGLE_STRIP || v.mode === Rn.TRIANGLE_FAN || v.mode === void 0) A = n.isSkinnedMesh === !0 ? new rd(m, b) : new ye(m, b), A.isSkinnedMesh === !0 && !A.geometry.attributes.skinWeight.normalized && A.normalizeSkinWeights(), v.mode === Rn.TRIANGLE_STRIP ? A.geometry = sO(A.geometry, CT) : v.mode === Rn.TRIANGLE_FAN && (A.geometry = sO(A.geometry, Px)); else if (v.mode === Rn.LINES) A = new sn(m, b); else if (v.mode === Rn.LINE_STRIP) A = new Vi(m, b); else if (v.mode === Rn.LINE_LOOP) A = new xw(m, b); else if (v.mode === Rn.POINTS) A = new Cw(m, b); else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + v.mode); Object.keys(A.geometry.morphAttributes).length > 0 && T7(A, n), A.name = t.createUniqueName(n.name || "mesh_" + e), pc(A, n), v.extensions && Eg(r, A, v), t.assignFinalMaterial(A), d.push(A) } for (let f = 0, g = d.length; f < g; f++)t.associations.set(d[f], { meshes: e, primitives: f }); if (d.length === 1) return d[0]; const p = new wn; t.associations.set(p, { meshes: e }); for (let f = 0, g = d.length; f < g; f++)p.add(d[f]); return p }) } loadCamera(e) { let t; const s = this.json.cameras[e], r = s[s.type]; if (!r) { console.warn("THREE.GLTFLoader: Missing camera parameters."); return } return s.type === "perspective" ? t = new Xt(kr.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : s.type === "orthographic" && (t = new Yu(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), s.name && (t.name = this.createUniqueName(s.name)), pc(t, s), Promise.resolve(t) } loadSkin(e) { const t = this.json.skins[e], s = { joints: t.joints }; return t.inverseBindMatrices === void 0 ? Promise.resolve(s) : this.getDependency("accessor", t.inverseBindMatrices).then(function (r) { return s.inverseBindMatrices = r, s }) } loadAnimation(e) { const t = this.json, s = this, r = t.animations[e], n = [], o = [], a = [], l = [], c = []; let h = 0, d = r.channels.length; for (h = 0, d = r.channels.length; h < d; h++) { const p = r.channels[h], f = r.samplers[p.sampler], g = p.target, m = r.parameters !== void 0 ? r.parameters[f.input] : f.input, v = r.parameters !== void 0 ? r.parameters[f.output] : f.output, A = s._invokeOne(function (b) { return b.loadAnimationTargetFromChannel && b.loadAnimationTargetFromChannel(p) }); n.push(A), o.push(this.getDependency("accessor", m)), a.push(this.getDependency("accessor", v)), l.push(f), c.push(g) } return Promise.all([Promise.all(n), Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c)]).then(function (p) { const f = p[0], g = p[1], m = p[2], v = p[3], A = p[4], b = []; for (h = 0, d = f.length; h < d; h++) { const _ = f[h], w = g[h], E = m[h], P = v[h], C = A[h]; if (_ === void 0) continue; _.updateMatrix && (_.updateMatrix(), _.matrixAutoUpdate = !0); const R = s._invokeOne(function (T) { return T.createAnimationTracks && T.createAnimationTracks(_, w, E, P, C) }); if (R) for (let T = 0; T < R.length; T++)b.push(R[T]) } const y = r.name ? r.name : "animation_" + e; return new En(y, void 0, b) }) } createNodeMesh(e) { const t = this.json, s = this, r = t.nodes[e]; return r.mesh === void 0 ? null : s.getDependency("mesh", r.mesh).then(function (n) { const o = s._getNodeRef(s.meshCache, r.mesh, n); return r.weights !== void 0 && o.traverse(function (a) { if (a.isMesh) for (let l = 0, c = r.weights.length; l < c; l++)a.morphTargetInfluences[l] = r.weights[l] }), o }) } loadNode(e) { const t = this.json, s = this.extensions, r = this, n = t.nodes[e], o = n.name ? r.createUniqueName(n.name) : ""; return function () { const a = [], l = r._invokeOne(function (c) { return c.createNodeMesh && c.createNodeMesh(e) }); return l && a.push(l), n.camera !== void 0 && a.push(r.getDependency("camera", n.camera).then(function (c) { return r._getNodeRef(r.cameraCache, n.camera, c) })), r._invokeAll(function (c) { return c.createNodeAttachment && c.createNodeAttachment(e) }).forEach(function (c) { a.push(c) }), Promise.all(a) }().then(function (a) { let l; if (n.isBone === !0 ? l = new Df : a.length > 1 ? l = new wn : a.length === 1 ? l = a[0] : l = new Me, l !== a[0]) for (let c = 0, h = a.length; c < h; c++)l.add(a[c]); if (n.name && (l.userData.name = n.name, l.name = o), pc(l, n), n.extensions && Eg(s, l, n), n.matrix !== void 0) { const c = new He; c.fromArray(n.matrix), l.applyMatrix4(c) } else n.translation !== void 0 && l.position.fromArray(n.translation), n.rotation !== void 0 && l.quaternion.fromArray(n.rotation), n.scale !== void 0 && l.scale.fromArray(n.scale); return r.associations.has(l) || r.associations.set(l, {}), r.associations.get(l).nodes = e, l }) } loadScene(e) { const t = this.json, s = this.extensions, r = this.json.scenes[e], n = this, o = new wn; r.name && (o.name = n.createUniqueName(r.name)), pc(o, r), r.extensions && Eg(s, o, r); const a = r.nodes || [], l = []; for (let c = 0, h = a.length; c < h; c++)l.push(tO(a[c], o, t, n)); return Promise.all(l).then(function () { const c = h => { const d = new Map; for (const [p, f] of n.associations) (p instanceof Tt || p instanceof Nt) && d.set(p, f); return h.traverse(p => { const f = n.associations.get(p); f != null && d.set(p, f) }), d }; return n.associations = c(o), o }) } loadAnimationTargetFromChannel(e) { const t = e.target, s = t.node !== void 0 ? t.node : t.id; return this.getDependency("node", s) } createAnimationTracks(e, t, s, r, n) { const o = [], a = e.name ? e.name : e.uuid, l = []; dc[n.path] === dc.weights ? e.traverse(function (p) { p.morphTargetInfluences && l.push(p.name ? p.name : p.uuid) }) : l.push(a); let c; switch (dc[n.path]) { case dc.weights: c = ql; break; case dc.rotation: c = ko; break; case dc.position: case dc.scale: default: switch (s.itemSize) { case 1: c = ql; break; case 2: case 3: c = Xl; break; case 4: c = Qf; break }break }const h = r.interpolation !== void 0 ? ZD[r.interpolation] : Pa, d = eO(s); for (let p = 0, f = l.length; p < f; p++) { const g = new c(l[p] + "." + dc[n.path], t.array, d, h); h === "CUBICSPLINE" && NC(g), o.push(g) } return o } } function tO(i, e, t, s) { const r = t.nodes[i]; return s.getDependency("node", i).then(function (n) { if (r.skin === void 0) return n; let o; return s.getDependency("skin", r.skin).then(function (a) { o = a; const l = []; for (let c = 0, h = o.joints.length; c < h; c++)l.push(s.getDependency("node", o.joints[c])); return Promise.all(l) }).then(function (a) { return n.traverse(function (l) { if (!l.isMesh) return; const c = [], h = []; for (let d = 0, p = a.length; d < p; d++) { const f = a[d]; if (f) { c.push(f); const g = new He; o.inverseBindMatrices !== void 0 && g.fromArray(o.inverseBindMatrices.array, d * 16), h.push(g) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', o.joints[d]) } l.bind(new Xp(c, h), l.matrixWorld) }), n }) }).then(function (n) { e.add(n); const o = []; if (r.children) { const a = r.children; for (let l = 0, c = a.length; l < c; l++) { const h = a[l]; o.push(tO(h, n, t, s)) } } return Promise.all(o) }) } function k7(i, e, t) { const s = e.attributes, r = new er; if (s.POSITION !== void 0) { const a = t.json.accessors[s.POSITION], l = a.min, c = a.max; if (l !== void 0 && c !== void 0) { if (r.set(new S(l[0], l[1], l[2]), new S(c[0], c[1], c[2])), a.normalized) { const h = UC(Ed[a.componentType]); r.min.multiplyScalar(h), r.max.multiplyScalar(h) } } else { console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); return } } else return; const n = e.targets; if (n !== void 0) { const a = new S, l = new S; for (let c = 0, h = n.length; c < h; c++) { const d = n[c]; if (d.POSITION !== void 0) { const p = t.json.accessors[d.POSITION], f = p.min, g = p.max; if (f !== void 0 && g !== void 0) { if (l.setX(Math.max(Math.abs(f[0]), Math.abs(g[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(g[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(g[2]))), p.normalized) { const m = UC(Ed[p.componentType]); l.multiplyScalar(m) } a.max(l) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } r.expandByVector(a) } i.boundingBox = r; const o = new Po; r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, i.boundingSphere = o } function iO(i, e, t) { const s = e.attributes, r = []; function n(o, a) { return t.getDependency("accessor", o).then(function (l) { i.setAttribute(a, l) }) } for (const o in s) { const a = LC[o] || o.toLowerCase(); a in i.attributes || r.push(n(s[o], a)) } if (e.indices !== void 0 && !i.index) { const o = t.getDependency("accessor", e.indices).then(function (a) { i.setIndex(a) }); r.push(o) } return pc(i, e), k7(i, e, t), Promise.all(r).then(function () { return e.targets !== void 0 ? I7(i, e.targets, t) : i }) } function sO(i, e) { let t = i.getIndex(); if (t === null) { const o = [], a = i.getAttribute("position"); if (a !== void 0) { for (let l = 0; l < a.count; l++)o.push(l); i.setIndex(o), t = i.getIndex() } else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), i } const s = t.count - 2, r = []; if (e === Px) for (let o = 1; o <= s; o++)r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1)); else for (let o = 0; o < s; o++)o % 2 === 0 ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2))) : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o))); r.length / 3 !== s && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const n = i.clone(); return n.setIndex(r), n } var rO = (i => (i[i.INT = 5124] = "INT", i[i.FLOAT = 5126] = "FLOAT", i[i.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", i[i.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", i[i.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", i[i.INT_VEC2 = 35667] = "INT_VEC2", i[i.INT_VEC3 = 35668] = "INT_VEC3", i[i.INT_VEC4 = 35669] = "INT_VEC4", i[i.BOOL = 35670] = "BOOL", i[i.BOOL_VEC2 = 35671] = "BOOL_VEC2", i[i.BOOL_VEC3 = 35672] = "BOOL_VEC3", i[i.BOOL_VEC4 = 35673] = "BOOL_VEC4", i[i.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", i[i.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", i[i.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", i[i.SAMPLER_2D = 35678] = "SAMPLER_2D", i[i.SAMPLER_3D = 35680] = "SAMPLER_3D", i[i.SAMPLER_CUBE = 35681] = "SAMPLER_CUBE", i[i.UNKNOWN = 0] = "UNKNOWN", i))(rO || {}); const Za = oe("debugcustomshader"), Md = "NEEDLE_techniques_webgl"; class D7 { constructor() { u(this, "objectToWorldMatrix", new He), u(this, "worldToObjectMatrix", new He), u(this, "objectToWorld", new Array), u(this, "worldToObject", new Array) } updateFrom(e) { this.objectToWorldMatrix.copy(e.matrixWorld), sy(this.objectToWorldMatrix, this.objectToWorld), this.worldToObjectMatrix.copy(e.matrixWorld).invert(), sy(this.worldToObjectMatrix, this.worldToObject) } } const Bi = class extends Nw { constructor(i, ...e) { super(...e), u(this, "identifier"), u(this, "onBeforeRenderSceneCallback", this.onBeforeRenderScene.bind(this)), u(this, "_sphericalHarmonicsName", "unity_SpecCube0"), u(this, "_objToWorldName", "hlslcc_mtx4x4unity_ObjectToWorld"), u(this, "_worldToObjectName", "hlslcc_mtx4x4unity_WorldToObject"), u(this, "_viewProjectionName", "hlslcc_mtx4x4unity_MatrixVP"), u(this, "_viewMatrixName", "hlslcc_mtx4x4unity_MatrixV"), u(this, "_rendererData", new D7), this.identifier = i, Za && console.log(this), this.type = "NEEDLE_CUSTOM_SHADER", this.uniforms[this._objToWorldName] || (this.uniforms[this._objToWorldName] = { value: [] }), this.uniforms[this._worldToObjectName] || (this.uniforms[this._worldToObjectName] = { value: [] }), this.uniforms[this._viewProjectionName] || (this.uniforms[this._viewProjectionName] = { value: [] }), this.uniforms[this._sphericalHarmonicsName] && this.waitForLighting(), (this.depthTextureUniform || this.opaqueTextureUniform) && _t.Current.pre_render_callbacks.push(this.onBeforeRenderSceneCallback) } clone() { const i = super.clone(); return nO(i), i } dispose() { super.dispose(); const i = _t.Current.pre_render_callbacks.indexOf(this.onBeforeRenderSceneCallback); i >= 0 && _t.Current.pre_render_callbacks.splice(i, 1) } async waitForLighting() { const i = _t.Current; if (!i) { console.error("Missing context"); return } const e = await i.sceneLighting.internalGetSceneLightingData(this.identifier); if (!e || !e.array) { console.warn("Missing lighting data for custom shader, getSceneLightingData did not return anything"); return } Za && console.log(e); const t = e.array, s = e.texture; this.uniforms.unity_SpecCube0 = { value: s }, rD(this.uniforms, t); const r = Math.sqrt(Math.PI * .5); this.uniforms.unity_SpecCube0_HDR = { value: new st(r, r, r, r) }, Za && console.log("Set environment lighting", this.uniforms) } get depthTextureUniform() { if (this.uniforms) return this.uniforms._CameraDepthTexture } get opaqueTextureUniform() { if (this.uniforms) return this.uniforms._CameraOpaqueTexture } onBeforeRenderScene() { this.opaqueTextureUniform && _t.Current.setRequireColor(!0), this.depthTextureUniform && _t.Current.setRequireDepth(!0) } onBeforeRender(i, e, t, s, r, n) { s.attributes.tangent || s.computeTangents(), this.onUpdateUniforms(t, r) } onUpdateUniforms(i, e) { const t = _t.Current; i && (Bi.viewProjection && this.uniforms[this._viewProjectionName] && (Bi.viewProjection.copy(i.projectionMatrix).multiply(i.matrixWorldInverse), sy(Bi.viewProjection, Bi._viewProjectionValues)), Bi.viewMatrix && this.uniforms[this._viewMatrixName] && (Bi.viewMatrix.copy(i.matrixWorldInverse), sy(Bi.viewMatrix, Bi._viewMatrixValues)), this.uniforms[Bi._worldSpaceCameraPosName] && Bi._worldSpaceCameraPos.setFromMatrixPosition(i.matrixWorld)), this.uniforms._TimeParameters ? this.uniforms._TimeParameters.value = t.sceneLighting.timeVec4 : this.uniforms._Time && (this.uniforms._Time.value = t.sceneLighting.timeVec4); const s = t.mainLight; if (s) { const o = xt(s.gameObject, Bi._mainLightPosition); this.uniforms._MainLightPosition = { value: o.normalize() }, Bi._mainLightColor.set(s.color.r, s.color.g, s.color.b, 0), this.uniforms._MainLightColor = { value: Bi._mainLightColor }; const a = s.intensity; Bi._lightData.z = a, this.uniforms.unity_LightData = { value: Bi._lightData } } if (i && (Bi.viewProjection && this.uniforms[this._viewProjectionName] && (this.uniforms[this._viewProjectionName].value = Bi._viewProjectionValues), Bi.viewMatrix && this.uniforms[this._viewMatrixName] && (this.uniforms[this._viewMatrixName].value = Bi._viewMatrixValues), this.uniforms[Bi._worldSpaceCameraPosName] && (this.uniforms[Bi._worldSpaceCameraPosName] = { value: Bi._worldSpaceCameraPos }), t.mainCameraComponent)) { if (this.uniforms._ProjectionParams) { const o = this.uniforms._ProjectionParams.value; o.x = 1, o.y = t.mainCameraComponent.nearClipPlane, o.z = t.mainCameraComponent.farClipPlane, o.w = 1 / o.z, this.uniforms._ProjectionParams.value = o } if (this.uniforms._ZBufferParams) { const o = this.uniforms._ZBufferParams.value, a = t.mainCameraComponent; o.x = 1 - a.farClipPlane / a.nearClipPlane, o.y = a.farClipPlane / a.nearClipPlane, o.z = o.x / a.farClipPlane, o.w = o.y / a.farClipPlane, this.uniforms._ZBufferParams.value = o } if (this.uniforms._ScreenParams) { const o = this.uniforms._ScreenParams.value; o.x = t.domWidth, o.y = t.domHeight, o.z = 1 + 1 / o.x, o.w = 1 + 1 / o.y, this.uniforms._ScreenParams.value = o } } const r = this.depthTextureUniform; r && (r.value = t.depthTexture); const n = this.opaqueTextureUniform; if (n && (n.value = t.opaqueColorTexture), e) { const o = this._rendererData; o.updateFrom(e), this.uniforms[this._worldToObjectName].value = o.worldToObject, this.uniforms[this._objToWorldName].value = o.objectToWorld } this.uniformsNeedUpdate = !0 } }; let vo = Bi; u(vo, "viewProjection", new He), u(vo, "_viewProjectionValues", []), u(vo, "viewMatrix", new He), u(vo, "_viewMatrixValues", []), u(vo, "_worldSpaceCameraPosName", "_WorldSpaceCameraPos"), u(vo, "_worldSpaceCameraPos", new S), u(vo, "_mainLightColor", new st), u(vo, "_mainLightPosition", new S), u(vo, "_lightData", new st); class O7 { constructor(e, t) { u(this, "parser"), u(this, "identifier"), this.parser = e, this.identifier = t } get name() { return Md } loadMaterial(e) { const t = this.parser.json.materials[e]; if (!t) return Za && console.log(e, this.parser.json.materials), null; if (!t.extensions || !t.extensions[Md]) return Za && console.log("material " + e + " does not use NEEDLE_techniques_webgl"), null; const s = t.extensions[Md].technique; if (s < 0) return null; const r = this.parser.json.extensions[Md]; if (!r) return null; Za && console.log(r); const n = r.techniques[s]; return n ? new Promise(async (o, a) => { var l, c, h; const d = await aq(r, n.program), p = d?.fragmentShader, f = d?.vertexShader; if (!p || !f) return a(); Za && console.log("loadMaterial", t, d); const g = {}, m = n.uniforms; f.includes("_Time") && (g._Time = { value: new st(0, 0, 0, 0) }); for (const b in m) { const y = b; switch (y) { case "_TimeParameters": const _ = new st; g[y] = { value: _ }; break; case "hlslcc_mtx4x4unity_MatrixV": case "hlslcc_mtx4x4unity_MatrixVP": g[y] = { value: [] }; break; case "_MainLightPosition": case "_MainLightColor": case "_WorldSpaceCameraPos": g[y] = { value: [0, 0, 0, 1] }; break; case "unity_OrthoParams": break; case "unity_SpecCube0": g[y] = { value: null }; break; default: case "_ScreenParams": case "_ZBufferParams": case "_ProjectionParams": g[y] = { value: [0, 0, 0, 0] }; break; case "_CameraOpaqueTexture": case "_CameraDepthTexture": g[y] = { value: null }; break } } let v = !1; if (t.extensions && t.extensions[Md]) { const b = t.extensions[Md]; if (b.technique === s) { Za && console.log(t.name, "Material Properties", b); for (const y in b.values) { const _ = b.values[y]; if (typeof _ == "string") { if (_.startsWith("/textures/")) { const w = _.substring(10), E = Number.parseInt(w); if (E >= 0) { const P = await this.parser.getDependency("texture", E); P && (P.encoding = Qi, P.needsUpdate = !0), g[y] = { value: P }; continue } } switch (y) { case "alphaMode": _ === "BLEND" && (v = !0); continue } } if (Array.isArray(_) && _.length === 4) { g[y] = { value: new st(_[0], _[1], _[2], _[3]) }; continue } g[y] = { value: _ } } } } const A = new vo(this.identifier, { name: t.name ?? "", uniforms: g, vertexShader: f, fragmentShader: p, lights: !1 }); switch ((l = g._Cull) == null ? void 0 : l.value) { case 0: A.side = yi; break; case 1: A.side = fs; break; case 2: A.side = pr; break; default: A.side = pr; break }switch ((c = g._ZTest) == null ? void 0 : c.value) { case 3: A.depthTest = !0, A.depthFunc = Iu; break; case 6: A.depthTest = !0, A.depthFunc = cf; break; case 2: A.depthTest = !0, A.depthFunc = lf; break; case 4: A.depthTest = !0, A.depthFunc = Mu; break; case 5: A.depthTest = !0, A.depthFunc = zv; break; case 7: A.depthTest = !0, A.depthFunc = Nv; break; case 8: A.depthTest = !1, A.depthFunc = Uv; break }A.transparent = v, v && (A.depthWrite = !1), rD(g), A.onUpdateUniforms(); for (const b in m) { const y = b, _ = m[b].type; if (((h = g[y]) == null ? void 0 : h.value) === void 0) switch (_) { case rO.SAMPLER_2D: g[y] = { value: rq }, console.warn("Missing/unassigned texture, fallback to white: " + y); break; default: y === "unity_OrthoParams" || console.warn("TODO: EXPECTED UNIFORM / fallback NOT SET: " + y, m[b]); break } } Za && console.log(A.uuid, g), nO(A), o(A) }) : null } } function nO(i) { if (i.uniforms) for (const e in i.uniforms) Object.getOwnPropertyDescriptor(i, e) || Object.defineProperty(i, e, { get: () => i.uniforms[e].value, set: t => { i.uniforms[e].value = t, i.needsUpdate = !0 } }) } const fc = ir, dy = "$___Export_Components", L7 = "NEEDLE_components"; var oO; class F7 { constructor() { u(this, oO) } } oO = eh; class U7 { constructor(e, t, s) { u(this, "node"), u(this, "nodeIndex"), u(this, "nodeDef"), this.node = e, this.nodeIndex = t, this.nodeDef = s } } class aO { constructor() { u(this, "parser"), u(this, "nodeToObjectMap", {}), u(this, "exportContext"), u(this, "objectToNodeMap", {}), u(this, "context"), u(this, "writer") } get name() { return L7 } registerExport(e) { e.register(t => { if ("serializeUserData" in t) { const s = t.serializeUserData.bind(t); this.writer = t, t.serializeUserData = (r, n) => { try { this.serializeUserData(r, n), s(r, n) } finally { this.afterSerializeUserData(r, n) } } } return this }) } beforeParse() { this.exportContext = {}, this.objectToNodeMap = {} } serializeUserData(e, t) { var s; const r = (s = e.userData) == null ? void 0 : s.components; !r || r.length <= 0 || (delete e.userData.components, e[dy] = r) } afterSerializeUserData(e, t) { if (e.type === "Scene" && fc && console.log("DONE", JSON.stringify(t)), e[dy] === void 0) return; const s = e[dy]; delete e[dy], s !== null && (e.userData.components = s) } writeNode(e, t) { let s = this.writer.json.nodes.length; console.log(e.name, s, e.uuid); const r = new U7(e, s, t); this.exportContext[s] = r, this.objectToNodeMap[e.uuid] = s } afterParse(e) { var t; fc && console.log("AFTER", e); for (const s in this.exportContext) { const r = this.exportContext[s], n = r.node, o = r.nodeDef, a = r.nodeIndex, l = (t = n.userData) == null ? void 0 : t.components; if (!l || l.length <= 0) continue; const c = new F7; o.extensions = o.extensions || {}, o.extensions[this.name] = c, this.context.object = n, this.context.nodeId = a, this.context.objectToNode = this.objectToNodeMap; const h = []; for (const d of l) { this.context.target = d; const p = fo().writeBuiltinComponentData(d, this.context); p !== null && h.push(p) } h.length > 0 && (c[eh] = h, fc && console.log("DID WRITE", n, "nodeIndex", a, h)) } } beforeRoot() { return fc && console.log("BEGIN LOAD"), this.nodeToObjectMap = {}, null } async afterRoot(e) { const t = e.parser, s = t?.extensions; if (!s) return; const r = s[this.name]; fc && console.log("After root", e, this.parser, s); const n = []; if (r === !0) { const o = t.json.nodes; for (let a = 0; a < o.length; a++) { const l = await t.getDependency("node", a); this.nodeToObjectMap[a] = l } for (let a = 0; a < o.length; a++) { const l = o[a], c = a, h = l.extensions; if (!h) continue; const d = h[this.name]; if (!d) continue; fc && console.log("NODE", l); const p = this.nodeToObjectMap[c]; if (!p) { console.error("Could not find object for node index: " + c, l, t); continue } V0(p), n.push(this.createComponents(p, d)) } } await Promise.all(n) } async createComponents(e, t) { if (!t) return; const s = t[eh]; if (s) { const r = new Array; fc && console.log(e.name, s); for (const n in s) { const o = s[n]; fc && console.log("Serialized data", JSON.parse(JSON.stringify(o))), o && this.parser && r.push(h1(this.parser, o)), e.userData = e.userData || {}, e.userData[eh] = e.userData[eh] || [], e.userData[eh].push(o) } await Promise.all(r) } } }/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/var lO = {}, zC = function (i) { return URL.createObjectURL(new Blob([i], { type: "text/javascript" })) }, cO = function (i) { return new Worker(i) }; try { URL.revokeObjectURL(zC("")) } catch { zC = function (i) { return "data:application/javascript;charset=UTF-8," + encodeURI(i) }, cO = function (i) { return new Worker(i, { type: "module" }) } } var N7 = function (i, e, t, s, r) { var n = cO(lO[e] || (lO[e] = zC(i))); return n.onerror = function (o) { return r(o.error, null) }, n.onmessage = function (o) { return r(null, o.data) }, n.postMessage(t, s), n }, Wt = Uint8Array, Ms = Uint16Array, $a = Uint32Array, Id = new Wt([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), Td = new Wt([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Mg = new Wt([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), hO = function (i, e) { for (var t = new Ms(31), s = 0; s < 31; ++s)t[s] = e += 1 << i[s - 1]; for (var r = new $a(t[30]), s = 1; s < 30; ++s)for (var n = t[s]; n < t[s + 1]; ++n)r[n] = n - t[s] << 5 | s; return [t, r] }, uO = hO(Id, 2), jC = uO[0], py = uO[1]; jC[28] = 258, py[258] = 28; for (var dO = hO(Td, 0), pO = dO[0], QC = dO[1], Ig = new Ms(32768), xi = 0; xi < 32768; ++xi) { var gc = (xi & 43690) >>> 1 | (xi & 21845) << 1; gc = (gc & 52428) >>> 2 | (gc & 13107) << 2, gc = (gc & 61680) >>> 4 | (gc & 3855) << 4, Ig[xi] = ((gc & 65280) >>> 8 | (gc & 255) << 8) >>> 1 } for (var Pn = function (i, e, t) { for (var s = i.length, r = 0, n = new Ms(e); r < s; ++r)++n[i[r] - 1]; var o = new Ms(e); for (r = 0; r < e; ++r)o[r] = o[r - 1] + n[r - 1] << 1; var a; if (t) { a = new Ms(1 << e); var l = 15 - e; for (r = 0; r < s; ++r)if (i[r]) for (var c = r << 4 | i[r], h = e - i[r], d = o[i[r] - 1]++ << h, p = d | (1 << h) - 1; d <= p; ++d)a[Ig[d] >>> l] = c } else for (a = new Ms(s), r = 0; r < s; ++r)i[r] && (a[r] = Ig[o[i[r] - 1]++] >>> 15 - i[r]); return a }, el = new Wt(288), xi = 0; xi < 144; ++xi)el[xi] = 8; for (var xi = 144; xi < 256; ++xi)el[xi] = 9; for (var xi = 256; xi < 280; ++xi)el[xi] = 7; for (var xi = 280; xi < 288; ++xi)el[xi] = 8; for (var Rd = new Wt(32), xi = 0; xi < 32; ++xi)Rd[xi] = 5; var fO = Pn(el, 9, 0), gO = Pn(el, 9, 1), mO = Pn(Rd, 5, 0), vO = Pn(Rd, 5, 1), fy = function (i) { for (var e = i[0], t = 1; t < i.length; ++t)i[t] > e && (e = i[t]); return e }, Bn = function (i, e, t) { var s = e / 8 | 0; return (i[s] | i[s + 1] << 8) >> (e & 7) & t }, gy = function (i, e) { var t = e / 8 | 0; return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) >> (e & 7) }, Tg = function (i) { return (i / 8 | 0) + (i & 7 && 1) }, kn = function (i, e, t) { (e == null || e < 0) && (e = 0), (t == null || t > i.length) && (t = i.length); var s = new (i instanceof Ms ? Ms : i instanceof $a ? $a : Wt)(t - e); return s.set(i.subarray(e, t)), s }, Rg = function (i, e, t) { var s = i.length; if (!s || t && !t.l && s < 5) return e || new Wt(0); var r = !e || t, n = !t || t.i; t || (t = {}), e || (e = new Wt(s * 3)); var o = function (K) { var je = e.length; if (K > je) { var Ue = new Wt(Math.max(je * 2, K)); Ue.set(e), e = Ue } }, a = t.f || 0, l = t.p || 0, c = t.b || 0, h = t.l, d = t.d, p = t.m, f = t.n, g = s * 8; do { if (!h) { t.f = a = Bn(i, l, 1); var m = Bn(i, l + 1, 3); if (l += 3, m) if (m == 1) h = gO, d = vO, p = 9, f = 5; else if (m == 2) { var v = Bn(i, l, 31) + 257, A = Bn(i, l + 10, 15) + 4, b = v + Bn(i, l + 5, 31) + 1; l += 14; for (var y = new Wt(b), _ = new Wt(19), w = 0; w < A; ++w)_[Mg[w]] = Bn(i, l + w * 3, 7); l += A * 3; for (var E = fy(_), P = (1 << E) - 1, C = Pn(_, E, 1), w = 0; w < b;) { var R = C[Bn(i, l, P)]; l += R & 15; var T = R >>> 4; if (T < 16) y[w++] = T; else { var z = 0, H = 0; for (T == 16 ? (H = 3 + Bn(i, l, 3), l += 2, z = y[w - 1]) : T == 17 ? (H = 3 + Bn(i, l, 7), l += 3) : T == 18 && (H = 11 + Bn(i, l, 127), l += 7); H--;)y[w++] = z } } var N = y.subarray(0, v), F = y.subarray(v); p = fy(N), f = fy(F), h = Pn(N, p, 1), d = Pn(F, f, 1) } else throw "invalid block type"; else { var T = Tg(l) + 4, X = i[T - 4] | i[T - 3] << 8, te = T + X; if (te > s) { if (n) throw "unexpected EOF"; break } r && o(c + X), e.set(i.subarray(T, te), c), t.b = c += X, t.p = l = te * 8; continue } if (l > g) { if (n) throw "unexpected EOF"; break } } r && o(c + 131072); for (var re = (1 << p) - 1, Z = (1 << f) - 1, fe = l; ; fe = l) { var z = h[gy(i, l) & re], ae = z >>> 4; if (l += z & 15, l > g) { if (n) throw "unexpected EOF"; break } if (!z) throw "invalid length/literal"; if (ae < 256) e[c++] = ae; else if (ae == 256) { fe = l, h = null; break } else { var De = ae - 254; if (ae > 264) { var w = ae - 257, Se = Id[w]; De = Bn(i, l, (1 << Se) - 1) + jC[w], l += Se } var ie = d[gy(i, l) & Z], ce = ie >>> 4; if (!ie) throw "invalid distance"; l += ie & 15; var F = pO[ce]; if (ce > 3) { var Se = Td[ce]; F += gy(i, l) & (1 << Se) - 1, l += Se } if (l > g) { if (n) throw "unexpected EOF"; break } r && o(c + 131072); for (var Te = c + De; c < Te; c += 4)e[c] = e[c - F], e[c + 1] = e[c + 1 - F], e[c + 2] = e[c + 2 - F], e[c + 3] = e[c + 3 - F]; c = Te } } t.l = h, t.p = fe, t.b = c, h && (a = 1, t.m = p, t.d = d, t.n = f) } while (!a); return c == e.length ? e : kn(e, 0, c) }, Go = function (i, e, t) { t <<= e & 7; var s = e / 8 | 0; i[s] |= t, i[s + 1] |= t >>> 8 }, Pd = function (i, e, t) { t <<= e & 7; var s = e / 8 | 0; i[s] |= t, i[s + 1] |= t >>> 8, i[s + 2] |= t >>> 16 }, my = function (i, e) { for (var t = [], s = 0; s < i.length; ++s)i[s] && t.push({ s, f: i[s] }); var r = t.length, n = t.slice(); if (!r) return [tl, 0]; if (r == 1) { var o = new Wt(t[0].s + 1); return o[t[0].s] = 1, [o, 1] } t.sort(function (w, E) { return w.f - E.f }), t.push({ s: -1, f: 25001 }); var a = t[0], l = t[1], c = 0, h = 1, d = 2; for (t[0] = { s: -1, f: a.f + l.f, l: a, r: l }; h != r - 1;)a = t[t[c].f < t[d].f ? c++ : d++], l = t[c != h && t[c].f < t[d].f ? c++ : d++], t[h++] = { s: -1, f: a.f + l.f, l: a, r: l }; for (var p = n[0].s, s = 1; s < r; ++s)n[s].s > p && (p = n[s].s); var f = new Ms(p + 1), g = vy(t[h - 1], f, 0); if (g > e) { var s = 0, m = 0, v = g - e, A = 1 << v; for (n.sort(function (E, P) { return f[P.s] - f[E.s] || E.f - P.f }); s < r; ++s) { var b = n[s].s; if (f[b] > e) m += A - (1 << g - f[b]), f[b] = e; else break } for (m >>>= v; m > 0;) { var y = n[s].s; f[y] < e ? m -= 1 << e - f[y]++ - 1 : ++s } for (; s >= 0 && m; --s) { var _ = n[s].s; f[_] == e && (--f[_], ++m) } g = e } return [new Wt(f), g] }, vy = function (i, e, t) { return i.s == -1 ? Math.max(vy(i.l, e, t + 1), vy(i.r, e, t + 1)) : e[i.s] = t }, GC = function (i) { for (var e = i.length; e && !i[--e];); for (var t = new Ms(++e), s = 0, r = i[0], n = 1, o = function (l) { t[s++] = l }, a = 1; a <= e; ++a)if (i[a] == r && a != e) ++n; else { if (!r && n > 2) { for (; n > 138; n -= 138)o(32754); n > 2 && (o(n > 10 ? n - 11 << 5 | 28690 : n - 3 << 5 | 12305), n = 0) } else if (n > 3) { for (o(r), --n; n > 6; n -= 6)o(8304); n > 2 && (o(n - 3 << 5 | 8208), n = 0) } for (; n--;)o(r); n = 1, r = i[a] } return [t.subarray(0, s), e] }, Bd = function (i, e) { for (var t = 0, s = 0; s < e.length; ++s)t += i[s] * e[s]; return t }, Pg = function (i, e, t) { var s = t.length, r = Tg(e + 2); i[r] = s & 255, i[r + 1] = s >>> 8, i[r + 2] = i[r] ^ 255, i[r + 3] = i[r + 1] ^ 255; for (var n = 0; n < s; ++n)i[r + n + 4] = t[n]; return (r + 4 + s) * 8 }, HC = function (i, e, t, s, r, n, o, a, l, c, h) { Go(e, h++, t), ++r[256]; for (var d = my(r, 15), p = d[0], f = d[1], g = my(n, 15), m = g[0], v = g[1], A = GC(p), b = A[0], y = A[1], _ = GC(m), w = _[0], E = _[1], P = new Ms(19), C = 0; C < b.length; ++C)P[b[C] & 31]++; for (var C = 0; C < w.length; ++C)P[w[C] & 31]++; for (var R = my(P, 7), T = R[0], z = R[1], H = 19; H > 4 && !T[Mg[H - 1]]; --H); var N = c + 5 << 3, F = Bd(r, el) + Bd(n, Rd) + o, X = Bd(r, p) + Bd(n, m) + o + 14 + 3 * H + Bd(P, T) + (2 * P[16] + 3 * P[17] + 7 * P[18]); if (N <= F && N <= X) return Pg(e, h, i.subarray(l, l + c)); var te, re, Z, fe; if (Go(e, h, 1 + (X < F)), h += 2, X < F) { te = Pn(p, f, 0), re = p, Z = Pn(m, v, 0), fe = m; var ae = Pn(T, z, 0); Go(e, h, y - 257), Go(e, h + 5, E - 1), Go(e, h + 10, H - 4), h += 14; for (var C = 0; C < H; ++C)Go(e, h + 3 * C, T[Mg[C]]); h += 3 * H; for (var De = [b, w], Se = 0; Se < 2; ++Se)for (var ie = De[Se], C = 0; C < ie.length; ++C) { var ce = ie[C] & 31; Go(e, h, ae[ce]), h += T[ce], ce > 15 && (Go(e, h, ie[C] >>> 5 & 127), h += ie[C] >>> 12) } } else te = fO, re = el, Z = mO, fe = Rd; for (var C = 0; C < a; ++C)if (s[C] > 255) { var ce = s[C] >>> 18 & 31; Pd(e, h, te[ce + 257]), h += re[ce + 257], ce > 7 && (Go(e, h, s[C] >>> 23 & 31), h += Id[ce]); var Te = s[C] & 31; Pd(e, h, Z[Te]), h += fe[Te], Te > 3 && (Pd(e, h, s[C] >>> 5 & 8191), h += Td[Te]) } else Pd(e, h, te[s[C]]), h += re[s[C]]; return Pd(e, h, te[256]), h + re[256] }, AO = new $a([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), tl = new Wt(0), yO = function (i, e, t, s, r, n) { var o = i.length, a = new Wt(s + o + 5 * (1 + Math.ceil(o / 7e3)) + r), l = a.subarray(s, a.length - r), c = 0; if (!e || o < 8) for (var h = 0; h <= o; h += 65535) { var d = h + 65535; d < o ? c = Pg(l, c, i.subarray(h, d)) : (l[h] = n, c = Pg(l, c, i.subarray(h, o))) } else { for (var p = AO[e - 1], f = p >>> 13, g = p & 8191, m = (1 << t) - 1, v = new Ms(32768), A = new Ms(m + 1), b = Math.ceil(t / 3), y = 2 * b, _ = function (Fe) { return (i[Fe] ^ i[Fe + 1] << b ^ i[Fe + 2] << y) & m }, w = new $a(25e3), E = new Ms(288), P = new Ms(32), C = 0, R = 0, h = 0, T = 0, z = 0, H = 0; h < o; ++h) { var N = _(h), F = h & 32767, X = A[N]; if (v[F] = X, A[N] = F, z <= h) { var te = o - h; if ((C > 7e3 || T > 24576) && te > 423) { c = HC(i, l, 0, w, E, P, R, T, H, h - H, c), T = C = R = 0, H = h; for (var re = 0; re < 286; ++re)E[re] = 0; for (var re = 0; re < 30; ++re)P[re] = 0 } var Z = 2, fe = 0, ae = g, De = F - X & 32767; if (te > 2 && N == _(h - De)) for (var Se = Math.min(f, te) - 1, ie = Math.min(32767, h), ce = Math.min(258, te); De <= ie && --ae && F != X;) { if (i[h + Z] == i[h + Z - De]) { for (var Te = 0; Te < ce && i[h + Te] == i[h + Te - De]; ++Te); if (Te > Z) { if (Z = Te, fe = De, Te > Se) break; for (var K = Math.min(De, Te - 2), je = 0, re = 0; re < K; ++re) { var Ue = h - De + re + 32768 & 32767, Pe = v[Ue], ve = Ue - Pe + 32768 & 32767; ve > je && (je = ve, X = Ue) } } } F = X, X = v[F], De += F - X + 32768 & 32767 } if (fe) { w[T++] = 268435456 | py[Z] << 18 | QC[fe]; var de = py[Z] & 31, Ae = QC[fe] & 31; R += Id[de] + Td[Ae], ++E[257 + de], ++P[Ae], z = h + Z, ++C } else w[T++] = i[h], ++E[i[h]] } } c = HC(i, l, n, w, E, P, R, T, H, h - H, c), !n && c & 7 && (c = Pg(l, c + 1, tl)) } return kn(a, 0, s + Tg(c) + r) }, bO = function () { for (var i = new $a(256), e = 0; e < 256; ++e) { for (var t = e, s = 9; --s;)t = (t & 1 && 3988292384) ^ t >>> 1; i[e] = t } return i }(), kd = function () { var i = -1; return { p: function (e) { for (var t = i, s = 0; s < e.length; ++s)t = bO[t & 255 ^ e[s]] ^ t >>> 8; i = t }, d: function () { return ~i } } }, VC = function () { var i = 1, e = 0; return { p: function (t) { for (var s = i, r = e, n = t.length, o = 0; o != n;) { for (var a = Math.min(o + 2655, n); o < a; ++o)r += s += t[o]; s = (s & 65535) + 15 * (s >> 16), r = (r & 65535) + 15 * (r >> 16) } i = s, e = r }, d: function () { return i %= 65521, e %= 65521, (i & 255) << 24 | i >>> 8 << 16 | (e & 255) << 8 | e >>> 8 } } }, Nh = function (i, e, t, s, r) { return yO(i, e.level == null ? 6 : e.level, e.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(i.length))) * 1.5) : 12 + e.mem, t, s, !r) }, Bg = function (i, e) { var t = {}; for (var s in i) t[s] = i[s]; for (var s in e) t[s] = e[s]; return t }, _O = function (i, e, t) { for (var s = i(), r = i.toString(), n = r.slice(r.indexOf("[") + 1, r.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < s.length; ++o) { var a = s[o], l = n[o]; if (typeof a == "function") { e += ";" + l + "="; var c = a.toString(); if (a.prototype) if (c.indexOf("[native code]") != -1) { var h = c.indexOf(" ", 8) + 1; e += c.slice(h, c.indexOf("(", h)) } else { e += c; for (var d in a.prototype) e += ";" + l + ".prototype." + d + "=" + a.prototype[d].toString() } else e += c } else t[l] = a } return [e, t] }, Ay = [], z7 = function (i) { var e = []; for (var t in i) (i[t] instanceof Wt || i[t] instanceof Ms || i[t] instanceof $a) && e.push((i[t] = new i[t].constructor(i[t])).buffer); return e }, xO = function (i, e, t, s) { var r; if (!Ay[t]) { for (var n = "", o = {}, a = i.length - 1, l = 0; l < a; ++l)r = _O(i[l], n, o), n = r[0], o = r[1]; Ay[t] = _O(i[a], n, o) } var c = Bg({}, Ay[t][1]); return N7(Ay[t][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + e.toString() + "}", t, c, z7(c), s) }, Dd = function () { return [Wt, Ms, $a, Id, Td, Mg, jC, pO, gO, vO, Ig, Pn, fy, Bn, gy, Tg, kn, Rg, Ud, mc, WC] }, Od = function () { return [Wt, Ms, $a, Id, Td, Mg, py, QC, fO, el, mO, Rd, Ig, AO, tl, Pn, Go, Pd, my, vy, GC, Bd, Pg, HC, Tg, kn, yO, Nh, kg, mc] }, wO = function () { return [XC, JC, li, kd, bO] }, CO = function () { return [YC, MO] }, SO = function () { return [KC, li, VC] }, EO = function () { return [IO] }, mc = function (i) { return postMessage(i, [i.buffer]) }, WC = function (i) { return i && i.size && new Wt(i.size) }, Ld = function (i, e, t, s, r, n) { var o = xO(t, s, r, function (a, l) { o.terminate(), n(a, l) }); return o.postMessage([i, e], e.consume ? [i.buffer] : []), function () { o.terminate() } }, Dn = function (i) { return i.ondata = function (e, t) { return postMessage([e, t], [e.buffer]) }, function (e) { return i.push(e.data[0], e.data[1]) } }, Fd = function (i, e, t, s, r) { var n, o = xO(i, s, r, function (a, l) { a ? (o.terminate(), e.ondata.call(e, a)) : (l[1] && o.terminate(), e.ondata.call(e, a, l[0], l[1])) }); o.postMessage(t), e.push = function (a, l) { if (n) throw "stream finished"; if (!e.ondata) throw "no stream handler"; o.postMessage([a, n = l], [a.buffer]) }, e.terminate = function () { o.terminate() } }, br = function (i, e) { return i[e] | i[e + 1] << 8 }, Xi = function (i, e) { return (i[e] | i[e + 1] << 8 | i[e + 2] << 16 | i[e + 3] << 24) >>> 0 }, qC = function (i, e) { return Xi(i, e) + Xi(i, e + 4) * 4294967296 }, li = function (i, e, t) { for (; t; ++e)i[e] = t, t >>>= 8 }, XC = function (i, e) { var t = e.filename; if (i[0] = 31, i[1] = 139, i[2] = 8, i[8] = e.level < 2 ? 4 : e.level == 9 ? 2 : 0, i[9] = 3, e.mtime != 0 && li(i, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)), t) { i[3] = 8; for (var s = 0; s <= t.length; ++s)i[s + 10] = t.charCodeAt(s) } }, YC = function (i) { if (i[0] != 31 || i[1] != 139 || i[2] != 8) throw "invalid gzip data"; var e = i[3], t = 10; e & 4 && (t += i[10] | (i[11] << 8) + 2); for (var s = (e >> 3 & 1) + (e >> 4 & 1); s > 0; s -= !i[t++]); return t + (e & 2) }, MO = function (i) { var e = i.length; return (i[e - 4] | i[e - 3] << 8 | i[e - 2] << 16 | i[e - 1] << 24) >>> 0 }, JC = function (i) { return 10 + (i.filename && i.filename.length + 1 || 0) }, KC = function (i, e) { var t = e.level, s = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2; i[0] = 120, i[1] = s << 6 | (s ? 32 - 2 * s : 1) }, IO = function (i) { if ((i[0] & 15) != 8 || i[0] >>> 4 > 7 || (i[0] << 8 | i[1]) % 31) throw "invalid zlib data"; if (i[1] & 32) throw "invalid zlib data: preset dictionaries not supported" }; function ZC(i, e) { return !e && typeof i == "function" && (e = i, i = {}), this.ondata = e, i } var Ho = function () { function i(e, t) { !t && typeof e == "function" && (t = e, e = {}), this.ondata = t, this.o = e || {} } return i.prototype.p = function (e, t) { this.ondata(Nh(e, this.o, 0, 0, !t), t) }, i.prototype.push = function (e, t) { if (this.d) throw "stream finished"; if (!this.ondata) throw "no stream handler"; this.d = t, this.p(e, t || !1) }, i }(), TO = function () { function i(e, t) { Fd([Od, function () { return [Dn, Ho] }], this, ZC.call(this, e, t), function (s) { var r = new Ho(s.data); onmessage = Dn(r) }, 6) } return i }(); function RO(i, e, t) { if (t || (t = e, e = {}), typeof t != "function") throw "no callback"; return Ld(i, e, [Od], function (s) { return mc(kg(s.data[0], s.data[1])) }, 0, t) } function kg(i, e) { return Nh(i, e || {}, 0, 0) } var Ur = function () { function i(e) { this.s = {}, this.p = new Wt(0), this.ondata = e } return i.prototype.e = function (e) { if (this.d) throw "stream finished"; if (!this.ondata) throw "no stream handler"; var t = this.p.length, s = new Wt(t + e.length); s.set(this.p), s.set(e, t), this.p = s }, i.prototype.c = function (e) { this.d = this.s.i = e || !1; var t = this.s.b, s = Rg(this.p, this.o, this.s); this.ondata(kn(s, t, this.s.b), this.d), this.o = kn(s, this.s.b - 32768), this.s.b = this.o.length, this.p = kn(this.p, this.s.p / 8 | 0), this.s.p &= 7 }, i.prototype.push = function (e, t) { this.e(e), this.c(t) }, i }(), $C = function () { function i(e) { this.ondata = e, Fd([Dd, function () { return [Dn, Ur] }], this, 0, function () { var t = new Ur; onmessage = Dn(t) }, 7) } return i }(); function eS(i, e, t) { if (t || (t = e, e = {}), typeof t != "function") throw "no callback"; return Ld(i, e, [Dd], function (s) { return mc(Ud(s.data[0], WC(s.data[1]))) }, 1, t) } function Ud(i, e) { return Rg(i, e) } var yy = function () { function i(e, t) { this.c = kd(), this.l = 0, this.v = 1, Ho.call(this, e, t) } return i.prototype.push = function (e, t) { Ho.prototype.push.call(this, e, t) }, i.prototype.p = function (e, t) { this.c.p(e), this.l += e.length; var s = Nh(e, this.o, this.v && JC(this.o), t && 8, !t); this.v && (XC(s, this.o), this.v = 0), t && (li(s, s.length - 8, this.c.d()), li(s, s.length - 4, this.l)), this.ondata(s, t) }, i }(), PO = function () { function i(e, t) { Fd([Od, wO, function () { return [Dn, Ho, yy] }], this, ZC.call(this, e, t), function (s) { var r = new yy(s.data); onmessage = Dn(r) }, 8) } return i }(); function BO(i, e, t) { if (t || (t = e, e = {}), typeof t != "function") throw "no callback"; return Ld(i, e, [Od, wO, function () { return [by] }], function (s) { return mc(by(s.data[0], s.data[1])) }, 2, t) } function by(i, e) { e || (e = {}); var t = kd(), s = i.length; t.p(i); var r = Nh(i, e, JC(e), 8), n = r.length; return XC(r, e), li(r, n - 8, t.d()), li(r, n - 4, s), r } var _y = function () { function i(e) { this.v = 1, Ur.call(this, e) } return i.prototype.push = function (e, t) { if (Ur.prototype.e.call(this, e), this.v) { var s = this.p.length > 3 ? YC(this.p) : 4; if (s >= this.p.length && !t) return; this.p = this.p.subarray(s), this.v = 0 } if (t) { if (this.p.length < 8) throw "invalid gzip stream"; this.p = this.p.subarray(0, -8) } Ur.prototype.c.call(this, t) }, i }(), kO = function () { function i(e) { this.ondata = e, Fd([Dd, CO, function () { return [Dn, Ur, _y] }], this, 0, function () { var t = new _y; onmessage = Dn(t) }, 9) } return i }(); function DO(i, e, t) { if (t || (t = e, e = {}), typeof t != "function") throw "no callback"; return Ld(i, e, [Dd, CO, function () { return [xy] }], function (s) { return mc(xy(s.data[0])) }, 3, t) } function xy(i, e) { return Rg(i.subarray(YC(i), -8), e || new Wt(MO(i))) } var tS = function () { function i(e, t) { this.c = VC(), this.v = 1, Ho.call(this, e, t) } return i.prototype.push = function (e, t) { Ho.prototype.push.call(this, e, t) }, i.prototype.p = function (e, t) { this.c.p(e); var s = Nh(e, this.o, this.v && 2, t && 4, !t); this.v && (KC(s, this.o), this.v = 0), t && li(s, s.length - 4, this.c.d()), this.ondata(s, t) }, i }(), j7 = function () { function i(e, t) { Fd([Od, SO, function () { return [Dn, Ho, tS] }], this, ZC.call(this, e, t), function (s) { var r = new tS(s.data); onmessage = Dn(r) }, 10) } return i }(); function Q7(i, e, t) { if (t || (t = e, e = {}), typeof t != "function") throw "no callback"; return Ld(i, e, [Od, SO, function () { return [iS] }], function (s) { return mc(iS(s.data[0], s.data[1])) }, 4, t) } function iS(i, e) { e || (e = {}); var t = VC(); t.p(i); var s = Nh(i, e, 2, 4); return KC(s, e), li(s, s.length - 4, t.d()), s } var wy = function () { function i(e) { this.v = 1, Ur.call(this, e) } return i.prototype.push = function (e, t) { if (Ur.prototype.e.call(this, e), this.v) { if (this.p.length < 2 && !t) return; this.p = this.p.subarray(2), this.v = 0 } if (t) { if (this.p.length < 4) throw "invalid zlib stream"; this.p = this.p.subarray(0, -4) } Ur.prototype.c.call(this, t) }, i }(), OO = function () { function i(e) { this.ondata = e, Fd([Dd, EO, function () { return [Dn, Ur, wy] }], this, 0, function () { var t = new wy; onmessage = Dn(t) }, 11) } return i }(); function LO(i, e, t) { if (t || (t = e, e = {}), typeof t != "function") throw "no callback"; return Ld(i, e, [Dd, EO, function () { return [vc] }], function (s) { return mc(vc(s.data[0], WC(s.data[1]))) }, 5, t) } function vc(i, e) { return Rg((IO(i), i.subarray(2, -4)), e) } var FO = function () { function i(e) { this.G = _y, this.I = Ur, this.Z = wy, this.ondata = e } return i.prototype.push = function (e, t) { if (!this.ondata) throw "no stream handler"; if (this.s) this.s.push(e, t); else { if (this.p && this.p.length) { var s = new Wt(this.p.length + e.length); s.set(this.p), s.set(e, this.p.length) } else this.p = e; if (this.p.length > 2) { var r = this, n = function () { r.ondata.apply(r, arguments) }; this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(n) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(n) : new this.Z(n), this.s.push(this.p, t), this.p = null } } }, i }(), G7 = function () { function i(e) { this.G = kO, this.I = $C, this.Z = OO, this.ondata = e } return i.prototype.push = function (e, t) { FO.prototype.push.call(this, e, t) }, i }(); function H7(i, e, t) { if (t || (t = e, e = {}), typeof t != "function") throw "no callback"; return i[0] == 31 && i[1] == 139 && i[2] == 8 ? DO(i, e, t) : (i[0] & 15) != 8 || i[0] >> 4 > 7 || (i[0] << 8 | i[1]) % 31 ? eS(i, e, t) : LO(i, e, t) } function V7(i, e) { return i[0] == 31 && i[1] == 139 && i[2] == 8 ? xy(i, e) : (i[0] & 15) != 8 || i[0] >> 4 > 7 || (i[0] << 8 | i[1]) % 31 ? Ud(i, e) : vc(i, e) } var sS = function (i, e, t, s) { for (var r in i) { var n = i[r], o = e + r; n instanceof Wt ? t[o] = [n, s] : Array.isArray(n) ? t[o] = [n[0], Bg(s, n[1])] : sS(n, o + "/", t, s) } }, UO = typeof TextEncoder < "u" && new TextEncoder, rS = typeof TextDecoder < "u" && new TextDecoder, NO = 0; try { rS.decode(tl, { stream: !0 }), NO = 1 } catch { } var zO = function (i) { for (var e = "", t = 0; ;) { var s = i[t++], r = (s > 127) + (s > 223) + (s > 239); if (t + r > i.length) return [e, kn(i, t - 1)]; r ? r == 3 ? (s = ((s & 15) << 18 | (i[t++] & 63) << 12 | (i[t++] & 63) << 6 | i[t++] & 63) - 65536, e += String.fromCharCode(55296 | s >> 10, 56320 | s & 1023)) : r & 1 ? e += String.fromCharCode((s & 31) << 6 | i[t++] & 63) : e += String.fromCharCode((s & 15) << 12 | (i[t++] & 63) << 6 | i[t++] & 63) : e += String.fromCharCode(s) } }, W7 = function () { function i(e) { this.ondata = e, NO ? this.t = new TextDecoder : this.p = tl } return i.prototype.push = function (e, t) { if (!this.ondata) throw "no callback"; if (t = !!t, this.t) { if (this.ondata(this.t.decode(e, { stream: !0 }), t), t) { if (this.t.decode().length) throw "invalid utf-8 data"; this.t = null } return } if (!this.p) throw "stream finished"; var s = new Wt(this.p.length + e.length); s.set(this.p), s.set(e, this.p.length); var r = zO(s), n = r[0], o = r[1]; if (t) { if (o.length) throw "invalid utf-8 data"; this.p = null } else this.p = o; this.ondata(n, t) }, i }(), q7 = function () { function i(e) { this.ondata = e } return i.prototype.push = function (e, t) { if (!this.ondata) throw "no callback"; if (this.d) throw "stream finished"; this.ondata(Vo(e), this.d = t || !1) }, i }(); function Vo(i, e) { if (e) { for (var t = new Wt(i.length), s = 0; s < i.length; ++s)t[s] = i.charCodeAt(s); return t } if (UO) return UO.encode(i); for (var r = i.length, n = new Wt(i.length + (i.length >> 1)), o = 0, a = function (d) { n[o++] = d }, s = 0; s < r; ++s) { if (o + 5 > n.length) { var l = new Wt(o + 8 + (r - s << 1)); l.set(n), n = l } var c = i.charCodeAt(s); c < 128 || e ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | c & 63)) : c > 55295 && c < 57344 ? (c = 65536 + (c & 1023 << 10) | i.charCodeAt(++s) & 1023, a(240 | c >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | c & 63)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | c & 63)) } return kn(n, 0, o) } function nS(i, e) { if (e) { for (var t = "", s = 0; s < i.length; s += 16384)t += String.fromCharCode.apply(null, i.subarray(s, s + 16384)); return t } else { if (rS) return rS.decode(i); var r = zO(i), n = r[0], o = r[1]; if (o.length) throw "invalid utf-8 data"; return n } } var jO = function (i) { return i == 1 ? 3 : i < 6 ? 2 : i == 9 ? 1 : 0 }, QO = function (i, e) { return e + 30 + br(i, e + 26) + br(i, e + 28) }, GO = function (i, e, t) { var s = br(i, e + 28), r = nS(i.subarray(e + 46, e + 46 + s), !(br(i, e + 8) & 2048)), n = e + 46 + s, o = Xi(i, e + 20), a = t && o == 4294967295 ? HO(i, n) : [o, Xi(i, e + 24), Xi(i, e + 42)], l = a[0], c = a[1], h = a[2]; return [br(i, e + 10), l, c, r, n + br(i, e + 30) + br(i, e + 32), h] }, HO = function (i, e) { for (; br(i, e) != 1; e += 4 + br(i, e + 2)); return [qC(i, e + 12), qC(i, e + 4), qC(i, e + 20)] }, Ac = function (i) { var e = 0; if (i) for (var t in i) { var s = i[t].length; if (s > 65535) throw "extra field too long"; e += s + 4 } return e }, Nd = function (i, e, t, s, r, n, o, a) { var l = s.length, c = t.extra, h = a && a.length, d = Ac(c); li(i, e, o != null ? 33639248 : 67324752), e += 4, o != null && (i[e++] = 20, i[e++] = t.os), i[e] = 20, e += 2, i[e++] = t.flag << 1 | (n == null && 8), i[e++] = r && 8, i[e++] = t.compression & 255, i[e++] = t.compression >> 8; var p = new Date(t.mtime == null ? Date.now() : t.mtime), f = p.getFullYear() - 1980; if (f < 0 || f > 119) throw "date not in range 1980-2099"; if (li(i, e, f << 25 | p.getMonth() + 1 << 21 | p.getDate() << 16 | p.getHours() << 11 | p.getMinutes() << 5 | p.getSeconds() >>> 1), e += 4, n != null && (li(i, e, t.crc), li(i, e + 4, n), li(i, e + 8, t.size)), li(i, e + 12, l), li(i, e + 14, d), e += 16, o != null && (li(i, e, h), li(i, e + 6, t.attrs), li(i, e + 10, o), e += 14), i.set(s, e), e += l, d) for (var g in c) { var m = c[g], v = m.length; li(i, e, +g), li(i, e + 2, v), i.set(m, e + 4), e += 4 + v } return h && (i.set(a, e), e += h), e }, oS = function (i, e, t, s, r) { li(i, e, 101010256), li(i, e + 8, t), li(i, e + 10, t), li(i, e + 12, s), li(i, e + 16, r) }, Dg = function () { function i(e) { this.filename = e, this.c = kd(), this.size = 0, this.compression = 0 } return i.prototype.process = function (e, t) { this.ondata(null, e, t) }, i.prototype.push = function (e, t) { if (!this.ondata) throw "no callback - add to ZIP archive before pushing"; this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1) }, i }(), X7 = function () { function i(e, t) { var s = this; t || (t = {}), Dg.call(this, e), this.d = new Ho(t, function (r, n) { s.ondata(null, r, n) }), this.compression = 8, this.flag = jO(t.level) } return i.prototype.process = function (e, t) { try { this.d.push(e, t) } catch (s) { this.ondata(s, null, t) } }, i.prototype.push = function (e, t) { Dg.prototype.push.call(this, e, t) }, i }(), Y7 = function () { function i(e, t) { var s = this; t || (t = {}), Dg.call(this, e), this.d = new TO(t, function (r, n, o) { s.ondata(r, n, o) }), this.compression = 8, this.flag = jO(t.level), this.terminate = this.d.terminate } return i.prototype.process = function (e, t) { this.d.push(e, t) }, i.prototype.push = function (e, t) { Dg.prototype.push.call(this, e, t) }, i }(), J7 = function () { function i(e) { this.ondata = e, this.u = [], this.d = 1 } return i.prototype.add = function (e) { var t = this; if (this.d & 2) throw "stream finished"; var s = Vo(e.filename), r = s.length, n = e.comment, o = n && Vo(n), a = r != e.filename.length || o && n.length != o.length, l = r + Ac(e.extra) + 30; if (r > 65535) throw "filename too long"; var c = new Wt(l); Nd(c, 0, e, s, a); var h = [c], d = function () { for (var v = 0, A = h; v < A.length; v++) { var b = A[v]; t.ondata(null, b, !1) } h = [] }, p = this.d; this.d = 0; var f = this.u.length, g = Bg(e, { f: s, u: a, o, t: function () { e.terminate && e.terminate() }, r: function () { if (d(), p) { var v = t.u[f + 1]; v ? v.r() : t.d = 1 } p = 1 } }), m = 0; e.ondata = function (v, A, b) { if (v) t.ondata(v, A, b), t.terminate(); else if (m += A.length, h.push(A), b) { var y = new Wt(16); li(y, 0, 134695760), li(y, 4, e.crc), li(y, 8, m), li(y, 12, e.size), h.push(y), g.c = m, g.b = l + m + 16, g.crc = e.crc, g.size = e.size, p && g.r(), p = 1 } else p && d() }, this.u.push(g) }, i.prototype.end = function () { var e = this; if (this.d & 2) throw this.d & 1 ? "stream finishing" : "stream finished"; this.d ? this.e() : this.u.push({ r: function () { e.d & 1 && (e.u.splice(-1, 1), e.e()) }, t: function () { } }), this.d = 3 }, i.prototype.e = function () { for (var e = 0, t = 0, s = 0, r = 0, n = this.u; r < n.length; r++) { var o = n[r]; s += 46 + o.f.length + Ac(o.extra) + (o.o ? o.o.length : 0) } for (var a = new Wt(s + 22), l = 0, c = this.u; l < c.length; l++) { var o = c[l]; Nd(a, e, o, o.f, o.u, o.c, t, o.o), e += 46 + o.f.length + Ac(o.extra) + (o.o ? o.o.length : 0), t += o.b } oS(a, e, this.u.length, s, t), this.ondata(null, a, !0), this.d = 2 }, i.prototype.terminate = function () { for (var e = 0, t = this.u; e < t.length; e++) { var s = t[e]; s.t() } this.d = 2 }, i }(); function K7(i, e, t) { if (t || (t = e, e = {}), typeof t != "function") throw "no callback"; var s = {}; sS(i, "", s, e); var r = Object.keys(s), n = r.length, o = 0, a = 0, l = n, c = new Array(n), h = [], d = function () { for (var m = 0; m < h.length; ++m)h[m]() }, p = function () { var m = new Wt(a + 22), v = o, A = a - o; a = 0; for (var b = 0; b < l; ++b) { var y = c[b]; try { var _ = y.c.length; Nd(m, a, y, y.f, y.u, _); var w = 30 + y.f.length + Ac(y.extra), E = a + w; m.set(y.c, E), Nd(m, o, y, y.f, y.u, _, a, y.m), o += 16 + w + (y.m ? y.m.length : 0), a = E + _ } catch (P) { return t(P, null) } } oS(m, o, c.length, A, v), t(null, m) }; n || p(); for (var f = function (m) { var v = r[m], A = s[v], b = A[0], y = A[1], _ = kd(), w = b.length; _.p(b); var E = Vo(v), P = E.length, C = y.comment, R = C && Vo(C), T = R && R.length, z = Ac(y.extra), H = y.level == 0 ? 0 : 8, N = function (F, X) { if (F) d(), t(F, null); else { var te = X.length; c[m] = Bg(y, { size: w, crc: _.d(), c: X, f: E, m: R, u: P != v.length || R && C.length != T, compression: H }), o += 30 + P + z + te, a += 76 + 2 * (P + z) + (T || 0) + te, --n || p() } }; if (P > 65535 && N("filename too long", null), !H) N(null, b); else if (w < 16e4) try { N(null, kg(b, y)) } catch (F) { N(F, null) } else h.push(RO(b, y, N)) }, g = 0; g < l; ++g)f(g); return d } function VO(i, e) { e || (e = {}); var t = {}, s = []; sS(i, "", t, e); var r = 0, n = 0; for (var o in t) { var a = t[o], l = a[0], c = a[1], h = c.level == 0 ? 0 : 8, d = Vo(o), p = d.length, f = c.comment, g = f && Vo(f), m = g && g.length, v = Ac(c.extra); if (p > 65535) throw "filename too long"; var A = h ? kg(l, c) : l, b = A.length, y = kd(); y.p(l), s.push(Bg(c, { size: l.length, crc: y.d(), c: A, f: d, m: g, u: p != o.length || g && f.length != m, o: r, compression: h })), r += 30 + p + v + b, n += 76 + 2 * (p + v) + (m || 0) + b } for (var _ = new Wt(n + 22), w = r, E = n - r, P = 0; P < s.length; ++P) { var d = s[P]; Nd(_, d.o, d, d.f, d.u, d.c.length); var C = 30 + d.f.length + Ac(d.extra); _.set(d.c, d.o + C), Nd(_, r, d, d.f, d.u, d.c.length, d.o, d.m), r += 16 + C + (d.m ? d.m.length : 0) } return oS(_, r, s.length, E, w), _ } var WO = function () { function i() { } return i.prototype.push = function (e, t) { this.ondata(null, e, t) }, i.compression = 0, i }(), Z7 = function () { function i() { var e = this; this.i = new Ur(function (t, s) { e.ondata(null, t, s) }) } return i.prototype.push = function (e, t) { try { this.i.push(e, t) } catch (s) { this.ondata(s, e, t) } }, i.compression = 8, i }(), $7 = function () { function i(e, t) { var s = this; t < 32e4 ? this.i = new Ur(function (r, n) { s.ondata(null, r, n) }) : (this.i = new $C(function (r, n, o) { s.ondata(r, n, o) }), this.terminate = this.i.terminate) } return i.prototype.push = function (e, t) { this.i.terminate && (e = kn(e, 0)), this.i.push(e, t) }, i.compression = 8, i }(), eX = function () { function i(e) { this.onfile = e, this.k = [], this.o = { 0: WO }, this.p = tl } return i.prototype.push = function (e, t) { var s = this; if (!this.onfile) throw "no callback"; if (!this.p) throw "stream finished"; if (this.c > 0) { var r = Math.min(this.c, e.length), n = e.subarray(0, r); if (this.c -= r, this.d ? this.d.push(n, !this.c) : this.k[0].push(n), e = e.subarray(r), e.length) return this.push(e, t) } else { var o = 0, a = 0, l = void 0, c = void 0; this.p.length ? e.length ? (c = new Wt(this.p.length + e.length), c.set(this.p), c.set(e, this.p.length)) : c = this.p : c = e; for (var h = c.length, d = this.c, p = d && this.d, f = function () { var A, b = Xi(c, a); if (b == 67324752) { o = 1, l = a, g.d = null, g.c = 0; var y = br(c, a + 6), _ = br(c, a + 8), w = y & 2048, E = y & 8, P = br(c, a + 26), C = br(c, a + 28); if (h > a + 30 + P + C) { var R = []; g.k.unshift(R), o = 2; var T = Xi(c, a + 18), z = Xi(c, a + 22), H = nS(c.subarray(a + 30, a += 30 + P), !w); T == 4294967295 ? (A = E ? [-2] : HO(c, a), T = A[0], z = A[1]) : E && (T = -1), a += C, g.c = T; var N, F = { name: H, compression: _, start: function () { if (!F.ondata) throw "no callback"; if (!T) F.ondata(null, tl, !0); else { var X = s.o[_]; if (!X) throw "unknown compression type " + _; N = T < 0 ? new X(H) : new X(H, T, z), N.ondata = function (fe, ae, De) { F.ondata(fe, ae, De) }; for (var te = 0, re = R; te < re.length; te++) { var Z = re[te]; N.push(Z, !1) } s.k[0] == R && s.c ? s.d = N : N.push(tl, !0) } }, terminate: function () { N && N.terminate && N.terminate() } }; T >= 0 && (F.size = T, F.originalSize = z), g.onfile(F) } return "break" } else if (d) { if (b == 134695760) return l = a += 12 + (d == -2 && 8), o = 3, g.c = 0, "break"; if (b == 33639248) return l = a -= 4, o = 3, g.c = 0, "break" } }, g = this; a < h - 4; ++a) { var m = f(); if (m === "break") break } if (this.p = tl, d < 0) { var v = o ? c.subarray(0, l - 12 - (d == -2 && 8) - (Xi(c, l - 16) == 134695760 && 4)) : c.subarray(0, a); p ? p.push(v, !!o) : this.k[+(o == 2)].push(v) } if (o & 2) return this.push(c.subarray(a), t); this.p = c.subarray(a) } if (t) { if (this.c) throw "invalid zip file"; this.p = null } }, i.prototype.register = function (e) { this.o[e.compression] = e }, i }(); function tX(i, e) { if (typeof e != "function") throw "no callback"; for (var t = [], s = function () { for (var p = 0; p < t.length; ++p)t[p]() }, r = {}, n = i.length - 22; Xi(i, n) != 101010256; --n)if (!n || i.length - n > 65558) { e("invalid zip file", null); return } var o = br(i, n + 8); o || e(null, {}); var a = o, l = Xi(i, n + 16), c = l == 4294967295; if (c) { if (n = Xi(i, n - 12), Xi(i, n) != 101075792) { e("invalid zip file", null); return } a = o = Xi(i, n + 32), l = Xi(i, n + 48) } for (var h = function (p) { var f = GO(i, l, c), g = f[0], m = f[1], v = f[2], A = f[3], b = f[4], y = f[5], _ = QO(i, y); l = b; var w = function (P, C) { P ? (s(), e(P, null)) : (r[A] = C, --o || e(null, r)) }; if (!g) w(null, kn(i, _, _ + m)); else if (g == 8) { var E = i.subarray(_, _ + m); if (m < 32e4) try { w(null, Ud(E, new Wt(v))) } catch (P) { w(P, null) } else t.push(eS(E, { size: v }, w)) } else w("unknown compression type " + g, null) }, d = 0; d < a; ++d)h(); return s } function iX(i) { for (var e = {}, t = i.length - 22; Xi(i, t) != 101010256; --t)if (!t || i.length - t > 65558) throw "invalid zip file"; var s = br(i, t + 8); if (!s) return {}; var r = Xi(i, t + 16), n = r == 4294967295; if (n) { if (t = Xi(i, t - 12), Xi(i, t) != 101075792) throw "invalid zip file"; s = Xi(i, t + 32), r = Xi(i, t + 48) } for (var o = 0; o < s; ++o) { var a = GO(i, r, n), l = a[0], c = a[1], h = a[2], d = a[3], p = a[4], f = a[5], g = QO(i, f); if (r = p, !l) e[d] = kn(i, g, g + c); else if (l == 8) e[d] = Ud(i.subarray(g, g + c), new Wt(h)); else throw "unknown compression type " + l } return e } const qO = Object.freeze(Object.defineProperty({ __proto__: null, AsyncCompress: PO, AsyncDecompress: G7, AsyncDeflate: TO, AsyncGunzip: kO, AsyncGzip: PO, AsyncInflate: $C, AsyncUnzipInflate: $7, AsyncUnzlib: OO, AsyncZipDeflate: Y7, AsyncZlib: j7, Compress: yy, DecodeUTF8: W7, Decompress: FO, Deflate: Ho, EncodeUTF8: q7, Gunzip: _y, Gzip: yy, Inflate: Ur, Unzip: eX, UnzipInflate: Z7, UnzipPassThrough: WO, Unzlib: wy, Zip: J7, ZipDeflate: X7, ZipPassThrough: Dg, Zlib: tS, compress: BO, compressSync: by, decompress: H7, decompressSync: V7, deflate: RO, deflateSync: kg, gunzip: DO, gunzipSync: xy, gzip: BO, gzipSync: by, inflate: eS, inflateSync: Ud, strFromU8: nS, strToU8: Vo, unzip: tX, unzipSync: iX, unzlib: LO, unzlibSync: vc, zip: K7, zipSync: VO, zlib: Q7, zlibSync: iS }, Symbol.toStringTag, { value: "Module" })); class aS extends Vw { constructor(e) { super(e), this.type = gs } parse(e) { const t = Math.pow(2.7182818, 2.2); function s(M, k) { let I = 0; for (let G = 0; G < 65536; ++G)(G == 0 || M[G >> 3] & 1 << (G & 7)) && (k[I++] = G); const L = I - 1; for (; I < 65536;)k[I++] = 0; return L } function r(M) { for (let k = 0; k < 16384; k++)M[k] = {}, M[k].len = 0, M[k].lit = 0, M[k].p = null } const n = { l: 0, c: 0, lc: 0 }; function o(M, k, I, L, G) { for (; I < M;)k = k << 8 | Ae(L, G), I += 8; I -= M, n.l = k >> I & (1 << M) - 1, n.c = k, n.lc = I } const a = new Array(59); function l(M) { for (let I = 0; I <= 58; ++I)a[I] = 0; for (let I = 0; I < 65537; ++I)a[M[I]] += 1; let k = 0; for (let I = 58; I > 0; --I) { const L = k + a[I] >> 1; a[I] = k, k = L } for (let I = 0; I < 65537; ++I) { const L = M[I]; L > 0 && (M[I] = L | a[L]++ << 6) } } function c(M, k, I, L, G, V) { const he = k; let be = 0, ke = 0; for (; L <= G; L++) { if (he.value - k.value > I) return !1; o(6, be, ke, M, he); const _e = n.l; if (be = n.c, ke = n.lc, V[L] = _e, _e == 63) { if (he.value - k.value > I) throw new Error("Something wrong with hufUnpackEncTable"); o(8, be, ke, M, he); let Oe = n.l + 6; if (be = n.c, ke = n.lc, L + Oe > G + 1) throw new Error("Something wrong with hufUnpackEncTable"); for (; Oe--;)V[L++] = 0; L-- } else if (_e >= 59) { let Oe = _e - 59 + 2; if (L + Oe > G + 1) throw new Error("Something wrong with hufUnpackEncTable"); for (; Oe--;)V[L++] = 0; L-- } } l(V) } function h(M) { return M & 63 } function d(M) { return M >> 6 } function p(M, k, I, L) { for (; k <= I; k++) { const G = d(M[k]), V = h(M[k]); if (G >> V) throw new Error("Invalid table entry"); if (V > 14) { const he = L[G >> V - 14]; if (he.len) throw new Error("Invalid table entry"); if (he.lit++, he.p) { const be = he.p; he.p = new Array(he.lit); for (let ke = 0; ke < he.lit - 1; ++ke)he.p[ke] = be[ke] } else he.p = new Array(1); he.p[he.lit - 1] = k } else if (V) { let he = 0; for (let be = 1 << 14 - V; be > 0; be--) { const ke = L[(G << 14 - V) + he]; if (ke.len || ke.p) throw new Error("Invalid table entry"); ke.len = V, ke.lit = k, he++ } } } return !0 } const f = { c: 0, lc: 0 }; function g(M, k, I, L) { M = M << 8 | Ae(I, L), k += 8, f.c = M, f.lc = k } const m = { c: 0, lc: 0 }; function v(M, k, I, L, G, V, he, be, ke) { if (M == k) { L < 8 && (g(I, L, G, V), I = f.c, L = f.lc), L -= 8; let _e = I >> L; if (_e = new Uint8Array([_e])[0], be.value + _e > ke) return !1; const Oe = he[be.value - 1]; for (; _e-- > 0;)he[be.value++] = Oe } else if (be.value < ke) he[be.value++] = M; else return !1; m.c = I, m.lc = L } function A(M) { return M & 65535 } function b(M) { const k = A(M); return k > 32767 ? k - 65536 : k } const y = { a: 0, b: 0 }; function _(M, k) { const I = b(M), L = b(k), G = I + (L & 1) + (L >> 1), V = G, he = G - L; y.a = V, y.b = he } function w(M, k) { const I = A(M), L = A(k), G = I - (L >> 1) & 65535, V = L + G - 32768 & 65535; y.a = V, y.b = G } function E(M, k, I, L, G, V, he) { const be = he < 16384, ke = I > G ? G : I; let _e = 1, Oe, Ge; for (; _e <= ke;)_e <<= 1; for (_e >>= 1, Oe = _e, _e >>= 1; _e >= 1;) { Ge = 0; const Je = Ge + V * (G - Oe), ot = V * _e, Rt = V * Oe, ct = L * _e, ft = L * Oe; let jt, O, ee, ue; for (; Ge <= Je; Ge += Rt) { let Y = Ge; const se = Ge + L * (I - Oe); for (; Y <= se; Y += ft) { const We = Y + ct, gt = Y + ot, pt = gt + ct; be ? (_(M[Y + k], M[gt + k]), jt = y.a, ee = y.b, _(M[We + k], M[pt + k]), O = y.a, ue = y.b, _(jt, O), M[Y + k] = y.a, M[We + k] = y.b, _(ee, ue), M[gt + k] = y.a, M[pt + k] = y.b) : (w(M[Y + k], M[gt + k]), jt = y.a, ee = y.b, w(M[We + k], M[pt + k]), O = y.a, ue = y.b, w(jt, O), M[Y + k] = y.a, M[We + k] = y.b, w(ee, ue), M[gt + k] = y.a, M[pt + k] = y.b) } if (I & _e) { const We = Y + ot; be ? _(M[Y + k], M[We + k]) : w(M[Y + k], M[We + k]), jt = y.a, M[We + k] = y.b, M[Y + k] = jt } } if (G & _e) { let Y = Ge; const se = Ge + L * (I - Oe); for (; Y <= se; Y += ft) { const We = Y + ct; be ? _(M[Y + k], M[We + k]) : w(M[Y + k], M[We + k]), jt = y.a, M[We + k] = y.b, M[Y + k] = jt } } Oe = _e, _e >>= 1 } return Ge } function P(M, k, I, L, G, V, he, be, ke) { let _e = 0, Oe = 0; const Ge = he, Je = Math.trunc(L.value + (G + 7) / 8); for (; L.value < Je;)for (g(_e, Oe, I, L), _e = f.c, Oe = f.lc; Oe >= 14;) { const Rt = _e >> Oe - 14 & 16383, ct = k[Rt]; if (ct.len) Oe -= ct.len, v(ct.lit, V, _e, Oe, I, L, be, ke, Ge), _e = m.c, Oe = m.lc; else { if (!ct.p) throw new Error("hufDecode issues"); let ft; for (ft = 0; ft < ct.lit; ft++) { const jt = h(M[ct.p[ft]]); for (; Oe < jt && L.value < Je;)g(_e, Oe, I, L), _e = f.c, Oe = f.lc; if (Oe >= jt && d(M[ct.p[ft]]) == (_e >> Oe - jt & (1 << jt) - 1)) { Oe -= jt, v(ct.p[ft], V, _e, Oe, I, L, be, ke, Ge), _e = m.c, Oe = m.lc; break } } if (ft == ct.lit) throw new Error("hufDecode issues") } } const ot = 8 - G & 7; for (_e >>= ot, Oe -= ot; Oe > 0;) { const Rt = k[_e << 14 - Oe & 16383]; if (Rt.len) Oe -= Rt.len, v(Rt.lit, V, _e, Oe, I, L, be, ke, Ge), _e = m.c, Oe = m.lc; else throw new Error("hufDecode issues") } return !0 } function C(M, k, I, L, G, V) { const he = { value: 0 }, be = I.value, ke = de(k, I), _e = de(k, I); I.value += 4; const Oe = de(k, I); if (I.value += 4, ke < 0 || ke >= 65537 || _e < 0 || _e >= 65537) throw new Error("Something wrong with HUF_ENCSIZE"); const Ge = new Array(65537), Je = new Array(16384); r(Je); const ot = L - (I.value - be); if (c(M, I, ot, ke, _e, Ge), Oe > 8 * (L - (I.value - be))) throw new Error("Something wrong with hufUncompress"); p(Ge, ke, _e, Je), P(Ge, Je, M, I, Oe, _e, V, G, he) } function R(M, k, I) { for (let L = 0; L < I; ++L)k[L] = M[k[L]] } function T(M) { for (let k = 1; k < M.length; k++) { const I = M[k - 1] + M[k] - 128; M[k] = I } } function z(M, k) { let I = 0, L = Math.floor((M.length + 1) / 2), G = 0; const V = M.length - 1; for (; !(G > V || (k[G++] = M[I++], G > V));)k[G++] = M[L++] } function H(M) { let k = M.byteLength; const I = new Array; let L = 0; const G = new DataView(M); for (; k > 0;) { const V = G.getInt8(L++); if (V < 0) { const he = -V; k -= he + 1; for (let be = 0; be < he; be++)I.push(G.getUint8(L++)) } else { const he = V; k -= 2; const be = G.getUint8(L++); for (let ke = 0; ke < he + 1; ke++)I.push(be) } } return I } function N(M, k, I, L, G, V) { let he = new DataView(V.buffer); const be = I[M.idx[0]].width, ke = I[M.idx[0]].height, _e = 3, Oe = Math.floor(be / 8), Ge = Math.ceil(be / 8), Je = Math.ceil(ke / 8), ot = be - (Ge - 1) * 8, Rt = ke - (Je - 1) * 8, ct = { value: 0 }, ft = new Array(_e), jt = new Array(_e), O = new Array(_e), ee = new Array(_e), ue = new Array(_e); for (let se = 0; se < _e; ++se)ue[se] = k[M.idx[se]], ft[se] = se < 1 ? 0 : ft[se - 1] + Ge * Je, jt[se] = new Float32Array(64), O[se] = new Uint16Array(64), ee[se] = new Uint16Array(Ge * 64); for (let se = 0; se < Je; ++se) { let We = 8; se == Je - 1 && (We = Rt); let gt = 8; for (let $e = 0; $e < Ge; ++$e) { $e == Ge - 1 && (gt = ot); for (let vt = 0; vt < _e; ++vt)O[vt].fill(0), O[vt][0] = G[ft[vt]++], F(ct, L, O[vt]), X(O[vt], jt[vt]), te(jt[vt]); re(jt); for (let vt = 0; vt < _e; ++vt)Z(jt[vt], ee[vt], $e * 64) } let pt = 0; for (let $e = 0; $e < _e; ++$e) { const vt = I[M.idx[$e]].type; for (let Bt = 8 * se; Bt < 8 * se + We; ++Bt) { pt = ue[$e][Bt]; for (let Lt = 0; Lt < Oe; ++Lt) { const fi = Lt * 64 + (Bt & 7) * 8; he.setUint16(pt + 0 * 2 * vt, ee[$e][fi + 0], !0), he.setUint16(pt + 1 * 2 * vt, ee[$e][fi + 1], !0), he.setUint16(pt + 2 * 2 * vt, ee[$e][fi + 2], !0), he.setUint16(pt + 3 * 2 * vt, ee[$e][fi + 3], !0), he.setUint16(pt + 4 * 2 * vt, ee[$e][fi + 4], !0), he.setUint16(pt + 5 * 2 * vt, ee[$e][fi + 5], !0), he.setUint16(pt + 6 * 2 * vt, ee[$e][fi + 6], !0), he.setUint16(pt + 7 * 2 * vt, ee[$e][fi + 7], !0), pt += 8 * 2 * vt } } if (Oe != Ge) for (let Bt = 8 * se; Bt < 8 * se + We; ++Bt) { const Lt = ue[$e][Bt] + 8 * Oe * 2 * vt, fi = Oe * 64 + (Bt & 7) * 8; for (let Cs = 0; Cs < gt; ++Cs)he.setUint16(Lt + Cs * 2 * vt, ee[$e][fi + Cs], !0) } } } const Y = new Uint16Array(be); he = new DataView(V.buffer); for (let se = 0; se < _e; ++se) { I[M.idx[se]].decoded = !0; const We = I[M.idx[se]].type; if (I[se].type == 2) for (let gt = 0; gt < ke; ++gt) { const pt = ue[se][gt]; for (let $e = 0; $e < be; ++$e)Y[$e] = he.getUint16(pt + $e * 2 * We, !0); for (let $e = 0; $e < be; ++$e)he.setFloat32(pt + $e * 2 * We, me(Y[$e]), !0) } } } function F(M, k, I) { let L, G = 1; for (; G < 64;)L = k[M.value], L == 65280 ? G = 64 : L >> 8 == 255 ? G += L & 255 : (I[G] = L, G++), M.value++ } function X(M, k) { k[0] = me(M[0]), k[1] = me(M[1]), k[2] = me(M[5]), k[3] = me(M[6]), k[4] = me(M[14]), k[5] = me(M[15]), k[6] = me(M[27]), k[7] = me(M[28]), k[8] = me(M[2]), k[9] = me(M[4]), k[10] = me(M[7]), k[11] = me(M[13]), k[12] = me(M[16]), k[13] = me(M[26]), k[14] = me(M[29]), k[15] = me(M[42]), k[16] = me(M[3]), k[17] = me(M[8]), k[18] = me(M[12]), k[19] = me(M[17]), k[20] = me(M[25]), k[21] = me(M[30]), k[22] = me(M[41]), k[23] = me(M[43]), k[24] = me(M[9]), k[25] = me(M[11]), k[26] = me(M[18]), k[27] = me(M[24]), k[28] = me(M[31]), k[29] = me(M[40]), k[30] = me(M[44]), k[31] = me(M[53]), k[32] = me(M[10]), k[33] = me(M[19]), k[34] = me(M[23]), k[35] = me(M[32]), k[36] = me(M[39]), k[37] = me(M[45]), k[38] = me(M[52]), k[39] = me(M[54]), k[40] = me(M[20]), k[41] = me(M[22]), k[42] = me(M[33]), k[43] = me(M[38]), k[44] = me(M[46]), k[45] = me(M[51]), k[46] = me(M[55]), k[47] = me(M[60]), k[48] = me(M[21]), k[49] = me(M[34]), k[50] = me(M[37]), k[51] = me(M[47]), k[52] = me(M[50]), k[53] = me(M[56]), k[54] = me(M[59]), k[55] = me(M[61]), k[56] = me(M[35]), k[57] = me(M[36]), k[58] = me(M[48]), k[59] = me(M[49]), k[60] = me(M[57]), k[61] = me(M[58]), k[62] = me(M[62]), k[63] = me(M[63]) } function te(M) { const k = .5 * Math.cos(.7853975), I = .5 * Math.cos(3.14159 / 16), L = .5 * Math.cos(3.14159 / 8), G = .5 * Math.cos(3 * 3.14159 / 16), V = .5 * Math.cos(5 * 3.14159 / 16), he = .5 * Math.cos(3 * 3.14159 / 8), be = .5 * Math.cos(7 * 3.14159 / 16), ke = new Array(4), _e = new Array(4), Oe = new Array(4), Ge = new Array(4); for (let Je = 0; Je < 8; ++Je) { const ot = Je * 8; ke[0] = L * M[ot + 2], ke[1] = he * M[ot + 2], ke[2] = L * M[ot + 6], ke[3] = he * M[ot + 6], _e[0] = I * M[ot + 1] + G * M[ot + 3] + V * M[ot + 5] + be * M[ot + 7], _e[1] = G * M[ot + 1] - be * M[ot + 3] - I * M[ot + 5] - V * M[ot + 7], _e[2] = V * M[ot + 1] - I * M[ot + 3] + be * M[ot + 5] + G * M[ot + 7], _e[3] = be * M[ot + 1] - V * M[ot + 3] + G * M[ot + 5] - I * M[ot + 7], Oe[0] = k * (M[ot + 0] + M[ot + 4]), Oe[3] = k * (M[ot + 0] - M[ot + 4]), Oe[1] = ke[0] + ke[3], Oe[2] = ke[1] - ke[2], Ge[0] = Oe[0] + Oe[1], Ge[1] = Oe[3] + Oe[2], Ge[2] = Oe[3] - Oe[2], Ge[3] = Oe[0] - Oe[1], M[ot + 0] = Ge[0] + _e[0], M[ot + 1] = Ge[1] + _e[1], M[ot + 2] = Ge[2] + _e[2], M[ot + 3] = Ge[3] + _e[3], M[ot + 4] = Ge[3] - _e[3], M[ot + 5] = Ge[2] - _e[2], M[ot + 6] = Ge[1] - _e[1], M[ot + 7] = Ge[0] - _e[0] } for (let Je = 0; Je < 8; ++Je)ke[0] = L * M[16 + Je], ke[1] = he * M[16 + Je], ke[2] = L * M[48 + Je], ke[3] = he * M[48 + Je], _e[0] = I * M[8 + Je] + G * M[24 + Je] + V * M[40 + Je] + be * M[56 + Je], _e[1] = G * M[8 + Je] - be * M[24 + Je] - I * M[40 + Je] - V * M[56 + Je], _e[2] = V * M[8 + Je] - I * M[24 + Je] + be * M[40 + Je] + G * M[56 + Je], _e[3] = be * M[8 + Je] - V * M[24 + Je] + G * M[40 + Je] - I * M[56 + Je], Oe[0] = k * (M[Je] + M[32 + Je]), Oe[3] = k * (M[Je] - M[32 + Je]), Oe[1] = ke[0] + ke[3], Oe[2] = ke[1] - ke[2], Ge[0] = Oe[0] + Oe[1], Ge[1] = Oe[3] + Oe[2], Ge[2] = Oe[3] - Oe[2], Ge[3] = Oe[0] - Oe[1], M[0 + Je] = Ge[0] + _e[0], M[8 + Je] = Ge[1] + _e[1], M[16 + Je] = Ge[2] + _e[2], M[24 + Je] = Ge[3] + _e[3], M[32 + Je] = Ge[3] - _e[3], M[40 + Je] = Ge[2] - _e[2], M[48 + Je] = Ge[1] - _e[1], M[56 + Je] = Ge[0] - _e[0] } function re(M) { for (let k = 0; k < 64; ++k) { const I = M[0][k], L = M[1][k], G = M[2][k]; M[0][k] = I + 1.5747 * G, M[1][k] = I - .1873 * L - .4682 * G, M[2][k] = I + 1.8556 * L } } function Z(M, k, I) { for (let L = 0; L < 64; ++L)k[I + L] = Th.toHalfFloat(fe(M[L])) } function fe(M) { return M <= 1 ? Math.sign(M) * Math.pow(Math.abs(M), 2.2) : Math.sign(M) * Math.pow(t, Math.abs(M) - 1) } function ae(M) { return new DataView(M.array.buffer, M.offset.value, M.size) } function De(M) { const k = M.viewer.buffer.slice(M.offset.value, M.offset.value + M.size), I = new Uint8Array(H(k)), L = new Uint8Array(I.length); return T(I), z(I, L), new DataView(L.buffer) } function Se(M) { const k = M.array.slice(M.offset.value, M.offset.value + M.size); typeof qO > "u" && console.error("THREE.EXRLoader: External library fflate.min.js required."); const I = vc(k), L = new Uint8Array(I.length); return T(I), z(I, L), new DataView(L.buffer) } function ie(M) { const k = M.viewer, I = { value: M.offset.value }, L = new Uint16Array(M.width * M.scanlineBlockSize * (M.channels * M.type)), G = new Uint8Array(8192); let V = 0; const he = new Array(M.channels); for (let Rt = 0; Rt < M.channels; Rt++)he[Rt] = {}, he[Rt].start = V, he[Rt].end = he[Rt].start, he[Rt].nx = M.width, he[Rt].ny = M.lines, he[Rt].size = M.type, V += he[Rt].nx * he[Rt].ny * he[Rt].size; const be = ut(k, I), ke = ut(k, I); if (ke >= 8192) throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE"); if (be <= ke) for (let Rt = 0; Rt < ke - be + 1; Rt++)G[Rt + be] = pe(k, I); const _e = new Uint16Array(65536), Oe = s(G, _e), Ge = de(k, I); C(M.array, k, I, Ge, L, V); for (let Rt = 0; Rt < M.channels; ++Rt) { const ct = he[Rt]; for (let ft = 0; ft < he[Rt].size; ++ft)E(L, ct.start + ft, ct.nx, ct.size, ct.ny, ct.nx * ct.size, Oe) } R(_e, L, V); let Je = 0; const ot = new Uint8Array(L.buffer.byteLength); for (let Rt = 0; Rt < M.lines; Rt++)for (let ct = 0; ct < M.channels; ct++) { const ft = he[ct], jt = ft.nx * ft.size, O = new Uint8Array(L.buffer, ft.end * 2, jt * 2); ot.set(O, Je), Je += jt * 2, ft.end += jt } return new DataView(ot.buffer) } function ce(M) { const k = M.array.slice(M.offset.value, M.offset.value + M.size); typeof qO > "u" && console.error("THREE.EXRLoader: External library fflate.min.js required."); const I = vc(k), L = M.lines * M.channels * M.width, G = M.type == 1 ? new Uint16Array(L) : new Uint32Array(L); let V = 0, he = 0; const be = new Array(4); for (let ke = 0; ke < M.lines; ke++)for (let _e = 0; _e < M.channels; _e++) { let Oe = 0; switch (M.type) { case 1: be[0] = V, be[1] = be[0] + M.width, V = be[1] + M.width; for (let Ge = 0; Ge < M.width; ++Ge) { const Je = I[be[0]++] << 8 | I[be[1]++]; Oe += Je, G[he] = Oe, he++ } break; case 2: be[0] = V, be[1] = be[0] + M.width, be[2] = be[1] + M.width, V = be[2] + M.width; for (let Ge = 0; Ge < M.width; ++Ge) { const Je = I[be[0]++] << 24 | I[be[1]++] << 16 | I[be[2]++] << 8; Oe += Je, G[he] = Oe, he++ } break } } return new DataView(G.buffer) } function Te(M) { const k = M.viewer, I = { value: M.offset.value }, L = new Uint8Array(M.width * M.lines * (M.channels * M.type * 2)), G = { version: Fe(k, I), unknownUncompressedSize: Fe(k, I), unknownCompressedSize: Fe(k, I), acCompressedSize: Fe(k, I), dcCompressedSize: Fe(k, I), rleCompressedSize: Fe(k, I), rleUncompressedSize: Fe(k, I), rleRawSize: Fe(k, I), totalAcUncompressedCount: Fe(k, I), totalDcUncompressedCount: Fe(k, I), acCompression: Fe(k, I) }; if (G.version < 2) throw new Error("EXRLoader.parse: " + ze.compression + " version " + G.version + " is unsupported"); const V = new Array; let he = ut(k, I) - 2; for (; he > 0;) { const ct = K(k.buffer, I), ft = pe(k, I), jt = ft >> 2 & 3, O = (ft >> 4) - 1, ee = new Int8Array([O])[0], ue = pe(k, I); V.push({ name: ct, index: ee, type: ue, compression: jt }), he -= ct.length + 3 } const be = ze.channels, ke = new Array(M.channels); for (let ct = 0; ct < M.channels; ++ct) { const ft = ke[ct] = {}, jt = be[ct]; ft.name = jt.name, ft.compression = 0, ft.decoded = !1, ft.type = jt.pixelType, ft.pLinear = jt.pLinear, ft.width = M.width, ft.height = M.lines } const _e = { idx: new Array(3) }; for (let ct = 0; ct < M.channels; ++ct) { const ft = ke[ct]; for (let jt = 0; jt < V.length; ++jt) { const O = V[jt]; ft.name == O.name && (ft.compression = O.compression, O.index >= 0 && (_e.idx[O.index] = ct), ft.offset = ct) } } let Oe, Ge, Je; if (G.acCompressedSize > 0) switch (G.acCompression) { case 0: Oe = new Uint16Array(G.totalAcUncompressedCount), C(M.array, k, I, G.acCompressedSize, Oe, G.totalAcUncompressedCount); break; case 1: const ct = M.array.slice(I.value, I.value + G.totalAcUncompressedCount), ft = vc(ct); Oe = new Uint16Array(ft.buffer), I.value += G.totalAcUncompressedCount; break }if (G.dcCompressedSize > 0) { const ct = { array: M.array, offset: I, size: G.dcCompressedSize }; Ge = new Uint16Array(Se(ct).buffer), I.value += G.dcCompressedSize } if (G.rleRawSize > 0) { const ct = M.array.slice(I.value, I.value + G.rleCompressedSize), ft = vc(ct); Je = H(ft.buffer), I.value += G.rleCompressedSize } let ot = 0; const Rt = new Array(ke.length); for (let ct = 0; ct < Rt.length; ++ct)Rt[ct] = new Array; for (let ct = 0; ct < M.lines; ++ct)for (let ft = 0; ft < ke.length; ++ft)Rt[ft].push(ot), ot += ke[ft].width * M.type * 2; N(_e, Rt, ke, Oe, Ge, L); for (let ct = 0; ct < ke.length; ++ct) { const ft = ke[ct]; if (!ft.decoded) switch (ft.compression) { case 2: let jt = 0, O = 0; for (let ee = 0; ee < M.lines; ++ee) { let ue = Rt[ct][jt]; for (let Y = 0; Y < ft.width; ++Y) { for (let se = 0; se < 2 * ft.type; ++se)L[ue++] = Je[O + se * ft.width * ft.height]; O++ } jt++ } break; case 1: default: throw new Error("EXRLoader.parse: unsupported channel compression") } } return new DataView(L.buffer) } function K(M, k) { const I = new Uint8Array(M); let L = 0; for (; I[k.value + L] != 0;)L += 1; const G = new TextDecoder().decode(I.slice(k.value, k.value + L)); return k.value = k.value + L + 1, G } function je(M, k, I) { const L = new TextDecoder().decode(new Uint8Array(M).slice(k.value, k.value + I)); return k.value = k.value + I, L } function Ue(M, k) { const I = ve(M, k), L = de(M, k); return [I, L] } function Pe(M, k) { const I = de(M, k), L = de(M, k); return [I, L] } function ve(M, k) { const I = M.getInt32(k.value, !0); return k.value = k.value + 4, I } function de(M, k) { const I = M.getUint32(k.value, !0); return k.value = k.value + 4, I } function Ae(M, k) { const I = M[k.value]; return k.value = k.value + 1, I } function pe(M, k) { const I = M.getUint8(k.value); return k.value = k.value + 1, I } const Fe = function (M, k) { const I = Number(M.getBigInt64(k.value, !0)); return k.value += 8, I }; function Re(M, k) { const I = M.getFloat32(k.value, !0); return k.value += 4, I } function ht(M, k) { return Th.toHalfFloat(Re(M, k)) } function me(M) { const k = (M & 31744) >> 10, I = M & 1023; return (M >> 15 ? -1 : 1) * (k ? k === 31 ? I ? NaN : 1 / 0 : Math.pow(2, k - 15) * (1 + I / 1024) : 6103515625e-14 * (I / 1024)) } function ut(M, k) { const I = M.getUint16(k.value, !0); return k.value += 2, I } function dt(M, k) { return me(ut(M, k)) } function Pt(M, k, I, L) { const G = I.value, V = []; for (; I.value < G + L - 1;) { const he = K(k, I), be = ve(M, I), ke = pe(M, I); I.value += 3; const _e = ve(M, I), Oe = ve(M, I); V.push({ name: he, pixelType: be, pLinear: ke, xSampling: _e, ySampling: Oe }) } return I.value += 1, V } function ii(M, k) { const I = Re(M, k), L = Re(M, k), G = Re(M, k), V = Re(M, k), he = Re(M, k), be = Re(M, k), ke = Re(M, k), _e = Re(M, k); return { redX: I, redY: L, greenX: G, greenY: V, blueX: he, blueY: be, whiteX: ke, whiteY: _e } } function U(M, k) { const I = ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"], L = pe(M, k); return I[L] } function D(M, k) { const I = de(M, k), L = de(M, k), G = de(M, k), V = de(M, k); return { xMin: I, yMin: L, xMax: G, yMax: V } } function le(M, k) { const I = ["INCREASING_Y"], L = pe(M, k); return I[L] } function Ie(M, k) { const I = Re(M, k), L = Re(M, k); return [I, L] } function Be(M, k) { const I = Re(M, k), L = Re(M, k), G = Re(M, k); return [I, L, G] } function Qe(M, k, I, L, G) { if (L === "string" || L === "stringvector" || L === "iccProfile") return je(k, I, G); if (L === "chlist") return Pt(M, k, I, G); if (L === "chromaticities") return ii(M, I); if (L === "compression") return U(M, I); if (L === "box2i") return D(M, I); if (L === "lineOrder") return le(M, I); if (L === "float") return Re(M, I); if (L === "v2f") return Ie(M, I); if (L === "v3f") return Be(M, I); if (L === "int") return ve(M, I); if (L === "rational") return Ue(M, I); if (L === "timecode") return Pe(M, I); if (L === "preview") return I.value += G, "skipped"; I.value += G } function rt(M, k, I) { const L = {}; if (M.getUint32(0, !0) != 20000630) throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format."); L.version = M.getUint8(4); const G = M.getUint8(5); L.spec = { singleTile: !!(G & 2), longName: !!(G & 4), deepFormat: !!(G & 8), multiPart: !!(G & 16) }, I.value = 8; let V = !0; for (; V;) { const he = K(k, I); if (he == 0) V = !1; else { const be = K(k, I), ke = de(M, I), _e = Qe(M, k, I, be, ke); _e === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${be}'.`) : L[he] = _e } } if (G & -5) throw console.error("EXRHeader:", L), new Error("THREE.EXRLoader: provided file is currently unsupported."); return L } function j(M, k, I, L, G) { const V = { size: 0, viewer: k, array: I, offset: L, width: M.dataWindow.xMax - M.dataWindow.xMin + 1, height: M.dataWindow.yMax - M.dataWindow.yMin + 1, channels: M.channels.length, bytesPerLine: null, lines: null, inputSize: null, type: M.channels[0].pixelType, uncompress: null, getter: null, format: null, encoding: null }; switch (M.compression) { case "NO_COMPRESSION": V.lines = 1, V.uncompress = ae; break; case "RLE_COMPRESSION": V.lines = 1, V.uncompress = De; break; case "ZIPS_COMPRESSION": V.lines = 1, V.uncompress = Se; break; case "ZIP_COMPRESSION": V.lines = 16, V.uncompress = Se; break; case "PIZ_COMPRESSION": V.lines = 32, V.uncompress = ie; break; case "PXR24_COMPRESSION": V.lines = 16, V.uncompress = ce; break; case "DWAA_COMPRESSION": V.lines = 32, V.uncompress = Te; break; case "DWAB_COMPRESSION": V.lines = 256, V.uncompress = Te; break; default: throw new Error("EXRLoader.parse: " + M.compression + " is unsupported") }if (V.scanlineBlockSize = V.lines, V.type == 1) switch (G) { case $i: V.getter = dt, V.inputSize = 2; break; case gs: V.getter = ut, V.inputSize = 2; break } else if (V.type == 2) switch (G) { case $i: V.getter = Re, V.inputSize = 4; break; case gs: V.getter = ht, V.inputSize = 4 } else throw new Error("EXRLoader.parse: unsupported pixelType " + V.type + " for " + M.compression + "."); V.blockCount = (M.dataWindow.yMax + 1) / V.scanlineBlockSize; for (let be = 0; be < V.blockCount; be++)Fe(k, L); V.outputChannels = V.channels == 3 ? 4 : V.channels; const he = V.width * V.height * V.outputChannels; switch (G) { case $i: V.byteArray = new Float32Array(he), V.channels < V.outputChannels && V.byteArray.fill(1, 0, he); break; case gs: V.byteArray = new Uint16Array(he), V.channels < V.outputChannels && V.byteArray.fill(15360, 0, he); break; default: console.error("THREE.EXRLoader: unsupported type: ", G); break }return V.bytesPerLine = V.width * V.inputSize * V.channels, V.outputChannels == 4 ? (V.format = _i, V.encoding = Qi) : (V.format = Fl, V.encoding = Qi), V } const J = new DataView(e), Ve = new Uint8Array(e), qe = { value: 0 }, ze = rt(J, e, qe), ge = j(ze, J, Ve, qe, this.type), lt = { value: 0 }, It = { R: 0, G: 1, B: 2, A: 3, Y: 0 }; for (let M = 0; M < ge.height / ge.scanlineBlockSize; M++) { const k = de(J, qe); ge.size = de(J, qe), ge.lines = k + ge.scanlineBlockSize > ge.height ? ge.height - k : ge.scanlineBlockSize; const I = ge.size < ge.lines * ge.bytesPerLine ? ge.uncompress(ge) : ae(ge); qe.value += ge.size; for (let L = 0; L < ge.scanlineBlockSize; L++) { const G = L + M * ge.scanlineBlockSize; if (G >= ge.height) break; for (let V = 0; V < ge.channels; V++) { const he = It[ze.channels[V].name]; for (let be = 0; be < ge.width; be++) { lt.value = (L * (ge.channels * ge.width) + V * ge.width + be) * ge.inputSize; const ke = (ge.height - 1 - G) * (ge.width * ge.outputChannels) + be * ge.outputChannels + he; ge.byteArray[ke] = ge.getter(I, lt) } } } } return { header: ze, width: ge.width, height: ge.height, data: ge.byteArray, format: ge.format, encoding: ge.encoding, type: this.type } } setDataType(e) { return this.type = e, this } load(e, t, s, r) { function n(o, a) { o.encoding = a.encoding, o.minFilter = Qt, o.magFilter = Qt, o.generateMipmaps = !1, o.flipY = !1, t && t(o, a) } return super.load(e, n, s, r) } } const lS = oe("debugexr"); class sX { constructor(e) { u(this, "parser"), u(this, "name"), this.parser = e, this.name = "EXT_texture_exr", lS && console.log(e) } loadTexture(e) { const t = this.name, s = this.parser, r = s.json.textures[e]; if (lS && console.log("EXT_texture_exr.loadTexture", e, r), !r.extensions || !r.extensions[t]) return null; const n = r.extensions[t], o = new aS(s.options.manager); return lS && console.log("EXT_texture_exr.loadTexture", n, o), s.loadTextureImage(e, n.source, o) } } window.addEventListener("unhandledrejection", i => { }); const XO = "NEEDLE_gameobject_data"; class rX { constructor(e) { u(this, "parser"), this.parser = e } get name() { return XO } afterRoot(e) { const t = []; for (let s = 0; s < this.parser.json.nodes.length; s++) { const r = this.parser.json.nodes[s]; if (r && r.extensions) { const n = r.extensions[XO]; if (n) { const o = this.findAndApplyExtensionData(s, n); t.push(o) } } } return Promise.all(t).then(() => { }) } async findAndApplyExtensionData(e, t) { const s = await this.parser.getDependency("node", e); s && this.applyExtensionData(s, t) } applyExtensionData(e, t) { t.layers === void 0 && (t.layers = 0), e.userData.layer = t.layers, e.layers.disableAll(), e.layers.set(t.layers), e.userData.tag = t.tag ?? "none", e.userData.hideFlags = t.hideFlags ?? 0, e.userData.static = t.static ?? !1, e.visible = t.activeSelf ?? !0, e.guid = t.guid } } const YO = "NEEDLE_lighting_settings", zh = oe("debugenvlight"); class nX { constructor(e, t, s) { u(this, "parser"), u(this, "sourceId"), u(this, "context"), this.parser = e, this.sourceId = t, this.context = s } get name() { return YO } afterRoot(e) { const t = this.parser.json.extensions; if (t) { const s = t[YO]; if (s) { zh && console.log('Loaded "' + this.name + '", src: "' + this.sourceId + '"', s); let r; if (e.scene.children.length === 1) { const n = e.scene.children[0]; r = $.addNewComponent(n, Cy, !1) } else { const n = new Me; n.name = "LightSettings " + this.sourceId, e.scene.add(n), r = $.addNewComponent(n, Cy, !1) } r.sourceId = this.sourceId, r.ambientIntensity = s.ambientIntensity, r.ambientLight = new xe().fromArray(s.ambientLight), Array.isArray(s.ambientTrilight) && (r.ambientTrilight = s.ambientTrilight.map(n => new xe().fromArray(n))), r.ambientMode = s.ambientMode, r.environmentReflectionSource = s.environmentReflectionSource } } return null } } Zi.registerCallback(Jr.ContextCreated, i => { const e = i.context, t = $.findObjectOfType(Cy, e); t != null && t.sourceId && (t.enabled = !0) }); class Cy extends Ee { constructor() { super(...arguments), u(this, "ambientMode", xd.Skybox), u(this, "ambientLight"), u(this, "ambientTrilight"), u(this, "ambientIntensity", 1), u(this, "environmentReflectionSource", oy.Skybox), u(this, "_hasReflection", !1), u(this, "_ambientLightObj"), u(this, "_hemisphereLightObj"), u(this, "_lightProbeObj") } awake() { var e; if (this.sourceId) { const s = this.environmentReflectionSource === oy.Skybox ? oc.Skybox : oc.Reflection, r = this.context.lightmaps.tryGet(this.sourceId, s, 0); this._hasReflection = r != null, r && this.context.sceneLighting.internalRegisterReflection(this.sourceId, r) } this.enabled = !1, this.context.sceneLighting.internalRegisterSceneLightSettings(this), zh && window.addEventListener("keydown", s => { if (!this.destroyed) switch (s.key) { case "l": this.enabled = !this.enabled; break } }); const t = (e = this.gameObject.userData) == null ? void 0 : e.components; if (t) { const s = t.indexOf(this); t.splice(s, 1), t.push(this) } } onDestroy() { this.context.sceneLighting.internalUnregisterSceneLightSettings(this) } calculateIntensityFactor(e) { const t = Math.max(e.r, e.g, e.b); return 2.2 * Ke.lerp(0, 1.33, t) } onEnable() { if (zh && console.warn("\u{1F4A1}\u{1F7E1} >>> Enable lighting", this.sourceId, this.enabled, this), this.ambientMode == xd.Flat) { if (this.ambientLight && !this._ambientLightObj) { const e = this.calculateIntensityFactor(this.ambientLight); this._ambientLightObj = new Jw(this.ambientLight, this.ambientIntensity * e), zh && console.log("Created ambient light", this.sourceId, this._ambientLightObj, this.ambientIntensity, e) } this._ambientLightObj && this.gameObject.add(this._ambientLightObj), this._lightProbeObj && this._lightProbeObj.removeFromParent() } else if (this.ambientMode === xd.Trilight) { if (this.ambientTrilight) { const e = this.ambientTrilight[0], t = this.ambientTrilight[this.ambientTrilight.length - 1], s = this.calculateIntensityFactor(t); this._hemisphereLightObj = new Ww(t, e, this.ambientIntensity * s), this.gameObject.add(this._hemisphereLightObj), zh && console.log("Created hemisphere ambient light", this.sourceId, this._hemisphereLightObj, this.ambientIntensity, s) } } else this._ambientLightObj && this._ambientLightObj.removeFromParent(), this._hemisphereLightObj && this._hemisphereLightObj.removeFromParent(), this._lightProbeObj ? this.enabled && this.destroyed && this._lightProbeObj && this.gameObject.add(this._lightProbeObj) : this.sourceId && this.context.sceneLighting.internalGetSceneLightingData(this.sourceId).then(e => { e && (this._lightProbeObj = e.lightProbe, this.enabled && !this.destroyed && this._lightProbeObj && (zh && console.log("Add", this.sourceId, e), this.gameObject.add(this._lightProbeObj))) }); this.sourceId && this.context.sceneLighting.internalEnableReflection(this.sourceId) } onDisable() { zh && console.warn("\u{1F4A1}\u26AB <<< Disable lighting:", this.sourceId, this), this._lightProbeObj && this._lightProbeObj.removeFromParent(), this._ambientLightObj && this._ambientLightObj.removeFromParent(), this._hemisphereLightObj && this._hemisphereLightObj.removeFromParent(), this.sourceId && this.context.sceneLighting.internalDisableReflection(this.sourceId) } } const cS = oe("debugstencil"); function oX(i, e) { return (i & 1 << e.layer) != 0 } const aX = Symbol("stencils"), zd = class { constructor(i, e) { u(this, "parser"), u(this, "source"), this.parser = i, this.source = e } static applyStencil(i) { if (!i) return; const e = i.sourceId; if (cS && console.log(e, zd.stencils), !e) return; const t = zd.stencils[e]; if (t) for (let s = t.length - 1; s >= 0; s--) { const r = t[s]; if (oX(r.layer, i)) { cS && console.log(r), setTimeout(() => { dr() && J0(i.gameObject) && (ao("Stencil not supported on instanced objects"), console.warn("Stencil not supported on instanced objects", i)) }, 500); for (let n = 0; n < i.sharedMaterials.length; n++) { let o = i.sharedMaterials[n]; o && (o = o.clone(), o[aX] = !0, o.stencilWrite = !0, o.stencilWriteMask = 255, o.stencilFuncMask = 255, o.stencilRef = r.value, o.stencilFunc = r.compareFunc, o.stencilZPass = r.passOp, o.stencilFail = r.failOp, o.stencilZFail = r.zFailOp, i.sharedMaterials[n] = o) } i.gameObject.renderOrder = r.event * 1e3 + r.index * 50; break } } } afterRoot(i) { const e = this.parser.json.extensions; if (e) { const t = e[cX]; if (t) { cS && console.log(t); const s = t.stencil; if (s && Array.isArray(s)) for (const r of s) { const n = { ...r }; n.compareFunc = lX(n.compareFunc), n.passOp = uS(n.passOp), n.failOp = uS(n.failOp), n.zFailOp = uS(n.zFailOp), zd.stencils[this.source] || (zd.stencils[this.source] = []), zd.stencils[this.source].push(n) } } } return null } }; let hS = zd; u(hS, "stencils", {}); function uS(i) { switch (i) { case 0: return Af; case 1: return ET; case 2: return MT; case 3: return IT; case 4: return TT; case 6: return RT; case 7: return PT; case 5: return BT }return 0 } function lX(i) { switch (i) { case 1: return kT; case 2: return DT; case 3: return OT; case 4: return LT; case 5: return FT; case 6: return UT; case 7: return NT; case 8: return Bx }return 0 } const cX = "NEEDLE_render_objects", Sy = "NEEDLE_progressive", Is = oe("debugprogressive"), dS = Symbol("needle-progressive-texture"), pS = new Map; let fS = !1; Is && window.addEventListener("keyup", i => { i.key === "p" && (pS.forEach((e, t) => { Object.entries(e).forEach(([s, r]) => { fS ? t[s] = r.lod0 : t[s] = r.original, t.needsUpdate = !0 }) }), fS = !fS) }); const Ey = class {
  constructor(i, e, t) { u(this, "parser"), u(this, "sourceId"), u(this, "context"), this.parser = i, this.sourceId = e, this.context = t } static assignTextureLOD(i, e, t, s = 0) {
    if (t) for (let r of Object.keys(t)) {
      const n = t[r]; n?.isTexture === !0 && (Is && console.log(`-----------
`, "FIND", t.name, r, n?.name, n?.userData, n, t), Ey.getOrLoadTexture(i, e, t, r, n, s).then(o => {
        if (o?.isTexture === !0 && (Is && console.log("Assign LOD", t.name, r, o.name, o.guid, t, "Prev:", n, "Now:", o, `
--------------`), t[r] = o, o.needsUpdate = !0, t.needsUpdate = !0, Is)) { let a = pS.get(t); a || (a = {}, pS.set(t, a)); let l = a[r]; l || (l = a[r] = { original: n, lod0: o }), l.lod0 = o }
      }))
    }
  } get name() { return Sy } afterRoot(i) { var e; return Is && console.log("AFTER", this.sourceId, i), (e = this.parser.json.textures) == null || e.forEach((t, s) => { if (t != null && t.extensions) { const r = t?.extensions[Sy]; r && this.parser.getDependency("texture", s).then(n => { Is && console.log("> Progressive: register", n.name, n.uuid, r), n.source && (n.source[dS] = r), Ey.cache.set(n.uuid, r) }) } }), null } static async getOrLoadTexture(i, e, t, s, r, n) { const o = r.uuid; let a; if (r.source && r.source[dS] && (a = r.source[dS]), a || (a = Ey.cache.get(o)), a) { Is && console.log(o, a.uri, a.guid); const l = Pl(e, a.uri); if (l.endsWith(".glb") || l.endsWith(".gltf")) { if (!a.guid) return console.warn("missing pointer for glb/gltf texture", a), null; const c = l + "_" + a.guid; if (this.resolved[c]) { let d = this.resolved[c]; if (d.image && d.image.data) return Is && console.log("Texture has already been loaded: " + c, t.name, s, r.name, d), d = this.copySettings(r, d), d; d && Is && console.log("Texture has been disposed, will load again: " + c, t.name, s, r.name, d) } const h = this.onProgressiveLoadStart(i, e, l, t, s); try { if (this.currentlyLoading[c] !== void 0) { Is && console.log("Already loading:", t.name + "." + s, c); let f = await this.currentlyLoading[c]; return f && (f = this.copySettings(r, f)), f } const d = a, p = new Promise(async (f, g) => { const m = new Sd; wg(m, i), Is && console.log("Load " + l, t.name, s, d.guid), Is && await nf(Math.random() * 1e3); const v = await m.loadAsync(l), A = v.parser; Is && console.log("Loading finished " + l, t.name, s, d.guid); let b = -1, y = !1; for (const w of v.parser.json.textures) if (b++, w != null && w.extensions) { const E = w?.extensions[Sy]; if (E != null && E.guid && E.guid === d.guid) { y = !0; break } } if (!y) return f(null); let _ = await A.getDependency("texture", b); _ = this.copySettings(r, _), _ && (_.guid = d.guid), this.resolved[c] = _, Is && console.log(t.name, s, 'change "' + r.name + '" \u2192 "' + _.name + '"', l, b, _, t, c), f(_) }); return this.currentlyLoading[c] = p, await p } finally { delete this.currentlyLoading[c], this.onProgressiveLoadEnd(h) } } else { const c = this.onProgressiveLoadStart(i, e, l, t, s); try { Is && console.log("Load texture from uri: " + l); const h = await new Yl().loadAsync(l); return h ? (h.guid = a.guid, h.flipY = !1, h.needsUpdate = !0, h.encoding = r.encoding, Is && console.log(a, h)) : Is && console.warn("failed loading", l), h } finally { this.onProgressiveLoadEnd(c) } } } else Is && console.warn("unknown texture", r.name, r.uuid, r); return null } static copySettings(i, e) { const t = i.clone(), s = e.source, r = e.mipmaps; return t.copy(i), t.source = s, t.mipmaps = r, t } static beginListenStart(i, e) { this._progressiveEventListeners.has(i) || this._progressiveEventListeners.set(i, new KO), this._progressiveEventListeners.get(i).start.push(e) } static stopListenStart(i, e) { if (!this._progressiveEventListeners.has(i)) return; const t = this._progressiveEventListeners.get(i).start, s = t.indexOf(e); s >= 0 && t.splice(s, 1) } static beginListenEnd(i, e) { this._progressiveEventListeners.has(i) || this._progressiveEventListeners.set(i, new KO), this._progressiveEventListeners.get(i).end.push(e) } static stopListenEnd(i, e) { if (!this._progressiveEventListeners.has(i)) return; const t = this._progressiveEventListeners.get(i).end, s = t.indexOf(e); s >= 0 && t.splice(s, 1) } static onProgressiveLoadStart(i, e, t, s, r) { this._currentProgressiveLoadingInfo.has(i) || this._currentProgressiveLoadingInfo.set(i, []); const n = new JO(i, e, t, s, r), o = this._currentProgressiveLoadingInfo.get(i), a = this._progressiveEventListeners.get(i); return a && a.onStart(n), o.push(n), n } static onProgressiveLoadEnd(i) { if (!i) return; const e = i.context; if (!this._currentProgressiveLoadingInfo.has(e)) return; const t = this._currentProgressiveLoadingInfo.get(e), s = t.indexOf(i); if (s < 0) return; t.splice(s, 1); const r = this._progressiveEventListeners.get(e); r && r.onEnd(i) }
}; let il = Ey; u(il, "cache", new Map), u(il, "resolved", {}), u(il, "currentlyLoading", {}), u(il, "_progressiveEventListeners", new Map), u(il, "_currentProgressiveLoadingInfo", new Map); class JO { constructor(e, t, s, r, n) { u(this, "context"), u(this, "source"), u(this, "uri"), u(this, "material"), u(this, "slot"), this.context = e, this.source = t, this.uri = s, this.material = r, this.slot = n } } class KO { constructor() { u(this, "start", []), u(this, "end", []) } onStart(e) { for (const t of this.start) t(e) } onEnd(e) { for (const t of this.end) t(e) } } const Og = new Array; function hX(i) { Og.includes(i) || Og.push(i) } function uX(i) { const e = Og.indexOf(i); e >= 0 && Og.splice(e, 1) } function gS(i) { const e = new aO; return i.register(t => (e.parser = t, e)), e } class dX { resolvePath(e) { return e.includes("/extensions/builtin_components/") ? e.replace("/extensions/builtin_components/", "/userData/components/") : e.includes("extensions/builtin_components/") ? e.replace("extensions/builtin_components/", "/userData/components/") : e } } function ZO(i, e, t) { const s = t.lastIndexOf("?"); s >= 0 && (t = t.substring(0, s)), i.register(n => new rX(n)), i.register(n => new o6(n)), i.register(n => new vq(n, e.lightmaps, t)), i.register(n => new nX(n, t, e)), i.register(n => new O7(n, t)), i.register(n => new hS(n, t)), i.register(n => new il(n, t, e)), i.register(n => new sX(n)), y2() && i.register(n => new m2(n)); for (const n of Og) i.register(o => new n(o)); const r = i.setAnimationPointerResolver; typeof r == "function" && r.bind(i)(new dX) } class Lg {
  constructor(e, t) { u(this, "lightmapIndex", -1), u(this, "lightmapScaleOffset", new st(1, 1, 0, 0)), u(this, "context"), u(this, "gameObject"), u(this, "lightmapTexture", null), u(this, "lightmapScaleOffsetUniform", { value: new st(1, 1, 0, 0) }), u(this, "lightmapUniform", { value: null }), u(this, "onBeforeRenderThreeComplete", (s, r, n, o, a, l) => { this.onBeforeRenderThree(a) }), this.gameObject = e, this.context = t } get lightmap() { return this.lightmapTexture } set lightmap(e) { e !== this.lightmapTexture && (this.lightmapTexture = e, this.applyLightmap()) } init(e, t, s, r = !1) { console.assert(this.gameObject !== void 0 && this.gameObject !== null, "Missing gameobject", this), this.lightmapIndex = e, !(this.lightmapIndex < 0) && (this.lightmapScaleOffset = t, this.lightmapTexture = s, r && this.setLightmapDebugMaterial(), this.applyLightmap()) } bindOnBeforeRender() { this.context.removeBeforeRenderListener(this.gameObject, this.onBeforeRenderThreeComplete), this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThreeComplete) } applyLightmap() { if (this.gameObject.type === "Object3D") return; if (this.gameObject.type === "Group") { console.warn("Lightmap on multimaterial object is not supported yet... please open a feature request on https://github.com/needle-tools/needle-engine-support if your project requires it"); return } console.assert(this.gameObject.type === "Mesh", "Lightmap only works on meshes", this); const e = this.gameObject; e.geometry.getAttribute("uv2") || e.geometry.setAttribute("uv2", e.geometry.getAttribute("uv")); const t = this.gameObject.material.clone(); if (this.gameObject.material = t, this.gameObject.material.onBeforeCompile = (s, r) => { s.uniforms.lightmap = this.lightmapUniform, s.uniforms.lightmapScaleOffset = this.lightmapScaleOffsetUniform }, this.lightmapIndex >= 0) { const s = this.lightmapTexture, r = this.gameObject.material; r && s && (r.uniforms || (r.uniforms = {}), r.lightMap = s, r.uniforms.lightmap = { value: s }) } } onBeforeRenderThree(e) { const t = e.uniforms; t && t.lightmap && (this.lightmapScaleOffsetUniform.value = this.lightmapScaleOffset, this.lightmapUniform.value = this.lightmapTexture, t.lightmap = this.lightmapUniform, t.lightmapScaleOffset = this.lightmapScaleOffsetUniform) } setLightmapDebugMaterial() {
    this.gameObject.material = new Vt({
      vertexShader: `
                attribute vec2 uv2;
                varying vec2 vUv2;
                void main()
                {
                    vUv2 = uv2;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
                `, fragmentShader: `
                uniform sampler2D lightmap;
                uniform float lightMapIntensity;
                uniform vec4 lightmapScaleOffset;
                varying vec2 vUv2;

                // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
                vec4 conv_sRGBToLinear( in vec4 value ) {
                    return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
                }

                void main() {
                    vec2 lUv = vUv2.xy * lightmapScaleOffset.xy + vec2(lightmapScaleOffset.z, (1. - (lightmapScaleOffset.y + lightmapScaleOffset.w)));
                    
                    vec4 lightMapTexel = texture2D( lightmap, lUv);
                    // The range of RGBM lightmaps goes from 0 to 34.49 (5^2.2) in linear space, and from 0 to 5 in gamma space.
                    //lightMapTexel.rgb *= lightMapTexel.a * 8.; // no idea where that "8" comes from... heuristically derived
                    //lightMapTexel.a = 1.;
                    //lightMapTexel = conv_sRGBToLinear(lightMapTexel);
                    // lightMapTexel.rgb = vec3(1.);

                    // gl_FragColor = vec4(vUv2.xy, 0, 1);
                    gl_FragColor = lightMapTexel;
                }
                `, defines: { USE_LIGHTMAP: "" }
    })
  }
} class mi extends xe { constructor(e, t, s, r) { super(e, t, s), u(this, "alpha", 1), this.alpha = r } get isRGBAColor() { return !0 } set a(e) { this.alpha = e } get a() { return this.alpha } clone() { const e = super.clone(); return e.alpha = this.alpha, e } copy(e) { return super.copy(e), "alpha" in e && typeof e.alpha == "number" ? this.alpha = e.alpha : typeof e.a == "number" && (this.alpha = e.a), this } lerp(e, t) { const s = e; return s.alpha && (this.alpha = Ke.lerp(this.alpha, s.alpha, t)), super.lerp(e, t) } lerpColors(e, t, s) { const r = e, n = t; return r.alpha && n.alpha && (this.alpha = Ke.lerp(r.alpha, n.alpha, s)), super.lerpColors(e, t, s) } multiply(e) { const t = e; return t.alpha && (this.alpha = this.alpha * t.alpha), super.multiply(e) } fromArray(e, t = 0) { return this.alpha = e[t + 3], super.fromArray(e, t) } } class jh { constructor(e, t) { u(this, "method"), u(this, "enabled"), this.method = e, this.enabled = t !== void 0 ? t : !0 } invoke(...e) { if (this.enabled !== !1) { if (!this.method) { console.warn("No function. Please check you assigned a method to invoke on export", this); return } this.method(...e) } } } const pX = i => /^[A-Z]*$/.test(i); class My extends Event { constructor() { super(...arguments), u(this, "args") } } class Nr { constructor(e) { u(this, "target"), u(this, "key"), u(this, "_isInvoking", !1), u(this, "methods", []), this.methods = e ?? [] } setEventTarget(e, t) { if (this.key = e, this.target = t, this.key !== void 0) { let s = "", r = !1; for (let n of this.key) r && pX(n) && (s += "-"), r = !0, s += n.toLowerCase(); this.key = s } } invoke(...e) { if (this._isInvoking) { console.warn("Circular event invocation detected. Please check your event listeners for circular references.", this); return } this._isInvoking = !0; try { for (const t of this.methods) t.invoke(...e); if (typeof this.target == "object" && typeof this.key == "string") { const t = this.target.dispatchEvent; if (typeof t == "function") { const s = new My(this.key); s.args = e, t.call(this.target, s) } } } finally { this._isInvoking = !1 } } addEventListener(e) { return this.methods.push(new jh(e, !0)), e } removeEventListener(e) { if (e) for (let t = this.methods.length - 1; t >= 0; t--)this.methods[t].method === e && (this.methods[t].enabled = !1, this.methods.splice(t, 1)) } removeAllEventListeners() { this.methods.length = 0 } } const $O = Symbol("previous-visibility"), Fg = class extends ri { render(i, e, t) { if (t instanceof rC) this._unsupported_effectcomposer_warning || (console.warn("RenderTexture.render() does not yet support EffectComposer"), this._unsupported_effectcomposer_warning = !0); else { this.onBeforeRender(); const s = t.getRenderTarget(); t.setRenderTarget(this), t.render(i, e), t.setRenderTarget(s), this.onAfterRender() } } onBeforeRender() { Fg._userSet.clear(); const i = V1(this.texture, !0, null, Fg._userSet); for (const e of i) e instanceof ye && (e[$O] = e.visible, e.visible = !1) } onAfterRender() { for (const i of Fg._userSet) i instanceof ye && (i.visible = i[$O]); Fg._userSet.clear() } }; let jd = Fg; u(jd, "_userSet", new Set); class fX extends $l { constructor() { super([xe, mi]) } onDeserialize(e) { if (e != null) return e.a !== void 0 ? new mi(e.r, e.g, e.b, e.a) : e.alpha !== void 0 ? new mi(e.r, e.g, e.b, e.alpha) : new xe(e.r, e.g, e.b) } onSerialize(e) { if (e != null) return e.a !== void 0 ? { r: e.r, g: e.g, b: e.b, a: e.a } : { r: e.r, g: e.g, b: e.b } } } const gX = new fX; class mX extends $l { constructor() { super(Me) } onSerialize(e, t) { if (t.objectToNode !== void 0 && e.uuid) { const s = t.objectToNode[e.uuid]; return ir && console.log(s, e.name, e.uuid), { node: s } } } onDeserialize(e, t) { var s; if (typeof e != "string" && e) { if (e.node !== void 0 && t.nodeToObject) { const r = t.nodeToObject[e.node]; return ir && console.log("Deserialized object reference?", e, r, t?.nodeToObject), r || console.warn("Did not find node: " + e.node, t.nodeToObject, t.object), r } else if (e.guid) { if (!t.context) { console.error("Missing context"); return } let r, n = (s = t.gltf) == null ? void 0 : s.scene; return n && (r = $.findByGuid(e.guid, n)), r || (r = $.findByGuid(e.guid, t.context.scene)), r ? ir && console.log("Deserialized object reference?", e, r, t?.nodeToObject) : ((Mn() || ir) && console.warn("Could not resolve object reference", t.path, e, t.target, t.context.scene), e.could_not_resolve = !0), r } } } } const eL = new mX; class vX extends $l { constructor() { super([ac, Ee]) } onSerialize(e, t) { if (e != null && e.guid) return { guid: e.guid } } onDeserialize(e, t) { var s; if (e != null && e.guid) { ir && console.log(e.guid, t.root, t.object, t.target); let r = this.findObjectForGuid(e.guid, t.root); if (r || t.context && (r = this.findObjectForGuid(e.guid, (s = t.context) == null ? void 0 : s.scene), r)) return r; (Mn() || ir) && console.warn("Could not resolve component reference", t.path, e, t.target), e.could_not_resolve = !0; return } } findObjectForGuid(e, t) { if (t.guid === e) return t; const s = $.foreachComponent(t, r => { if (r.guid === e) return r }, !1); if (s !== void 0) return s; for (let r = 0; r < t.children.length; r++) { const n = t.children[r], o = this.findObjectForGuid(e, n); if (o) return o } } } const Iy = new vX, AX = Symbol("eventListDebugInfo"); class yX extends $l { constructor() { super([Nr]) } onSerialize(e, t) { console.log("TODO: SERIALIZE EVENT") } onDeserialize(e, t) { var s, r, n, o; if (typeof e == "function") return new Nr([new jh(e, !0)]); if (e && e.type === "EventList") { ir && console.log("DESERIALIZE EVENT", e); const a = new Array; if (e.calls && Array.isArray(e.calls)) for (const h of e.calls) { ir && console.log(h); let d = Iy.findObjectForGuid(h.target, t.root); !d && (s = t.context) != null && s.scene && (d = Iy.findObjectForGuid(h.target, (r = t.context) == null ? void 0 : r.scene)); const p = ((n = h.method) == null ? void 0 : n.length) > 0; if (d && p) { const v = () => { const A = h.method[0].toLowerCase() + h.method.slice(1); if (typeof d[A] == "function") { console.warn(`Could not find method ${h.method} on object ${d.name}. Please rename ${h.method} to ${A}?`, d, typeof d[h.method]); return } else console.warn(`Could not find method ${h.method} on object ${d.name}`, d, typeof d[h.method]) }; if (typeof d[h.method] != "function") { let A = !1, b = d; for (; b;) { const y = Object.getOwnPropertyDescriptor(b, h.method); if (y && (y.writable === !0 || y.set)) { A = !0; break } b = Object.getPrototypeOf(b) } !A && (Mn() || ir) && v() } } let f, g = h.argument; const m = p ? this.createEventMethod(d, h.method, g) : void 0; if (h.argument !== void 0 ? (typeof g == "object" && (g = eL.onDeserialize(h.argument, t), g || (g = Iy.onDeserialize(h.argument, t))), f = new jh(m, h.enabled)) : f = new jh(m, h.enabled), f.method || (f[AX] = (o = t.object) == null ? void 0 : o.name), !d || !f.method) { const v = t.object ? "Current object: " + t.object.name + ", " + t.object.guid : null; d ? console.warn('EventList method not found: "' + h.method + '" on', d) : console.warn("EventList is missing target - will be ignored", h.target, v, e) } else a.push(f) } const l = new Nr(a); ir && console.log(l); const c = t.target; return c !== void 0 && t.path !== void 0 && l.setEventTarget(t.path, c), l } } createEventMethod(e, t, s) { return (...r) => { const n = e[t]; typeof n == "function" ? s !== void 0 ? n?.call(e, s) : n?.call(e, ...r) : e[t] = s } } } const bX = new yX; class tL extends $l { constructor() { super([jd, ri]) } onSerialize(e, t) { } onDeserialize(e, t) { if (e instanceof Nt && t.type === jd) { const s = e, r = new jd(s.image.width, s.image.height); return r.texture = s, r } } } new tL; class iL extends $l { constructor() { super([URL]) } onSerialize(e, t) { return null } onDeserialize(e, t) { if (typeof e == "string" && e.length > 0) return Pl(t.gltfId, e) } } new iL; const _r = new S, sL = new S, rL = new we, yc = 8947848; class Wo { static DrawRay(e, t, s = yc, r = 0, n = !0) { const o = xr.getLine(r), a = o.geometry.getAttribute("position"); a.setXYZ(0, e.x, e.y, e.z), _r.set(t.x, t.y, t.z).multiplyScalar(999999999), a.setXYZ(1, e.x + _r.x, e.y + _r.y, e.z + _r.z), a.needsUpdate = !0, o.material.color.set(s), o.material.depthTest = n, o.material.depthWrite = !1 } static DrawDirection(e, t, s = yc, r = 0, n = !0, o = 1) { const a = xr.getLine(r), l = a.geometry.getAttribute("position"); l.setXYZ(0, e.x, e.y, e.z), t.w !== void 0 ? (_r.set(0, 0, -o), rL.set(t.x, t.y, t.z, t.w), _r.applyQuaternion(rL)) : (_r.set(t.x, t.y, t.z), _r.multiplyScalar(o)), l.setXYZ(1, e.x + _r.x, e.y + _r.y, e.z + _r.z), l.needsUpdate = !0, a.material.color.set(s), a.material.depthTest = n, a.material.depthWrite = !1 } static DrawLine(e, t, s = yc, r = 0, n = !0) { const o = xr.getLine(r), a = o.geometry.getAttribute("position"); a.setXYZ(0, e.x, e.y, e.z), a.setXYZ(1, t.x, t.y, t.z), a.needsUpdate = !0, o.material.color.set(s), o.material.depthTest = n, o.material.depthWrite = !1 } static DrawWireSphere(e, t, s = yc, r = 0, n = !0) { const o = xr.getSphere(t, r, !0); dd(o, e.x, e.y, e.z), o.material.color.set(s), o.material.depthTest = n, o.material.depthWrite = !1 } static DrawSphere(e, t, s = yc, r = 0, n = !0) { const o = xr.getSphere(t, r, !1); dd(o, e.x, e.y, e.z), o.material.color.set(s), o.material.depthTest = n, o.material.depthWrite = !1 } static DrawBox(e, t, s = yc, r = 0, n = !0) { const o = xr.getBox(r); o.position.set(e.x, e.y, e.z), o.scale.set(t.x, t.y, t.z), o.material.color.set(s), o.material.depthTest = n, o.material.wireframe = !0, o.material.depthWrite = !1 } static DrawBox3(e, t = yc, s = 0, r = !0) { const n = xr.getBox(s); n.position.copy(e.getCenter(_r)), n.scale.copy(e.getSize(_r)), n.material.color.set(t), n.material.depthTest = r, n.material.wireframe = !0, n.material.depthWrite = !1 } static DrawArrow(e, t, s = yc, r = 0, n = !0, o = !1) { const a = xr.getArrowHead(r); a.position.set(t.x, t.y, t.z), a.quaternion.setFromUnitVectors(this._up.set(0, 1, 0), _r.set(t.x, t.y, t.z).sub(sL.set(e.x, e.y, e.z)).normalize()); const l = _r.set(t.x, t.y, t.z).sub(sL.set(e.x, e.y, e.z)).length() * .1; a.scale.set(l, l, l), a.material.color.set(s), a.material.depthTest = n, a.material.wireframe = o, this.DrawLine(e, t, s, r, n) } } u(Wo, "_up", new S(0, 1, 0)); const _X = new pi(1, 1, 1); function nL(i = null) { const e = new xe(i ?? 14540253), t = new Ow(_X); return new sn(t, new Hi({ color: e })) } const oL = Symbol("GizmoCache"); class xr { static getBox(e) { let t = this.boxesCache.pop(); if (!t) { const s = new pi(1, 1, 1); t = new ye(s) } return this.registerTimedObject(_t.Current, t, e, this.boxesCache), t } static getLine(e) { let t = this.linesCache.pop(); if (!t) { t = new Vi; let s = t.geometry.getAttribute("position"); s || (s = new nt(new Float32Array(2 * 3), 3), t.geometry.setAttribute("position", s)) } return this.registerTimedObject(_t.Current, t, e, this.linesCache), t } static getSphere(e, t, s) { let r = this.spheresCache.pop(); return r || (r = new ye(new Zn(1, 8, 8))), r.scale.set(e, e, e), r.material.wireframe = s, this.registerTimedObject(_t.Current, r, t, this.spheresCache), r } static getArrowHead(e) { let t = this.arrowHeadsCache.pop(); return t || (t = new ye(new ji(0, .5, 1, 8))), this.registerTimedObject(_t.Current, t, e, this.arrowHeadsCache), t } static registerTimedObject(e, t, s, r) { if (!this.contextPostRenderCallbacks.get(e)) { const n = () => { this.onPostRender(e, this.timedObjectsBuffer, this.timesBuffer) }; this.contextPostRenderCallbacks.set(e, n), e.post_render_callbacks.push(n) } t.layers.disableAll(), t.layers.enable(2), t[oL] = r, this.timedObjectsBuffer.push(t), this.timesBuffer.push(_t.Current.time.time + s), e.scene.add(t) } static onPostRender(e, t, s) { const r = e.time.time; for (let n = 0; n < t.length; n++)if (r > s[n]) { const o = t[n]; o[oL].push(o), e.scene.remove(o), t.splice(n, 1), s.splice(n, 1) } } } u(xr, "linesCache", []), u(xr, "spheresCache", []), u(xr, "boxesCache", []), u(xr, "arrowHeadsCache", []), u(xr, "timedObjectsBuffer", new Array), u(xr, "timesBuffer", new Array), u(xr, "contextPostRenderCallbacks", new Map); const xX = oe("gizmos"), wX = oe("debugboxhelper"), Ao = class extends Ee { constructor() { super(...arguments), u(this, "box", null), u(this, "_lastMatrixUpdateFrame", -1), u(this, "_helper", null), u(this, "_color", null) } isInBox(i, e) { var t; if (!i) return; if (this.box || (this.box = new er), i.type === "Mesh") Ao.testBox.setFromObject(i); else if (i.type === "Group") { if (Ao.testBox.makeEmpty(), i.children.length > 0) for (let r = 0; r < i.children.length; r++)i.children[r].type === "Mesh" && Ao.testBox.expandByObject(i) } else { const r = xt(i, Ao._position), n = Fs(i, Ao._size); e !== void 0 && n.multiplyScalar(e), Ao.testBox.setFromCenterAndSize(r, n) } this.updateBox(); const s = (t = this.box) == null ? void 0 : t.intersectsBox(Ao.testBox); return s && wX && Wo.DrawBox3(Ao.testBox, 16711680, 5), s } intersects(i) { return i ? this.updateBox(!1).intersectsBox(i) : !1 } updateBox(i = !1) { if (this.box || (this.box = new er), i || this.context.time.frameCount != this._lastMatrixUpdateFrame) { const e = this._lastMatrixUpdateFrame < 0; this._lastMatrixUpdateFrame = this.context.time.frameCount; const t = e, s = xt(this.gameObject, Ao._position, t), r = Fs(this.gameObject, Ao._size); this.box.setFromCenterAndSize(s, r) } return this.box } awake() { this._helper = null, this._color = null, this.box = null } showHelper(i = null, e = !1) { var t; if (!(!xX && !e)) { if (this._helper) { i && ((t = this._color) == null || t.set(i)), this.gameObject.add(this._helper); return } this._helper = nL(i), this.gameObject.add(this._helper) } } }; let qo = Ao; u(qo, "testBox", new er), u(qo, "_position", new S), u(qo, "_size", new S(.01, .01, .01)); var CX = Object.defineProperty, SX = Object.getOwnPropertyDescriptor, aL = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? SX(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && CX(e, t, r), r }; const Qh = oe("debugreflectionprobe"), lL = oe("noreflectionprobe"), EX = Symbol("reflectionProbeKey"), MX = Symbol("original material"); var Ty; const sl = (Ty = class extends Ee {
  constructor() { var i; super(), u(this, "_texture"), u(this, "center"), u(this, "size"), u(this, "_boxHelper"), sl._probes.has(this.context) || sl._probes.set(this.context, []), (i = sl._probes.get(this.context)) == null || i.push(this) } static get(i, e, t, s) { if (!i || i.isObject3D !== !0 || lL) return null; const r = sl._probes.get(e); if (r) { for (const n of r) if (n.__didAwake || n.__internalAwake(), n.enabled) { if (s) { if (n.gameObject === s) return n } else if (n.isInBox(i, void 0)) return Qh && console.log("Found reflection probe", i.name, n.name), n } } return Qh && console.debug("Did not find reflection probe", i.name, t, i), null } set texture(i) { if (i && !(i instanceof Nt)) { console.error("ReflectionProbe.texture must be a Texture", i); return } this._texture = i, i && (i.mapping = An, i.encoding = Xe, i.needsUpdate = !0) } get texture() { return this._texture } isInBox(i, e) { var t; return (t = this._boxHelper) == null ? void 0 : t.isInBox(i, e) } awake() { this._boxHelper = this.gameObject.addNewComponent(qo), this._boxHelper.updateBox(!0), Qh && this._boxHelper.showHelper(5592320, !0), this.texture && (this.texture.mapping = An, this.texture.encoding = Xe, this.texture.needsUpdate = !0) } onDestroy() { const i = sl._probes.get(this.context); if (i) { const e = i.indexOf(this); e >= 0 && i.splice(e, 1) } } onSet(i) {
    var e; if (lL || !this.enabled || ((e = i.sharedMaterials) == null ? void 0 : e.length) <= 0 || !this.texture) return; let t = sl._rendererMaterialsCache.get(i); t || (t = [], sl._rendererMaterialsCache.set(i, t)); for (let s = 0; s < i.sharedMaterials.length; s++) {
      const r = i.sharedMaterials[s]; if (!r || r.envMap === void 0) continue; let n = t[s], o = r === n?.copy, a = !n || n.material.uuid !== r.uuid || n.copy.version !== r.version; if (!o && a) {
        if (Qh) {
          let h = ""; n ? n.material !== r ? h = "reference changed; cached instance?: " + o : n.copy.version !== r.version && (h = "version changed") : h = "not cached", console.warn("Cloning material", r.name, r.version, "Reason:", h, `
`, r.uuid, `
`, n?.copy.uuid, `
`, i.name)
        } const c = r.clone(); c.version = r.version, n ? (n.copy = c, n.material = r) : (n = { material: r, copy: c }, t.push(n)), c[EX] = this, c[MX] = r, Qh && console.log("Set reflection", i.name, i.guid)
      } const l = n?.copy; l.envMap = this.texture, i.sharedMaterials[s] = l
    }
  } onUnset(i) { const e = sl._rendererMaterialsCache.get(i); if (e) for (let t = 0; t < e.length; t++) { const s = e[t]; i.sharedMaterials[t] = s.material } }
}, u(Ty, "_probes", new Map), u(Ty, "_rendererMaterialsCache", new Map), Ty); let Qd = sl; aL([x(S)], Qd.prototype, "center", 2), aL([x(S)], Qd.prototype, "size", 2); const cL = Symbol("customVisibilityFlag"); function mS(i, e) { i.layers[cL] = e } const hL = Symbol("DidPatchLayers"); function IX() { const i = bn.prototype; if (i[hL]) return; i[hL] = !0; const e = i.test; i.test = function (t) { return this[cL] === !1 ? !1 : e.call(this, t) } } IX(); var TX = Object.defineProperty, RX = Object.getOwnPropertyDescriptor, rl = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? RX(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && TX(e, t, r), r }; const uL = oe("debugrenderer"), dL = oe("noInstancing"), pL = !!oe("debuglightmaps"), fL = oe("debuginstancing"), PX = oe("debugprogressive"), BX = oe("noprogressive"), kX = oe("wireframe"); class vS { constructor() { u(this, "path", null), u(this, "asset", null), u(this, "default") } } class DX { constructor(e, t) { u(this, "_renderer"), u(this, "_targets", []), u(this, "_indexMapMaxIndex"), u(this, "_indexMap"), u(this, "_changed", !1), this._renderer = e; const s = this.setMaterial.bind(this), r = this.getMaterial.bind(this), n = e.gameObject; if (this._targets = [], n) switch (n.type) { case "Group": this._targets = [...n.children]; break; case "SkinnedMesh": case "Mesh": this._targets.push(n); break }let o = !1, a, l = 0; for (let c = 0; c < this._targets.length; c++) { const h = this._targets[c]; if (!h) continue; const d = h.material; if (d) { d.shadowSide = d.side; for (let p = 0; p < t.length; p++) { const f = t[p]; if (!f) { o = !0; continue } if (d.name === f.name) { a === void 0 && (a = new Map), a.set(p, c), l = Math.max(l, p); break } } } } if (o) { this._indexMapMaxIndex = l, this._indexMap = a; const c = `Renderer ${e.name} was initialized with missing materials - this may lead to unexpected behaviour when trying to access sharedMaterials by index.`; console.warn(c), dr() && ao("Found renderer with missing materials: please check the console for details.") } return new Proxy(this, { get(c, h) { if (typeof h == "string") { const d = parseInt(h); if (!isNaN(d)) return r(d) } return c[h] }, set(c, h, d) { return typeof h == "string" && s(d, Number.parseInt(h)), Reflect.set(c, h, d) ? (d instanceof Tt && (c.changed = !0), !0) : !1 } }) } get changed() { return this._changed } set changed(e) { e === !0 && uL && console.warn("SharedMaterials have changed: " + this._renderer.name, this), this._changed = e } is(e) { return this._renderer === e } get length() { return this._indexMapMaxIndex !== void 0 ? this._indexMapMaxIndex + 1 : this._targets.length } *[Symbol.iterator]() { for (let e = 0; e < this.length; e++)yield this.getMaterial(e) } resolveIndex(e) { const t = this._indexMap; return t && t.has(e) ? t.get(e) : e } setMaterial(e, t) { if (t = this.resolveIndex(t), t < 0 || t >= this._targets.length) return; const s = this._targets[t]; !s || s.material === void 0 || (s.material = e, this.changed = !0) } getMaterial(e) { if (e = this.resolveIndex(e), e < 0) return null; const t = this._targets; if (e >= t.length) return null; const s = t[e]; return s ? s.material : null } } const gL = class extends Ee { constructor() { super(...arguments), u(this, "receiveShadows", !1), u(this, "shadowCastingMode", 0), u(this, "lightmapIndex", -1), u(this, "lightmapScaleOffset", new st(1, 1, 0, 0)), u(this, "enableInstancing"), u(this, "renderOrder"), u(this, "allowOcclusionWhenDynamic", !0), u(this, "probeAnchor"), u(this, "reflectionProbeUsage", 0), u(this, "_lightmaps"), u(this, "_sharedMaterials"), u(this, "_originalMaterials"), u(this, "_lightmapTextureOverride"), u(this, "allowProgressiveLoading", !0), u(this, "_isInstancingEnabled", !1), u(this, "handles"), u(this, "prevLayers"), u(this, "_reflectionProbe", null) } static setVisible(i, e) { mS(i, e) } get sharedMesh() { if (this.gameObject.type === "Mesh") return this.gameObject; if (this.gameObject.type === "SkinnesMesh") return this.gameObject; if (this.gameObject.type === "Group") return this.gameObject.children[0] } get sharedMaterial() { return this.sharedMaterials[0] } set sharedMaterial(i) { this.sharedMaterials[0] !== i && (this.sharedMaterials[0] = i, this.applyLightmapping()) } get material() { return this.sharedMaterials[0] } set material(i) { this.sharedMaterial = i } set sharedMaterials(i) { if (!this._originalMaterials) this._originalMaterials = i; else if (i) { let e = !1; for (let t = 0; t < this._sharedMaterials.length; t++) { const s = t < i.length ? i[t] : null; s && s instanceof Tt ? this.sharedMaterials[t] = s : e || (e = !0, console.warn("Can not assign null as material: " + this.name, s)) } } } get sharedMaterials() { return (!this._sharedMaterials || !this._sharedMaterials.is(this)) && (this._originalMaterials || (this._originalMaterials = []), this._sharedMaterials = new DX(this, this._originalMaterials)), this._sharedMaterials } static get shouldSuppressInstancing() { return dL } get lightmap() { var i; return (i = this._lightmaps) != null && i.length ? this._lightmaps[0].lightmap : null } set lightmap(i) { var e; if (this._lightmapTextureOverride = i, i === void 0 && (i = this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex)), (e = this._lightmaps) != null && e.length) for (const t of this._lightmaps) t.lightmap = i } get hasLightmap() { return this.lightmap != null } registering() { this.enabled || this.setVisibility(!1) } awake() { if (uL && console.log("Renderer ", this.name, this), this.clearInstancingState(), this.probeAnchor && Qh && this.probeAnchor.add(new ud(.2)), this._reflectionProbe = null, this.isMultiMaterialObject(this.gameObject)) { for (const i of this.gameObject.children) this.context.addBeforeRenderListener(i, this.onBeforeRenderThree.bind(this)), i.layers.mask = this.gameObject.layers.mask; if (this.renderOrder !== void 0) { let i = 0; for (let e = 0; e < this.gameObject.children.length; e++) { const t = this.gameObject.children[e]; if (!(t.type !== "Mesh" || $.getComponent(t, gL))) { if (this.renderOrder.length <= i) { console.error("Incorrect element count", this); break } t.renderOrder = this.renderOrder[i], i += 1 } } } } else this.isMeshOrSkinnedMesh(this.gameObject) ? (this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree.bind(this)), this.renderOrder !== void 0 && this.renderOrder.length > 0 && (this.gameObject.renderOrder = this.renderOrder[0])) : this.context.addBeforeRenderListener(this.gameObject, this.onBeforeRenderThree.bind(this)); if (this.applyLightmapping(), kX) for (let i = 0; i < this.sharedMaterials.length; i++) { const e = this.sharedMaterials[i]; e && (e.wireframe = !0) } } applyLightmapping() { var i; if (this.lightmapIndex >= 0) { const e = this.gameObject.type, t = this._lightmapTextureOverride !== void 0 ? this._lightmapTextureOverride : this.context.lightmaps.tryGetLightmap(this.sourceId, this.lightmapIndex); if (t) { if (this._lightmaps || (this._lightmaps = []), e === "Mesh") { const s = this.gameObject.material; if (s != null && s.isMeshBasicMaterial) s && console.warn("Lightmapping is not supported on MeshBasicMaterial", s.name); else { if (this._lightmaps.length <= 0) { const r = new Lg(this.gameObject, this.context); this._lightmaps.push(r) } this._lightmaps[0].init(this.lightmapIndex, this.lightmapScaleOffset, t, pL) } } else if (this.isMultiMaterialObject(this.gameObject) && this.sharedMaterials.length > 0) for (let s = 0; s < this.gameObject.children.length; s++) { const r = this.gameObject.children[s]; if (!((i = r.material) != null && i.isMeshBasicMaterial)) { let n; s >= this._lightmaps.length ? (n = new Lg(r, this.context), this._lightmaps.push(n)) : n = this._lightmaps[s], n.init(this.lightmapIndex, this.lightmapScaleOffset, t, pL), n.bindOnBeforeRender() } } } else Qh && console.warn("Lightmap not found", this.sourceId, this.lightmapIndex) } } clearInstancingState() { this._isInstancingEnabled = !1, this.handles = void 0, this.prevLayers = void 0 } setInstancingEnabled(i) { if (this._isInstancingEnabled === i) return i && (this.handles === void 0 || this.handles != null && this.handles.length > 0); if (this._isInstancingEnabled = i, i) { if (this.handles === void 0) { if (this.handles = LX.setup(this, this.gameObject, this.context, null, { rend: this, foundMeshes: 0, useMatrixWorldAutoUpdate: this.useInstanceMatrixWorldAutoUpdate() }), this.handles) return $.markAsInstancedRendered(this.gameObject, !0), !0 } else if (this.handles !== null) { for (const e of this.handles) e.updateInstanceMatrix(!0), e.add(); return $.markAsInstancedRendered(this.gameObject, !0), !0 } } else { if (this.handles) for (const e of this.handles) e.remove(); return !0 } return !1 } useInstanceMatrixWorldAutoUpdate() { return !0 } start() { if (this.enableInstancing && !dL && this.setInstancingEnabled(!0), this.gameObject.frustumCulled = this.allowOcclusionWhenDynamic, this.isMultiMaterialObject(this.gameObject)) for (let i = 0; i < this.gameObject.children.length; i++) { const e = this.gameObject.children[i]; e.frustumCulled = this.allowOcclusionWhenDynamic } } onEnable() { this.setVisibility(!0), this._isInstancingEnabled ? this.setInstancingEnabled(!0) : this.enabled && this.applyStencil(), this.updateReflectionProbe() } onDisable() { this.setVisibility(!1), this.handles && this.handles.length > 0 && this.setInstancingEnabled(!1) } onDestroy() { this.handles = null } applyStencil() { hS.applyStencil(this) } onBeforeRender() { var i, e; if (this.gameObject) { if (this.isMultiMaterialObject(this.gameObject) && ((i = this.gameObject.children) == null ? void 0 : i.length) > 0) for (const t of this.gameObject.children) this.applySettings(t); else this.applySettings(this.gameObject); if (this.sharedMaterials.changed && (this.sharedMaterials.changed = !1, this.applyLightmapping()), (e = this.handles) != null && e.length && this.gameObject[ag] === !0) { fL && console.log("UPDATE INSTANCED MATRICES", this.context.time.frame), this.gameObject[ag] = !1; for (let t = this.handles.length - 1; t >= 0; t--)this.handles[t].updateInstanceMatrix(); this.gameObject.matrixWorldNeedsUpdate = !1 } if (this.handles && this.handles.length <= 0 && $.markAsInstancedRendered(this.gameObject, !1), this._isInstancingEnabled && this.handles) for (let t = 0; t < this.handles.length; t++) { const s = this.handles[t]; this.prevLayers || (this.prevLayers = []); const r = s.object.layers.mask; t >= this.prevLayers.length ? this.prevLayers.push(r) : this.prevLayers[t] = r, s.object.layers.disableAll() } this.reflectionProbeUsage !== 0 && this._reflectionProbe && this._reflectionProbe.onSet(this) } } onBeforeRenderThree(i, e, t, s, r, n) { if (this.loadProgressiveTextures(r), r.envMapIntensity !== void 0) { const o = this.hasLightmap ? Math.PI : 1; r.envMapIntensity = Math.max(0, this.context.sceneLighting.environmentIntensity / o) } if (this._lightmaps) for (const o of this._lightmaps) o.onBeforeRenderThree(r) } onAfterRender() { if (this._isInstancingEnabled && this.handles && this.prevLayers && this.prevLayers.length >= this.handles.length) for (let i = 0; i < this.handles.length; i++) { const e = this.handles[i]; e.object.layers.mask = this.prevLayers[i] } this.reflectionProbeUsage !== 0 && this._reflectionProbe && this._reflectionProbe.onUnset(this) } loadProgressiveTextures(i) { !BX && i && i._didRequestTextureLOD === void 0 && this.allowProgressiveLoading && (i._didRequestTextureLOD = 0, PX && console.log("Load material LOD", i.name), il.assignTextureLOD(this.context, this.sourceId, i)) } applySettings(i) { i.receiveShadow = this.receiveShadows, this.shadowCastingMode == 1 ? i.castShadow = !0 : i.castShadow = !1 } updateReflectionProbe() { if (this._reflectionProbe = null, this.reflectionProbeUsage !== 0) { if (!this.probeAnchor) return; this.startCoroutine(this._updateReflectionProbe(), on.LateUpdate) } } *_updateReflectionProbe() { const i = this.probeAnchor || this.gameObject, e = !!this.probeAnchor; this._reflectionProbe = Qd.get(i, this.context, e, this.probeAnchor) } setVisibility(i) { if (!this.isMultiMaterialObject(this.gameObject)) mS(this.gameObject, i); else for (const e of this.gameObject.children) this.isMeshOrSkinnedMesh(e) && mS(e, i) } isMultiMaterialObject(i) { return i.type === "Group" } isMeshOrSkinnedMesh(i) { return i.type === "Mesh" || i.type === "SkinnedMesh" } }; let Ui = gL; rl([x()], Ui.prototype, "receiveShadows", 2), rl([x()], Ui.prototype, "shadowCastingMode", 2), rl([x()], Ui.prototype, "lightmapIndex", 2), rl([x(st)], Ui.prototype, "lightmapScaleOffset", 2), rl([x()], Ui.prototype, "enableInstancing", 2), rl([x()], Ui.prototype, "renderOrder", 2), rl([x()], Ui.prototype, "allowOcclusionWhenDynamic", 2), rl([x(Me)], Ui.prototype, "probeAnchor", 2), rl([x()], Ui.prototype, "reflectionProbeUsage", 2); class Ry extends Ui { } class AS extends Ry { awake() { super.awake(), this.allowOcclusionWhenDynamic = !1 } } class OX { constructor() { u(this, "objs", []) } setup(e, t, s, r, n, o = 0) { e.applySettings(t); const a = this.tryCreateOrAddInstance(t, s, n); if (a) e.loadProgressiveTextures(a.instancer.material), r === null && (r = []), r.push(a); else if (o <= 0 && t.type !== "Mesh") { const l = o + 1; for (const c of t.children) r = this.setup(e, c, s, r, n, l) } return o === 0 && n.useMatrixWorldAutoUpdate && r && r.length >= 0 && this.autoUpdateInstanceMatrix(t), r } tryCreateOrAddInstance(e, t, s) { if (e.type === "Mesh") { const r = s.foundMeshes; if (s.foundMeshes += 1, !s.rend.enableInstancing || r >= s.rend.enableInstancing.length || !s.rend.enableInstancing[r]) return null; const n = e, o = n.geometry, a = n.material; for (const c of this.objs) if (!c.isFull() && c.geo === o && c.material === a) return c.addInstance(n); const l = new vL(e.name, o, a, 200, t); return this.objs.push(l), l.addInstance(n) } return null } autoUpdateInstanceMatrix(e) { const t = e.matrixWorld.multiplyMatrices.bind(e.matrixWorld); let s = e.matrixWorld.clone(); const r = (n, o) => { const a = t(n, o); return (e[ag] || s.equals(a) === !1) && (s.copy(a), e[ag] = !0), a }; e.matrixWorld.multiplyMatrices = r } } const LX = new OX; class FX { constructor(e, t, s) { u(this, "instanceIndex", -1), u(this, "object"), u(this, "instancer"), this.instanceIndex = e, this.object = t, this.instancer = s, $.markAsInstancedRendered(t, !0) } get name() { return this.object.name } updateInstanceMatrix(e = !1) { this.instanceIndex < 0 || (this.object.updateWorldMatrix(!0, e), this.instancer.updateInstance(this.object.matrixWorld, this.instanceIndex)) } setMatrix(e) { this.instanceIndex < 0 || this.instancer.updateInstance(e, this.instanceIndex) } add() { this.instanceIndex >= 0 || this.instancer.add(this) } remove() { this.instanceIndex < 0 || this.instancer.remove(this) } } const mL = class { constructor(i, e, t, s, r) { u(this, "name", ""), u(this, "geo"), u(this, "material"), u(this, "context"), u(this, "inst"), u(this, "handles", []), u(this, "maxCount"), this.name = i, this.geo = e, this.material = t, this.context = r, this.maxCount = s, fL && (t = new di({ color: this.randomColor() })), this.inst = new DA(e, t, s), this.inst.count = 0, this.inst.layers.set(2), this.inst.visible = !0, this.context.scene.add(this.inst) } set castShadow(i) { this.inst.castShadow = i } set receiveShadow(i) { this.inst.receiveShadow = i } get currentCount() { return this.inst.count } isFull() { return this.currentCount >= this.maxCount } randomColor() { return new xe(Math.random(), Math.random(), Math.random()) } addInstance(i) { if (this.currentCount >= this.maxCount) return console.error("TOO MANY INSTANCES - resize is not yet implemented!", this.inst.count), null; const e = new FX(-1, i, this); return i.castShadow === !0 && this.inst.castShadow === !1 && (this.inst.castShadow = !0), i.receiveShadow === !0 && this.inst.receiveShadow === !1 && (this.inst.receiveShadow = !0), this.add(e), e } add(i) { i.instanceIndex < 0 && (i.instanceIndex = this.currentCount, i.instanceIndex >= this.handles.length ? this.handles.push(i) : this.handles[i.instanceIndex] = i), i.object.updateWorldMatrix(!0, !0), this.inst.setMatrixAt(i.instanceIndex, i.object.matrixWorld), this.inst.instanceMatrix.needsUpdate = !0, this.inst.count += 1, this.inst.count > 0 && (this.inst.visible = !0) } remove(i) { if (!(!i || i.instanceIndex < 0 || i.instanceIndex >= this.handles.length || this.inst.count <= 0)) { if (this.handles[i.instanceIndex] !== i) { console.error("instance handle is not part of renderer, was it removed before?", i.instanceIndex, this.name); const e = this.handles.indexOf(i); if (e < 0) return; i.instanceIndex = e } if (this.handles[i.instanceIndex] = null, this.inst.setMatrixAt(i.instanceIndex, mL.nullMatrix), !(i.instanceIndex >= this.currentCount - 1) && this.currentCount > 0) { const e = this.handles[this.currentCount - 1]; e && (e.instanceIndex = i.instanceIndex, e.updateInstanceMatrix(), this.handles[i.instanceIndex] = e, this.handles[this.currentCount - 1] = null) } this.inst.count > 0 && (this.inst.count -= 1), i.instanceIndex = -1, this.inst.count <= 0 && (this.inst.visible = !1), this.inst.instanceMatrix.needsUpdate = !0 } } updateInstance(i, e) { this.inst.setMatrixAt(e, i), this.inst.instanceMatrix.needsUpdate = !0 } }; let vL = mL; u(vL, "nullMatrix", new He); function yS(i) { return i = i.replace(/[^a-zA-Z0-9_]/g, ""), i.match(/^[a-zA-Z_]/) || (i = "_" + i), i } const Py = class { constructor(i, e, t, s = null, r = null, n = null) { u(this, "uuid"), u(this, "name"), u(this, "matrix"), u(this, "_isDynamic"), u(this, "geometry"), u(this, "material"), u(this, "camera"), u(this, "parent"), u(this, "children", []), u(this, "_eventListeners"), this.uuid = i, this.name = yS(e), this.matrix = t, this.geometry = s, this.material = r, this.camera = n, this.parent = null, this.children = [], this._eventListeners = {}, this._isDynamic = !1 } get isDynamic() { return this._isDynamic } set isDynamic(i) { this._isDynamic = i } static createEmptyParent(i) { const e = new Py(kr.generateUUID(), i.name + "_empty_" + Py.USDObject_export_id++, i.matrix); return i.parent.add(e), e.add(i), e.isDynamic = !0, i.matrix = new He().identity(), e } is(i) { return i ? this.uuid === i.uuid : !1 } isEmpty() { return !this.geometry } clone() { const i = new Py(kr.generateUUID(), this.name, this.matrix, this.geometry, this.material); return i.isDynamic = this.isDynamic, i } getPath() { let i = this.parent, e = this.name; for (; i;)e = i.name + "/" + e, i = i.parent; return "</" + e + ">" } add(i) { i.parent && i.parent.remove(i), i.parent = this, this.children.push(i) } remove(i) { const e = this.children.indexOf(i); e >= 0 && (i.parent === this && (i.parent = null), this.children.splice(e, 1)) } addEventListener(i, e) { this._eventListeners[i] || (this._eventListeners[i] = []), this._eventListeners[i].push(e) } removeEventListener(i, e) { if (!this._eventListeners[i]) return; const t = this._eventListeners[i].indexOf(e); t >= 0 && this._eventListeners[i].splice(t, 1) } onSerialize(i, e) { const t = this._eventListeners.serialize; t && t.forEach(s => s(i, e)) } }; let nl = Py; u(nl, "USDObject_export_id", 0); class AL extends nl {
  constructor() { super(void 0, "StageRoot", new He, null, null, null), u(this, "stageLength"), this.children = [], this.stageLength = 200 } get isDocumentRoot() { return !0 } get isDynamic() { return !1 } add(e) { e.parent = this, this.children.push(e) } remove(e) { const t = this.children.indexOf(e); t >= 0 && (e.parent === this && (e.parent = null), this.children.splice(t, 1)) } traverse(e, t = null) { if (t !== null ? e(t) : t = this, t.children) for (const s of t.children) this.traverse(e, s) } findById(e) { let t = !1; function s(r) { if (!t) { if (r.uuid === e) return t = !0, r; if (r.children) for (const n of r.children) { const o = s(n); if (o) return o } } } return s(this) } buildHeader() {
    return `#usda 1.0
(
	customLayerData = {
		string creator = "Three.js USDZExporter"
	}
	defaultPrim = "${yS(this.name)}"
	metersPerUnit = 1
	upAxis = "Y"
	startTimeCode = 0
	endTimeCode = ${this.stageLength}
	timeCodesPerSecond = 60
	framesPerSecond = 60
)
`}
} const Gd = `
`; class UX { constructor() { u(this, "str"), u(this, "indent"), this.str = "", this.indent = 0 } clear() { this.str = "", this.indent = 0 } beginBlock(e) { e = this.applyIndent(e), this.str += e, this.str += Gd, this.str += this.applyIndent("{"), this.str += Gd, this.indent += 1 } closeBlock() { this.indent -= 1, this.str += this.applyIndent("}") + Gd } beginArray(e) { e = this.applyIndent(e + " = ["), this.str += e, this.str += Gd, this.indent += 1 } closeArray() { this.indent -= 1, this.str += this.applyIndent("]") + Gd } appendLine(e = "") { e = this.applyIndent(e), this.str += e, this.str += Gd } toString() { return this.str } applyIndent(e) { let t = ""; for (let s = 0; s < this.indent; s++)t += "	"; return t + e } } class NX { constructor(e, t, s) { u(this, "root"), u(this, "exporter"), u(this, "extensions"), u(this, "materials"), u(this, "textures"), u(this, "files"), u(this, "document"), u(this, "output"), this.root = e, this.exporter = t, s && (this.extensions = s), this.materials = {}, this.textures = {}, this.files = {}, this.document = new AL, this.output = "" } } class yL { constructor() { u(this, "ar", { anchoring: { type: "plane" }, planeAnchoring: { alignment: "horizontal" } }), u(this, "quickLookCompatible", !1), u(this, "extensions", []) } } let zX = class {
  constructor() { u(this, "debug"), u(this, "sceneAnchoringOptions", {}), u(this, "extensions"), this.debug = !1 } async parse(i, e = new yL) {
    e = Object.assign(new yL, e), this.sceneAnchoringOptions = e; const t = new NX(i, this, e.extensions); this.extensions = t.extensions; const s = t.files, r = "model.usda"; s[r] = null; const n = t.materials, o = t.textures; By(t, "onBeforeBuildDocument"), bL(i, t.document, t), By(t, "onAfterBuildDocument"), jX(t), await By(t, "onAfterSerialize"), t.output += JX(n, o); const a = t.document.buildHeader() + `
`+ t.output; this.debug && console.log(a), s[r] = Vo(a), t.output = ""; for (const c in o) { let h = o[c]; const d = h.format === 1023; h.isCompressedTexture && (h = QX(h)); const p = await xL(h.image); if (p) { const f = await new Promise(g => p.toBlob(g, d ? "image/png" : "image/jpeg", 1)); s[`textures/Texture_${c}.${d ? "png" : "jpg"}`] = new Uint8Array(await f.arrayBuffer()) } else console.warn("Can`t export texture: ", h) } let l = 0; for (const c in s) { const h = s[c], d = 34 + c.length; l += d; const p = l & 63; if (p !== 4) { const f = 64 - p, g = new Uint8Array(f); s[c] = [h, { extra: { 12345: g } }] } l = h.length } return VO(s, { level: 0 })
  }
}; function bL(i, e, t) { if (!i.visible) return; let s, r, n; i instanceof ye && (r = i.geometry, n = i.material); const o = $.getComponent(i, Ui); if (o && !o.enabled && (r = void 0, n = void 0), i instanceof ye && n && (n instanceof od || n instanceof di) && !(i instanceof rd)) { const a = ky(i); s = new nl(i.uuid, a, i.matrix, r, n) } else if (i instanceof gh) { const a = ky(i); s = new nl(i.uuid, a, i.matrix, void 0, void 0, i) } else { const a = ky(i); s = new nl(i.uuid, a, i.matrix) } if (s) { if (e && e.add(s), e = s, t.extensions) for (const a of t.extensions) a.onExportObject && a.onExportObject.call(a, i, s, t) } else { const a = ky(i), l = new nl(i.uuid, a, i.matrix); e && e.add(l), e = l } for (const a of i.children) bL(a, e, t) } async function jX(i) {
  for (const t of i.document.children) _L(t, i); const e = new UX; e.beginBlock(`def Xform "${i.document.name}"`), e.beginBlock(`def Scope "Scenes" (
			kind = "sceneLibrary"
		)`), e.beginBlock(`def Xform "Scene" (
			apiSchemas = ["Preliminary_AnchoringAPI"]
			customData = {
				bool preliminary_collidesWithEnvironment = 0
				string sceneName = "Scene"
			}
			sceneName = "Scene"
		)`), e.appendLine(`token preliminary:anchoring:type = "${i.exporter.sceneAnchoringOptions.ar.anchoring.type}"`), i.exporter.sceneAnchoringOptions.ar.anchoring.type === "plane" && e.appendLine(`token preliminary:planeAnchoring:alignment = "${i.exporter.sceneAnchoringOptions.ar.planeAnchoring.alignment}"`), i.exporter.sceneAnchoringOptions.ar.anchoring.type === "image" && e.appendLine(`rel preliminary:imageAnchoring:referenceImage = </${i.document.name}/Scenes/Scene/AnchoringReferenceImage>`), e.appendLine(); for (const t of i.document.children) wL(t, e, i); By(i, "onAfterHierarchy", e), e.closeBlock(), e.closeBlock(), e.closeBlock(), i.output += e.toString()
} function _L(i, e) { const t = i.geometry; let s = i.material; if (t) if (s.isMeshStandardMaterial) { const r = "geometries/Geometry_" + t.id + ".usd"; if (!(r in e.files)) { const n = WX(t); e.files[r] = VX(n) } s.uuid in e.materials || (e.materials[s.uuid] = s) } else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", name); for (const r of i.children) _L(r, e) } async function By(i, e, t = null) { if (i.extensions) { for (const s of i.extensions) if (s && typeof s[e] == "function") { const r = s[e]; r.constructor.name === "AsyncFunction" ? await r.call(s, i, t) : r.call(s, i, t) } } } function QX(i) {
  const e = new ks(2, 2, 1, 1), t = new Vt({
    uniforms: { blitTexture: new Ce(i) }, defines: { IS_SRGB: i.encoding == Xe }, vertexShader: `
            varying vec2 vUv;
            void main(){
                vUv = uv;
				vUv.y = 1. - vUv.y;
                gl_Position = vec4(position.xy * 1.0,0.,.999999);
            }`, fragmentShader: `
            uniform sampler2D blitTexture; 
            varying vec2 vUv;

            // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
            vec4 conv_LinearTosRGB( in vec4 value ) {
                return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
            }

            void main(){ 
                gl_FragColor = vec4(vUv.xy, 0, 1);
                
                #ifdef IS_SRGB
                gl_FragColor = conv_LinearTosRGB( texture2D( blitTexture, vUv) );
                #else
                gl_FragColor = texture2D( blitTexture, vUv);
                #endif
            }`}), s = new ye(e, t); s.frustumCulled = !1; const r = new Xt, n = new Cn; n.add(s); const o = new $u({ antialias: !1 }); o.setSize(i.image.width, i.image.height), o.clear(), o.render(n, r); const a = new Nt(o.domElement); return a.encoding = i.encoding, a
} function GX(i) { return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas || typeof ImageBitmap < "u" && i instanceof ImageBitmap } async function xL(i, e = void 0, t = !1) { if (GX(i)) { const s = 1024 / Math.max(i.width, i.height), r = document.createElement("canvas"); r.width = i.width * Math.min(1, s), r.height = i.height * Math.min(1, s); const n = r.getContext("2d"); if (!n) throw new Error("Could not get canvas 2D context"); if (t === !0 && (n.translate(0, r.height), n.scale(1, -1)), n.drawImage(i, 0, 0, r.width, r.height), e !== void 0) { const o = parseInt(e, 16), a = (o >> 16 & 255) / 255, l = (o >> 8 & 255) / 255, c = (o & 255) / 255, h = n.getImageData(0, 0, r.width, r.height), d = h.data; for (let p = 0; p < d.length; p += 4)d[p + 0] = d[p + 0] * a, d[p + 1] = d[p + 1] * l, d[p + 2] = d[p + 2] * c; n.putImageData(h, 0, 0) } return r } else throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.") } const wr = 7; function HX() {
  return `#usda 1.0
(
    customLayerData = {
        string creator = "Three.js USDZExporter"
    }
    metersPerUnit = 1
    upAxis = "Y"
)
`} function VX(i, e) { let t = HX(); return t += i, Vo(t) } function ky(i) { return i.name.replace(/[-<>\(\)\[\]§$%&\/\\\=\?\,\;]/g, "") + "_" + i.id } function wL(i, e, t) {
  const s = i.matrix, r = i.geometry, n = i.material, o = i.camera, a = i.name; i.onBeforeSerialize && i.onBeforeSerialize(e, t); const l = CL(s); if (s.determinant() < 0 && console.warn("THREE.USDZExporter: USDZ does not support negative scales", a), r ? e.beginBlock(`def Xform "${a}" (
prepend references = @./geometries/Geometry_${r.id}.usd@</Geometry>
prepend apiSchemas = ["MaterialBindingAPI"]
		)`) : o ? e.beginBlock(`def Camera "${a}"`) : e.beginBlock(`def Xform "${a}"`), n && e.appendLine(`rel material:binding = </Materials/Material_${n.id}>`), e.appendLine(`matrix4d xformOp:transform = ${l}`), e.appendLine('uniform token[] xformOpOrder = ["xformOp:transform"]'), o && (o.isOrthographicCamera ? (e.appendLine(`float2 clippingRange = (${o.near}, ${o.far})`), e.appendLine(`float horizontalAperture = ${((Math.abs(o.left) + Math.abs(o.right)) * 10).toPrecision(wr)}`), e.appendLine(`float verticalAperture = ${((Math.abs(o.top) + Math.abs(o.bottom)) * 10).toPrecision(wr)}`), e.appendLine('token projection = "orthographic"')) : (e.appendLine(`float2 clippingRange = (${o.near.toPrecision(wr)}, ${o.far.toPrecision(wr)})`), e.appendLine(`float focalLength = ${o.getFocalLength().toPrecision(wr)}`), e.appendLine(`float focusDistance = ${o.focus.toPrecision(wr)}`), e.appendLine(`float horizontalAperture = ${o.getFilmWidth().toPrecision(wr)}`), e.appendLine('token projection = "perspective"'), e.appendLine(`float verticalAperture = ${o.getFilmHeight().toPrecision(wr)}`))), i.onSerialize && i.onSerialize(e, t), i.children) { e.appendLine(); for (const c of i.children) wL(c, e, t) } e.closeBlock()
} function Dy(i) { return i.toFixed(10) } function CL(i) { const e = i.elements; return `( ${Oy(e, 0)}, ${Oy(e, 4)}, ${Oy(e, 8)}, ${Oy(e, 12)} )` } function Oy(i, e) { return `(${Dy(i[e + 0])}, ${Dy(i[e + 1])}, ${Dy(i[e + 2])}, ${Dy(i[e + 3])})` } function WX(i) {
  return `
def "Geometry"
{
  ${qX(i)}
}
`} function qX(i) {
  const e = "Geometry", t = i.attributes, s = t.position.count; return `
    def Mesh "${e}"
    {
        int[] faceVertexCounts = [${XX(i)}]
        int[] faceVertexIndices = [${YX(i)}]
        normal3f[] normals = [${SL(t.normal, s)}] (
            interpolation = "vertex"
        )
        point3f[] points = [${SL(t.position, s)}]
        ${t.uv ? `texCoord2f[] primvars:st = [${EL(t.uv, s)}] (
            interpolation = "vertex"
        )`: ""}
		${t.uv2 ? `texCoord2f[] primvars:st2 = [${EL(t.uv2, s)}] (
            interpolation = "vertex"
        )`: ""}
        uniform token subdivisionScheme = "none"
    }
`} function XX(i) { const e = i.index !== null ? i.index.count : i.attributes.position.count; return Array(e / 3).fill(3).join(", ") } function YX(i) { const e = i.index, t = []; if (e !== null) for (let s = 0; s < e.count; s++)t.push(e.getX(s)); else { const s = i.attributes.position.count; for (let r = 0; r < s; r++)t.push(r) } return t.join(", ") } function SL(i, e) { if (i === void 0) return console.warn("USDZExporter: Normals missing."), Array(e).fill("(0, 0, 0)").join(", "); const t = []; for (let s = 0; s < i.count; s++) { const r = i.getX(s), n = i.getY(s), o = i.getZ(s); t.push(`(${r.toPrecision(wr)}, ${n.toPrecision(wr)}, ${o.toPrecision(wr)})`) } return t.join(", ") } function EL(i, e) { if (i === void 0) return console.warn("USDZExporter: UVs missing."), Array(e).fill("(0, 0)").join(", "); const t = []; for (let s = 0; s < i.count; s++) { const r = i.getX(s), n = i.getY(s); t.push(`(${r.toPrecision(wr)}, ${1 - n.toPrecision(wr)})`) } return t.join(", ") } function JX(i, e) {
  const t = []; for (const s in i) { const r = i[s]; t.push(KX(r, e)) } return `def "Materials"
{
${t.join("")}
}

`} function KX(i, e) {
  var t; const s = "            ", r = [], n = []; function o(l, c, h = void 0, d = void 0) {
    const p = l.id + (h ? "_" + h.getHexString() : "") + (d ? "_" + d : ""), f = l.format === 1023, g = l.wrapS == yn ? "repeat" : l.wrapS == Ta ? "mirror" : "clamp", m = l.wrapT == yn ? "repeat" : l.wrapT == Ta ? "mirror" : "clamp", v = l.repeat.clone(), A = l.offset.clone(), b = l.rotation; let y = Math.sin(b), _ = Math.cos(b); A.y = 1 - A.y - v.y, A.x += y * v.x, A.y += (1 - _) * v.y, e[p] = l; const w = c == "occlusion" ? "uvReader_st2" : "uvReader_st", E = v.x != 1 || v.y != 1 || A.x != 0 || A.y != 0 || b != 0, P = `</Materials/Material_${i.id}/${w}.outputs:result>`, C = `</Materials/Material_${i.id}/Transform2d_${c}.outputs:result>`, R = c !== "normal" && h && (h.r !== 1 || h.g !== 1 || h.b !== 1 || d !== 1) || !1, T = c === "normal", z = (i.normalScale ? i.normalScale.x * 2 : 2).toFixed(wr); return `
        ${E ? `def Shader "Transform2d_${c}" (
            sdrMetadata = {
                string role = "math"
            }
        )
        {
            uniform token info:id = "UsdTransform2d"
            float2 inputs:in.connect = ${P}
            float2 inputs:scale = ${IL(v)}
            float2 inputs:translation = ${IL(A)}
			float inputs:rotation = ${(b / Math.PI * 180).toFixed(wr)}
            float2 outputs:result
        }
		`: ""}
		def Shader "Texture_${l.id}_${c}"
        {
            uniform token info:id = "UsdUVTexture"
            asset inputs:file = @textures/Texture_${p}.${f ? "png" : "jpg"}@
			token inputs:sourceColorSpace = "${l.colorSpace === "srgb" ? "sRGB" : "raw"}"
            float2 inputs:st.connect = ${E ? C : P}
			${R ? `
			float4 inputs:scale = (${h ? h.r + ", " + h.g + ", " + h.b : "1, 1, 1"}, ${d || "1"})
			`: ""}
			${T ? `
			float4 inputs:scale = (${z}, ${z}, ${z}, 1)
			float4 inputs:bias = (-1, -1, -1, 0)
			`: ""}
            token inputs:wrapS = "${g}"
            token inputs:wrapT = "${m}"
            float outputs:r
            float outputs:g
            float outputs:b
            float3 outputs:rgb
            ${i.transparent || i.alphaTest > 0 ? "float outputs:a" : ""}
        }`} const a = i.transparent || i.alphaTest ? i.opacity : 1; return i.side === yi && console.warn("THREE.USDZExporter: USDZ does not support double sided materials", i), i.map !== null ? (r.push(`${s}color3f inputs:diffuseColor.connect = </Materials/Material_${i.id}/Texture_${i.map.id}_diffuse.outputs:rgb>`), i.transparent ? r.push(`${s}float inputs:opacity.connect = </Materials/Material_${i.id}/Texture_${i.map.id}_diffuse.outputs:a>`) : i.alphaTest > 0 && (r.push(`${s}float inputs:opacity.connect = </Materials/Material_${i.id}/Texture_${i.map.id}_diffuse.outputs:a>`), r.push(`${s}float inputs:opacityThreshold = ${i.alphaTest}`)), n.push(o(i.map, "diffuse", i.color, a))) : r.push(`${s}color3f inputs:diffuseColor = ${ML(i.color)}`), i.emissiveMap ? (r.push(`${s}color3f inputs:emissiveColor.connect = </Materials/Material_${i.id}/Texture_${i.emissiveMap.id}_emissive.outputs:rgb>`), n.push(o(i.emissiveMap, "emissive"))) : ((t = i.emissive) == null ? void 0 : t.getHex()) > 0 ? r.push(`${s}color3f inputs:emissiveColor = ${ML(i.emissive)}`) : r.push(`${s}color3f inputs:emissiveColor = (0, 0, 0)`), i.normalMap && (r.push(`${s}normal3f inputs:normal.connect = </Materials/Material_${i.id}/Texture_${i.normalMap.id}_normal.outputs:rgb>`), n.push(o(i.normalMap, "normal"))), i.aoMap && (r.push(`${s}float inputs:occlusion.connect = </Materials/Material_${i.id}/Texture_${i.aoMap.id}_occlusion.outputs:r>`), n.push(o(i.aoMap, "occlusion"))), i.roughnessMap && i.roughness === 1 ? (r.push(`${s}float inputs:roughness.connect = </Materials/Material_${i.id}/Texture_${i.roughnessMap.id}_roughness.outputs:g>`), n.push(o(i.roughnessMap, "roughness"))) : r.push(`${s}float inputs:roughness = ${i.roughness}`), i.metalnessMap && i.metalness === 1 ? (r.push(`${s}float inputs:metallic.connect = </Materials/Material_${i.id}/Texture_${i.metalnessMap.id}_metallic.outputs:b>`), n.push(o(i.metalnessMap, "metallic"))) : r.push(`${s}float inputs:metallic = ${i.metalness}`), i.alphaMap ? (r.push(`${s}float inputs:opacity.connect = </Materials/Material_${i.id}/Texture_${i.alphaMap.id}_opacity.outputs:r>`), r.push(`${s}float inputs:opacityThreshold = 0.0001`), n.push(o(i.alphaMap, "opacity"))) : r.push(`${s}float inputs:opacity = ${a}`), i instanceof Bo && (r.push(`${s}float inputs:clearcoat = ${i.clearcoat}`), r.push(`${s}float inputs:clearcoatRoughness = ${i.clearcoatRoughness}`), r.push(`${s}float inputs:ior = ${i.ior}`)), `
    def Material "Material_${i.id}"
    {
        def Shader "PreviewSurface"
        {
            uniform token info:id = "UsdPreviewSurface"
${r.join(`
`)}
            int inputs:useSpecularWorkflow = 0
            token outputs:surface
        }

        token outputs:surface.connect = </Materials/Material_${i.id}/PreviewSurface.outputs:surface>

        def Shader "uvReader_st"
        {
            uniform token info:id = "UsdPrimvarReader_float2"
            token inputs:varname = "st"
            float2 inputs:fallback = (0.0, 0.0)
            float2 outputs:result
        }

		def Shader "uvReader_st2"
        {
            uniform token info:id = "UsdPrimvarReader_float2"
            token inputs:varname = "st2"
            float2 inputs:fallback = (0.0, 0.0)
            float2 outputs:result
        }

${n.join(`
`)}

    }
`} function ML(i) { return `(${i.r}, ${i.g}, ${i.b})` } function IL(i) { return `(${i.x}, ${i.y})` } const TL = class { constructor(i, e, t) { u(this, "id"), u(this, "trigger"), u(this, "action"), u(this, "exclusive", !1), this.id = "Behavior_" + yS(i) + "_" + TL.global_id++, this.trigger = e, this.action = t } makeExclusive(i) { return this.exclusive = i, this } writeTo(i, e, t) { if (!this.trigger || !this.action) return; t.beginBlock(`def Preliminary_Behavior "${this.id}"`), t.appendLine(`rel actions = <${this.action.id}>`), t.appendLine(`uniform bool exclusive = ${this.exclusive}`); let s = ""; if (Array.isArray(this.trigger)) { s = "["; for (let r = 0; r < this.trigger.length; r++) { const n = this.trigger[r]; s += "<" + n.id + ">", r + 1 < this.trigger.length && (s += ", ") } s += "]" } else s = `<${this.trigger.id}>`; if (t.appendLine(`rel triggers = ${s} `), t.appendLine(), Array.isArray(this.trigger)) for (const r of this.trigger) r.writeTo(e, t), t.appendLine(); else this.trigger.writeTo(e, t); t.appendLine(), this.action.writeTo(e, t), t.closeBlock() } }; let Cr = TL; u(Cr, "global_id", 0); function bS(i, e) { var t, s; let r = ""; if (Array.isArray(i)) { let n = "[ "; for (let o = 0; o < i.length; o++) { let a = i[o]; if (typeof a == "string") n += a; else if (typeof a == "object") { a.isObject3D && (a = e.findById(a.uuid)); const l = (t = a.getPath) == null ? void 0 : t.call(a); n += l } o + 1 < i.length && (n += ", ") } n += " ]", r = n } else typeof i == "object" && (i.isObject3D && (i = e.findById(i.uuid)), r = (s = i.getPath) == null ? void 0 : s.call(i)); return r = r.replace(e.name, e.name + "/Scenes/Scene"), r } const RL = class { constructor(i, e) { u(this, "id"), u(this, "targetId"), u(this, "tokenId"), u(this, "type"), i && (this.targetId = i), e ? this.id = e : this.id = "Trigger_" + RL.global_id++ } writeTo(i, e) { e.beginBlock(`def Preliminary_Trigger "${this.id}"`), this.targetId && (typeof this.targetId != "string" && (this.targetId = bS(this.targetId, i)), e.appendLine("rel affectedObjects = " + this.targetId)), this.tokenId && e.appendLine(`token info:id = "${this.tokenId}"`), this.type && e.appendLine(`token type = "${this.type}"`), e.closeBlock() } }; let Hd = RL; u(Hd, "global_id", 0); class zr { static sceneStartTrigger() { const e = new Hd; return e.targetId = void 0, e.tokenId = "SceneTransition", e.type = "enter", e } static tapTrigger(e) { const t = new Hd(e); return t.tokenId = "TapGesture", t } static isTapTrigger(e) { return e?.tokenId === "TapGesture" } } class bc { constructor(e, t) { u(this, "id"), u(this, "actions"), u(this, "loops", 0), u(this, "performCount", 1), u(this, "type", "serial"), this.id = e, this.actions = t } static getId() { return this.global_id++ } addAction(e) { return this.actions.push(e), this } makeParallel() { return this.type = "parallel", this } makeSequence() { return this.type = "serial", this } makeLooping() { return this.loops = 1, this } makeRepeat(e) { return this.performCount = e, this } writeTo(e, t) { t.beginBlock(`def Preliminary_Action "${this.id}"`), t.beginArray("rel actions"); for (const s of this.actions) s && t.appendLine("<" + s.id + ">,"); t.closeArray(), t.appendLine(), t.appendLine('token info:id = "Group"'), t.appendLine(`bool loops = ${this.loops} `), t.appendLine(`int performCount = ${this.performCount} `), t.appendLine(`token type = "${this.type}"`), t.appendLine(); for (const s of this.actions) s && (s.writeTo(e, t), t.appendLine()); t.closeBlock() } } u(bc, "global_id", 0); var _S = (i => (i[i.pop = 0] = "pop", i[i.blink = 1] = "blink", i[i.bounce = 2] = "bounce", i[i.flip = 3] = "flip", i[i.float = 4] = "float", i[i.jiggle = 5] = "jiggle", i[i.pulse = 6] = "pulse", i[i.spin = 7] = "spin", i))(_S || {}), xS = (i => (i.Relative = "relative", i.Absolute = "absolute", i))(xS || {}); const wS = class { constructor(i, e) { u(this, "id"), u(this, "tokenId"), u(this, "affectedObjects"), u(this, "easeType"), u(this, "motionType"), u(this, "duration"), u(this, "moveDistance"), u(this, "style"), u(this, "type"), u(this, "front"), u(this, "up"), u(this, "start"), u(this, "animationSpeed"), u(this, "reversed"), u(this, "pingPong"), u(this, "xFormTarget"), u(this, "audio"), u(this, "gain"), u(this, "auralMode"), u(this, "multiplePerformOperation"), i && (this.affectedObjects = i), e ? this.id = e : this.id = "Action", this.id += "_" + wS.global_id++ } clone() { const i = new wS, e = i.id; return Object.assign(i, this), i.id = e, i } writeTo(i, e) { e.beginBlock(`def Preliminary_Action "${this.id}"`), this.affectedObjects && (typeof this.affectedObjects != "string" && (this.affectedObjects = bS(this.affectedObjects, i)), e.appendLine("rel affectedObjects = " + this.affectedObjects)), typeof this.duration == "number" && e.appendLine(`double duration = ${this.duration} `), this.easeType && e.appendLine(`token easeType = "${this.easeType}"`), this.tokenId && e.appendLine(`token info:id = "${this.tokenId}"`), this.motionType && e.appendLine(`token motionType = "${this.motionType}"`), typeof this.moveDistance == "number" && e.appendLine(`double moveDistance = ${this.moveDistance} `), this.style && e.appendLine(`token style = "${this.style}"`), this.type && e.appendLine(`token type = "${this.type}"`), this.front && e.appendLine(`vector3d front = (${this.front.x}, ${this.front.y}, ${this.front.z})`), this.up && e.appendLine(`vector3d upVector = (${this.up.x}, ${this.up.y}, ${this.up.z})`), typeof this.start == "number" && e.appendLine(`double start = ${this.start} `), typeof this.animationSpeed == "number" && e.appendLine(`double animationSpeed = ${this.animationSpeed} `), typeof this.reversed == "boolean" && e.appendLine(`bool reversed = ${this.reversed}`), typeof this.pingPong == "boolean" && e.appendLine(`bool reverses = ${this.pingPong}`), this.xFormTarget && (typeof this.xFormTarget != "string" && (this.xFormTarget = bS(this.xFormTarget, i)), e.appendLine(`rel xformTarget = ${this.xFormTarget}`)), typeof this.audio == "string" && e.appendLine(`asset audio = @${this.audio}@`), typeof this.gain == "number" && e.appendLine(`double gain = ${this.gain}`), typeof this.auralMode == "string" && e.appendLine(`token auralMode = "${this.auralMode}"`), typeof this.multiplePerformOperation == "string" && e.appendLine(`token multiplePerformOperation = "${this.multiplePerformOperation}"`), e.closeBlock() } }; let yo = wS; u(yo, "global_id", 0); let Vd = class Wp { constructor(e, t, s) { u(this, "x", 0), u(this, "y", 0), u(this, "z", 0), this.x = e, this.y = t, this.z = s } static get up() { return new Wp(0, 1, 0) } static get right() { return new Wp(1, 0, 0) } static get forward() { return new Wp(0, 0, 1) } static get back() { return new Wp(0, 0, -1) } static get zero() { return new Wp(0, 0, 0) } }; var PL = (i => (i.Play = "play", i.Pause = "pause", i.Stop = "stop", i))(PL || {}), CS = (i => (i.Spatial = "spatial", i.NonSpatial = "nonSpatial", i.Ambient = "ambient", i))(CS || {}); class ni { static sequence(...e) { return new bc("group_" + bc.getId(), e).makeSequence() } static parallel(...e) { return new bc("group_" + bc.getId(), e).makeParallel() } static fadeAction(e, t, s) { const r = new yo(e); return r.tokenId = "Visibility", r.type = s ? "show" : "hide", r.duration = t, r.style = "basic", r.motionType = "none", r.moveDistance = 0, r.easeType = "none", r } static startAnimationAction(e, t, s = 0, r = 1, n = !1, o = !1) { const a = new yo(e); if (a.tokenId = "StartAnimation", a.start = t, a.duration = s, a.animationSpeed = r, a.reversed = n, a.pingPong = o, n && (a.start -= s), o) { a.pingPong = !1; const l = a.clone(); return l.reversed = !n, l.start = a.start, l.reversed && (l.start -= s), ni.sequence(a, l) } return a } static waitAction(e) { const t = new yo; return t.tokenId = "Wait", t.duration = e, t } static lookAtCameraAction(e, t = 9999999999999, s, r) { const n = new yo(e); return n.tokenId = "LookAtCamera", n.duration = t, n.front = s ?? Vd.forward, n.up = r ?? Vd.up, n } static emphasize(e, t, s = 2, r = 1, n = "basic") { const o = new yo(e); return o.tokenId = "Emphasize", o.duration = t, o.style = n ?? "basic", o.motionType = _S[s], o.moveDistance = r, o } static transformAction(e, t, s, r, n = "inout") { const o = new yo(e); return o.tokenId = "Transform", o.duration = s, o.type = r, o.easeType = n, Array.isArray(t) && console.error("Transform target must not be an array", t), o.xFormTarget = t, o } static playAudioAction(e, t, s = "play", r = 1, n = "spatial") { const o = new yo(e); return o.tokenId = "Audio", o.type = s, o.audio = t, o.gain = r, o.auralMode = n, o.multiplePerformOperation = "allow", o } } class ZX { constructor(e) { u(this, "object"), u(this, "model"), this.object = e } get id() { return this.object.uuid } apply(e) { if (!this.model && (this.model = e.findById(this.object.uuid), !this.model)) { console.error("could not find model with id " + this.object.uuid); return } this.onApply(e) } } class SS extends ZX { constructor(e, t, s, r) { super(e), u(this, "matrix"), u(this, "material"), u(this, "geometry"), u(this, "_enableAction"), u(this, "_disableAction"), this.matrix = t, this.material = s, this.geometry = r } onApply(e) { var t, s; const r = this.model; if (!r) return; (t = r.parent) != null && t.isDynamic || nl.createEmptyParent(r); const n = r.clone(); this.matrix && (n.matrix = this.matrix), this.material && (n.material = this.material), this.geometry && (n.geometry = this.geometry), (s = r.parent) == null || s.add(n) } enable() { return this._enableAction ? this._enableAction : (this._enableAction = ni.fadeAction(this.object, 0, !0), this._enableAction) } disable() { return this._disableAction ? this._disableAction : (this._disableAction = ni.fadeAction(this.object, 0, !1), this._disableAction) } } class ES { constructor(e) { u(this, "actions"), u(this, "sortedActions"), this.actions = [...e] } organize() { this.sortedActions = {}; for (const e of this.actions) { const t = e.id; this.sortedActions[t] || (this.sortedActions[t] = []), this.sortedActions[t].push(e) } } getActions(e) { return this.sortedActions || this.organize(), this.sortedActions[e.uuid] } } var $X = Object.defineProperty, eY = Object.getOwnPropertyDescriptor, BL = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? eY(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && $X(e, t, r), r }; class Ug extends Ee { constructor() { super(...arguments), u(this, "from"), u(this, "to"), u(this, "width", 0), u(this, "centered", !0), u(this, "_centerPos") } awake() { this._centerPos = new S } update() { if (!this.from || !this.to) return; const e = xt(this.from).clone(), t = xt(this.to).clone(), s = e.distanceTo(t); this._centerPos.copy(e), this._centerPos.add(t), this._centerPos.multiplyScalar(.5), ts(this.gameObject, this.centered ? this._centerPos : e), this.gameObject.lookAt(xt(this.to).clone()), this.gameObject.scale.set(this.width, this.width, s) } } BL([x($)], Ug.prototype, "from", 2), BL([x($)], Ug.prototype, "to", 2); var tY = Object.defineProperty, iY = Object.getOwnPropertyDescriptor, _c = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? iY(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && tY(e, t, r), r }; class xc { constructor() { u(this, "time"), u(this, "value"), u(this, "inTangent"), u(this, "inWeight"), u(this, "outTangent"), u(this, "outWeight"), u(this, "weightedMode") } } _c([x()], xc.prototype, "time", 2), _c([x()], xc.prototype, "value", 2), _c([x()], xc.prototype, "inTangent", 2), _c([x()], xc.prototype, "inWeight", 2), _c([x()], xc.prototype, "outTangent", 2), _c([x()], xc.prototype, "outWeight", 2), _c([x()], xc.prototype, "weightedMode", 2); class Gh { constructor() { u(this, "keys") } get duration() { return !this.keys || this.keys.length == 0 ? 0 : this.keys[this.keys.length - 1].time } evaluate(e) { if (!this.keys || this.keys.length == 0) return 0; if (this.keys[0].time >= e) return this.keys[0].value; for (let t = 0; t < this.keys.length; t++) { const s = this.keys[t]; if (s.time <= e) if (t + 1 < this.keys.length) { const r = this.keys[t + 1]; if (r.time < e) continue; const n = Ke.remap(e, s.time, r.time, 0, 1); return Ke.lerp(s.value, r.value, n) } else return s.value } return this.keys[this.keys.length - 1].value } } _c([x(xc)], Gh.prototype, "keys", 2); const Wd = oe("debugusdzanimation"); class Ly { constructor(e, t, s) { u(this, "ext"), u(this, "root"), u(this, "clip"), this.ext = e, this.root = t, this.clip = s } get start() { return this.ext.getStartTime01(this.root, this.clip) } get duration() { return this.clip.duration } } class Fy { constructor(e, t, s, r) { u(this, "clip"), u(this, "pos"), u(this, "rot"), u(this, "scale"), u(this, "ext"), u(this, "root"), u(this, "target"), this.ext = e, this.root = t, this.target = s, this.clip = r } get frameRate() { return 60 } addTrack(e) { e.name.endsWith("position") && (this.pos = e), e.name.endsWith("quaternion") && (this.rot = e), e.name.endsWith("scale") && (this.scale = e) } getFrames() { var e, t, s, r, n, o; return Math.max(((t = (e = this.pos) == null ? void 0 : e.times) == null ? void 0 : t.length) ?? 0, ((r = (s = this.rot) == null ? void 0 : s.times) == null ? void 0 : r.length) ?? 0, ((o = (n = this.scale) == null ? void 0 : n.times) == null ? void 0 : o.length) ?? 0) } getDuration() { var e, t, s; const r = ((e = this.pos) == null ? void 0 : e.times) ?? ((t = this.rot) == null ? void 0 : t.times) ?? ((s = this.scale) == null ? void 0 : s.times); return r ? r[r.length - 1] : 0 } getStartTime(e) { let t = 0; for (let s = 0; s < e.length; s++) { const r = e[s]; if (r === this) return t; t += r.getDuration() } return t } } class Uy { constructor() { u(this, "dict", new Map), u(this, "rootTargetMap", new Map), u(this, "serializers", []) } get extensionName() { return "animation" } getStartTime01(e, t) { const s = this.rootTargetMap.get(e); if (!s) return 1 / 0; let r = -1; for (const n of s) { const o = this.dict.get(n); let a = 0; if (o != null && o.length) { for (const l of o) { if (l.clip === t) break; a += l.getDuration() } r = Math.max(r, a) } else console.warn("No animation found on root", e, t, o) } return r } registerAnimation(e, t) { if (!t || !e) return null; this.rootTargetMap.has(e) || this.rootTargetMap.set(e, []); for (const s of t.tracks) { const r = s.name.split(".")[2], n = e.getObjectByName(r); if (!n) { console.warn("no object found for track", s.name, "using " + e.name + " instead"); continue } this.dict.has(n) || this.dict.set(n, []); const o = this.dict.get(n); if (!o) continue; let a = o.find(c => c.clip === t); a || (a = new Fy(this, e, n, t), o.push(a)), a.addTrack(s); const l = this.rootTargetMap.get(e); l != null && l.includes(n) || l == null || l.push(n) } return new Ly(this, e, t) } onAfterHierarchy(e) { Wd && console.log(this.dict) } onAfterBuildDocument(e) { var t, s; for (const r of this.serializers) { const n = (t = r.model) == null ? void 0 : t.parent, o = n?.isDynamic === !0; Wd && console.log(o, (s = r.model) == null ? void 0 : s.parent), o && r.registerCallback(n) } } onExportObject(e, t, s) { $.foreachComponent(e, n => { const o = n; typeof o.createAnimation == "function" && o.createAnimation(this, t, s) }, !1); const r = new sY(e, this.dict); this.serializers.push(r), r.registerCallback(t) } } class sY { constructor(e, t) { u(this, "object"), u(this, "dict"), u(this, "model"), u(this, "callback"), this.object = e, this.dict = t } registerCallback(e) { this.model && this.callback && this.model.removeEventListener("serialize", this.callback), this.callback || (this.callback = this.onSerialize.bind(this)), Wd && console.log("REPARENT", e), this.model = e, this.model.addEventListener("serialize", this.callback) } onSerialize(e, t) { var s, r, n, o, a, l; if (!this.model) return; Wd && console.log("SERIALIZE", this.model.name, this.object.type); const c = this.object, h = this.dict.get(c); if (!h) return; const d = new He, p = new S, f = new we, g = new S(1, 1, 1); e.appendLine("matrix4d xformOp:transform.timeSamples = {"), e.indent++; for (const m of h) { let v = (s = m.pos) == null ? void 0 : s.times, A = (r = m.rot) == null ? void 0 : r.times, b = (n = m.scale) == null ? void 0 : n.times, y = []; if (v) for (const C of v) y.push(C); if (A) for (const C of A) y.push(C); if (b) for (const C of b) y.push(C); if (y.sort((C, R) => C - R), y = [...new Set(y)], !y || y.length === 0) { console.error("got an animated object but no time values??", c, m); continue } const _ = m.getStartTime(h); Wd && e.appendLine(m.clip.name + ": start=" + _.toFixed(3) + ", length=" + m.getDuration().toFixed(3) + ", frames=" + m.getFrames()); const w = (o = m.pos) == null ? void 0 : o.createInterpolant(), E = (a = m.rot) == null ? void 0 : a.createInterpolant(), P = (l = m.scale) == null ? void 0 : l.createInterpolant(); w || p.set(c.position.x, c.position.y, c.position.z), E || f.set(c.quaternion.x, c.quaternion.y, c.quaternion.z, c.quaternion.w), P || g.set(c.scale.x, c.scale.y, c.scale.z); for (let C = 0; C < y.length; C++) { const R = y[C]; if (w) { const z = w.evaluate(R); p.set(z[0], z[1], z[2]) } if (E) { const z = E.evaluate(R); f.set(z[0], z[1], z[2], z[3]) } if (P) { const z = P.evaluate(R); g.set(z[0], z[1], z[2]) } d.compose(p, f, g); let T = `${(_ + R) * m.frameRate}: ${CL(d)},`; Wd && (T = "#" + C + "	" + T), e.appendLine(T) } } e.indent--, e.appendLine("}") } } class rY extends Vi { constructor(e, t = 1, s = 16, r = 2) { const n = new yt, o = s + r * 2, a = new Float32Array((o * 3 + 3) * 3); n.setAttribute("position", new nt(a, 3)); const l = new Hi({ color: 65280 }), c = new Hi({ color: 16776960 }); super(n, [c, l]), this.audio = e, this.range = t, this.divisionsInnerAngle = s, this.divisionsOuterAngle = r, this.type = "PositionalAudioHelper", this.update() } update() { const e = this.audio, t = this.range, s = this.divisionsInnerAngle, r = this.divisionsOuterAngle, n = kr.degToRad(e.panner.coneInnerAngle), o = kr.degToRad(e.panner.coneOuterAngle), a = n / 2, l = o / 2; let c = 0, h = 0, d, p; const f = this.geometry, g = f.attributes.position; f.clearGroups(); function m(v, A, b, y) { const _ = (A - v) / b; for (g.setXYZ(c, 0, 0, 0), h++, d = v; d < A; d += _)p = c + h, g.setXYZ(p, Math.sin(d) * t, 0, Math.cos(d) * t), g.setXYZ(p + 1, Math.sin(Math.min(d + _, A)) * t, 0, Math.cos(Math.min(d + _, A)) * t), g.setXYZ(p + 2, 0, 0, 0), h += 3; f.addGroup(c, h, y), c += h, h = 0 } m(-l, -a, r, 0), m(-a, a, s, 1), m(a, l, r, 0), g.needsUpdate = !0, n === o && (this.material[0].visible = !1) } dispose() { this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose() } } var nY = Object.defineProperty, oY = Object.getOwnPropertyDescriptor, wc = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? oY(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && nY(e, t, r), r }; const ar = oe("debugaudio"); var Ng; const Ts = (Ng = class extends Ee { constructor() { super(...arguments), u(this, "clip", ""), u(this, "playOnAwake", !1), u(this, "_spatialBlend", 0), u(this, "_minDistance", 1), u(this, "_maxDistance", 100), u(this, "_volume", 1), u(this, "rollOffMode", 0), u(this, "playInBackground", !0), u(this, "_loop", !1), u(this, "sound", null), u(this, "helper", null), u(this, "wasPlaying", !1), u(this, "audioLoader", null), u(this, "shouldPlay", !1), u(this, "_lastClipStartedLoading", null), u(this, "onVisibilityChanged", () => { switch (document.visibilityState) { case "hidden": this.playInBackground === !1 && (this.wasPlaying = this.isPlaying, this.isPlaying && this.pause()); break; case "visible": ar && console.log("visible", this.enabled, this.playOnAwake, !this.isPlaying, Ts._userInteractionRegistered, this.wasPlaying), this.enabled && this.playOnAwake && !this.isPlaying && Ts._userInteractionRegistered && this.wasPlaying && this.play(); break } }), u(this, "onApplicationMuteChanged", () => { var i, e; this.context.application.muted ? (i = this.sound) == null || i.setVolume(0) : (e = this.sound) == null || e.setVolume(this.volume) }), u(this, "lerp", (i, e, t) => i * (1 - t) + e * t), u(this, "_lastContextTime", 0), u(this, "_hasEnded", !0), u(this, "_needUpdateSpatialDistanceSettings", !1) } static get userInteractionRegistered() { return Ts._didCallBeginWaitForUserInteraction || (Ts._didCallBeginWaitForUserInteraction = !0, Ts._beginWaitForUserInteraction()), Ts._userInteractionRegistered } static registerWaitForAllowAudio(i) { if (i !== null) { if (this._userInteractionRegistered) { i(); return } this.callbacks.indexOf(i) === -1 && this.callbacks.push(i), Ts._didCallBeginWaitForUserInteraction || (Ts._didCallBeginWaitForUserInteraction = !0, Ts._beginWaitForUserInteraction()) } } static _beginWaitForUserInteraction(i = null) { if (this._userInteractionRegistered) { i && i(); return } i !== null && this.registerWaitForAllowAudio(i); const e = (() => { if (e != null && !Ts._userInteractionRegistered) { Ts._userInteractionRegistered = !0, ar && console.log("\u{1F50A} registered interaction, can play audio now"), document.removeEventListener("pointerdown", e), document.removeEventListener("click", e), document.removeEventListener("dragstart", e), document.removeEventListener("touchstart", e); for (const t of this.callbacks) t(); this.callbacks.length = 0 } }).bind(this); document.addEventListener("pointerdown", e), document.addEventListener("click", e), document.addEventListener("dragstart", e), document.addEventListener("touchstart", e) } get loop() { return this.sound && (this._loop = this.sound.getLoop()), this._loop } set loop(i) { this._loop = i, this.sound && this.sound.setLoop(i) } get spatialBlend() { return this._spatialBlend } set spatialBlend(i) { i !== this._spatialBlend && (this._spatialBlend = i, this._needUpdateSpatialDistanceSettings = !0) } get minDistance() { return this._minDistance } set minDistance(i) { this._minDistance !== i && (this._minDistance = i, this._needUpdateSpatialDistanceSettings = !0) } get maxDistance() { return this._maxDistance } set maxDistance(i) { this._maxDistance !== i && (this._maxDistance = i, this._needUpdateSpatialDistanceSettings = !0) } get volume() { return this._volume } set volume(i) { this._volume = i, this.sound && !this.context.application.muted && (ar && console.log(this.name, "audio set volume", i), this.sound.setVolume(i)) } get Sound() { if (!this.sound && Ts._userInteractionRegistered) { const i = $.getComponent(this.context.mainCamera, cp) ?? $.findObjectOfType(cp, this.context); i != null && i.listener && (this.sound = new FP(i.listener), this.gameObject.add(this.sound)) } return this.sound } get ShouldPlay() { return this.shouldPlay } awake() { this.audioLoader = new $A, this.playOnAwake && (this.shouldPlay = !0) } onEnable() { Ts._userInteractionRegistered ? this.playOnAwake && this.context.application.isVisible && this.play() : Ts._beginWaitForUserInteraction(() => { this.enabled && !this.destroyed && this.shouldPlay && this.loadAndPlay(this.clip) }), globalThis.addEventListener("visibilitychange", this.onVisibilityChanged), this.context.application.addEventListener(ay.MuteChanged, this.onApplicationMuteChanged) } onDisable() { globalThis.removeEventListener("visibilitychange", this.onVisibilityChanged), this.context.application.removeEventListener(ay.MuteChanged, this.onApplicationMuteChanged), this.stop() } onLoaded(i) { ar && console.log("audio buffer loaded"), Ts.registerWaitForAllowAudio(() => { ar && console.log("finished loading", i); const e = this.Sound; if (!e) { console.warn("Failed getting sound", this.name); return } e.isPlaying && e.stop(), e.setBuffer(i), e.loop = this._loop, this.context.application.muted ? e.setVolume(0) : e.setVolume(this.volume), e.autoplay = this.shouldPlay, this.applySpatialDistanceSettings(), e.isPlaying && e.stop(), ar && console.log(this.name, this.shouldPlay, Ts.userInteractionRegistered, this), this.shouldPlay && Ts._userInteractionRegistered && this.play() }) } applySpatialDistanceSettings() { const i = this.sound; if (!i) return; this._needUpdateSpatialDistanceSettings = !1; const e = this.lerp(10 * this._maxDistance / Math.max(1e-4, this.spatialBlend), this._minDistance, this.spatialBlend); switch (ar && console.log(this.name, this._minDistance, this._maxDistance, this.spatialBlend, "Ref distance=" + e), i.setRefDistance(e), i.setMaxDistance(Math.max(.01, this._maxDistance)), this.rollOffMode) { case 0: i.setDistanceModel("exponential"); break; case 1: i.setDistanceModel("linear"); break }this.spatialBlend > 0 ? ar && !this.helper && (this.helper = new rY(i, i.getRefDistance()), i.add(this.helper)) : this.helper && this.helper.parent && this.helper.removeFromParent() } loadAndPlay(i) { if (i && (this.clip = i), this.clip && (ar && console.log(this.clip), this.clip.endsWith(".mp3") || this.clip.endsWith(".wav"))) { if (this.audioLoader || (this.audioLoader = new $A), this.shouldPlay = !0, this._lastClipStartedLoading === this.clip) { ar && console.log("Is currently loading:", this._lastClipStartedLoading, this); return } this._lastClipStartedLoading = this.clip, ar && console.log("load audio", this.clip), this.audioLoader.load(this.clip, this.onLoaded.bind(this), () => { }, console.error) } } play(i = void 0) { var e; if (!this.audioLoader || !this.sound || i && i !== this.clip) { this.loadAndPlay(i); return } if (this.shouldPlay = !0, this._hasEnded = !1, ar && console.log("play", (e = this.sound) == null ? void 0 : e.getVolume(), this.sound), this.sound && !this.sound.isPlaying) { const t = this.context.application.muted; t && this.sound.setVolume(0), this.sound.play(t ? .1 : 0) } } pause() { var i; ar && console.log("Pause", this), this._hasEnded = !0, this.shouldPlay = !1, this.sound && this.sound.isPlaying && this.sound.source && (this._lastContextTime = (i = this.sound) == null ? void 0 : i.context.currentTime, this.sound.pause()) } stop() { var i; ar && console.log("Pause", this), this._hasEnded = !0, this.shouldPlay = !1, this.sound && this.sound.source && (this._lastContextTime = (i = this.sound) == null ? void 0 : i.context.currentTime, ar && console.log(this._lastContextTime), this.sound.stop()) } get isPlaying() { var i; return ((i = this.sound) == null ? void 0 : i.isPlaying) ?? !1 } set isPlaying(i) { } get time() { var i, e; return (i = this.sound) != null && i.source ? ((e = this.sound.source) == null ? void 0 : e.context.currentTime) - this._lastContextTime + this.sound.offset : 0 } set time(i) { if (this.sound) { if (i === this.sound.offset) return; const e = this.isPlaying; this.stop(), this.sound.offset = i, e && this.play() } } update() { this.helper && (this.isPlaying && this.helper.update(), this.helper.visible = this.isPlaying), this._needUpdateSpatialDistanceSettings && this.applySpatialDistanceSettings(), this.sound && !this.sound.isPlaying && this.shouldPlay && !this._hasEnded && (this._hasEnded = !0, ar && console.log("Audio clip ended", this.clip), this.sound.dispatchEvent({ type: "ended", target: this })) } }, u(Ng, "_didCallBeginWaitForUserInteraction", !1), u(Ng, "callbacks", []), u(Ng, "_userInteractionRegistered", !1), Ng); let ss = Ts; wc([x(URL)], ss.prototype, "clip", 2), wc([x()], ss.prototype, "playOnAwake", 2), wc([x()], ss.prototype, "loop", 1), wc([x()], ss.prototype, "spatialBlend", 1), wc([x()], ss.prototype, "minDistance", 1), wc([x()], ss.prototype, "maxDistance", 1), wc([x()], ss.prototype, "volume", 1), wc([x()], ss.prototype, "rollOffMode", 2); var aY = Object.defineProperty, lY = Object.getOwnPropertyDescriptor, cY = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? lY(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && aY(e, t, r), r }; class zg extends Ee { constructor() { super(...arguments), u(this, "constraintActive", !0), u(this, "locked", !1), u(this, "sources", []) } } cY([x(Me)], zg.prototype, "sources", 2); const kL = { type: "change" }, MS = { type: "start" }, DL = { type: "end" }; let OL = class extends ms { constructor(i, e) { super(), this.object = i, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new S, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: ih.ROTATE, MIDDLE: ih.DOLLY, RIGHT: ih.PAN }, this.touches = { ONE: sh.ROTATE, TWO: sh.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () { return o.phi }, this.getAzimuthalAngle = function () { return o.theta }, this.getDistance = function () { return this.object.position.distanceTo(this.target) }, this.listenToKeyEvents = function (j) { j.addEventListener("keydown", ii), this._domElementKeyEvents = j }, this.saveState = function () { t.target0.copy(t.target), t.position0.copy(t.object.position), t.zoom0 = t.object.zoom }, this.reset = function () { t.target.copy(t.target0), t.object.position.copy(t.position0), t.object.zoom = t.zoom0, t.object.updateProjectionMatrix(), t.dispatchEvent(kL), t.update(), r = s.NONE }, this.update = function () { const j = new S, J = new we().setFromUnitVectors(i.up, new S(0, 1, 0)), Ve = J.clone().invert(), qe = new S, ze = new we, ge = 2 * Math.PI; return function () { const lt = t.object.getWorldPosition(i.position); j.copy(lt).sub(t.target), j.applyQuaternion(J), o.setFromVector3(j), t.autoRotate && r === s.NONE && R(P()), t.enableDamping ? (o.theta += a.theta * t.dampingFactor, o.phi += a.phi * t.dampingFactor) : (o.theta += a.theta, o.phi += a.phi); let It = t.minAzimuthAngle, M = t.maxAzimuthAngle; return isFinite(It) && isFinite(M) && (It < -Math.PI ? It += ge : It > Math.PI && (It -= ge), M < -Math.PI ? M += ge : M > Math.PI && (M -= ge), It <= M ? o.theta = Math.max(It, Math.min(M, o.theta)) : o.theta = o.theta > (It + M) / 2 ? Math.max(It, o.theta) : Math.min(M, o.theta)), o.phi = Math.max(t.minPolarAngle, Math.min(t.maxPolarAngle, o.phi)), o.makeSafe(), c = kr.lerp(c, l, t.dampingFactor), o.radius *= c, o.radius = Math.max(t.minDistance, Math.min(t.maxDistance, o.radius)), t.enableDamping === !0 ? t.target.addScaledVector(h, t.dampingFactor) : t.target.add(h), j.setFromSpherical(o), j.applyQuaternion(Ve), lt.copy(t.target).add(j), t.object.parent ? t.object.parent.worldToLocal(lt) : t.object.position.copy(lt), t.object.lookAt(t.target), t.enableDamping === !0 ? (a.theta *= 1 - t.dampingFactor, a.phi *= 1 - t.dampingFactor, h.multiplyScalar(1 - t.dampingFactor)) : (a.set(0, 0, 0), h.set(0, 0, 0)), l = 1, d || qe.distanceToSquared(t.object.position) > n || 8 * (1 - ze.dot(t.object.quaternion)) > n ? (t.dispatchEvent(kL), qe.copy(t.object.position), ze.copy(t.object.quaternion), d = !1, !0) : !1 } }(), this.dispose = function () { t.domElement.removeEventListener("contextmenu", le), t.domElement.removeEventListener("pointerdown", Fe), t.domElement.removeEventListener("pointercancel", me), t.domElement.removeEventListener("wheel", Pt), t.domElement.removeEventListener("pointermove", Re), t.domElement.removeEventListener("pointerup", ht), t._domElementKeyEvents !== null && t._domElementKeyEvents.removeEventListener("keydown", ii) }; const t = this, s = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let r = s.NONE; const n = 1e-6, o = new s1, a = new s1; let l = 1, c = 1; const h = new S; let d = !1; const p = new W, f = new W, g = new W, m = new W, v = new W, A = new W, b = new W, y = new W, _ = new W, w = [], E = {}; function P() { return 2 * Math.PI / 60 / 60 * t.autoRotateSpeed } function C() { return Math.pow(.95, t.zoomSpeed) } function R(j) { a.theta -= j } function T(j) { a.phi -= j } const z = function () { const j = new S; return function (J, Ve) { j.setFromMatrixColumn(Ve, 0), j.multiplyScalar(-J), h.add(j) } }(), H = function () { const j = new S; return function (J, Ve) { t.screenSpacePanning === !0 ? j.setFromMatrixColumn(Ve, 1) : (j.setFromMatrixColumn(Ve, 0), j.crossVectors(t.object.up, j)), j.multiplyScalar(J), h.add(j) } }(), N = function () { const j = new S, J = new S; return function (Ve, qe) { const ze = t.domElement; if (t.object.isPerspectiveCamera) { t.object.getWorldPosition(J), j.copy(J).sub(t.target); let ge = j.length(); ge *= Math.tan(t.object.fov / 2 * Math.PI / 180), z(2 * Ve * ge / ze.clientHeight, t.object.matrixWorld), H(2 * qe * ge / ze.clientHeight, t.object.matrixWorld) } else t.object.isOrthographicCamera ? (z(Ve * (t.object.right - t.object.left) / t.object.zoom / ze.clientWidth, t.object.matrixWorld), H(qe * (t.object.top - t.object.bottom) / t.object.zoom / ze.clientHeight, t.object.matrixWorld)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), t.enablePan = !1) } }(); function F(j) { t.object.isPerspectiveCamera ? l /= j : t.object.isOrthographicCamera ? (t.object.zoom = Math.max(t.minZoom, Math.min(t.maxZoom, t.object.zoom * j)), t.object.updateProjectionMatrix(), d = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), t.enableZoom = !1) } function X(j) { t.object.isPerspectiveCamera ? l *= j : t.object.isOrthographicCamera ? (t.object.zoom = Math.max(t.minZoom, Math.min(t.maxZoom, t.object.zoom / j)), t.object.updateProjectionMatrix(), d = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), t.enableZoom = !1) } function te(j) { p.set(j.clientX, j.clientY) } function re(j) { b.set(j.clientX, j.clientY) } function Z(j) { m.set(j.clientX, j.clientY) } function fe(j) { f.set(j.clientX, j.clientY), g.subVectors(f, p).multiplyScalar(t.rotateSpeed); const J = t.domElement; R(2 * Math.PI * g.x / J.clientHeight), T(2 * Math.PI * g.y / J.clientHeight), p.copy(f), t.update() } function ae(j) { y.set(j.clientX, j.clientY), _.subVectors(y, b), _.y > 0 ? F(C()) : _.y < 0 && X(C()), b.copy(y), t.update() } function De(j) { v.set(j.clientX, j.clientY), A.subVectors(v, m).multiplyScalar(t.panSpeed), N(A.x, A.y), m.copy(v), t.update() } function Se(j) { j.deltaY < 0 ? X(C()) : j.deltaY > 0 && F(C()), t.update() } function ie(j) { let J = !1; switch (j.code) { case t.keys.UP: j.ctrlKey || j.metaKey || j.shiftKey ? T(2 * Math.PI * t.rotateSpeed / t.domElement.clientHeight) : N(0, t.keyPanSpeed), J = !0; break; case t.keys.BOTTOM: j.ctrlKey || j.metaKey || j.shiftKey ? T(-2 * Math.PI * t.rotateSpeed / t.domElement.clientHeight) : N(0, -t.keyPanSpeed), J = !0; break; case t.keys.LEFT: j.ctrlKey || j.metaKey || j.shiftKey ? R(2 * Math.PI * t.rotateSpeed / t.domElement.clientHeight) : N(t.keyPanSpeed, 0), J = !0; break; case t.keys.RIGHT: j.ctrlKey || j.metaKey || j.shiftKey ? R(-2 * Math.PI * t.rotateSpeed / t.domElement.clientHeight) : N(-t.keyPanSpeed, 0), J = !0; break }J && (j.preventDefault(), t.update()) } function ce() { if (w.length === 1) p.set(w[0].pageX, w[0].pageY); else { const j = .5 * (w[0].pageX + w[1].pageX), J = .5 * (w[0].pageY + w[1].pageY); p.set(j, J) } } function Te() { if (w.length === 1) m.set(w[0].pageX, w[0].pageY); else { const j = .5 * (w[0].pageX + w[1].pageX), J = .5 * (w[0].pageY + w[1].pageY); m.set(j, J) } } function K() { const j = w[0].pageX - w[1].pageX, J = w[0].pageY - w[1].pageY, Ve = Math.sqrt(j * j + J * J); b.set(0, Ve) } function je() { t.enableZoom && K(), t.enablePan && Te() } function Ue() { t.enableZoom && K(), t.enableRotate && ce() } function Pe(j) { if (w.length == 1) f.set(j.pageX, j.pageY); else { const Ve = rt(j), qe = .5 * (j.pageX + Ve.x), ze = .5 * (j.pageY + Ve.y); f.set(qe, ze) } g.subVectors(f, p).multiplyScalar(t.rotateSpeed); const J = t.domElement; R(2 * Math.PI * g.x / J.clientHeight), T(2 * Math.PI * g.y / J.clientHeight), p.copy(f) } function ve(j) { if (w.length === 1) v.set(j.pageX, j.pageY); else { const J = rt(j), Ve = .5 * (j.pageX + J.x), qe = .5 * (j.pageY + J.y); v.set(Ve, qe) } A.subVectors(v, m).multiplyScalar(t.panSpeed), N(A.x, A.y), m.copy(v) } function de(j) { const J = rt(j), Ve = j.pageX - J.x, qe = j.pageY - J.y, ze = Math.sqrt(Ve * Ve + qe * qe); y.set(0, ze), _.set(0, Math.pow(y.y / b.y, t.zoomSpeed)), F(_.y), b.copy(y) } function Ae(j) { t.enableZoom && de(j), t.enablePan && ve(j) } function pe(j) { t.enableZoom && de(j), t.enableRotate && Pe(j) } function Fe(j) { t.enabled !== !1 && (w.length === 0 && (t.domElement.addEventListener("pointermove", Re), t.domElement.addEventListener("pointerup", ht)), Ie(j), j.pointerType === "touch" ? U(j) : ut(j)) } function Re(j) { t.enabled !== !1 && (j.pointerType === "touch" ? D(j) : dt(j)) } function ht(j) { Be(j), w.length === 0 && (t.domElement.removeEventListener("pointermove", Re), t.domElement.removeEventListener("pointerup", ht)), t.dispatchEvent(DL), r = s.NONE } function me(j) { Be(j) } function ut(j) { let J; switch (j.button) { case 0: J = t.mouseButtons.LEFT; break; case 1: J = t.mouseButtons.MIDDLE; break; case 2: J = t.mouseButtons.RIGHT; break; default: J = -1 }switch (J) { case ih.DOLLY: if (t.enableZoom === !1) return; re(j), r = s.DOLLY; break; case ih.ROTATE: if (j.ctrlKey || j.metaKey || j.shiftKey) { if (t.enablePan === !1) return; Z(j), r = s.PAN } else { if (t.enableRotate === !1) return; te(j), r = s.ROTATE } break; case ih.PAN: if (j.ctrlKey || j.metaKey || j.shiftKey) { if (t.enableRotate === !1) return; te(j), r = s.ROTATE } else { if (t.enablePan === !1) return; Z(j), r = s.PAN } break; default: r = s.NONE }r !== s.NONE && t.dispatchEvent(MS) } function dt(j) { switch (r) { case s.ROTATE: if (t.enableRotate === !1) return; fe(j); break; case s.DOLLY: if (t.enableZoom === !1) return; ae(j); break; case s.PAN: if (t.enablePan === !1) return; De(j); break } } function Pt(j) { t.enabled === !1 || t.enableZoom === !1 || r !== s.NONE || (j.preventDefault(), t.dispatchEvent(MS), Se(j), t.dispatchEvent(DL)) } function ii(j) { t.enabled === !1 || t.enablePan === !1 || ie(j) } function U(j) { switch (Qe(j), w.length) { case 1: switch (t.touches.ONE) { case sh.ROTATE: if (t.enableRotate === !1) return; ce(), r = s.TOUCH_ROTATE; break; case sh.PAN: if (t.enablePan === !1) return; Te(), r = s.TOUCH_PAN; break; default: r = s.NONE }break; case 2: switch (t.touches.TWO) { case sh.DOLLY_PAN: if (t.enableZoom === !1 && t.enablePan === !1) return; je(), r = s.TOUCH_DOLLY_PAN; break; case sh.DOLLY_ROTATE: if (t.enableZoom === !1 && t.enableRotate === !1) return; Ue(), r = s.TOUCH_DOLLY_ROTATE; break; default: r = s.NONE }break; default: r = s.NONE }r !== s.NONE && t.dispatchEvent(MS) } function D(j) { switch (Qe(j), r) { case s.TOUCH_ROTATE: if (t.enableRotate === !1) return; Pe(j), t.update(); break; case s.TOUCH_PAN: if (t.enablePan === !1) return; ve(j), t.update(); break; case s.TOUCH_DOLLY_PAN: if (t.enableZoom === !1 && t.enablePan === !1) return; Ae(j), t.update(); break; case s.TOUCH_DOLLY_ROTATE: if (t.enableZoom === !1 && t.enableRotate === !1) return; pe(j), t.update(); break; default: r = s.NONE } } function le(j) { t.enabled !== !1 && j.preventDefault() } function Ie(j) { w.push(j) } function Be(j) { delete E[j.pointerId]; for (let J = 0; J < w.length; J++)if (w[J].pointerId == j.pointerId) { w.splice(J, 1); return } } function Qe(j) { let J = E[j.pointerId]; J === void 0 && (J = new W, E[j.pointerId] = J), J.set(j.pageX, j.pageY) } function rt(j) { const J = j.pointerId === w[0].pointerId ? w[1] : w[0]; return E[J.pointerId] } t.domElement.addEventListener("contextmenu", le), t.domElement.addEventListener("pointerdown", Fe), t.domElement.addEventListener("pointercancel", me), t.domElement.addEventListener("wheel", Pt, { passive: !1 }), this.update() } }; class hY { static createButton(e, t = {}, s) { const r = document.createElement("button"); let n = !1; function o() { if (t.optionalFeatures = t.optionalFeatures || [], t.domOverlay === void 0) { var h = document.createElement("div"); h.style.display = "none", document.body.appendChild(h); var d = document.createElementNS("http://www.w3.org/2000/svg", "svg"); d.setAttribute("width", 38), d.setAttribute("height", 38), d.style.position = "absolute", d.style.right = "20px", d.style.top = "20px", d.addEventListener("click", function () { f.end() }), h.appendChild(d); var p = document.createElementNS("http://www.w3.org/2000/svg", "path"); p.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), p.setAttribute("stroke", "#fff"), p.setAttribute("stroke-width", 2), d.appendChild(p), t.optionalFeatures.push("dom-overlay"), t.domOverlay = { root: h }, n = !0 } let f = null, g = null; async function m(A) { var b; if (/WebXRViewer\//i.test(navigator.userAgent)) if ((b = t.domOverlay) != null && b.root) { const y = t.domOverlay.root; g = y.parentElement, g && (console.log("Reparent DOM Overlay to body", y, y.style.display), y.style.display = "", y.style.visibility = "", document.body.appendChild(y)) } else console.warn("WebXRViewer: No DOM Overlay found"); A.addEventListener("end", v), await e.xr.setSession(A), r.textContent = "STOP AR", n && (t.domOverlay.root.style.display = ""), f = A } function v() { f.removeEventListener("end", v), r.textContent = "START AR", g && g.appendChild(t.domOverlay.root), n && (t.domOverlay.root.style.display = "none"), f = null } r.style.display = "", r.style.cursor = "pointer", r.style.left = "calc(50% - 50px)", r.style.width = "100px", r.textContent = "START AR", r.onmouseenter = function () { r.style.opacity = "1.0" }, r.onmouseleave = function () { r.style.opacity = "0.5" }, r.onclick = function () { f === null ? (s?.call(this, t), navigator.xr.requestSession("immersive-ar", t).then(m)) : f.end() } } function a() { r.disabled = !0, r.style.display = "", r.style.cursor = "auto", r.style.left = "calc(50% - 75px)", r.style.width = "150px", r.onmouseenter = null, r.onmouseleave = null, r.onclick = null } function l() { a(), r.textContent = "AR NOT SUPPORTED" } function c(h) { h.style.position = "absolute", h.style.bottom = "20px", h.style.padding = "12px 6px", h.style.border = "1px solid #fff", h.style.borderRadius = "4px", h.style.background = "rgba(0,0,0,0.1)", h.style.color = "#fff", h.style.font = "normal 13px sans-serif", h.style.textAlign = "center", h.style.opacity = "0.5", h.style.outline = "none", h.style.zIndex = "999" } if ("xr" in navigator) return r.id = "ARButton", r.style.display = "none", c(r), navigator.xr.isSessionSupported("immersive-ar").then(function (h) { h ? o() : l() }).catch(l), r; { const h = document.createElement("a"); return window.isSecureContext === !1 ? (h.href = document.location.href.replace(/^http:/, "https:"), h.innerHTML = "WEBXR NEEDS HTTPS") : (h.href = "https://immersiveweb.dev/", h.innerHTML = "WEBXR NOT AVAILABLE"), h.style.left = "calc(50% - 90px)", h.style.width = "180px", h.style.textDecoration = "none", c(h), h } } } const IS = class { static createButton(i, e) { const t = document.createElement("button"); function s() { let a = null; async function l(h) { h.addEventListener("end", c), await i.xr.setSession(h), t.textContent = "EXIT VR", a = h } function c() { a.removeEventListener("end", c), t.textContent = "ENTER VR", a = null } t.style.display = "", t.style.cursor = "pointer", t.style.left = "calc(50% - 50px)", t.style.width = "100px", t.textContent = "ENTER VR", t.onmouseenter = function () { t.style.opacity = "1.0" }, t.onmouseleave = function () { t.style.opacity = "0.5" }, t.onclick = function () { if (a === null) { const h = { optionalFeatures: e.optionalFeatures }; navigator.xr.requestSession("immersive-vr", h).then(l) } else a.end() } } function r() { t.disabled = !0, t.style.display = "", t.style.cursor = "auto", t.style.left = "calc(50% - 75px)", t.style.width = "150px", t.onmouseenter = null, t.onmouseleave = null, t.onclick = null } function n() { r(), t.textContent = "VR NOT SUPPORTED" } function o(a) { a.style.position = "absolute", a.style.bottom = "20px", a.style.padding = "12px 6px", a.style.border = "1px solid #fff", a.style.borderRadius = "4px", a.style.background = "rgba(0,0,0,0.1)", a.style.color = "#fff", a.style.font = "normal 13px sans-serif", a.style.textAlign = "center", a.style.opacity = "0.5", a.style.outline = "none", a.style.zIndex = "999" } if ("xr" in navigator) return t.id = "VRButton", t.style.display = "none", o(t), navigator.xr.isSessionSupported("immersive-vr").then(function (a) { a ? s() : n(), IS.xrSessionIsGranted && (console.log("XR session is granted - will enter immersive web now"), t.click()) }), t; { const a = document.createElement("a"); return window.isSecureContext === !1 ? (a.href = document.location.href.replace(/^http:/, "https:"), a.innerHTML = "WEBXR NEEDS HTTPS") : (a.href = "https://immersiveweb.dev/", a.innerHTML = "WEBXR NOT AVAILABLE"), a.style.left = "calc(50% - 90px)", a.style.width = "180px", a.style.textDecoration = "none", o(a), a } } static registerSessionGrantedListener() { if ("xr" in navigator) { if (/WebXRViewer\//i.test(navigator.userAgent)) return; navigator.xr.addEventListener("sessiongranted", () => { IS.xrSessionIsGranted = !0 }) } } }; let TS = IS; u(TS, "xrSessionIsGranted", !1), TS.registerSessionGrantedListener(); const Ny = "noVoip", jr = oe("debugvoip"), uY = oe("voip"); class dY { constructor(e) { u(this, "id"), this.id = e } } class pY { constructor(e, t, s, r) { u(this, "peer"), u(this, "voip"), u(this, "userId"), u(this, "peerId"), u(this, "call", null), u(this, "callErrorListener", null), u(this, "stream", null), this.voip = e, this.peer = t, this.userId = s, this.peerId = r } close() { var e; jr && console.log("close voip call"), this.callErrorListener && this.peer.off("error", this.callErrorListener), this.call && this.call.open && this.call.close(), (e = this.stream) == null || e.getTracks().forEach(function (t) { t.stop() }) } updateMute(e) { var t; if (!this.stream) return; const s = (t = this.stream) == null ? void 0 : t.getAudioTracks(); for (const r of s) r.enabled = !e } async startVoipCall() { if (!await Il.HasMicrophonePermissions()) { console.warn("no permission to use microphone, can not start call"); return } jr && console.log("start voip call"), this.stream = await navigator.mediaDevices.getUserMedia({ audio: !0, video: !1 }), this.updateMute(this.voip.muteOutput), jr && console.log(this.stream), this.call = this.peer.call(this.peerId, this.stream, { metadata: { userId: this.userId } }), this.call.on("error", e => { console.error(e) }), this.call.on("stream", e => { jr && console.log("received stream from remote again", e) }), this.peer.on("close", this.onCallClose.bind(this)), this.callErrorListener = e => { var t; e.message.includes(this.peerId) ? (console.log("Could not connect to " + this.peerId), this.callErrorListener && this.peer.off("error", this.callErrorListener), this.call && this.call.close(), (t = this.stream) == null || t.getTracks().forEach(function (s) { s.stop() }), this.stream = null) : console.error(e) }, this.peer.on("error", this.callErrorListener) } onCallClose(e) { jr && console.log("call closed", e) } } class fY { constructor(e, t, s) { u(this, "voip"), u(this, "call"), u(this, "audio", null), u(this, "stream", null), u(this, "obj"), u(this, "analyzer", null), u(this, "waitingForStart", !1), u(this, "closed", !1), u(this, "audioElement", null), this.voip = e, this.obj = t, this.call = s } get currentStream() { return this.stream } get currentAudio() { return this.audio } get currentAnalyzer() { return this.analyzer } openAudioStream(e) { const t = e.getAudioTracks(); for (const s of t) if (s.kind === "audio" && s.readyState === "live") { this.open(s); return } console.warn("failed finding valid audio stream to begin call") } open(e) { console.assert(e.kind === "audio", "invalid track kind, expected audio but received " + e.kind), !this.waitingForStart && (this.waitingForStart = !0, ss.userInteractionRegistered || jr && console.log("Incoming call, waiting for user interaction before opening audio"), ss.registerWaitForAllowAudio(async () => { if (this.call.open && !this.closed) { jr && console.log("Setup audio and begin listening"), this.stream = new MediaStream([e]); const t = new $w; this.audio = new t0(t), this.audio.setVolume(this.voip.muteInput ? 0 : 1), this.audio.setMediaStreamSource(this.stream); const s = document.createElement("audio"); this.audioElement = s, s.style.display = "none", document.body.appendChild(s), s.srcObject = this.stream, s.sinkId !== void 0 && navigator.mediaDevices.enumerateDevices().then(r => { if (s) { console.log(r); for (const n of r) if (n.label === "Speakerphone") { s.sinkId = n.deviceId; break } } }), jr && console.log("call is setup, you should hear something now"), this.analyzer = new UP(this.audio, 32) } })) } close() { var e, t, s; this.closed = !0, (e = this.call) != null && e.open && this.call.close(), (t = this.audio) == null || t.disconnect(), (s = this.stream) == null || s.getTracks().forEach(r => { r.stop() }), this.stream = null, this.audioElement && this.audioElement.remove() } } class Il extends Ee { constructor() { super(...arguments), u(this, "requireParam", !1), u(this, "peer", null), u(this, "model", null), u(this, "connections", {}), u(this, "currentIncomingCalls", {}), u(this, "_inputMuted", !1), u(this, "_outputMuted", !1) } set muteInput(e) { var t; if (e === this._inputMuted || (this._inputMuted = e, !this.currentIncomingCalls)) return; const s = this._inputMuted ? 0 : 1; for (const r in this.currentIncomingCalls) { const n = this.currentIncomingCalls[r]; (t = n?.currentAudio) == null || t.setVolume(s) } } get muteInput() { return this._inputMuted } set muteOutput(e) { if (e !== this._outputMuted && (this._outputMuted = e, !!this.connections)) for (const t in this.connections) { const s = this.connections[t]; s?.updateMute(e) } } get muteOutput() { return this._outputMuted } getFrequency(e) { if (e === null) { for (const s in this.currentIncomingCalls) { const r = this.currentIncomingCalls[s]; if (r && r.currentAnalyzer) return r.currentAnalyzer.getAverageFrequency() } return null } const t = this.currentIncomingCalls[e]; return t && t.currentAnalyzer ? t.currentAnalyzer.getAverageFrequency() : null } awake() { if (oe(Ny)) { console.log("VOIP is disabled by url parameter: " + Ny); return } if (this.requireParam && !uY) { console.debug("VOIP must be enabled explicitly by url parameter"); return } if (of() && Sa()) { console.log("VOIP is currently not supported on Safari iOS"); return } this.peer = new U0, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia, this.context.connection.beginListen(Li.JoinedRoom, e => { navigator.mediaDevices.getUserMedia({ audio: !0, video: !1 }) }), this.context.connection.beginListen("peer-update-id", e => { if (e.id !== this.context.connection.connectionId) { const t = this.connections[e.id]; if (t && t.close(), this.peer && this.context.connection.connectionId) { const s = new pY(this, this.peer, this.context.connection.connectionId, e.peerId); this.connections[e.id] = s, s.startVoipCall() } } }), this.context.connection.beginListen(Li.UserLeftRoom, e => { const { userId: t } = e, s = this.connections[t]; this.connections[t] = null, s && s.close(); const r = this.currentIncomingCalls[t]; jr && console.log("UserLeftRoom", e, t, r), r && (r.close(), this.currentIncomingCalls[t] = null) }), this.peer.on("open", this.onOpenPeerConnection.bind(this)) } onEnable() { } onDisable() { console.log("TODO: close all"); for (const e in this.currentIncomingCalls) try { const t = this.currentIncomingCalls[e]; t?.close(); const s = this.connections[e]; s?.close() } catch (t) { console.error(t) } } async onOpenPeerConnection(e) { jr && console.log("Peer connection established and received id"), this.model = new dY(e), this.context.connection.send("peer-update-id", this.model, Lr.OnRoomJoin), this.peer && (this.peer.on("call", this.onReceiveCall.bind(this)), this.peer.on("connection", function (t) { jr && console.log("CONNECTION", t), t.on("data", function (s) { jr && console.log("Received", s) }) })) } async onReceiveCall(e) { const { metadata: t } = e; console.assert(t.userId); const { userId: s } = t, r = this.currentIncomingCalls[s]; if (r && r.close(), jr && console.log("received call"), await Il.HasMicrophonePermissions()) { const n = await navigator.mediaDevices.getUserMedia({ audio: !0, video: !1 }); e.answer(n) } else e.answer(null); this.currentIncomingCalls[s] = new fY(this, this.gameObject, e), e.on("stream", n => { var o; jr && console.log("receive caller stream, will setup audio now"), (o = this.currentIncomingCalls[s]) == null || o.openAudioStream(n) }), e.on("error", console.error) } static async HasMicrophonePermissions() { return (await navigator.permissions.query({ name: "microphone" })).state !== "denied" } } var gY = Object.defineProperty, mY = Object.getOwnPropertyDescriptor, LL = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? mY(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && gY(e, t, r), r }; class Cc extends Ee { constructor() { super(...arguments), u(this, "webAR", null), u(this, "invertForward", !1), u(this, "_initalMatrix", new He), u(this, "_selectStartFn", this.onSelectStart.bind(this)), u(this, "_selectEndFn", this.onSelectEnd.bind(this)), u(this, "_arScale", 5), u(this, "_rig", null), u(this, "_startPose", null), u(this, "_placementPose", null), u(this, "_isTouching", !1), u(this, "_rigStartPose", null), u(this, "_gotFirstHitTestResult", !1) } get rig() { var e; return (e = this.webAR) == null ? void 0 : e.webxr.Rig } get arScale() { return this._arScale } set arScale(e) { e !== this._arScale && (this._arScale = e, this.setScale(e)) } start() { const e = $.findObjectOfType(wt); e && (e.Rig.updateMatrix(), this._initalMatrix.copy(e.Rig.matrix)) } onBegin(e) { var t; this._placementPose = null, this.gameObject.visible = !1, this.gameObject.matrixAutoUpdate = !1, this._startPose = this.gameObject.matrix.clone(), this._rigStartPose = (t = this.rig) == null ? void 0 : t.matrix.clone(), this._gotFirstHitTestResult = !1, e.addEventListener("selectstart", this._selectStartFn), e.addEventListener("selectend", this._selectEndFn), this.gameObject.visible = !1, this.rig && (this.rig.matrixAutoUpdate = !0, this._initalMatrix.decompose(this.rig.position, this.rig.quaternion, this.rig.scale)), this.dispatchEvent(new CustomEvent("onBeginSession")) } onUpdate(e, t, s) { if (s && !this._placementPose && (this._gotFirstHitTestResult || (this._gotFirstHitTestResult = !0, this.dispatchEvent(new CustomEvent("canPlaceSession", { detail: { pose: s } }))), this._isTouching)) { const r = new He().fromArray(s.transform.matrix).invert(); return this.dispatchEvent(new CustomEvent("placedSession", { detail: { pose: s, poseMatrix: r } })), this.webAR && this.webAR.setReticleActive(!1), this.placeAt(e, r), !0 } return !1 } placeAt(e, t) { this._placementPose || (this._placementPose = new He), this._placementPose.copy(t); const s = this.gameObject.matrixWorld.clone().invert(); if (this._placementPose.premultiply(s), e) { if (this.invertForward) { const r = new He().makeRotationY(Math.PI); this._placementPose.premultiply(r) } this._rig = e, this.setScale(this.arScale) } else this._rig = null; this.gameObject.visible = !0 } onEnd(e, t) { this._placementPose = null, this.gameObject.visible = !1, this.gameObject.matrixAutoUpdate = !1, this._startPose && this.gameObject.matrix.copy(this._startPose), e && (e.matrixAutoUpdate = !0, this._rigStartPose && this._rigStartPose.decompose(e.position, e.quaternion, e.scale)), Xr.markDirty(this.gameObject, !0), setTimeout(() => { this.gameObject.matrixAutoUpdate = !0, this.gameObject.visible = !0 }, 100) } onSelectStart() { this._isTouching = !0 } onSelectEnd() { this._isTouching = !1 } setScale(e) { const t = this._rig; !t || !this._placementPose || (this._rigStartPose || (this._rigStartPose = t.matrix.clone()), t.matrixAutoUpdate = !1, t.matrix.multiplyMatrices(new He().makeScale(e, e, e), this._placementPose), t.matrix.decompose(t.position, t.quaternion, t.scale), t.updateMatrixWorld(), console.log("Place", t.position)) } } LL([x()], Cc.prototype, "invertForward", 2), LL([x()], Cc.prototype, "arScale", 1); const vY = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/"; class AY { constructor(e, t, s, r, n = null) { this.controller = t, this.handModel = e, this.bones = [], n === null && (n = new Sd, n.setPath(s || vY)), n.load(`${r}.glb`, o => { const a = o.scene.children[0]; this.handModel.add(a), a.layers.mask = this.handModel.layers.mask; const l = a.getObjectByProperty("type", "SkinnedMesh"); l.frustumCulled = !1, l.castShadow = !0, l.receiveShadow = !0, ["wrist", "thumb-metacarpal", "thumb-phalanx-proximal", "thumb-phalanx-distal", "thumb-tip", "index-finger-metacarpal", "index-finger-phalanx-proximal", "index-finger-phalanx-intermediate", "index-finger-phalanx-distal", "index-finger-tip", "middle-finger-metacarpal", "middle-finger-phalanx-proximal", "middle-finger-phalanx-intermediate", "middle-finger-phalanx-distal", "middle-finger-tip", "ring-finger-metacarpal", "ring-finger-phalanx-proximal", "ring-finger-phalanx-intermediate", "ring-finger-phalanx-distal", "ring-finger-tip", "pinky-finger-metacarpal", "pinky-finger-phalanx-proximal", "pinky-finger-phalanx-intermediate", "pinky-finger-phalanx-distal", "pinky-finger-tip"].forEach(c => { const h = a.getObjectByName(c); h !== void 0 ? h.jointName = c : console.warn(`Couldn't find ${c} in ${r} hand mesh`), this.bones.push(h) }) }) } updateMesh() { const e = this.controller.joints; for (let t = 0; t < this.bones.length; t++) { const s = this.bones[t]; if (s) { const r = e[s.jointName]; if (r.visible) { const n = r.position; s.position.copy(n), s.quaternion.copy(r.quaternion) } } } } } const yY = .01, bY = "index-finger-tip"; class _Y extends Me { constructor(e, t = null) { super(), this.controller = e, this.motionController = null, this.envMap = null, this.loader = t, this.mesh = null, e.addEventListener("connected", s => { const r = s.data; r.hand && !this.motionController && (this.xrInputSource = r, this.motionController = new AY(this, e, this.path, r.handedness, this.loader)) }), e.addEventListener("disconnected", () => { this.clear(), this.motionController = null }) } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.motionController && this.motionController.updateMesh() } getPointerPosition() { const e = this.controller.joints[bY]; return e ? e.position : null } intersectBoxObject(e) { const t = this.getPointerPosition(); if (t) { const s = new Po(t, yY), r = new er().setFromObject(e); return s.intersectsBox(r) } else return !1 } checkButton(e) { this.intersectBoxObject(e) ? e.onPress() : e.onClear(), e.isPressed() && e.whilePressed() } } const xY = .05, FL = .02, zy = .01, UL = .02, NL = 1, qd = .4, wY = .002, jg = .01, jy = .003, zL = .035, vi = 16, On = 12, RS = 110, CY = new S(0, 1, 0), SY = new S(0, 0, 1), EY = .02, MY = 1.5; class IY extends Me { constructor(e, t) { super(), this.hand = e, this.controller = t, this.motionController = null, this.envMap = null, this.mesh = null, this.pointerGeometry = null, this.pointerMesh = null, this.pointerObject = null, this.pinched = !1, this.attached = !1, this.cursorObject = null, this.raycaster = null, e.addEventListener("connected", s => { const r = s.data; r.hand && (this.visible = !0, this.xrInputSource = r, this.pointerObject === null && this.createPointer()) }) } _drawVerticesRing(e, t, s) { const r = t.clone(); for (let n = 0; n < vi; n++) { r.applyAxisAngle(SY, Math.PI * 2 / vi); const o = s * vi + n; e[3 * o] = r.x, e[3 * o + 1] = r.y, e[3 * o + 2] = r.z } } _updatePointerVertices(e) { const t = this.pointerGeometry.attributes.position.array, s = new S(wY, 0, -1 * (zL - e)); this._drawVerticesRing(t, s, 0); const r = new S(Math.sin(Math.PI * RS / 180) * e, Math.cos(Math.PI * RS / 180) * e, 0); for (let c = 0; c < On; c++)this._drawVerticesRing(t, r, c + 1), r.applyAxisAngle(CY, Math.PI * RS / 180 / (On * -2)); const n = vi * (1 + On), o = vi * (1 + On) + 1, a = new S(0, 0, -1 * (zL - e)); t[n * 3] = a.x, t[n * 3 + 1] = a.y, t[n * 3 + 2] = a.z; const l = new S(0, 0, e); t[o * 3] = l.x, t[o * 3 + 1] = l.y, t[o * 3 + 2] = l.z, this.pointerGeometry.setAttribute("position", new et(t, 3)) } createPointer() { let e, t; const s = new Array(((On + 1) * vi + 2) * 3).fill(0), r = []; for (this.pointerGeometry = new yt, this.pointerGeometry.setAttribute("position", new et(s, 3)), this._updatePointerVertices(jg), e = 0; e < On; e++) { for (t = 0; t < vi - 1; t++)r.push(e * vi + t, e * vi + t + 1, (e + 1) * vi + t), r.push(e * vi + t + 1, (e + 1) * vi + t + 1, (e + 1) * vi + t); r.push((e + 1) * vi - 1, e * vi, (e + 2) * vi - 1), r.push(e * vi, (e + 1) * vi, (e + 2) * vi - 1) } const n = vi * (1 + On), o = vi * (1 + On) + 1; for (e = 0; e < vi - 1; e++)r.push(n, e + 1, e), r.push(o, e + vi * On, e + vi * On + 1); r.push(n, 0, vi - 1), r.push(o, vi * (On + 1) - 1, vi * On); const a = new di; a.transparent = !0, a.opacity = qd, this.pointerGeometry.setIndex(r), this.pointerMesh = new ye(this.pointerGeometry, a), this.pointerMesh.position.set(0, 0, -1 * jg), this.pointerObject = new Me, this.pointerObject.add(this.pointerMesh), this.raycaster = new hd; const l = new Zn(EY, 10, 10), c = new di; c.transparent = !0, c.opacity = qd, this.cursorObject = new ye(l, c), this.pointerObject.add(this.cursorObject), this.add(this.pointerObject), this.pointerObject.layers.mask = this.layers.mask, this.pointerMesh.layers.mask = this.layers.mask } _updateRaycaster() { if (this.raycaster) { const e = this.pointerObject.matrixWorld, t = new He; t.identity().extractRotation(e), this.raycaster.ray.origin.setFromMatrixPosition(e), this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(t) } } _updatePointer() { this.pointerObject.visible = this.controller.visible; const e = this.hand.joints["index-finger-tip"], t = this.hand.joints["thumb-tip"], s = e.position.distanceTo(t.position), r = e.position.clone().add(t.position).multiplyScalar(.5); this.pointerObject.position.copy(r), this.pointerObject.quaternion.copy(this.controller.quaternion), this.pinched = s <= FL; const n = (s - zy) / (xY - zy), o = (s - zy) / (FL - zy); if (n > 1) this._updatePointerVertices(jg), this.pointerMesh.position.set(0, 0, -1 * jg), this.pointerMesh.material.opacity = qd; else if (n > 0) { const a = (jg - jy) * n + jy; this._updatePointerVertices(a), o < 1 ? (this.pointerMesh.position.set(0, 0, -1 * a - (1 - o) * UL), this.pointerMesh.material.opacity = qd + (1 - o) * (NL - qd)) : (this.pointerMesh.position.set(0, 0, -1 * a), this.pointerMesh.material.opacity = qd) } else this._updatePointerVertices(jy), this.pointerMesh.position.set(0, 0, -1 * jy - UL), this.pointerMesh.material.opacity = NL; this.cursorObject.material.opacity = this.pointerMesh.material.opacity } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.pointerGeometry && (this._updatePointer(), this._updateRaycaster()) } isPinched() { return this.pinched } setAttached(e) { this.attached = e } isAttached() { return this.attached } intersectObject(e, t = !0) { if (this.raycaster) return this.raycaster.intersectObject(e, t) } intersectObjects(e, t = !0) { if (this.raycaster) return this.raycaster.intersectObjects(e, t) } checkIntersections(e, t = !1) { if (this.raycaster && !this.attached) { const s = this.raycaster.intersectObjects(e, t), r = new S(0, 0, -1); if (s.length > 0) { const n = s[0].distance; this.cursorObject.position.copy(r.multiplyScalar(n)) } else this.cursorObject.position.copy(r.multiplyScalar(MY)) } } setCursor(e) { const t = new S(0, 0, -1); this.raycaster && !this.attached && this.cursorObject.position.copy(t.multiplyScalar(e)) } } const Ni = { Handedness: Object.freeze({ NONE: "none", LEFT: "left", RIGHT: "right" }), ComponentState: Object.freeze({ DEFAULT: "default", TOUCHED: "touched", PRESSED: "pressed" }), ComponentProperty: Object.freeze({ BUTTON: "button", X_AXIS: "xAxis", Y_AXIS: "yAxis", STATE: "state" }), ComponentType: Object.freeze({ TRIGGER: "trigger", SQUEEZE: "squeeze", TOUCHPAD: "touchpad", THUMBSTICK: "thumbstick", BUTTON: "button" }), ButtonTouchThreshold: .05, AxisTouchThreshold: .1, VisualResponseProperty: Object.freeze({ TRANSFORM: "transform", VISIBILITY: "visibility" }) }; async function jL(i) { const e = await fetch(i); if (e.ok) return e.json(); throw new Error(e.statusText) } async function TY(i) { if (!i) throw new Error("No basePath supplied"); return await jL(`${i}/profilesList.json`) } async function RY(i, e, t = null, s = !0) { if (!i) throw new Error("No xrInputSource supplied"); if (!e) throw new Error("No basePath supplied"); const r = await TY(e); let n; if (i.profiles.some(l => { const c = r[l]; return c && (n = { profileId: l, profilePath: `${e}/${c.path}`, deprecated: !!c.deprecated }), !!n }), !n) { if (!t) throw new Error("No matching profile name found"); const l = r[t]; if (!l) throw new Error(`No matching profile name found and default profile "${t}" missing.`); n = { profileId: t, profilePath: `${e}/${l.path}`, deprecated: !!l.deprecated } } const o = await jL(n.profilePath); let a; if (s) { let l; if (i.handedness === "any" ? l = o.layouts[Object.keys(o.layouts)[0]] : l = o.layouts[i.handedness], !l) throw new Error(`No matching handedness, ${i.handedness}, in profile ${n.profileId}`); l.assetPath && (a = n.profilePath.replace("profile.json", l.assetPath)) } return { profile: o, assetPath: a } } const PY = { xAxis: 0, yAxis: 0, button: 0, state: Ni.ComponentState.DEFAULT }; function BY(i = 0, e = 0) { let t = i, s = e; if (Math.sqrt(i * i + e * e) > 1) { const r = Math.atan2(e, i); t = Math.cos(r), s = Math.sin(r) } return { normalizedXAxis: t * .5 + .5, normalizedYAxis: s * .5 + .5 } } class kY { constructor(e) { this.componentProperty = e.componentProperty, this.states = e.states, this.valueNodeName = e.valueNodeName, this.valueNodeProperty = e.valueNodeProperty, this.valueNodeProperty === Ni.VisualResponseProperty.TRANSFORM && (this.minNodeName = e.minNodeName, this.maxNodeName = e.maxNodeName), this.value = 0, this.updateFromComponent(PY) } updateFromComponent({ xAxis: e, yAxis: t, button: s, state: r }) { const { normalizedXAxis: n, normalizedYAxis: o } = BY(e, t); switch (this.componentProperty) { case Ni.ComponentProperty.X_AXIS: this.value = this.states.includes(r) ? n : .5; break; case Ni.ComponentProperty.Y_AXIS: this.value = this.states.includes(r) ? o : .5; break; case Ni.ComponentProperty.BUTTON: this.value = this.states.includes(r) ? s : 0; break; case Ni.ComponentProperty.STATE: this.valueNodeProperty === Ni.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(r) : this.value = this.states.includes(r) ? 1 : 0; break; default: throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`) } } } class DY { constructor(e, t) { if (!e || !t || !t.visualResponses || !t.gamepadIndices || Object.keys(t.gamepadIndices).length === 0) throw new Error("Invalid arguments supplied"); this.id = e, this.type = t.type, this.rootNodeName = t.rootNodeName, this.touchPointNodeName = t.touchPointNodeName, this.visualResponses = {}, Object.keys(t.visualResponses).forEach(s => { const r = new kY(t.visualResponses[s]); this.visualResponses[s] = r }), this.gamepadIndices = Object.assign({}, t.gamepadIndices), this.values = { state: Ni.ComponentState.DEFAULT, button: this.gamepadIndices.button !== void 0 ? 0 : void 0, xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0, yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0 } } get data() { return { id: this.id, ...this.values } } updateFromGamepad(e) { if (this.values.state = Ni.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && e.buttons.length > this.gamepadIndices.button) { const t = e.buttons[this.gamepadIndices.button]; this.values.button = t.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, t.pressed || this.values.button === 1 ? this.values.state = Ni.ComponentState.PRESSED : (t.touched || this.values.button > Ni.ButtonTouchThreshold) && (this.values.state = Ni.ComponentState.TOUCHED) } this.gamepadIndices.xAxis !== void 0 && e.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = e.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === Ni.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Ni.AxisTouchThreshold && (this.values.state = Ni.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && e.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = e.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === Ni.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Ni.AxisTouchThreshold && (this.values.state = Ni.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach(t => { t.updateFromComponent(this.values) }) } } class OY { constructor(e, t, s) { if (!e) throw new Error("No xrInputSource supplied"); if (!t) throw new Error("No profile supplied"); this.xrInputSource = e, this.assetUrl = s, this.id = t.profileId, this.layoutDescription = t.layouts[e.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach(r => { const n = this.layoutDescription.components[r]; this.components[r] = new DY(r, n) }), this.updateFromGamepad() } get gripSpace() { return this.xrInputSource.gripSpace } get targetRaySpace() { return this.xrInputSource.targetRaySpace } get data() { const e = []; return Object.values(this.components).forEach(t => { e.push(t.data) }), e } updateFromGamepad() { Object.values(this.components).forEach(e => { e.updateFromGamepad(this.xrInputSource.gamepad) }) } } const LY = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", FY = "generic-trigger"; class UY extends Me { constructor() { super(), this.motionController = null, this.envMap = null } setEnvironmentMap(e) { return this.envMap == e ? this : (this.envMap = e, this.traverse(t => { t.isMesh && (t.material.envMap = this.envMap, t.material.needsUpdate = !0) }), this) } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach(t => { Object.values(t.visualResponses).forEach(s => { const { valueNode: r, minNode: n, maxNode: o, value: a, valueNodeProperty: l } = s; r && (l === Ni.VisualResponseProperty.VISIBILITY ? r.visible = a : l === Ni.VisualResponseProperty.TRANSFORM && (r.quaternion.slerpQuaternions(n.quaternion, o.quaternion, a), r.position.lerpVectors(n.position, o.position, a))) }) })) } } function NY(i, e) { Object.values(i.components).forEach(t => { const { type: s, touchPointNodeName: r, visualResponses: n } = t; if (s === Ni.ComponentType.TOUCHPAD) if (t.touchPointNode = e.getObjectByName(r), t.touchPointNode) { const o = new Zn(.001), a = new di({ color: 255 }), l = new ye(o, a); t.touchPointNode.add(l) } else console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`); Object.values(n).forEach(o => { const { valueNodeName: a, minNodeName: l, maxNodeName: c, valueNodeProperty: h } = o; if (h === Ni.VisualResponseProperty.TRANSFORM) { if (o.minNode = e.getObjectByName(l), o.maxNode = e.getObjectByName(c), !o.minNode) { console.warn(`Could not find ${l} in the model`); return } if (!o.maxNode) { console.warn(`Could not find ${c} in the model`); return } } o.valueNode = e.getObjectByName(a), o.valueNode || console.warn(`Could not find ${a} in the model`) }) }) } function QL(i, e) { NY(i.motionController, e), i.envMap && e.traverse(t => { t.isMesh && (t.material.envMap = i.envMap, t.material.needsUpdate = !0) }), i.layers.mask != 0 && e.traverse(t => { t.layers.mask = i.layers.mask }), i.add(e) } class zY { constructor(e = null) { this.gltfLoader = e, this.path = LY, this._assetCache = {}, this.gltfLoader || (this.gltfLoader = new Sd) } createControllerModel(e) { const t = new UY; let s = null; return e.addEventListener("connected", r => { const n = r.data; n.targetRayMode !== "tracked-pointer" || !n.gamepad || RY(n, this.path, FY).then(({ profile: o, assetPath: a }) => { t.motionController = new OY(n, o, a); const l = this._assetCache[t.motionController.assetUrl]; if (l) s = l.scene.clone(), QL(t, s); else { if (!this.gltfLoader) throw new Error("GLTFLoader not set."); this.gltfLoader.setPath(""), this.gltfLoader.load(t.motionController.assetUrl, c => { this._assetCache[t.motionController.assetUrl] = c, s = c.scene.clone(), QL(t, s) }, null, () => { throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`) }) } }).catch(o => { console.warn(o) }) }), e.addEventListener("disconnected", () => { t.motionController = null, t.remove(s), s = null }), t } } const Qg = oe("debugavatar"); class Qy { constructor(e, t, s, r) { u(this, "root"), u(this, "head"), u(this, "leftHand"), u(this, "rigthHand"); var n; this.root = e, this.head = t, this.leftHand = s, this.rigthHand = r, (n = this.root) == null || n.traverse(o => o.layers.set(2)) } get isValid() { return this.head !== null && this.head !== void 0 } } class Gy { constructor() { u(this, "avatarRegistryUrl", null) } async getOrCreateNewAvatarInstance(e, t) { if (!t) return console.error("Can not create avatar: failed to provide id or root object"), null; let s = null; if (typeof t == "string") { if (s = await this.loadAvatar(e, t), !s) { const n = new No; s = $.instantiate(Cu(t, e.scene), n) } } else s = t; if (!s) return null; const r = this.findAvatar(s); return r.isValid ? (Qg && console.log("[Custom Avatar] valid config", t, Qg ? r : ""), r) : (console.warn("[Custom Avatar] config isn't valid", t, Qg ? r : ""), null) } async loadAvatar(e, t) { if (console.assert(t != null && typeof t == "string", "Avatar id must not be null"), t.length <= 0 || !t) return null; if (Qg && console.log("[Custom Avatar] " + t + ", loading..."), t.endsWith(".glb") || (t += ".glb"), this.avatarRegistryUrl === null) { const r = await fetch("./" + t); let n = null; if (r.ok) { const a = await r.blob(); a && (n = await a.arrayBuffer()) } if (!n && (n = await hC(t, t, 0, "no url here go away", !0), !n)) return null; const o = await fo().parseSync(e, n, null, 0); return o?.scene ?? null } const s = new Sd; return wg(s, e), new Promise((r, n) => { const o = this.avatarRegistryUrl + "/" + t; s.load(o, async a => { await fo().createBuiltinComponents(e, o, a, null, void 0), r(a.scene) }, a => { Qg && console.log("[Custom Avatar] " + a.loaded / a.total * 100 + "% loaded of " + a.total / 1024 + "kB") }, a => { console.error("[Custom Avatar] Error when loading: " + a), r(null) }) }) } cacheModel(e, t) { } findAvatar(e) { const t = e; let s = t; s.children.length == 1 && (s = e.children[0]); let r = this.findAvatarPart(s, ["head"]); const n = this.findAvatarPart(s, ["left", "hand"]), o = this.findAvatarPart(s, ["right", "hand"]); if (!r) { r = t; const a = new S; new er().setFromObject(r).getSize(a); const l = Math.max(a.x, a.y, a.z); console.warn("[Custom Avatar] Normalizing head scale, it's too big: " + l + " meters! Should be < 0.3m"), l > .3 && r.scale.multiplyScalar(1 / l * .3) } return new Qy(t, r, n, o) } findAvatarPart(e, t) { const s = e.name.toLowerCase(); let r = !0; for (const n of t) { if (!r) break; s.indexOf(n) === -1 && (r = !1) } if (r) return e; if (e.children) for (const n of e.children) { const o = this.findAvatarPart(n, t); if (o) return o } return null } handleCustomAvatarErrors(e) { if (!e.ok) throw Error(e.statusText); return e } } const Xd = oe("debugflags"); var rs = (i => (i[i.Never = 0] = "Never", i[i.Browser = 1] = "Browser", i[i.AR = 2] = "AR", i[i.VR = 4] = "VR", i[i.FirstPerson = 8] = "FirstPerson", i[i.ThirdPerson = 16] = "ThirdPerson", i[i.All = 4294967295] = "All", i))(rs || {}); const GL = class { constructor() { u(this, "Mask", 17) } Has(i) { return (this.Mask & i) !== 0 } Set(i) { Xd && console.warn("Set XR flag state to", i), this.Mask = i, Sr.Apply() } Enable(i) { this.Mask |= i, Sr.Apply() } Disable(i) { this.Mask &= ~i, Sr.Apply() } Toggle(i) { this.Mask ^= i, Sr.Apply() } EnableAll() { this.Mask = -1, Sr.Apply() } DisableAll() { this.Mask = 0, Sr.Apply() } }; let Xo = GL; u(Xo, "Global", new GL); const ol = class extends Ee { constructor() { super(...arguments), u(this, "visibleIn") } static Apply() { for (const i of this.registry) i.UpdateVisible(Xo.Global) } awake() { ol.registry.push(this) } onEnable() { ol.firstApply ? this.UpdateVisible(Xo.Global) : (ol.firstApply = !0, ol.Apply()) } onDestroy() { const i = ol.registry.indexOf(this); i >= 0 && ol.registry.splice(i, 1) } get isOn() { return this.gameObject.visible } UpdateVisible(i = null) { let e; const t = i; t && typeof t == "number" && (console.assert(typeof t == "number", "XRFlag.UpdateVisible: state must be a number", t), Xd && console.log(t), ol.buffer.Mask = t, i = ol.buffer); const s = i; if (s ? (Xd && console.warn(this.name, "use passed in mask", s.Mask, this.visibleIn), e = s.Has(this.visibleIn)) : (Xd && console.log(this.name, "use global mask"), Xo.Global.Has(this.visibleIn)), e !== void 0) if (e) Xd && console.log(this.name, "is visible", this.gameObject.uuid), $.setActive(this.gameObject, !0); else { if (Xd && console.log(this.name, "is not visible", this.gameObject.uuid), !this.gameObject.visible) return; this.gameObject.visible = !1 } } }; let Sr = ol; u(Sr, "registry", []), u(Sr, "firstApply"), u(Sr, "buffer", new Xo); const Sc = oe("debugavatar"), Yo = class extends Ee { constructor() { super(...arguments), u(this, "connectionId"), u(this, "avatar") } static getAvatar(i) { return i >= 0 && i < Yo.instances.length ? Yo.instances[i] : null } static onAvatarMarkerCreated(i) { return Yo._onNewAvatarMarkerAdded.push(i), i } static onAvatarMarkerDestroyed(i) { return Yo._onAvatarMarkerDestroyed.push(i), i } awake() { Yo.instances.push(this), Sc && console.log(this); for (const i of Yo._onNewAvatarMarkerAdded) i({ avatarMarker: this, gameObject: this.gameObject }) } onDestroy() { Yo.instances.splice(Yo.instances.indexOf(this), 1); for (const i of Yo._onAvatarMarkerDestroyed) i({ avatarMarker: this, gameObject: this.gameObject }) } isLocalAvatar() { return this.connectionId === this.context.connection.connectionId } setVisible(i) { this.avatar && ("setVisible" in this.avatar ? this.avatar.setVisible(i) : $.setActive(this.avatar, i)) } }; let lr = Yo; u(lr, "instances", []), u(lr, "_onNewAvatarMarkerAdded", []), u(lr, "_onAvatarMarkerDestroyed", []); const Hy = class { constructor(i, e, t) { u(this, "_isVisible", !0), u(this, "guid"), u(this, "root", null), u(this, "head", null), u(this, "handLeft", null), u(this, "handRight", null), u(this, "lastUpdate", -1), u(this, "isLocalAvatar", !1), u(this, "flags", null), u(this, "headScale", new S(1, 1, 1)), u(this, "handLeftScale", new S(1, 1, 1)), u(this, "handRightScale", new S(1, 1, 1)), u(this, "webxr"), u(this, "lastAvatarId", null), u(this, "hasAvatarOverride", !1), u(this, "context"), u(this, "avatarMarker", null), u(this, "_headTarget", new Me), u(this, "_handLeftTarget", new Me), u(this, "_handRightTarget", new Me), u(this, "_canInterpolate", !1), this.context = i, this.guid = e, this.webxr = t, this.setupCustomAvatar(this.webxr.defaultAvatar) } setVisible(i) { this._isVisible = i, this.updateVisibility() } get isWebXRAvatar() { return !0 } updateFlags() { if (!this.flags) return; let i = this.isLocalAvatar ? rs.FirstPerson : rs.ThirdPerson; this.context.isInVR ? i |= rs.VR : this.context.isInAR ? i |= rs.AR : i |= rs.Browser; for (const e of this.flags) e.gameObject.visible = !0, e.UpdateVisible(i) } async setAvatarOverride(i) { return this.hasAvatarOverride = i !== null, this.hasAvatarOverride && this.lastAvatarId !== i && (this.lastAvatarId = i, i != null && i.length > 0) ? await this.setupCustomAvatar(i) : null } tryUpdate(i, e) { if (i.guid === this.guid && (this.lastAvatarId !== i.avatarId && i.avatarId && i.avatarId.length > 0 && (this.lastAvatarId = i.avatarId, this.setupCustomAvatar(i.avatarId)), this.lastUpdate = i.time, this.head)) { const t = this.webxr.IsInAR ? jo.Handheld : jo.Headset; let s = this.head; this.context.players.setPlayerView(i.guid, s, t), Xr.markDirty(this.head), this._canInterpolate = !0; const r = this.isLocalAvatar ? this.head : this._headTarget; if (r.position.set(i.position.x, i.position.y, i.position.z), r.quaternion.set(i.rotation.x, i.rotation.y, i.rotation.z, i.rotation.w), r.scale.set(i.scale, i.scale, i.scale), r.scale.multiply(this.headScale), this.handLeft) { const n = this.isLocalAvatar ? this.handLeft : this._handLeftTarget; n.position.set(i.posLeftHand.x, i.posLeftHand.y, i.posLeftHand.z), n.quaternion.set(i.rotLeftHand._x, i.rotLeftHand._y, i.rotLeftHand._z, i.rotLeftHand._w), n.quaternion.multiply(Hy.invertRotation), n.scale.set(i.scale, i.scale, i.scale), n.scale.multiply(this.handLeftScale), Xr.markDirty(this.handLeft) } if (this.handRight) { const n = this.isLocalAvatar ? this.handRight : this._handRightTarget; n.position.set(i.posRightHand.x, i.posRightHand.y, i.posRightHand.z), n.quaternion.set(i.rotRightHand._x, i.rotRightHand._y, i.rotRightHand._z, i.rotRightHand._w), n.quaternion.multiply(Hy.invertRotation), n.scale.set(i.scale, i.scale, i.scale), n.scale.multiply(this.handRightScale), Xr.markDirty(this.handRight) } } } update() { if (this.isLocalAvatar || !this._canInterpolate) return; const i = this.context.time.deltaTime / .1; this.head && (this.head.position.lerp(this._headTarget.position, i), this.head.quaternion.slerp(this._headTarget.quaternion, i), this.head.scale.lerp(this._headTarget.scale, i)), this.handLeft && this._handLeftTarget && (this.handLeft.position.lerp(this._handLeftTarget.position, i), this.handLeft.quaternion.slerp(this._handLeftTarget.quaternion, i), this.handLeft.scale.lerp(this._handLeftTarget.scale, i)), this.handRight && this._handRightTarget && (this.handRight.position.lerp(this._handRightTarget.position, i), this.handRight.quaternion.slerp(this._handRightTarget.quaternion, i), this.handRight.scale.lerp(this._handRightTarget.scale, i)) } destroy() { var i, e; Sc && console.log("Destroy avatar", this.guid), (i = this.root) == null || i.removeFromParent(), (e = this.avatarMarker) == null || e.destroy(), this.lastAvatarId = null, this.head && Er.Remove(this.context, this.head) } updateVisibility() { const i = this.root; i && $.setActive(i, this._isVisible) } async setupCustomAvatar(i) { var e, t, s; if (Sc && console.log("LOAD", i, this), !i || typeof i == "string" && i.length <= 0) return !1; this.head && Er.Remove(this.context, this.head); const r = i; if (r?.loadAssetAsync !== void 0) { await r.loadAssetAsync(); const o = r.asset; $.setActive(o, !1), i = $.instantiate(o), $.setActive(i, !0) } Sc && console.log(i); const n = await Hy.loader.getOrCreateNewAvatarInstance(this.context, i); if (Sc && console.log(n, n?.isValid, this.lastAvatarId, i), n != null && n.isValid) { if (this.root = n.root, this.root.position.set(0, 0, 0), this.root.quaternion.set(0, 0, 0, 1), this.root.scale.set(1, 1, 1), this.avatarMarker = $.addNewComponent(this.root, lr), this.avatarMarker.connectionId = this.guid, this.avatarMarker.avatar = this, this.head && this.head !== n.head && ((e = this.head) == null || e.removeFromParent()), this.head = n.head, this.headScale.copy(this.head.scale), this.head && !this.isLocalAvatar && Er.Add(this.context, this.head, this.avatarMarker), n.leftHand && ((t = this.handLeft) == null || t.removeFromParent()), this.handLeft = n.leftHand ?? this.handLeft, this.handLeft ? this.handLeftScale.copy(this.handLeft.scale) : this.handLeftScale.set(1, 1, 1), n.rigthHand && ((s = this.handRight) == null || s.removeFromParent()), this.handRight = n.rigthHand ?? this.handRight, this.handRight ? this.handRightScale.copy(this.handRight.scale) : this.handRightScale.set(1, 1, 1), this.context.scene.add(this.root), this.flags == null && (this.flags = []), this.flags.length = 0, this.flags.push(...$.getComponentsInChildren(this.root, Sr)), this.flags.length <= 0 && this.head) { const o = $.addNewComponent(this.head, Sr); o.visibleIn = rs.ThirdPerson | rs.VR, this.flags.push(o), Sc && console.log("Added flag to head: " + o.visibleIn, this.head.name) } return Sc && console.log("[Avatar], is Local? ", this.isLocalAvatar, this.root), this.updateFlags(), this.updateVisibility(), !0 } else return Sc && console.warn("build avatar failed"), !1 } }; let Ec = Hy; u(Ec, "loader", new Gy), u(Ec, "invertRotation", new we().setFromAxisAngle(new S(0, 1, 0), Math.PI)); class Er { static Add(e, t, s = null) { if (t) { for (const r of this.Pois) if (r.obj === t) return; this.Pois.push({ obj: t, avatar: s }), this.LastChangeTime = e.time.time } } static Remove(e, t) { var s; if (t) { for (const r of this.Pois) if (r.obj === t) { this.Pois.splice(this.Pois.indexOf(r), 1), this.LastChangeTime = e?.time.time ?? ((s = _t.Current) == null ? void 0 : s.time.time); return } } } } u(Er, "Pois", []), u(Er, "LastChangeTime", 0); class jY { constructor() { u(this, "guid"), u(this, "position", new S) } } class Gg extends Ee { constructor() { super(...arguments), u(this, "target", null), u(this, "avatar", null), u(this, "_model", null), u(this, "_targetModel", new jY), u(this, "_currentTargetObject", null), u(this, "_lastUpdateTime", 0), u(this, "_lookDuration", 0), u(this, "_lastPoiChangedTime", 0) } set controlledTarget(e) { this.target = e; const t = Q.get("MoveRandom"); if (t && this.target) { const s = $.getComponent(this.target, t); s && s.destroy() } } awake() { if (this.avatar = $.getComponentInParent(this.gameObject, lr), this.avatar) { const e = $.getComponentInParent(this.gameObject, lr); this._model = new z0(this.context.connection, this.guid), e != null && e.isLocalAvatar && this._model.requestOwnership() } this.context.connection.beginListen("avatar-look-target-changed", e => { var t; this.target && e && e.guid === ((t = this.avatar) == null ? void 0 : t.guid) && ts(this.target, e.position) }) } update() { var e; if ((!this.context.connection.isConnected || (e = this._model) != null && e.hasOwnership) && (Er.LastChangeTime !== this._lastPoiChangedTime && (this._lastPoiChangedTime = Er.LastChangeTime, this._lookDuration = 0), this.selectTarget(), this._currentTargetObject && this.context.time.frameCount % 10 === 0 && this.target)) { const t = xt(this._currentTargetObject); ts(this.target, t), this.context.connection.isConnected && this.avatar && (this.context.connection.send("avatar-look-target-changed", this._targetModel), this._targetModel.guid = this.avatar.guid, this._targetModel.position.copy(t)) } } selectTarget() { if (this.context.time.time - this._lastUpdateTime > this._lookDuration) { this._lastUpdateTime = this.context.time.time, this._lookDuration = Math.random() * .5 + .2; const e = Er.Pois; if (e.length > 0) { const t = e[Math.floor(Math.random() * e.length)]; if (t && t.obj) { if (t.avatar && t.avatar === this.avatar) return; this._currentTargetObject = t.obj } } } } } class Yd extends Ee { constructor() { super(...arguments), u(this, "canGrab", !0) } onPointerClick(e) { } } class Jd extends Ee { constructor() { super(...arguments), u(this, "isUsed", !0), u(this, "usedBy", null) } } var Jo = (i => (i[i.Average = 0] = "Average", i[i.Multiply = 1] = "Multiply", i[i.Minimum = 2] = "Minimum", i[i.Maximum = 3] = "Maximum", i))(Jo || {}), Vy = (i => (i[i.Discrete = 0] = "Discrete", i[i.Continuous = 1] = "Continuous", i))(Vy || {}), Yi = (i => (i[i.None = 0] = "None", i[i.FreezePositionX = 2] = "FreezePositionX", i[i.FreezePositionY = 4] = "FreezePositionY", i[i.FreezePositionZ = 8] = "FreezePositionZ", i[i.FreezePosition = 14] = "FreezePosition", i[i.FreezeRotationX = 16] = "FreezeRotationX", i[i.FreezeRotationY = 32] = "FreezeRotationY", i[i.FreezeRotationZ = 64] = "FreezeRotationZ", i[i.FreezeRotation = 112] = "FreezeRotation", i[i.FreezeAll = 126] = "FreezeAll", i))(Yi || {}), Kd = (i => (i[i.None = 0] = "None", i[i.X = 2] = "X", i[i.Y = 4] = "Y", i[i.Z = 8] = "Z", i[i.All = -1] = "All", i))(Kd || {}); const Ko = function (i, e) { return function (t, s, r) { QY(t, s, r, i, e) } }; function QY(i, e, t, s, r) { if (!(!r && !s && !i.onValidate)) { if (t !== void 0) { console.error("Invalid usage of validate decorator. Only fields can be validated.", i, e, t), Ls("Invalid usage of validate decorator. Only fields can be validated. Property: " + e, Ro.Error); return } if (i.__internalAwake) { const n = Symbol(e), o = i.__internalAwake; i.__internalAwake = function () { this[n] === void 0 && (this[n] = this[e], Object.defineProperty(this, e, { set: function (a) { var l; if (this[g1] === !0) this[n] = a; else { s?.call(this, a); const c = this[n]; this[n] = a, (l = this.onValidate) == null || l.call(this, e, c) } }, get: function () { return r?.call(this), this[n] } })), o.call(this) } } } } const GY = function (i) { return function (e, t, s) { const r = i.prototype, n = Object.getOwnPropertyDescriptor(r, t); if (!(n != null && n.value)) { console.warn("Can not apply prefix: type does not have method named", t, i); return } const o = n.value, a = e[t]; Object.defineProperty(r, t, { value: function (...l) { if (a?.call(this, ...l) !== !1) return o.call(this, ...l) } }) } }; var HY = Object.defineProperty, VY = Object.getOwnPropertyDescriptor, al = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? VY(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && HY(e, t, r), r }; class WY { constructor(e, t) { u(this, "positionChanged", !1), u(this, "rotationChanged", !1), u(this, "position"), u(this, "quaternion"), u(this, "_positionKeys", ["x", "y", "z"]), u(this, "_quaternionKeys", ["_x", "_y", "_z", "_w"]), u(this, "mute", !1), u(this, "context"), u(this, "obj"), u(this, "_positionWatch"), u(this, "_rotationWatch"), this.context = t, this.obj = e } get isDirty() { return this.positionChanged || this.rotationChanged } reset(e = !1) { if (this.positionChanged = !1, this.rotationChanged = !1, this.mute = !1, e) { if (this.position) for (const t of this._positionKeys) delete this.position[t]; if (this.quaternion) for (const t of this._quaternionKeys) delete this.quaternion[t] } } syncValues() { for (const e of this._positionKeys) this.position[e] = this.obj.position[e]; for (const e of this._quaternionKeys) this.quaternion[e] = this.obj.quaternion[e] } applyValues() { if (this.positionChanged && this.position) for (const e of this._positionKeys) { const t = this.position[e]; t !== void 0 && (this.obj.position[e] = t) } if (this.rotationChanged && this.quaternion) for (const e of this._quaternionKeys) { const t = this.quaternion[e]; t !== void 0 && (this.obj.quaternion[e] = t) } } start(e, t) { this.reset(), e && (this._positionWatch || (this._positionWatch = new qp(this.obj.position, ["x", "y", "z"])), this._positionWatch.apply(), this.position = {}, this._positionWatch.subscribeWrite((n, o) => { var a; if ((a = this.context.physics.engine) != null && a.isUpdating || this.mute) return; const l = this.position[o]; Math.abs(l - n) < 1e-5 || (this.position[o] = n, this.positionChanged = !0) })), t && (this._rotationWatch || (this._rotationWatch = new qp(this.obj.quaternion, ["_x", "_y", "_z", "_w"])), this._rotationWatch.apply(), this.quaternion = {}, this._rotationWatch.subscribeWrite((n, o) => { var a; if ((a = this.context.physics.engine) != null && a.isUpdating || this.mute) return; const l = this.quaternion[o]; Math.abs(l - n) < 1e-5 || (this.quaternion[o] = n, this.rotationChanged = !0) })); const s = this.obj.matrixWorld.multiplyMatrices.bind(this.obj.matrixWorld), r = new He; this.obj.matrixWorld.multiplyMatrices = (n, o) => (r.equals(n) || (this.positionChanged = !0, this.rotationChanged = !0, r.copy(n)), s(n, o)) } stop() { var e, t; (e = this._positionWatch) == null || e.revoke(), (t = this._rotationWatch) == null || t.revoke() } } var PS; const BS = (PS = class extends Ee { constructor() { super(...arguments), u(this, "mass", 1), u(this, "useGravity", !0), u(this, "constraints", Yi.None), u(this, "isKinematic", !1), u(this, "drag", 0), u(this, "angularDrag", 1), u(this, "detectCollisions", !0), u(this, "sleepThreshold", .01), u(this, "collisionDetectionMode", Vy.Discrete), u(this, "_gravityScale", 1), u(this, "_propertiesChanged", !1), u(this, "_currentVelocity", new S), u(this, "_smoothedVelocity", new S), u(this, "_smoothedVelocityGetter", new S), u(this, "_lastPosition", new S), u(this, "_watch") } get lockPositionX() { return (this.constraints & Yi.FreezePositionX) !== 0 } get lockPositionY() { return (this.constraints & Yi.FreezePositionY) !== 0 } get lockPositionZ() { return (this.constraints & Yi.FreezePositionZ) !== 0 } get lockRotationX() { return (this.constraints & Yi.FreezeRotationX) !== 0 } get lockRotationY() { return (this.constraints & Yi.FreezeRotationY) !== 0 } get lockRotationZ() { return (this.constraints & Yi.FreezeRotationZ) !== 0 } set lockPositionX(i) { i ? this.constraints |= Yi.FreezePositionX : this.constraints &= ~Yi.FreezePositionX } set lockPositionY(i) { i ? this.constraints |= Yi.FreezePositionY : this.constraints &= ~Yi.FreezePositionY } set lockPositionZ(i) { i ? this.constraints |= Yi.FreezePositionZ : this.constraints &= ~Yi.FreezePositionZ } set lockRotationX(i) { i ? this.constraints |= Yi.FreezeRotationX : this.constraints &= ~Yi.FreezeRotationX } set lockRotationY(i) { i ? this.constraints |= Yi.FreezeRotationY : this.constraints &= ~Yi.FreezeRotationY } set lockRotationZ(i) { i ? this.constraints |= Yi.FreezeRotationZ : this.constraints &= ~Yi.FreezeRotationZ } set gravityScale(i) { this._gravityScale = i } get gravityScale() { return this._gravityScale } awake() { this._watch = void 0, this._propertiesChanged = !1 } onEnable() { this._watch || (this._watch = new WY(this.gameObject, this.context)), this._watch.start(!0, !0), this.startCoroutine(this.beforePhysics(), on.LateUpdate) } onDisable() { var i, e; (i = this._watch) == null || i.stop(), (e = this.context.physics.engine) == null || e.removeBody(this) } onDestroy() { var i; (i = this.context.physics.engine) == null || i.removeBody(this) } onValidate() { this._propertiesChanged = !0 } *beforePhysics() { for (var i, e, t, s; ;)this._propertiesChanged && (this._propertiesChanged = !1, (i = this.context.physics.engine) == null || i.updateProperties(this)), (e = this._watch) != null && e.isDirty ? (this._watch.mute = !0, this._watch.applyValues(), (t = this.context.physics.engine) == null || t.updateBody(this, this._watch.positionChanged, this._watch.rotationChanged), this._watch.reset()) : (s = this._watch) == null || s.syncValues(), this.captureVelocity(), yield } teleport(i, e = !0) { var t; (t = this._watch) == null || t.reset(!0), e ? this.gameObject.position.set(i.x, i.y, i.z) : this.setWorldPosition(i.x, i.y, i.z), this.resetForcesAndTorques(), this.resetVelocities() } resetForces() { var i; (i = this.context.physics.engine) == null || i.resetForces(this, !0) } resetTorques() { var i; (i = this.context.physics.engine) == null || i.resetTorques(this, !0) } resetVelocities() { this.setVelocity(0, 0, 0), this.setAngularVelocity(0, 0, 0) } resetForcesAndTorques() { this.resetForces(), this.resetTorques() } wakeUp() { var i; (i = this.context.physics.engine) == null || i.wakeup(this) } applyForce(i, e) { var t; (t = this.context.physics.engine) == null || t.addForce(this, i, !0) } applyImpulse(i) { var e; (e = this.context.physics.engine) == null || e.applyImpulse(this, i, !0) } setForce(i, e, t) { var s, r; (s = this.context.physics.engine) == null || s.resetForces(this, !0), (r = this.context.physics.engine) == null || r.addForce(this, { x: i, y: e, z: t }, !0) } getVelocity() { var i; const e = (i = this.context.physics.engine) == null ? void 0 : i.getLinearVelocity(this); return e ? (this._currentVelocity.x = e.x, this._currentVelocity.y = e.y, this._currentVelocity.z = e.z, this._currentVelocity) : this._currentVelocity.set(0, 0, 0) } setVelocity(i, e, t) { var s, r; if (i instanceof S) { const n = i; (s = this.context.physics.engine) == null || s.setLinearVelocity(this, n, !0); return } e === void 0 || t === void 0 || (r = this.context.physics.engine) == null || r.setLinearVelocity(this, { x: i, y: e, z: t }, !0) } setAngularVelocity(i, e, t) { var s, r; if (i instanceof S) { const n = i; (s = this.context.physics.engine) == null || s.setAngularVelocity(this, n, !0); return } e === void 0 || t === void 0 || (r = this.context.physics.engine) == null || r.setAngularVelocity(this, { x: i, y: e, z: t }, !0) } getAngularVelocity() { var i; const e = (i = this.context.physics.engine) == null ? void 0 : i.getAngularVelocity(this); return e ? (this._currentVelocity.x = e.x, this._currentVelocity.y = e.y, this._currentVelocity.z = e.z, this._currentVelocity) : this._currentVelocity.set(0, 0, 0) } setTorque(i, e, t) { this.setAngularVelocity(i, e, t) } get smoothedVelocity() { return this._smoothedVelocityGetter.copy(this._smoothedVelocity), this._smoothedVelocityGetter.multiplyScalar(1 / this.context.time.deltaTime) } setBodyFromGameObject(i = null) { } captureVelocity() { const i = xt(this.gameObject); BS.tempPosition.copy(i); const e = i.sub(this._lastPosition); this._lastPosition.copy(BS.tempPosition), this._smoothedVelocity.lerp(e, this.context.time.deltaTime / .1) } }, u(PS, "tempPosition", new S), PS); let ki = BS; al([Ko(), x()], ki.prototype, "mass", 2), al([Ko(), x()], ki.prototype, "useGravity", 2), al([Ko(), x()], ki.prototype, "constraints", 2), al([Ko(), x()], ki.prototype, "isKinematic", 2), al([Ko(), x()], ki.prototype, "drag", 2), al([Ko(), x()], ki.prototype, "angularDrag", 2), al([Ko(), x()], ki.prototype, "detectCollisions", 2), al([Ko(), x()], ki.prototype, "sleepThreshold", 2), al([Ko(), x()], ki.prototype, "collisionDetectionMode", 2); class an { constructor() { u(this, "bb", null), u(this, "bb_pos", 0) } __init(e, t) { return this.bb_pos = e, this.bb = t, this } x() { return this.bb.readFloat32(this.bb_pos) } y() { return this.bb.readFloat32(this.bb_pos + 4) } z() { return this.bb.readFloat32(this.bb_pos + 8) } static sizeOf() { return 12 } static createVec3(e, t, s, r) { return e.prep(4, 12), e.writeFloat32(r), e.writeFloat32(s), e.writeFloat32(t), e.offset() } } class HL { constructor() { u(this, "bb", null), u(this, "bb_pos", 0) } __init(e, t) { return this.bb_pos = e, this.bb = t, this } position(e) { return (e || new an).__init(this.bb_pos, this.bb) } rotation(e) { return (e || new an).__init(this.bb_pos + 12, this.bb) } scale(e) { return (e || new an).__init(this.bb_pos + 24, this.bb) } static sizeOf() { return 36 } static createTransform(e, t, s, r, n, o, a, l, c, h) { return e.prep(4, 36), e.prep(4, 12), e.writeFloat32(h), e.writeFloat32(c), e.writeFloat32(l), e.prep(4, 12), e.writeFloat32(a), e.writeFloat32(o), e.writeFloat32(n), e.prep(4, 12), e.writeFloat32(r), e.writeFloat32(s), e.writeFloat32(t), e.offset() } } class Tl { constructor() { u(this, "bb", null), u(this, "bb_pos", 0) } __init(e, t) { return this.bb_pos = e, this.bb = t, this } static getRootAsSyncedTransformModel(e, t) { return (t || new Tl).__init(e.readInt32(e.position()) + e.position(), e) } static getSizePrefixedRootAsSyncedTransformModel(e, t) { return e.setPosition(e.position() + E0), (t || new Tl).__init(e.readInt32(e.position()) + e.position(), e) } guid(e) { const t = this.bb.__offset(this.bb_pos, 4); return t ? this.bb.__string(this.bb_pos + t, e) : null } fast() { const e = this.bb.__offset(this.bb_pos, 6); return e ? !!this.bb.readInt8(this.bb_pos + e) : !1 } transform(e) { const t = this.bb.__offset(this.bb_pos, 8); return t ? (e || new HL).__init(this.bb_pos + t, this.bb) : null } dontSave() { const e = this.bb.__offset(this.bb_pos, 10); return e ? !!this.bb.readInt8(this.bb_pos + e) : !1 } static startSyncedTransformModel(e) { e.startObject(4) } static addGuid(e, t) { e.addFieldOffset(0, t, 0) } static addFast(e, t) { e.addFieldInt8(1, +t, 0) } static addTransform(e, t) { e.addFieldStruct(2, t, 0) } static addDontSave(e, t) { e.addFieldInt8(3, +t, 0) } static endSyncedTransformModel(e) { return e.endObject() } static finishSyncedTransformModelBuffer(e, t) { e.finish(t) } static finishSizePrefixedSyncedTransformModelBuffer(e, t) { e.finish(t, void 0, !0) } } const Mc = oe("debugsync"), Hg = "STRS"; C1(Hg, Tl.getRootAsSyncedTransformModel); const Zo = new Zp; function VL(i, e, t = !0) { Zo.clear(); const s = Zo.createString(i); Tl.startSyncedTransformModel(Zo), Tl.addGuid(Zo, s), Tl.addFast(Zo, t); const r = e.worldPosition, n = e.worldEuler, o = e.gameObject.scale; Tl.addTransform(Zo, HL.createTransform(Zo, r.x, r.y, r.z, n.x, n.y, n.z, o.x, o.y, o.z)); const a = Tl.endSyncedTransformModel(Zo); return Zo.finish(a, Hg), Zo.asUint8Array() } class Ic extends Ee { constructor() { super(...arguments), u(this, "overridePhysics", !0), u(this, "interpolatePosition", !0), u(this, "interpolateRotation", !0), u(this, "fastMode", !1), u(this, "syncDestroy", !1), u(this, "_model", null), u(this, "_needsUpdate", !0), u(this, "rb", null), u(this, "_wasKinematic", !1), u(this, "_receivedDataBefore", !1), u(this, "_targetPosition"), u(this, "_targetRotation"), u(this, "_receivedFastUpdate", !1), u(this, "_shouldRequestOwnership", !1), u(this, "joinedRoomCallback", null), u(this, "receivedDataCallback", null), u(this, "tempEuler", new ps), u(this, "receivedUpdate", !1), u(this, "lastWorldPos"), u(this, "lastWorldRotation") } requestOwnership() { Mc && console.log("Request ownership"), this._model ? this._model.requestOwnership() : (this._shouldRequestOwnership = !0, this._needsUpdate = !0) } hasOwnership() { var e; return ((e = this._model) == null ? void 0 : e.hasOwnership) ?? void 0 } isOwned() { var e; return (e = this._model) == null ? void 0 : e.isOwned } awake() { Mc && console.log("new instance", this.guid, this), this._receivedDataBefore = !1, this._targetPosition = new S, this._targetRotation = new we, this.lastWorldPos = new S, this.lastWorldRotation = new we, this.rb = $.getComponentInChildren(this.gameObject, ki), this.rb && (this._wasKinematic = this.rb.isKinematic), this.receivedUpdate = !0, this._model = new z0(this.context.connection, this.guid), this.context.connection.isConnected && this.tryGetLastState(), this.joinedRoomCallback = this.tryGetLastState.bind(this), this.context.connection.beginListen(Li.JoinedRoom, this.joinedRoomCallback), this.receivedDataCallback = this.onReceivedData.bind(this), this.context.connection.beginListenBinary(Hg, this.receivedDataCallback) } onDestroy() { this.syncDestroy && e2(this.guid, this.context.connection), this._model = null, this.context.connection.stopListen(Li.JoinedRoom, this.joinedRoomCallback), this.context.connection.stopListenBinary(Hg, this.receivedDataCallback) } tryGetLastState() { const e = this.context.connection.tryGetState(this.guid); e && this.onReceivedData(e) } onReceivedData(e) { var t; if (!this.destroyed && typeof e.guid == "function" && e.guid() === this.guid) { Mc && console.log("new data", this.context.connection.connectionId, this.context.time.frameCount, this.guid, e), this.receivedUpdate = !0, this._receivedFastUpdate = e.fast(); const s = e.transform(); if (s) { Xr.markDirty(this.gameObject, !0); const r = s.position(); r && (this.interpolatePosition && ((t = this._targetPosition) == null || t.set(r.x(), r.y(), r.z())), (!this.interpolatePosition || !this._receivedDataBefore) && this.setWorldPosition(r.x(), r.y(), r.z())); const n = s.rotation(); n && (this.tempEuler.set(n.x(), n.y(), n.z()), this.interpolateRotation && this._targetRotation.setFromEuler(this.tempEuler), (!this.interpolateRotation || !this._receivedDataBefore) && bB(this.gameObject, this.tempEuler)) } this._receivedDataBefore = !0 } } onEnable() { this.lastWorldPos.copy(this.worldPosition), this.lastWorldRotation.copy(this.worldQuaternion), this._needsUpdate = !0, this._model && this._model.updateIsOwned() } onDisable() { this._model && this._model.freeOwnership() } onBeforeRender() { if (!this.activeAndEnabled || !this.context.connection.isConnected) return; if (!this.context.connection.isInRoom || !this._model) { Mc && console.log("no model or room", this.name, this.guid, this.context.connection.isInRoom); return } this._shouldRequestOwnership && (this._shouldRequestOwnership = !1, this._model.requestOwnership()); let e = this.worldPosition, t = this.worldQuaternion; if (this._model.isOwned && !this.receivedUpdate) { const n = e.distanceTo(this.lastWorldPos), o = t.angleTo(this.lastWorldRotation), a = this._model.hasOwnership || this.fastMode ? 1e-4 : .001; (n > a || o > a) && (this._model.hasOwnership ? this._needsUpdate = !0 : (Mc && console.log(this.guid, "reset because not owned but", this.gameObject.name, this.lastWorldPos), this.worldPosition = this.lastWorldPos, e.copy(this.lastWorldPos), this.worldQuaternion = this.lastWorldRotation, t.copy(this.lastWorldRotation), Xr.markDirty(this.gameObject, !0), this._needsUpdate = !1)) } if (this._model && !this._model.hasOwnership && this._model.isOwned && this._receivedDataBefore) { const n = this._receivedFastUpdate || this.fastMode ? .5 : .3; let o = !1; if (this.interpolatePosition && this._targetPosition) { const a = this.worldPosition; a.lerp(this._targetPosition, n), this.worldPosition = a, o = !0 } if (this.interpolateRotation && this._targetRotation) { const a = this.worldQuaternion; a.slerp(this._targetRotation, n), this.worldQuaternion = a, o = !0 } o && Xr.markDirty(this.gameObject, !0) } if (this.receivedUpdate = !1, this.lastWorldPos.copy(e), this.lastWorldRotation.copy(t), !this._model) return; if (!this._model || this._model.hasOwnership === void 0 || !this._model.hasOwnership) { this.rb && (this.rb.isKinematic = this._model.isOwned ?? !1, this.rb.setVelocity(0, 0, 0)); return } this.rb && (this._wasKinematic !== void 0 && (Mc && console.log("reset kinematic", this.rb.name, this._wasKinematic), this.rb.isKinematic = this._wasKinematic), this.gameObject.position.distanceTo(new S(0, 0, 0)) > 1e3 && (Mc && console.log("RESET", this.name), this.gameObject.position.set(0, 1, 0), this.rb.setVelocity(0, 0, 0))); const s = 10, r = this.rb || this.fastMode; if (this._needsUpdate && (this.context.time.frameCount % s === 0 || r)) { Mc && console.log("send update", this.context.connection.connectionId, this.guid, this.gameObject.name, this.gameObject.guid), this.overridePhysics && this.rb, this._needsUpdate = !1; const n = VL(this.guid, this, !!r); this.context.connection.sendBinary(n) } } } var bo = {}; bo.d = (i, e) => { for (var t in e) bo.o(e, t) && !bo.o(i, t) && Object.defineProperty(i, t, { enumerable: !0, get: e[t] }) }, bo.o = (i, e) => Object.prototype.hasOwnProperty.call(i, e), bo.r = i => { typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 }) }; var ns = {}; bo.d(ns, { w8: () => ci, cg: () => _F, gO: () => Pv, wb: () => kS, zV: () => Vh, HS: () => Vg, Ec: () => Hh, gF: () => ef, ol: () => kv, pz: () => a3, tx: () => $n, hj: () => DS, FV: () => $g, sV: () => $3, xv: () => Bv, mx: () => r3, gE: () => n3, ZP: () => O$, Vx: () => xF }); var kS = {}; bo.r(kS), bo.d(kS, { get: () => WL, set: () => qY }); var DS = {}; bo.r(DS), bo.d(DS, { alphaTestTransformer: () => Jy, asPreprocessorValueTransformer: () => l3, toPreprocessorTriggerTransformer: () => qS, toUserDataTransformer: () => sK, uniformOrUserDataTransformer: () => Ln }); const OS = {
  fontFamily: null, fontSize: .05, fontKerning: "normal", fontStyle: "normal", fontWeight: "400", offset: .005, lineHeight: 1.2, lineBreak: `- ,.:?!
`, whiteSpace: "pre-line", flexDirection: "column", justifyContent: "start", alignItems: "start", backgroundImage: null, textAlign: "left", boxSizing: "content-box", position: "static", color: 16777215, fontColor: 16777215, fontOpacity: 1, opacity: 1, fontPXRange: 4, fontSupersampling: !0, fontSmooth: "antialiased", borderRadius: 0, borderWidth: 0, borderColor: "black", borderOpacity: 1, backgroundSize: "cover", backgroundColor: 0, backgroundOpacity: 0, overflow: "visible", letterSpacing: 0, invertAlpha: !1, segments: 1
}, qY = function (i) { for (const e in i) OS[e] = i[e] }, WL = function (i) { return Object.prototype.hasOwnProperty.call(OS, i) || console.warn(`ThreeMeshUI::DefaultValues is trying to retrieve non-existing property '${i}'`), OS[i] }; class ci { constructor(e, t = null, s = !0) { this._id = e, this._value = t, this._needsUpdate = !0, this._needsProcess = !1, this._needsRender = !1, this._isPrimitive = s } get id() { return this._id } get value() { return this._value } set value(e) { this.isValid(e) && this._value !== e && (this._value = e, this._needsUpdate = !0) } update(e, t) { this.output(t) } output(e) { } _outputValue(e) { e[this._id] = this._value } process(e) { } render(e) { } getInheritedInput(e) { if (this._value !== "inherit") return this._value; const t = e._parent._value; return t && t[`_${this._id}`] ? t[`_${this._id}`].getInheritedInput(t) : this.getDefaultValue() } getDefaultValue() { return WL(this._id) } isValid(e) { return !0 } emptyStrategyLogic() { throw new Error(`ThreeMeshUI::${this.constructor.name} has empty strategy. Update has not been processed.`) } requestUpdate() { this._needsUpdate = !0 } requestProcess() { this._needsProcess = !1 } requestRender() { this._needsRender = !1 } } class XY extends ci { constructor() { super("renderOrder", "auto", !0), this.output = this._outputValue, this._actualValue = 0 } set value(e) { this.isValid(e) && (this._value = e, this._needsUpdate = !0) } update(e, t) { if (this._value !== "auto") this._actualValue = this._value; else { const s = e._parent._value; if (s !== null) { const r = s._renderOrder._actualValue, n = 1 + s._children._uis.indexOf(e); this._actualValue = r + n } } for (const s of e._children._uis) s._renderOrder._value === "auto" && (s._renderOrder._needsUpdate = !0); this._outputValue(t) } _outputValue(e) { e[this._id] = this._actualValue } get value() { return this._value } } class Hh extends ci { constructor(e, t = null, s = !0) { super(e, t, s), this.output = this._outputValue, this._notInheritedValue = null } update(e, t) { this._notInheritedValue = this._value, this._notInheritedValue === "inherit" && (this._notInheritedValue = this.getInheritedInput(e)), this.propagate(e), this._outputValue(t) } propagate(e) { for (const t of e._children._uis) { const s = t[`_${this._id}`]; s !== void 0 && s._value === "inherit" && (t[`_${this._id}`]._needsUpdate = !0) } } _outputValue(e) { e[this._id] = this._notInheritedValue } set value(e) { this.isValid(e) && this._value !== e && (this._value = e, this._needsUpdate = !0) } get value() { return this._value === "inherit" ? this._notInheritedValue : this._value } } class YY extends Hh { constructor() { super("offset", "inherit", !1) } update(e, t) { super.update(e, t), e._parent._value !== null && (e.position.z = this._notInheritedValue) } } class JY extends Hh { constructor() { super("fontSmooth", "inherit", !0), this._needsUpdate = !1, this.isValid = ZY, this.output = this._outputValue } } const KY = ["inherit", "none", "antialiased"]; function ZY(i) { return KY.indexOf(i) === -1 ? (console.warn(`.fontSmoothing value '${i}' is not valid. Aborted`), !1) : !0 } var $Y = i => { var e = {}; return bo.d(e, i), e }; const Ze = $Y({ BackSide: () => fs, BufferAttribute: () => nt, BufferGeometry: () => yt, Color: () => xe, DoubleSide: () => yi, EventDispatcher: () => ms, FileLoader: () => bs, FrontSide: () => pr, LinearFilter: () => Qt, Mesh: () => ye, Object3D: () => Me, Plane: () => xn, PlaneGeometry: () => ks, ShaderMaterial: () => Vt, Texture: () => Nt, TextureLoader: () => Yl, Vector2: () => W, Vector3: () => S, Vector4: () => st }); class wi extends ci { constructor(e, t, s = !0) { super(e, "unset", s), this._input = "inherit", this._allowsInherit = !0, this._inheritedInput = void 0, this._inline = void 0 } update(e, t) { this._allowsInherit || (this._inheritedInput = this.getInheritedInput(e)), this.computeOutputValue(e); for (const s of e._children._uis) { const r = s[`_${this._id}`]; (r._input ? r._input : r._value) === "inherit" && (s[`_${this._id}`]._needsUpdate = !0) } this.output(t) } computeOutputValue(e) { this._value = this._input } _computeFromInherited(e) { this._value = this._inheritedInput } set value(e) { console.warn(".(style) sub-property cannot be directly set. It must comes from inline or computed setter.") } set inline(e) { this.isValidValue(e) && e !== this._inline && (this._input = this._inline = e, this._needsUpdate = !0) } get inline() { return this._inline } isValidValue(e) { return !0 } getInheritedInput(e) { if (this._input !== "inherit") return this._input; const t = e._parent._value; return t ? t[`_${this._id}`].getInheritedInput(t) : this.getDefaultValue() } } class Wy extends wi { constructor(e, t) { super(e, t, !1), this._input = new Ze.Vector4(0, 0, 0, 0), this._inline = null, this._value = new Ze.Vector4(0, 0, 0, 0) } get value() { return this._value } computeOutputValue(e) { this._vector4ValueSetter(this._value, this._input) } set inline(e) { this._vector4ValueSetter(this._input, e), !this._input.equals(this._value) && (this._needsUpdate = !0) } set top(e) { this._input.x !== e && (this._input.x = e, this._needsUpdate = !0) } get top() { return this._input.x } set right(e) { this._input.y !== e && (this._input.y = e, this._needsUpdate = !0) } get right() { return this._input.y } set bottom(e) { this._input.z !== e && (this._input.z = e, this._needsUpdate = !0) } get bottom() { return this._input.z } set left(e) { this._input.w !== e && (this._input.w = e, this._needsUpdate = !0) } get left() { return this._input.w } dispose() { this._computed = null, this._inline = null, this._input = null, this._output = null } _vector4ValueSetter(e, t) { if (t instanceof Ze.Vector4) { e.copy(t); return } if ((typeof t == "string" || t instanceof String) && (t = t.split(" ")), Array.isArray(t)) switch (t = t.map(s => parseFloat(s)), t.length) { case 1: e.setScalar(t[0]); return; case 2: e.x = e.z = t[0], e.y = e.w = t[1]; return; case 3: e.x = t[0], e.y = t[1], e.z = t[2]; return; case 4: e.x = t[0], e.y = t[1], e.z = t[2], e.w = t[3]; return; default: console.error("StyleVector4Property::set() Four Dimension property had more than four values"); return }isNaN(t) || e.setScalar(t) } } class eJ extends Wy { constructor() { super("padding", new Ze.Vector4(0, 0, 0, 0)) } computeOutputValue(e) { super.computeOutputValue(e), e._bounds._needsUpdate = !0, e._bounds._needsRender = !0, e._layouter._needsProcess = !0, e._renderer._needsRender = !0, e._parent._value && (e._parent._value._layouter._needsProcess = !0) } } class tJ extends Wy { constructor() { super("margin", new Ze.Vector4(0, 0, 0, 0)) } computeOutputValue(e) { super.computeOutputValue(e), e._renderer._needsRender = !0, e._parent._value && (e._parent._value._flexDirection._needsProcess = !0) } } const qL = function (i, e, t) { i[e] = t }, iJ = function (i, e, t) { t !== null && (i[e] = t) }; class qy { constructor(e) { this._definition = e } set definition(e) { this._definition = e } mediate(e, t, s, r = null) { for (const n in this._definition) { const o = this._definition[n]; if (s[n] !== void 0) { const a = o.t ? o.t : qL; a(t, o.m, s[n]), r && a(r, o.m, s[n]) } } } static mediate(e, t, s, r, n = null) { if (t) for (const o in r) { const a = r[o]; if (s[o] !== void 0) { const l = a.t ? a.t : qL; l(t, a.m, s[o]), n && l(n, a.m, s[o]) } } } } class sJ extends ci { constructor() { super("parent", null, !1) } update(e, t) { e.parent && e.parent.isUI ? this._value = e.parent : this._value = null } set value(e) { console.warn("ParentProperty is readonly") } get value() { return this._value } find(e) { return this._value ? e(this._value) ? this._value : this._value._parent.find(e) : null } dispose() { this._value = null } } const LS = function (i, e, t = 6) { return i.toFixed(t) === e.toFixed(t) }; class XL extends ci { constructor(e, t) { super(e, t, !0), this.output = this._outputValue } set value(e) { this.isValid(e) && (LS(this._value, e) || (this._value = e, this._needsUpdate = !0)) } get value() { return this._value } } class YL extends Hh { constructor(e) { super(e, "inherit", !0), this.isValid = nJ } } const rJ = [Ze.FrontSide, Ze.BackSide, Ze.DoubleSide]; function nJ(i) { return rJ.indexOf(i) === -1 ? (console.warn(`SideProperty value '${i}' is not valid. Abort`), !1) : !0 } class oJ extends Ze.EventDispatcher { constructor(e, t) { super(), this._isReady = !1, this._weight = e, this._style = t, this._size = 42, this._lineHeight = 42, this._lineBase = 42, this._font = null } get typographic() { return this._font } get isReady() { return this._isReady } get weight() { return this._weight } get style() { return this._style } get texture() { return this._texture } set fontMaterial(e) { throw Error(`FontVariant('${this.id}')::fontMaterial - is abstract.`) } get fontMaterial() { throw Error(`FontVariant('${this.id}')::fontMaterial - is abstract.`) } get id() { return `${this._name}(w:${this.weight},s:${this.style})` } getTypographicGlyph(e) { let t = this._chars[e]; if (t) return t; if (e.match(/\s/)) return this._chars[" "]; const s = this._getFallbackCharacter(e); if (s && (t = this._chars[s], t)) return t; throw Error(`FontVariant('${this.id}')::getTypographicGlyph() - character('${e}') and/or fallback character were not found in provided msdf charset.`) } _getFallbackCharacter(e) { throw new Error(`FontVariant(${typeof this})::_getFallbackCharacter() is abstract and should therefore be overridden.`) } getGeometricGlyph(e, t) { throw new Error(`FontVariant(${typeof this})::getGeometryCharacter() is abstract and should therefore be overridden.`) } getKerningAmount(e) { return this._kernings[e] ? this._kernings[e] : 0 } adjustTypographicGlyphs(e) { for (const t in e) { const s = this.getTypographicGlyph(t), r = e[t]; for (const n in r) s["_" + n] = e[t][n] } } _checkReadiness() { this._readyCondition() && lJ(this) } _alterElementProperties(e) { throw new Error(`FontVariant(${typeof this})::_alterElementProperties() is abstract and should therefore be overridden.`) } _readyCondition() { throw new Error(`FontVariant(${typeof this})::_readyCondition() is abstract and should therefore be overridden.`) } } const aJ = { type: "ready" }; function lJ(i) { i._isReady = !0, i.dispatchEvent(aJ) } const Vg = oJ; class cJ extends ci { constructor(e = null) { super("font", e, !1), this._needsUpdate = !1, this._fontVariant = null, this._handleFontReadyClosure = null, this.isValid = hJ } output(e) { e[this._id] = this._fontVariant } update(e, t) { if (this._fontVariant && !this._fontVariant.isReady && this._fontVariant.removeEventListener("ready", this._handleFontReadyClosure), this._value && this._value instanceof Vg) this._fontVariant = this._value; else { const s = e._fontFamily._value; s && (this._fontVariant = s.getVariant(e._fontWeight._value, e._fontStyle._value)) } this._fontVariant && (this._fontVariant._alterElementProperties(e), this._handleFontReadyClosure = uJ(e, this), this._fontVariant.isReady ? this._handleFontReadyClosure() : this._fontVariant.addEventListener("ready", this._handleFontReadyClosure), (!e._fontMaterial._defaultMaterial || !(e._fontMaterial._defaultMaterial instanceof this._fontVariant.fontMaterial)) && (e._fontMaterial._defaultMaterial = new this._fontVariant.fontMaterial, e._fontMaterial._needsUpdate = !0)) } set value(e) { this.isValid(e) && this._value !== e && (this._value = e, this._needsUpdate = !0) } get value() { return this._value } get fontVariant() { return this._fontVariant } dispose() { this._handleFontReadyClosure && (this._fontVariant.removeEventListener("ready", this._handleFontReadyClosure), this._handleFontReadyClosure = null), this._value = null, this._fontVariant = null } } function hJ(i) { return i instanceof Vg ? !0 : (console.warn(`.font value '${i}' is not valid. It requires a FontVariant instance. Aborted`), !1) } function uJ(i, e) { return function () { e._needsUpdate = !0, i._glyphs._needsProcess = !0, e._fontVariant.removeEventListener("ready", e._handleFontReadyClosure), e._handleFontReadyClosure = null } } class dJ extends wi { constructor(e) { super("display", e), this._value = "flex", this._allowsInherit = !1, this._needsUpdate = !1, this.isValidValue = fJ } computeOutputValue(e) { e._visible._value = this._output !== "none" } } const pJ = ["none", "flex"]; function fJ(i) { return pJ.indexOf(i) === -1 ? (console.warn(`(.style) display value '${i}' is not valid. Aborted`), !1) : !0 } class gJ extends wi { constructor(e) { super("boxSizing", e), this._allowsInherit = !1, this.isValidValue = vJ } computeOutputValue(e) { this._value = this._inheritedInput, e._bounds._needsUpdate = !0 } } const mJ = ["border-box", "content-box"]; function vJ(i) { return mJ.indexOf(i) === -1 ? (console.warn(`(.style) boxSizing value '${i}' is not valid. Aborted`), !1) : !0 } class Wg extends wi { constructor(e, t) { super(e, t, !1), this._value = new Ze.Color, this.output = this._outputValue } computeOutputValue(e) { this._input !== "inherit" && this._value.set(this._input) } set inline(e) { this._input = this._inline = e, this._needsUpdate = !0 } } class FS extends wi { constructor(e, t) { super(e, t, !0), this.isValidValue = AJ, this._allowsInherit = !1, this._input = t, this._value = t, this.output = this._outputValue, this.computeOutputValue = this._computeFromInherited } _outputValue(e) { e[this._id] = this._inheritedInput } } function AJ(i) { return i < 0 && i > 1 ? (console.warn(`(.style) styleFactorProperty('${this.id}') value '${i}' is not valid)`), !1) : !0 } class yJ extends wi { constructor(e) { super("backgroundImage", e, !0), this._input = null, this._allowsInherit = !1, this._textureSize = new Ze.Vector2(1, 1), this.isValidValue = bJ } get value() { return this._value } output(e) { e[this._id] = this._value, e.tSize = this._textureSize } computeOutputValue(e) { if (this._value = this._inheritedInput, this._value instanceof Ze.Texture && !this._value.image) { console.warn("ThreeMeshUI - .backgroundImage :: Please provide preloaded texture in order to have accurate sizing."); return } this._needsProcess = !0 } process(e) { this._value ? this._textureSize.set(this._value.image.width, this._value.image.height) : this._textureSize.set(1, 1) } } function bJ(i) { return !0 } class _J extends wi { constructor(e) { super("backgroundSize", e, !0), this.isValidValue = wJ, this.output = this._outputValue } } const xJ = ["cover", "contain", "stretch"]; function wJ(i) { return xJ.indexOf(i) === -1 ? (console.warn(`(.style) backgroundSize value '${i}' is not valid. Aborted`), !1) : !0 } class CJ extends wi { constructor(e) { super("overflow", e, !0), this.isValidValue = EJ, this._clippingPlanes = null, this._renderStrategy = this._emptyRender } update(e, t) { this._inline !== void 0 && this._inline !== "unset" ? this._input = this._inline : this._computed !== void 0 && (this._input = this._computed), this._allowsInherit || (this._inheritedInput = this.getInheritedInput(e)), this.computeOutputValue(e); for (const s of e._children._uis) s._overflow._needsUpdate = !0; this.output(t) } output(e) { e.clippingPlanes = this._clippingPlanes } computeOutputValue(e) { super.computeOutputValue(e), this._value === "hidden" ? this._renderStrategy = this._propagateRender : (this._renderStrategy = this._emptyRender, this._clippingPlanes = null); const t = e._parent._value; if (t !== null) { const s = t._overflow; if ((s._value === "hidden" || s._clippingPlanes !== null) && !this._clippingPlanes) { this._clippingPlanes = [new Ze.Plane(new Ze.Vector3(0, -1, 0), 1), new Ze.Plane(new Ze.Vector3(-1, 0, 0), 1), new Ze.Plane(new Ze.Vector3(0, 1, 0), 1), new Ze.Plane(new Ze.Vector3(1, 0, 0), 1)]; for (let r = 0; r < this._clippingPlanes.length; r++)this._clippingPlanes[r].parent = t; s._clippingPlanes !== null && this._clippingPlanes.push(...s._clippingPlanes), this._renderStrategy = this._hiddenRender, this._needsRender = !0 } else (s._value === "visible" || s._clippingPlanes === null) && this._clippingPlanes !== null && (this._clippingPlanes = null, this._renderStrategy = this._emptyRender, this._needsRender = !0) } } render(e) { this._renderStrategy(e) } _emptyRender(e) { } _hiddenRender(e) { const t = e._parent._value, s = t._bounds._offsetHeight, r = t._bounds._offsetWidth, n = t._padding._value, o = t._borderWidth._value; for (let a = 0; a < 4 && a < this._clippingPlanes.length; a++) { const l = this._clippingPlanes[a]; switch (a % 4) { case 0: l.constant = s / 2 - (n.x + o.x); break; case 1: l.constant = r / 2 - (n.y + o.y); break; case 2: l.constant = s / 2 - (n.z + o.z); break; case 3: l.constant = r / 2 - (n.w + o.w); break }l.applyMatrix4(t.matrixWorld) } for (let a = 0; a < e._children._uis.length; a++) { const l = e._children._uis[a]; l._overflow._needsRender = !0 } } _propagateRender(e) { for (let t = 0; t < e._children._uis.length; t++) { const s = e._children._uis[t]; s._overflow._needsRender = !0 } } } const SJ = ["visible", "hidden"]; function EJ(i) { return SJ.indexOf(i) === -1 ? (console.warn(`(.style) overflow value '${i}' is not valid. Aborted`), !1) : !0 } const Zd = "rem", JL = "em", Xy = "%", MJ = [Zd, JL, Xy], KL = function (i) { return MJ.indexOf(i) === -1 ? Zd : i }; class IJ extends Wy { constructor(e) { super("borderRadius", e), this._valueUV = this._value.clone(), this._input = new Ze.Vector4(0, 0, 0, 0), this._mediation = !0, this._cornerTL = new Ze.Vector2(0, 1), this._cornerTR = new Ze.Vector2(1, 1), this._cornerBR = new Ze.Vector2(1, 0), this._cornerBL = new Ze.Vector2(0, 0); const t = new Yy(this._valueUV, ["x", "y"]), s = new Yy(this._valueUV, ["z", "w"]), r = new Yy(this._valueUV, ["x", "w"]), n = new Yy(this._valueUV, ["y", "z"]); t.complementaryMediation = s, s.complementaryMediation = t, r.complementaryMediation = n, n.complementaryMediation = r, this._sideMediators = [t, s, r, n], this._units = Zd } set units(e) { this._units = KL(e), this._needsProcess = !0 } get units() { return this._units } set mediation(e) { e !== this._mediation && (this._mediation = e, this._needsUpdate = !0) } get mediation() { return this._mediation } output(e) { e.cornerTL = this._cornerTL, e.cornerTR = this._cornerTR, e.cornerBR = this._cornerBR, e.cornerBL = this._cornerBL } computeOutputValue(e) { this._vector4ValueSetter(this._value, this._input), this._needsProcess = !0 } process(e) { this._needsRender = !0 } render(e) { this._valueUV.copy(this._value); const t = e._bounds._offsetWidth, s = e._bounds._offsetHeight; if (this._units === Xy && this._valueUV.divideScalar(100), this._units === Zd && this._valueUV.divideScalar(Math.min(t, s)), this._mediation) do this._sideMediators.forEach(o => o.computeValue()), this._sideMediators.sort((o, a) => o.value < a.value ? 1 : -1), this._sideMediators[0].value > 1 && this._sideMediators[0].mediate(); while (this._sideMediators[0].value > 1); let r = t > s ? s / t : 1, n = t < s ? t / s : 1; this._units === Xy && (r = n = 1), this._cornerTL.x = this._valueUV.x * r, this._cornerTL.y = 1 - this._valueUV.x * n, this._cornerTR.x = 1 - this._valueUV.y * r, this._cornerTR.y = 1 - this._valueUV.y * n, this._cornerBR.x = 1 - this._valueUV.z * r, this._cornerBR.y = this._valueUV.z * n, this._cornerBL.x = this._valueUV.w * r, this._cornerBL.y = this._valueUV.w * n } dispose() { for (const e of this._sideMediators) e.dispose(); this._sideMediators = null, this._cornerTL = null, this._cornerTR = null, this._cornerBR = null, this._cornerBL = null, super.dispose() } set topLeft(e) { this._input.x !== e && (this._input.x = e, this._needsUpdate = !0) } get topLeft() { return this._input.x } set topRight(e) { this._input.y !== e && (this._input.y = e, this._needsUpdate = !0) } get topRight() { return this._input.y } set bottomRight(e) { this._input.z !== e && (this._input.z = e, this._needsUpdate = !0) } get bottomRight() { return this._input.z } set bottomLeft(e) { this._input.w !== e && (this._input.w = e, this._needsUpdate = !0) } get bottomLeft() { return this._input.w } set top(e) { this._input.x === e && this._input.y === e || (this._input.x = this._input.y = e, this._needsUpdate = !0) } get top() { return (this._input.x + this._input.y) / 2 } set right(e) { this._input.y === e && this._input.z === e || (this._input.y = this._input.z = e, this._needsUpdate = !0) } get right() { return (this._input.y + this._input.z) / 2 } set bottom(e) { this._input.z === e && this._input.w === e || (this._input.z = this._input.w = e, this._needsUpdate = !0) } get bottom() { return (this._input.z + this._input.w) / 2 } set left(e) { this._input.w === e && this._input.x === e || (this._input.w = this._input.x = e, this._needsUpdate = !0) } get left() { return (this._input.w + this._input.x) / 2 } } class Yy { constructor(e, t) { this._borderRadiuses = e, this._sideProperties = t, this._complementaryMediation = null, this._value = 0 } get value() { return this._value } set complementaryMediation(e) { this._complementaryMediation = e } computeValue() { let e = 0; for (const t of this._sideProperties) e += this._borderRadiuses[t]; this._value = e } mediate(e = !0) { if (!(this._value < 1)) { for (const t of this._sideProperties) this._borderRadiuses[t] /= this._value; e && this._complementaryMediation.mediate(!1) } } dispose() { this._complementaryMediation = null, this._borderRadiuses = null } } class TJ extends Wy { constructor(e) { super("borderWidth", e, !1), this._valueUV = this._value.clone(), this.output = this._outputValue, this._units = Zd } set units(e) { this._units = KL(e), this._needsUpdate = !0 } get units() { return this._units } computeOutputValue(e) { this._vector4ValueSetter(this._value, this._input), this._needsProcess = !0, e._bounds._needsUpdate = !0, e._layouter._needsUpdate = !0 } _outputValue(e) { e[this._id] = this._valueUV } process(e) { this._needsRender = !0, e._borderRadius._needsRender = !0 } render(e) { this._valueUV.copy(this._value); const t = e._bounds._offsetWidth, s = e._bounds._offsetHeight; if (this._units === Xy && (console.log("Percent"), console.log(this._valueUV)), this._units === Zd) t !== 0 && (this._valueUV.w /= t, this._valueUV.y /= t), s !== 0 && (this._valueUV.x /= s, this._valueUV.z /= s); else if (this._units === JL) { if (t !== 0) { const r = t > s ? s / t : 1; this._valueUV.y *= r, this._valueUV.w *= r } if (s !== 0) { const r = t < s ? t / s : 1; this._valueUV.x *= r, this._valueUV.z *= r } } } } class RJ extends ci { constructor(e, t = !0) { super("visible", t, !0), this._needsUpdate = !1 } update(e, t) { e.visible = this._value, e._parent._value && (e._parent._value._children._needsUpdate = !0) } set value(e) { this.isValid(e) && this._value !== e && (this._value = e, this._needsUpdate = !0) } get value() { return this._value } } class ZL extends Wg { constructor(e) { super("backgroundColor", e, !1), this._input = "transparent", this._allowsInherit = !1 } computeOutputValue(e) { e._backgroundMesh.visible = !(this._input === "none" || this._input === "transparent"), this._input === "inherit" ? this._value.set(this.getInheritedInput(e)) : this._input === "transparent" || this._input === "none" || this._value.set(this._input) } } class ll extends ci { constructor(e = "untitled") { super(e, void 0, !1) } update(e, t) { } output(e) { } } class PJ extends ci { constructor() { super("inlineJustificator", null, !1), this._value = null } update(e, t) { } process(e) { const t = e._bounds._innerHeight, s = e._layouter._value, r = Math.abs(s.height); let n = (() => { switch (e._alignItems._value) { case "inherit": case "start": return t / 2; case "end": return r - t / 2; case "stretch": case "center": return r / 2 } })(); const o = e._padding._value, a = e._borderWidth._value; n += (-o.x + o.z) / 2 + (-a.x + a.z) / 2, s.forEach(l => { l.y += n, l.forEach(c => { c.offsetY += n }) }) } } const BJ = ["start", "center", "end", "stretch"], kJ = function (i) { return BJ.indexOf(i) === -1 ? (console.warn(`(.style) alignItems value '${i}' is not valid. Aborted`), !1) : !0 }; class US extends wi { constructor() { super("alignItems", "inherit", !0), this.isValidValue = kJ } } class NS extends wi { constructor() { super("textAlign", "inherit", !0), this.isValidValue = OJ } } const DJ = ["left", "right", "center", "justify", "justify-left", "justify-right", "justify-center"], OJ = function (i) { return DJ.indexOf(i) === -1 ? (console.warn(`(.style) textAlign value '${i}' is not valid. Aborted`), !1) : !0 }; class zS extends wi { constructor() { super("flexDirection", "inherit", !0), this.isValid = FJ } } const LJ = ["row", "row-reverse", "column", "column-reverse"]; function FJ(i) { return LJ.indexOf(i) === -1 ? (console.warn(`(.style) flexDirection value '${i}' is not valid. Aborted`), !1) : !0 } class jS extends wi { constructor() { super("justifyContent", "inherit", !0), this.isValidValue = NJ } } const UJ = ["start", "center", "end", "space-between", "space-around", "space-evenly"]; function NJ(i) { return UJ.indexOf(i) === -1 ? (console.warn(`(.style) justifyContent value '${i}' is not valid. Aborted`), !1) : !0 } class zJ extends wi { constructor() { super("order", 0, !0), this._value = 0, this._input = 0, this._allowsInherit = !1 } computeOutputValue(e) { this._value = this._inheritedInput, e._parent._value && (e._parent._value._children._needsProcess = !0) } } class $L extends wi { constructor() { super("position", "static", !0), this._allowsInherit = !1, this._value = "static", this._needsUpdate = !1, this.computeOutputValue = this._computeFromInherited, this.isValidValue = QJ } _computeFromInherited(e) { super._computeFromInherited(e), e._parent._value && (e._parent._value._children._needsProcess = !0) } } const jJ = ["static", "absolute"]; function QJ(i) { return jJ.indexOf(i) === -1 ? (console.warn(`(.style) position value '${i}' is not valid. Aborted`), !1) : !0 } class e3 extends wi { constructor(e, t = null) { super(e, t, !0), this._input = "auto", this._auto = !0, this._relative = !1, this._updateRequired = !0 } set inline(e) { this.isValidValue(e) && e !== this._inline && (this._inline = e, this._input !== this._inline && this._parseInput()) } get inline() { return this._inline } _parseInput() { let e = !0; if (this._inline !== void 0 && this._inline !== "unset" ? this._input = this._inline : this._computed !== void 0 ? (this._computed === this._input && (e = !1), this._input = this._computed) : e = this._input === "inherit", e) { if (this._auto = !this._input || this._input === "auto", this._auto) this._relative = !1; else if ((typeof this._input == "string" || this._input instanceof String) && this._input.endsWith("%")) { this._relative = !0, this._value = 0; const t = parseFloat(this._input.replace("%", "").trim()); isNaN(t) || (this._value = t / 100) } else this._relative = !1, this._value = this._input; this._needsUpdate = this._updateRequired = e } } update(e, t) { if (this._updateRequired) { this._updateRequired = !1, this._allowsInherit || (this._inheritedInput = this.getInheritedInput(e)), this.computeOutputValue(e); for (const s of e._children._uis) s[`_${this._id}`]._needsUpdate = !0; this.output(t), e._parent._value && (e._parent._value._layouter._needsProcess = !0) } } computeOutputValue(e) { e._bounds._needsUpdate = !0, e._renderer._needsRender = !0 } getInheritedInput(e) { if (this._input !== "inherit" && !this._auto) return this._input; const t = e._parent._value; return t ? t[`_${this._id}`].getInheritedInput(t) : this.getDefaultValue() } getDefaultValue() { return 0 } get value() { return this._value } } class GJ extends e3 { constructor() { super("width") } } class HJ extends e3 { constructor() { super("height") } computeOutputValue(e) { super.computeOutputValue(e) } } class t3 extends ll { constructor() { super("textContent"), this._needsUpdate = !1 } set value(e) { } process(e) { let t = ""; for (let s = 0; s < e.children.length; s++) { const r = e.children[s]; r.isUI && (t += r.textContent) } this._value = t } } class i3 extends wi { constructor(e) { super("fontStyle", e, !0), this.isValidValue = WJ } } const VJ = ["normal", "italic"]; function WJ(i) { return VJ.indexOf(i) === -1 ? (console.warn(`(.style) fontStyle value '${i}' is not valid. Aborted`), !1) : !0 } class s3 extends wi { constructor() { super("fontWeight", "inherit", !0), this.isValid = XJ } } const qJ = ["100", "200", "300", "400", "500", "600", "700", "800", "900", "light", "normal", "bold", "bolder"]; function XJ(i) { return qJ.indexOf(i.toString()) === -1 ? (console.warn(`(.style) fontWeight value '${i}' is not valid. Aborted`), !1) : !0 } class r3 { constructor() { this._size = 42, this._lineHeight = 42, this._lineBase = 38, this._name = "-", this._charset = "" } get size() { return this._size } get lineHeight() { return this._lineHeight } get lineBase() { return this._lineBase } get name() { return this._name } get charset() { return this._charset } } class YJ extends r3 { constructor(e) { super(), this._size = e.info.size, this._lineHeight = e.common.lineHeight, this._lineBase = e.common.base, this._name = e.info.face, this._textureWidth = e.common.scaleW, this._textureHeight = e.common.scaleH, this._charset = e.chars.map(t => t.char).join("") } get textureWidth() { return this._textureWidth } get textureHeight() { return this._textureHeight } } class n3 { constructor(e) { this._char = "", this._width = 1, this._heigth = 1, this._xadvance = 1, this._xoffset = 0, this._yoffset = 0, this._font = e } get font() { return this._font } get char() { return this._char } get width() { return this._width } get height() { return this._heigth } get xadvance() { return this._xadvance } get xoffset() { return this._xoffset } get yoffset() { return this._yoffset } set yoffset(e) { this._yoffset = e } clone(e) { throw new Error("Abstract... Need to be implemented") } asInlineGlyph() { throw new Error("Abstract... Need to be implemented") } } class o3 { constructor() { this._offsetX = 0, this._offsetY = 0, this._lineBreak = null, this._kerning = 0, this._fontFactor = 1, this._fontSize = 0, this._cumulativeWidth = 0, this._paddingLeft = 0, this._paddingRight = 0, this._marginLeft = 0, this._marginRight = 0 } resetOffsets() { this._offsetX = this._offsetY = 0, this._cumulativeWidth = 0 } get xadvance() { return 0 } get xoffset() { return 0 } get yoffset() { return 0 } get width() { return 0 } get height() { return 0 } set lineBreak(e) { this._lineBreak = e } get lineBreak() { return this._lineBreak } get anchor() { return 0 } get kerning() { return this._kerning * this._fontFactor } set kerning(e) { this._kerning = e } get fontSize() { return this._fontSize } set fontSize(e) { this._fontSize = e } get lineHeight() { return 0 } get offsetX() { return this._offsetX } set offsetX(e) { this._offsetX = e } get offsetY() { return this._offsetY } set offsetY(e) { this._offsetY = e } get cumulativeWidth() { return this._cumulativeWidth } set cumulativeWidth(e) { this._cumulativeWidth = e } get marginLeft() { return this._marginLeft } set marginLeft(e) { this._marginLeft = e } get marginRight() { return this._marginRight } set marginRight(e) { this._marginRight = e } get paddingLeft() { return this._paddingLeft } set paddingLeft(e) { this._paddingLeft = e } get paddingRight() { return this._paddingRight } set paddingRight(e) { this._paddingRight = e } get lineBase() { return 0 } set fontFactor(e) { this._fontFactor = e } get fontFactor() { return this._fontFactor } } class a3 extends o3 { constructor(e) { super(), this._typographic = e } get typographic() { return this._typographic } get xadvance() { return this._typographic.xadvance * this._fontFactor } get xoffset() { return this._typographic.xoffset * this._fontFactor } get yoffset() { return this._typographic.yoffset * this._fontFactor } get width() { return this._typographic.width * this._fontFactor } get height() { return this._typographic.height * this._fontFactor } get char() { return this._typographic.char } get anchor() { return this.yoffset } get lineHeight() { return this._typographic.font.lineHeight * this._fontFactor } get lineBase() { return this._typographic.font.lineBase * this._fontFactor } } class JJ extends a3 { constructor(e) { super(e) } get uv() { return this.typographic.uv } } class O_ extends n3 { constructor(e, t) { super(e), this._char = t.char, this._width = t.width, this._heigth = t.height, this._xadvance = t.xadvance ? t.xadvance : this._width, this._xoffset = t.xoffset ? t.xoffset : 0, this._yoffset = t.yoffset ? t.yoffset : 0, this._uv = t.uv ? t.uv : null, isNaN(t.x) || (this._uv = { left: t.x / e.textureWidth, right: (t.x + t.width) / e.textureWidth, top: 1 - (t.y + t.height) / e.textureHeight, bottom: 1 - t.y / e.textureHeight }) } get uv() { return this._uv } clone(e) { return new O_(this._font, { char: e, width: this._width, height: this._heigth, xadvance: this._xadvance, xoffset: this._xoffset, yoffset: this._yoffset, uv: null }) } asInlineGlyph() { return new JJ(this) } } class KJ extends Ze.PlaneGeometry { constructor(e, t) { let s = 1, r = 1; const n = e.typographic.font.size, o = t._segments.value; s = Math.ceil(e.typographic.width / n * o), r = Math.ceil(e.typographic.height / n * o), super(e.width, e.height, s, r), e.uv ? (this._mapUVs(e), this._transformGeometry(e)) : (this._nullifyUVs(), this.scale(0, 0, 1), this.translate(0, e.fontSize / 2, 0)), this.name = "GlyphGeometry" } _mapUVs(e) { const t = e.uv.right - e.uv.left, s = e.uv.bottom - e.uv.top, r = this.getAttribute("uv").array.slice(), n = []; for (let o = 0; o < r.length; o += 2) { const a = r[o], l = r[o + 1]; n.push(e.uv.left + t * a), n.push(e.uv.top + s * l) } this.setAttribute("uvG", new Ze.BufferAttribute(new Float32Array(n), 2)) } _nullifyUVs() { const e = [], t = this.getAttribute("uv").array.length; for (let s = 0; s < t; s++)e.push(0); this.setAttribute("uvG", new Ze.BufferAttribute(new Float32Array(e), 2)) } _transformGeometry(e) { this.translate(e.width / 2, -e.height / 2, 0) } } const ZJ = `
attribute vec2 uvG;
varying vec2 vUvG;
`, QS = ZJ, $J = `
vUvG = uvG;
`, GS = $J, eK = `
gl_Position.z -= 0.00001;
`, HS = eK, tK = `
varying vec2 vUvG;
uniform sampler2D glyphMap;
uniform vec2 unitRange;
// functions from the original msdf repo:
// https://github.com/Chlumsky/msdfgen#using-a-multi-channel-distance-field
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
float screenPxRange() {

	// precomputed unitRange as recommended by Chlumsky
	// vec2 unitRange = vec2(pxRange)/vec2(textureSize(glyphMap, 0));
	vec2 screenTexSize = vec2(1.0)/fwidth(vUvG);
	return max(0.5*dot(unitRange, screenTexSize), 1.0);
}
float tap(vec2 offsetUV) {
	vec3 msd = texture( glyphMap, offsetUV ).rgb;
	float sd = median(msd.r, msd.g, msd.b);
	float screenPxDistance = screenPxRange() * (sd - 0.5);
	float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
	return alpha;
}
`, VS = tK, iK = `
	float alpha;
#ifdef NO_RGSS

	alpha = tap( vUvG );

#else

	// shader-based supersampling based on https://bgolus.medium.com/sharper-mipmapping-using-shader-based-supersampling-ed7aadb47bec
	// per pixel partial derivatives
	vec2 dx = dFdx(vUvG);
	vec2 dy = dFdy(vUvG);
	// rotated grid uv offsets
	vec2 uvOffsets = vec2(0.125, 0.375);
	vec2 offsetUV = vec2(0.0, 0.0);
	// supersampled using 2x2 rotated grid
	alpha = 0.0;
	offsetUV.xy = vUvG + uvOffsets.x * dx + uvOffsets.y * dy;
	alpha += tap(offsetUV);
	offsetUV.xy = vUvG - uvOffsets.x * dx - uvOffsets.y * dy;
	alpha += tap(offsetUV);
	offsetUV.xy = vUvG + uvOffsets.y * dx - uvOffsets.x * dy;
	alpha += tap(offsetUV);
	offsetUV.xy = vUvG - uvOffsets.y * dx + uvOffsets.x * dy;
	alpha += tap(offsetUV);
	alpha *= 0.25;

#endif

	alpha = clamp( alpha, 0.0, 1.0 );

#ifdef INVERT_ALPHA

	alpha = 1.0 - alpha;

#endif

	diffuseColor.a *= alpha;
`, WS = iK, Jy = function (i, e, t) { i.alphaTest = t, qS(i, "USE_ALPHATEST", t > 0) }, qS = function (i, e, t) { i.defines && (t ? i.defines[e] === void 0 && (i.defines[e] = "", i.needsUpdate = !0) : i.defines[e] !== void 0 && (delete i.defines[e], i.needsUpdate = !0)) }, l3 = function (i, e, t) { i.defines[e] && i.defines[e] === t || (i.defines[e] = t, i.needsUpdate = !0) }, Ln = function (i, e, t) { i.userData[e] ? i.userData[e].value = t : i.uniforms[e].value = t }, sK = function (i, e, t) { i.userData[e].value = t }; class $n {
  static ensureMaterialOptions(e) { e.transparent = !0, e.alphaTest = e.alphaTest || .02 } static ensureDefines(e) { e.defines || (e.defines = {}) } static ensureUserData(e, t) { e.userData.glyphMap = { value: t.glyphMap }, e.userData.unitRange = { value: new Ze.Vector2 } } static bindUniformsWithUserData(e, t) { e.uniforms.glyphMap = t.userData.glyphMap, e.uniforms.unitRange = t.userData.unitRange } static injectShaderChunks(e) { $n.injectVertexShaderChunks(e), $n.injectFragmentShaderChunks(e) } static injectVertexShaderChunks(e) {
    e.vertexShader = e.vertexShader.replace("#include <uv_pars_vertex>", `#include <uv_pars_vertex>
`+ QS), e.vertexShader = e.vertexShader.replace("#include <uv_vertex>", `#include <uv_vertex>
`+ GS), e.vertexShader = e.vertexShader.replace("#include <project_vertex>", `#include <project_vertex>
`+ HS)
  } static injectFragmentShaderChunks(e) {
    e.fragmentShader = e.fragmentShader.replace("#include <uv_pars_fragment>", `#include <uv_pars_fragment>
`+ VS), e.fragmentShader = e.fragmentShader.replace("#include <alphamap_fragment>", `#include <alphamap_fragment>
`+ WS)
  } static from(e) { return class extends e { constructor(t = {}) { $n.ensureMaterialOptions(t), super(t), u(this, "_cumulativeOnBeforeCompile", s => { $n.bindUniformsWithUserData(s, this), $n.injectShaderChunks(s), this._userDefinedOnBeforeCompile(s) }), $n.ensureDefines(this), $n.ensureUserData(this, t), this._userDefinedOnBeforeCompile = s => { }, this._onBeforeCompile = this._cumulativeOnBeforeCompile } static get fontMaterialProperties() { return $n.mediation } set onBeforeCompile(t) { this._userDefinedOnBeforeCompile = t } get onBeforeCompile() { return this._onBeforeCompile } } } static get mediation() { return oK }
} const rK = function (i, e, t) { const s = t ? t.texture : null, r = t ? t.unitRange : new Ze.Vector2; if (i[e] !== void 0) { i.glyphMap = s, i.unitRange = r; return } i.userData && i.userData.glyphMap && (i.userData.glyphMap.value = s, i.userData.unitRange.value = r) }, nK = function (i, e, t) { t && t !== "antialiased" ? i.defines.NO_RGSS = "" : delete i.defines.NO_RGSS, i.needsUpdate = !0 }, oK = { clippingPlanes: { m: "clippingPlanes" }, fontAlphaTest: { m: "alphaTest", t: Jy }, fontSide: { m: "side" }, font: { m: "glyphMap", t: rK }, color: { m: "color" }, fontOpacity: { m: "opacity" }, fontSmooth: { m: "NO_RGSS", t: nK }, invertAlpha: { m: "INVERT_ALPHA", t: qS } }, aK = `
${QS}
#include <clipping_planes_pars_vertex>
void main() {
	${GS}
	#include <begin_vertex>
	#include <project_vertex>
	${HS}
	#include <clipping_planes_vertex>
}
`, lK = `
uniform vec3 diffuse;
uniform float opacity;
${VS}
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	// instead of <color_fragment> : vec4 diffuseColor
	vec4 diffuseColor = vec4( diffuse, opacity );
	${WS}
	#include <alphatest_fragment>
	// instead of <output_fragment>
	gl_FragColor = diffuseColor;
	#include <clipping_planes_fragment>
}
`, cK = .02; class CI extends Ze.ShaderMaterial { static get mediation() { return $n.mediation } constructor(e = {}) { super({ uniforms: { glyphMap: { value: null }, diffuse: { value: null }, opacity: { value: 1 }, unitRange: { value: new Ze.Vector2(0, 0) }, alphaTest: { value: cK } }, transparent: !0, clipping: !0, vertexShader: aK, fragmentShader: lK, extensions: { derivatives: !0 } }), this.defines.USE_ALPHATEST = "", this.needsUpdate = !0, this.noRGSS = e.noRGSS || !1 } get color() { return this.uniforms.diffuse.value } set color(e) { this.uniforms.diffuse.value = e } set opacity(e) { this.uniforms && (this.uniforms.opacity.value = e) } get opacity() { return this.uniforms.opacity.value } get unitRange() { return this.uniforms.unitRange.value } set unitRange(e) { this.uniforms.unitRange.value.copy(e) } get glyphMap() { return this.uniforms.glyphMap.value } set glyphMap(e) { this.uniforms.glyphMap.value = e } get isDefault() { return this.constructor === CI } get alphaTest() { return this.uniforms.alphaTest.value } set alphaTest(e) { this.uniforms.alphaTest.value = e } } class hK extends Vg {
  constructor(e, t, s, r) { if (super(e, t), this._unitRange = new Ze.Vector2(1, 1), s.pages ? this._buildData(s) : uK(this, s), r instanceof Ze.Texture) this._texture = r, this._buildTexture(r); else if (typeof r == "string" || r instanceof String) dK(this, r); else throw new Error(`ThreeMeshUI::MSDFVariant provided 'texture' parameter is '${typeof r}'. Only Texture and String allowed.`); this._defaultMaterialClass = CI, this._checkReadiness() } get texture() { return this._texture } get unitRange() { return this._unitRange } set fontMaterial(e) { this._defaultMaterialClass = e } get fontMaterial() { return this._defaultMaterialClass } _buildData(e) {
    this._font = new YJ(e), this._kernings = this._buildKerningPairs(e), this._chars = this._buildCharacters(e), this._chars[" "] = this._buildCharacterWhite(e), this._chars[`
`] = this._buildCharacterWhite(e, `
`, .001, 1), this._chars["	"] = this._buildCharacterWhite(e, "	", 4, 1), this._size = e.info.size, this._lineHeight = e.common.lineHeight, this._lineBase = e.common.base, this._distanceRange = e.distanceField.distanceRange, this._unitRange = new Ze.Vector2(this._distanceRange, this._distanceRange).divide(new Ze.Vector2(e.common.scaleW, e.common.scaleH))
  } _buildTexture(e) { e.generateMipmaps = !1, e.minFilter = Ze.LinearFilter, e.magFilter = Ze.LinearFilter, e.needsUpdate = !0 } _getFallbackCharacter(e) { return Vh.missingCharacter(this, e) } getGeometricGlyph(e, t) { return new KJ(e, t) } _readyCondition() { return this._chars && this._texture && this._texture.image } _buildKerningPairs(e) { const t = {}; for (let s = 0; s < e.kernings.length; s++) { const r = e.kernings[s]; if (r.amount === 0) continue; const n = String.fromCharCode(r.first, r.second); t[n] = r.amount } return t } _buildCharacters(e) { const t = {}; for (let s = 0; s < e.chars.length; s++) { const r = e.chars[s]; t[r.char] = new O_(this._font, r) } return t } _buildCharacterWhite(e, t = " ", s = 1, r = 1) { return new O_(this._font, { char: t, width: e.info.size / 3 * s, height: e.info.size * .7 * r }) } _alterElementProperties(e) { }
} function uK(i, e) { new Ze.FileLoader().setResponseType("json").load(e, t => { i._buildData(t), i._checkReadiness() }) } function dK(i, e) { i._texture = new Ze.TextureLoader().load(e, t => { i._buildTexture(t), i._checkReadiness() }) } class Ky extends Ze.EventDispatcher { constructor(e) { super(), u(this, "_checkReadiness", () => { this._variants.every(t => t.isReady) && fK(this) }), this._name = e, this._variants = [], this._isReady = !1 } get isReady() { return this._isReady } addVariant(e, t, s, r, n = !1) { if (n || !this.getVariant(e, t)) { this._isReady = !1; const o = new hK(e, t, s, r); this._variants.push(o), o.isReady ? this._checkReadiness() : o.addEventListener("ready", this._checkReadiness) } else console.warn(`FontFamily('${this._name}')::addVariant() - Variant(${e}, ${t}) already exists.`); return this } addCustomImplementationVariant(e, t = !1) { return t || !this.getVariant(e.weight, e.style) ? (this._isReady = !1, this._variants.push(e), e.isReady ? this._checkReadiness() : e.addEventListener("ready", this._checkReadiness)) : console.warn(`FontFamily('${this._name}')::addCustomImplementationVariant() - Variant(${e.weight}, ${e.style}) already exists.`), this } getVariant(e, t) { return this._variants.find(s => s.weight === e && s.style === t) } get name() { return this._name } } const pK = { type: "ready" }; function fK(i) { i._isReady = !0, i.dispatchEvent(pK) } const Zy = {}, gK = function (i) { const e = [...arguments]; e.forEach(s => { if (!(s instanceof Ky)) throw new Error(`FontLibrary::prepare() - One of the provided parameter is not a FontFamily. Instead ${typeof s} given.`) }); const t = function () { return e.every(s => s.isReady) }; return new Promise((s, r) => { if (t()) s(); else for (let n = 0; n < e.length; n++) { const o = e[n]; o.isReady || o.addEventListener("ready", () => { t() && s() }) } }) }, mK = function (i) { return Zy[i] && console.error(`FontLibrary::addFontFamily - Font('${i}') is already registered`), Zy[i] = new Ky(i), Zy[i] }, vK = function (i) { return Zy[i] }, AK = function (i) { c3 = i }; let c3 = function (i, e) { return console.error(`The character '${e}' is not included in the font characters set.`), " " }; function yK(i, e) { return c3(i, e) } const bK = { addFontFamily: mK, getFontFamily: vK, prepare: gK, setMissingCharacterHandler: AK, missingCharacter: yK }, Vh = bK; class h3 extends wi { constructor() { super("fontFamily", "inherit", !0) } computeOutputValue(e) { if (this._input instanceof Ky) this._value = this._input; else if (this._input !== "inherit") if (typeof this._input == "string") { const t = Vh.getFontFamily(this._input); t ? this._value = t : console.warn(`(.style) fontFamily, the font '${this._input}' is not registered. Aborted.`) } else console.warn("(.style) fontFamily requires a registered fontFamily instance, or the id of a registered fontFamily."), console.warn("If you want to set a specific font, please use .font property instead.") } get value() { return this._value } getInheritedInput(e) { if (this._input !== "inherit") return this._input; const t = e._parent._value; return t ? t[`_${this._id}`].getInheritedInput(t) : this.getDefaultValue() } } class u3 extends wi { constructor() { super("lineHeight", "inherit", !0) } update(e, t) { super.update(e, t), e._layouter._needsProcess = !0 } } class d3 extends wi { constructor() { super("whiteSpace", "inherit"), this.isValidValue = xK } } const _K = ["normal", "nowrap", "pre", "pre-line", "pre-wrap"]; function xK(i) { return _K.indexOf(i) === -1 ? (console.warn(`(.style) whiteSpace value '${i}' is not valid. Aborted`), !1) : !0 } class p3 extends wi { constructor() { super("letterSpacing", "inherit", !0) } } class wK extends wi { constructor() { super("fontSize", "inherit", !0) } } class f3 extends ci { constructor() { super("segments", 1, !1) } } class CK extends Hh { constructor() { super("invertAlpha", "inherit") } } class $y extends wi { constructor() { super("fontKerning", "inherit"), this.isValidValue = EK } } const SK = ["normal", "none", "inherit"]; function EK(i) { return SK.indexOf(i) === -1 ? (console.warn(`(.style) fontKerning value '${i}' is not valid. Aborted`), !1) : !0 } class eb extends Hh { constructor(e) { super(e, "inherit", !0) } } class g3 extends Hh { constructor(e) { super(e, "inherit", !1), this._mediation = {}, this._defaultMaterial = null } update(e, t) { this._notInheritedValue = this._value, this._notInheritedValue === "inherit" ? this._notInheritedValue = this.getInheritedInput(e) : this.propagate(e), this._notInheritedValue ? this._notInheritedValue.constructor.mediation ? this._mediation = { ...this._notInheritedValue.constructor.mediation } : this._mediation = { clippingPlanes: { m: "clippingPlanes" }, fontAlphaTest: { m: "alphaTest", t: Jy }, fontSide: { m: "side" }, color: { m: "color" }, fontOpacity: { m: "opacity" } } : this._mediation = {}, e._transferToFontMaterial(), this._outputValue(t) } getInheritedInput(e) { if (this._value !== "inherit") return this._value; let t = e, s = null; for (; t._parent._value;)if (t = t._parent._value, t[`_${this._id}`]._value !== "inherit") { s = t[`_${this._id}`]._value; break } return s !== null ? s : this.getDefaultValue() } getDefaultValue() { return this._defaultMaterial } } var MK = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], m3 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], IK = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", v3 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", XS = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, YS = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", TK = { 5: YS, "5module": YS + " export import", 6: YS + " const class extends export import super" }, RK = /^in(stanceof)?$/, PK = new RegExp("[" + v3 + "]"), BK = new RegExp("[" + v3 + IK + "]"); function JS(i, e) { for (var t = 65536, s = 0; s < e.length; s += 2) { if (t += e[s], t > i) return !1; if (t += e[s + 1], t >= i) return !0 } } function cl(i, e) { return i < 65 ? i === 36 : i < 91 ? !0 : i < 97 ? i === 95 : i < 123 ? !0 : i <= 65535 ? i >= 170 && PK.test(String.fromCharCode(i)) : e === !1 ? !1 : JS(i, m3) } function $d(i, e) { return i < 48 ? i === 36 : i < 58 ? !0 : i < 65 ? !1 : i < 91 ? !0 : i < 97 ? i === 95 : i < 123 ? !0 : i <= 65535 ? i >= 170 && BK.test(String.fromCharCode(i)) : e === !1 ? !1 : JS(i, m3) || JS(i, MK) } var ei = function (i, e) { e === void 0 && (e = {}), this.label = i, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop || null, this.updateContext = null }; function Fn(i, e) { return new ei(i, { beforeExpr: !0, binop: e }) } var Un = { beforeExpr: !0 }, Qr = { startsExpr: !0 }, KS = {}; function Yt(i, e) { return e === void 0 && (e = {}), e.keyword = i, KS[i] = new ei(i, e) } var B = { num: new ei("num", Qr), regexp: new ei("regexp", Qr), string: new ei("string", Qr), name: new ei("name", Qr), privateId: new ei("privateId", Qr), eof: new ei("eof"), bracketL: new ei("[", { beforeExpr: !0, startsExpr: !0 }), bracketR: new ei("]"), braceL: new ei("{", { beforeExpr: !0, startsExpr: !0 }), braceR: new ei("}"), parenL: new ei("(", { beforeExpr: !0, startsExpr: !0 }), parenR: new ei(")"), comma: new ei(",", Un), semi: new ei(";", Un), colon: new ei(":", Un), dot: new ei("."), question: new ei("?", Un), questionDot: new ei("?."), arrow: new ei("=>", Un), template: new ei("template"), invalidTemplate: new ei("invalidTemplate"), ellipsis: new ei("...", Un), backQuote: new ei("`", Qr), dollarBraceL: new ei("${", { beforeExpr: !0, startsExpr: !0 }), eq: new ei("=", { beforeExpr: !0, isAssign: !0 }), assign: new ei("_=", { beforeExpr: !0, isAssign: !0 }), incDec: new ei("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }), prefix: new ei("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), logicalOR: Fn("||", 1), logicalAND: Fn("&&", 2), bitwiseOR: Fn("|", 3), bitwiseXOR: Fn("^", 4), bitwiseAND: Fn("&", 5), equality: Fn("==/!=/===/!==", 6), relational: Fn("</>/<=/>=", 7), bitShift: Fn("<</>>/>>>", 8), plusMin: new ei("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }), modulo: Fn("%", 10), star: Fn("*", 10), slash: Fn("/", 10), starstar: new ei("**", { beforeExpr: !0 }), coalesce: Fn("??", 1), _break: Yt("break"), _case: Yt("case", Un), _catch: Yt("catch"), _continue: Yt("continue"), _debugger: Yt("debugger"), _default: Yt("default", Un), _do: Yt("do", { isLoop: !0, beforeExpr: !0 }), _else: Yt("else", Un), _finally: Yt("finally"), _for: Yt("for", { isLoop: !0 }), _function: Yt("function", Qr), _if: Yt("if"), _return: Yt("return", Un), _switch: Yt("switch"), _throw: Yt("throw", Un), _try: Yt("try"), _var: Yt("var"), _const: Yt("const"), _while: Yt("while", { isLoop: !0 }), _with: Yt("with"), _new: Yt("new", { beforeExpr: !0, startsExpr: !0 }), _this: Yt("this", Qr), _super: Yt("super", Qr), _class: Yt("class", Qr), _extends: Yt("extends", Un), _export: Yt("export"), _import: Yt("import", Qr), _null: Yt("null", Qr), _true: Yt("true", Qr), _false: Yt("false", Qr), _in: Yt("in", { beforeExpr: !0, binop: 7 }), _instanceof: Yt("instanceof", { beforeExpr: !0, binop: 7 }), _typeof: Yt("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _void: Yt("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _delete: Yt("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }) }, Nn = /\r\n?|\n|\u2028|\u2029/, kK = new RegExp(Nn.source, "g"); function ep(i) { return i === 10 || i === 13 || i === 8232 || i === 8233 } function A3(i, e, t) { t === void 0 && (t = i.length); for (var s = e; s < t; s++) { var r = i.charCodeAt(s); if (ep(r)) return s < t - 1 && r === 13 && i.charCodeAt(s + 1) === 10 ? s + 2 : s + 1 } return -1 } var y3 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, zn = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, b3 = Object.prototype, DK = b3.hasOwnProperty, OK = b3.toString, qg = Object.hasOwn || function (i, e) { return DK.call(i, e) }, _3 = Array.isArray || function (i) { return OK.call(i) === "[object Array]" }; function Wh(i) { return new RegExp("^(?:" + i.replace(/ /g, "|") + ")$") } function Tc(i) { return i <= 65535 ? String.fromCharCode(i) : (i -= 65536, String.fromCharCode((i >> 10) + 55296, (i & 1023) + 56320)) } var LK = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Xg = function (i, e) { this.line = i, this.column = e }; Xg.prototype.offset = function (i) { return new Xg(this.line, this.column + i) }; var tb = function (i, e, t) { this.start = e, this.end = t, i.sourceFile !== null && (this.source = i.sourceFile) }; function x3(i, e) { for (var t = 1, s = 0; ;) { var r = A3(i, s, e); if (r < 0) return new Xg(t, e - s); ++t, s = r } } var ZS = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: !1, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1 }, w3 = !1; function FK(i) {
  var e = {}; for (var t in ZS) e[t] = i && qg(i, t) ? i[t] : ZS[t]; if (e.ecmaVersion === "latest" ? e.ecmaVersion = 1e8 : e.ecmaVersion == null ? (!w3 && typeof console == "object" && console.warn && (w3 = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), e.ecmaVersion = 11) : e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009), e.allowReserved == null && (e.allowReserved = e.ecmaVersion < 5), i.allowHashBang == null && (e.allowHashBang = e.ecmaVersion >= 14), _3(e.onToken)) { var s = e.onToken; e.onToken = function (r) { return s.push(r) } } return _3(e.onComment) && (e.onComment = UK(e, e.onComment)), e
} function UK(i, e) { return function (t, s, r, n, o, a) { var l = { type: t ? "Block" : "Line", value: s, start: r, end: n }; i.locations && (l.loc = new tb(this, o, a)), i.ranges && (l.range = [r, n]), e.push(l) } } var Yg = 1, tp = 2, $S = 4, C3 = 8, S3 = 16, E3 = 32, eE = 64, M3 = 128, Jg = 256, tE = Yg | tp | Jg; function iE(i, e) { return tp | (i ? $S : 0) | (e ? C3 : 0) } var ib = 0, sE = 1, hl = 2, I3 = 3, T3 = 4, R3 = 5, Rs = function (i, e, t) {
  this.options = i = FK(i), this.sourceFile = i.sourceFile, this.keywords = Wh(TK[i.ecmaVersion >= 6 ? 6 : i.sourceType === "module" ? "5module" : 5]); var s = ""; i.allowReserved !== !0 && (s = XS[i.ecmaVersion >= 6 ? 6 : i.ecmaVersion === 5 ? 5 : 3], i.sourceType === "module" && (s += " await")), this.reservedWords = Wh(s); var r = (s ? s + " " : "") + XS.strict; this.reservedWordsStrict = Wh(r), this.reservedWordsStrictBind = Wh(r + " " + XS.strictBind), this.input = String(e), this.containsEsc = !1, t ? (this.pos = t, this.lineStart = this.input.lastIndexOf(`
`, t - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Nn).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = B.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = i.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = Object.create(null), this.pos === 0 && i.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Yg), this.regexpState = null, this.privateNameStack = []
}, $o = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } }; Rs.prototype.parse = function () { var i = this.options.program || this.startNode(); return this.nextToken(), this.parseTopLevel(i) }, $o.inFunction.get = function () { return (this.currentVarScope().flags & tp) > 0 }, $o.inGenerator.get = function () { return (this.currentVarScope().flags & C3) > 0 && !this.currentVarScope().inClassFieldInit }, $o.inAsync.get = function () { return (this.currentVarScope().flags & $S) > 0 && !this.currentVarScope().inClassFieldInit }, $o.canAwait.get = function () { for (var i = this.scopeStack.length - 1; i >= 0; i--) { var e = this.scopeStack[i]; if (e.inClassFieldInit || e.flags & Jg) return !1; if (e.flags & tp) return (e.flags & $S) > 0 } return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction }, $o.allowSuper.get = function () { var i = this.currentThisScope(), e = i.flags, t = i.inClassFieldInit; return (e & eE) > 0 || t || this.options.allowSuperOutsideMethod }, $o.allowDirectSuper.get = function () { return (this.currentThisScope().flags & M3) > 0 }, $o.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) }, $o.allowNewDotTarget.get = function () { var i = this.currentThisScope(), e = i.flags, t = i.inClassFieldInit; return (e & (tp | Jg)) > 0 || t }, $o.inClassStaticBlock.get = function () { return (this.currentVarScope().flags & Jg) > 0 }, Rs.extend = function () { for (var i = [], e = arguments.length; e--;)i[e] = arguments[e]; for (var t = this, s = 0; s < i.length; s++)t = i[s](t); return t }, Rs.parse = function (i, e) { return new this(e, i).parse() }, Rs.parseExpressionAt = function (i, e, t) { var s = new this(t, i, e); return s.nextToken(), s.parseExpression() }, Rs.tokenizer = function (i, e) { return new this(e, i) }, Object.defineProperties(Rs.prototype, $o); var Mr = Rs.prototype, NK = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/; Mr.strictDirective = function (i) { if (this.options.ecmaVersion < 5) return !1; for (; ;) { zn.lastIndex = i, i += zn.exec(this.input)[0].length; var e = NK.exec(this.input.slice(i)); if (!e) return !1; if ((e[1] || e[2]) === "use strict") { zn.lastIndex = i + e[0].length; var t = zn.exec(this.input), s = t.index + t[0].length, r = this.input.charAt(s); return r === ";" || r === "}" || Nn.test(t[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(r) || r === "!" && this.input.charAt(s + 1) === "=") } i += e[0].length, zn.lastIndex = i, i += zn.exec(this.input)[0].length, this.input[i] === ";" && i++ } }, Mr.eat = function (i) { return this.type === i ? (this.next(), !0) : !1 }, Mr.isContextual = function (i) { return this.type === B.name && this.value === i && !this.containsEsc }, Mr.eatContextual = function (i) { return this.isContextual(i) ? (this.next(), !0) : !1 }, Mr.expectContextual = function (i) { this.eatContextual(i) || this.unexpected() }, Mr.canInsertSemicolon = function () { return this.type === B.eof || this.type === B.braceR || Nn.test(this.input.slice(this.lastTokEnd, this.start)) }, Mr.insertSemicolon = function () { if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0 }, Mr.semicolon = function () { !this.eat(B.semi) && !this.insertSemicolon() && this.unexpected() }, Mr.afterTrailingComma = function (i, e) { if (this.type === i) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), e || this.next(), !0 }, Mr.expect = function (i) { this.eat(i) || this.unexpected() }, Mr.unexpected = function (i) { this.raise(i ?? this.start, "Unexpected token") }; var sb = function () { this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1 }; Mr.checkPatternErrors = function (i, e) { if (i) { i.trailingComma > -1 && this.raiseRecoverable(i.trailingComma, "Comma is not permitted after the rest element"); var t = e ? i.parenthesizedAssign : i.parenthesizedBind; t > -1 && this.raiseRecoverable(t, e ? "Assigning to rvalue" : "Parenthesized pattern") } }, Mr.checkExpressionErrors = function (i, e) { if (!i) return !1; var t = i.shorthandAssign, s = i.doubleProto; if (!e) return t >= 0 || s >= 0; t >= 0 && this.raise(t, "Shorthand property assignments are valid only in destructuring patterns"), s >= 0 && this.raiseRecoverable(s, "Redefinition of __proto__ property") }, Mr.checkYieldAwaitInDefaultParams = function () { this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value") }, Mr.isSimpleAssignTarget = function (i) { return i.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(i.expression) : i.type === "Identifier" || i.type === "MemberExpression" }; var St = Rs.prototype; St.parseTopLevel = function (i) { var e = Object.create(null); for (i.body || (i.body = []); this.type !== B.eof;) { var t = this.parseStatement(null, !0, e); i.body.push(t) } if (this.inModule) for (var s = 0, r = Object.keys(this.undefinedExports); s < r.length; s += 1) { var n = r[s]; this.raiseRecoverable(this.undefinedExports[n].start, "Export '" + n + "' is not defined") } return this.adaptDirectivePrologue(i.body), this.next(), i.sourceType = this.options.sourceType, this.finishNode(i, "Program") }; var rE = { kind: "loop" }, zK = { kind: "switch" }; St.isLet = function (i) { if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1; zn.lastIndex = this.pos; var e = zn.exec(this.input), t = this.pos + e[0].length, s = this.input.charCodeAt(t); if (s === 91 || s === 92 || s > 55295 && s < 56320) return !0; if (i) return !1; if (s === 123) return !0; if (cl(s, !0)) { for (var r = t + 1; $d(s = this.input.charCodeAt(r), !0);)++r; if (s === 92 || s > 55295 && s < 56320) return !0; var n = this.input.slice(t, r); if (!RK.test(n)) return !0 } return !1 }, St.isAsyncFunction = function () { if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1; zn.lastIndex = this.pos; var i = zn.exec(this.input), e = this.pos + i[0].length, t; return !Nn.test(this.input.slice(this.pos, e)) && this.input.slice(e, e + 8) === "function" && (e + 8 === this.input.length || !($d(t = this.input.charCodeAt(e + 8)) || t > 55295 && t < 56320)) }, St.parseStatement = function (i, e, t) { var s = this.type, r = this.startNode(), n; switch (this.isLet(i) && (s = B._var, n = "let"), s) { case B._break: case B._continue: return this.parseBreakContinueStatement(r, s.keyword); case B._debugger: return this.parseDebuggerStatement(r); case B._do: return this.parseDoStatement(r); case B._for: return this.parseForStatement(r); case B._function: return i && (this.strict || i !== "if" && i !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(r, !1, !i); case B._class: return i && this.unexpected(), this.parseClass(r, !0); case B._if: return this.parseIfStatement(r); case B._return: return this.parseReturnStatement(r); case B._switch: return this.parseSwitchStatement(r); case B._throw: return this.parseThrowStatement(r); case B._try: return this.parseTryStatement(r); case B._const: case B._var: return n = n || this.value, i && n !== "var" && this.unexpected(), this.parseVarStatement(r, n); case B._while: return this.parseWhileStatement(r); case B._with: return this.parseWithStatement(r); case B.braceL: return this.parseBlock(!0, r); case B.semi: return this.parseEmptyStatement(r); case B._export: case B._import: if (this.options.ecmaVersion > 10 && s === B._import) { zn.lastIndex = this.pos; var o = zn.exec(this.input), a = this.pos + o[0].length, l = this.input.charCodeAt(a); if (l === 40 || l === 46) return this.parseExpressionStatement(r, this.parseExpression()) } return this.options.allowImportExportEverywhere || (e || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), s === B._import ? this.parseImport(r) : this.parseExport(r, t); default: if (this.isAsyncFunction()) return i && this.unexpected(), this.next(), this.parseFunctionStatement(r, !0, !i); var c = this.value, h = this.parseExpression(); return s === B.name && h.type === "Identifier" && this.eat(B.colon) ? this.parseLabeledStatement(r, c, h, i) : this.parseExpressionStatement(r, h) } }, St.parseBreakContinueStatement = function (i, e) { var t = e === "break"; this.next(), this.eat(B.semi) || this.insertSemicolon() ? i.label = null : this.type !== B.name ? this.unexpected() : (i.label = this.parseIdent(), this.semicolon()); for (var s = 0; s < this.labels.length; ++s) { var r = this.labels[s]; if ((i.label == null || r.name === i.label.name) && (r.kind != null && (t || r.kind === "loop") || i.label && t)) break } return s === this.labels.length && this.raise(i.start, "Unsyntactic " + e), this.finishNode(i, t ? "BreakStatement" : "ContinueStatement") }, St.parseDebuggerStatement = function (i) { return this.next(), this.semicolon(), this.finishNode(i, "DebuggerStatement") }, St.parseDoStatement = function (i) { return this.next(), this.labels.push(rE), i.body = this.parseStatement("do"), this.labels.pop(), this.expect(B._while), i.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(B.semi) : this.semicolon(), this.finishNode(i, "DoWhileStatement") }, St.parseForStatement = function (i) { this.next(); var e = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1; if (this.labels.push(rE), this.enterScope(0), this.expect(B.parenL), this.type === B.semi) return e > -1 && this.unexpected(e), this.parseFor(i, null); var t = this.isLet(); if (this.type === B._var || this.type === B._const || t) { var s = this.startNode(), r = t ? "let" : this.value; return this.next(), this.parseVar(s, !0, r), this.finishNode(s, "VariableDeclaration"), (this.type === B._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && s.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === B._in ? e > -1 && this.unexpected(e) : i.await = e > -1), this.parseForIn(i, s)) : (e > -1 && this.unexpected(e), this.parseFor(i, s)) } var n = this.isContextual("let"), o = !1, a = new sb, l = this.parseExpression(e > -1 ? "await" : !0, a); return this.type === B._in || (o = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === B._in ? e > -1 && this.unexpected(e) : i.await = e > -1), n && o && this.raise(l.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(l, !1, a), this.checkLValPattern(l), this.parseForIn(i, l)) : (this.checkExpressionErrors(a, !0), e > -1 && this.unexpected(e), this.parseFor(i, l)) }, St.parseFunctionStatement = function (i, e, t) { return this.next(), this.parseFunction(i, Kg | (t ? 0 : nE), !1, e) }, St.parseIfStatement = function (i) { return this.next(), i.test = this.parseParenExpression(), i.consequent = this.parseStatement("if"), i.alternate = this.eat(B._else) ? this.parseStatement("if") : null, this.finishNode(i, "IfStatement") }, St.parseReturnStatement = function (i) { return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(B.semi) || this.insertSemicolon() ? i.argument = null : (i.argument = this.parseExpression(), this.semicolon()), this.finishNode(i, "ReturnStatement") }, St.parseSwitchStatement = function (i) { this.next(), i.discriminant = this.parseParenExpression(), i.cases = [], this.expect(B.braceL), this.labels.push(zK), this.enterScope(0); for (var e, t = !1; this.type !== B.braceR;)if (this.type === B._case || this.type === B._default) { var s = this.type === B._case; e && this.finishNode(e, "SwitchCase"), i.cases.push(e = this.startNode()), e.consequent = [], this.next(), s ? e.test = this.parseExpression() : (t && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), t = !0, e.test = null), this.expect(B.colon) } else e || this.unexpected(), e.consequent.push(this.parseStatement(null)); return this.exitScope(), e && this.finishNode(e, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(i, "SwitchStatement") }, St.parseThrowStatement = function (i) { return this.next(), Nn.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), i.argument = this.parseExpression(), this.semicolon(), this.finishNode(i, "ThrowStatement") }; var jK = []; St.parseTryStatement = function (i) { if (this.next(), i.block = this.parseBlock(), i.handler = null, this.type === B._catch) { var e = this.startNode(); if (this.next(), this.eat(B.parenL)) { e.param = this.parseBindingAtom(); var t = e.param.type === "Identifier"; this.enterScope(t ? E3 : 0), this.checkLValPattern(e.param, t ? T3 : hl), this.expect(B.parenR) } else this.options.ecmaVersion < 10 && this.unexpected(), e.param = null, this.enterScope(0); e.body = this.parseBlock(!1), this.exitScope(), i.handler = this.finishNode(e, "CatchClause") } return i.finalizer = this.eat(B._finally) ? this.parseBlock() : null, !i.handler && !i.finalizer && this.raise(i.start, "Missing catch or finally clause"), this.finishNode(i, "TryStatement") }, St.parseVarStatement = function (i, e) { return this.next(), this.parseVar(i, !1, e), this.semicolon(), this.finishNode(i, "VariableDeclaration") }, St.parseWhileStatement = function (i) { return this.next(), i.test = this.parseParenExpression(), this.labels.push(rE), i.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(i, "WhileStatement") }, St.parseWithStatement = function (i) { return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), i.object = this.parseParenExpression(), i.body = this.parseStatement("with"), this.finishNode(i, "WithStatement") }, St.parseEmptyStatement = function (i) { return this.next(), this.finishNode(i, "EmptyStatement") }, St.parseLabeledStatement = function (i, e, t, s) { for (var r = 0, n = this.labels; r < n.length; r += 1) { var o = n[r]; o.name === e && this.raise(t.start, "Label '" + e + "' is already declared") } for (var a = this.type.isLoop ? "loop" : this.type === B._switch ? "switch" : null, l = this.labels.length - 1; l >= 0; l--) { var c = this.labels[l]; if (c.statementStart === i.start) c.statementStart = this.start, c.kind = a; else break } return this.labels.push({ name: e, kind: a, statementStart: this.start }), i.body = this.parseStatement(s ? s.indexOf("label") === -1 ? s + "label" : s : "label"), this.labels.pop(), i.label = t, this.finishNode(i, "LabeledStatement") }, St.parseExpressionStatement = function (i, e) { return i.expression = e, this.semicolon(), this.finishNode(i, "ExpressionStatement") }, St.parseBlock = function (i, e, t) { for (i === void 0 && (i = !0), e === void 0 && (e = this.startNode()), e.body = [], this.expect(B.braceL), i && this.enterScope(0); this.type !== B.braceR;) { var s = this.parseStatement(null); e.body.push(s) } return t && (this.strict = !1), this.next(), i && this.exitScope(), this.finishNode(e, "BlockStatement") }, St.parseFor = function (i, e) { return i.init = e, this.expect(B.semi), i.test = this.type === B.semi ? null : this.parseExpression(), this.expect(B.semi), i.update = this.type === B.parenR ? null : this.parseExpression(), this.expect(B.parenR), i.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(i, "ForStatement") }, St.parseForIn = function (i, e) { var t = this.type === B._in; return this.next(), e.type === "VariableDeclaration" && e.declarations[0].init != null && (!t || this.options.ecmaVersion < 8 || this.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") && this.raise(e.start, (t ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), i.left = e, i.right = t ? this.parseExpression() : this.parseMaybeAssign(), this.expect(B.parenR), i.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(i, t ? "ForInStatement" : "ForOfStatement") }, St.parseVar = function (i, e, t) { for (i.declarations = [], i.kind = t; ;) { var s = this.startNode(); if (this.parseVarId(s, t), this.eat(B.eq) ? s.init = this.parseMaybeAssign(e) : t === "const" && !(this.type === B._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : s.id.type !== "Identifier" && !(e && (this.type === B._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : s.init = null, i.declarations.push(this.finishNode(s, "VariableDeclarator")), !this.eat(B.comma)) break } return i }, St.parseVarId = function (i, e) { i.id = this.parseBindingAtom(), this.checkLValPattern(i.id, e === "var" ? sE : hl, !1) }; var Kg = 1, nE = 2, P3 = 4; St.parseFunction = function (i, e, t, s, r) { this.initFunction(i), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !s) && (this.type === B.star && e & nE && this.unexpected(), i.generator = this.eat(B.star)), this.options.ecmaVersion >= 8 && (i.async = !!s), e & Kg && (i.id = e & P3 && this.type !== B.name ? null : this.parseIdent(), i.id && !(e & nE) && this.checkLValSimple(i.id, this.strict || i.generator || i.async ? this.treatFunctionsAsVar ? sE : hl : I3)); var n = this.yieldPos, o = this.awaitPos, a = this.awaitIdentPos; return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(iE(i.async, i.generator)), e & Kg || (i.id = this.type === B.name ? this.parseIdent() : null), this.parseFunctionParams(i), this.parseFunctionBody(i, t, !1, r), this.yieldPos = n, this.awaitPos = o, this.awaitIdentPos = a, this.finishNode(i, e & Kg ? "FunctionDeclaration" : "FunctionExpression") }, St.parseFunctionParams = function (i) { this.expect(B.parenL), i.params = this.parseBindingList(B.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams() }, St.parseClass = function (i, e) { this.next(); var t = this.strict; this.strict = !0, this.parseClassId(i, e), this.parseClassSuper(i); var s = this.enterClassBody(), r = this.startNode(), n = !1; for (r.body = [], this.expect(B.braceL); this.type !== B.braceR;) { var o = this.parseClassElement(i.superClass !== null); o && (r.body.push(o), o.type === "MethodDefinition" && o.kind === "constructor" ? (n && this.raise(o.start, "Duplicate constructor in the same class"), n = !0) : o.key && o.key.type === "PrivateIdentifier" && QK(s, o) && this.raiseRecoverable(o.key.start, "Identifier '#" + o.key.name + "' has already been declared")) } return this.strict = t, this.next(), i.body = this.finishNode(r, "ClassBody"), this.exitClassBody(), this.finishNode(i, e ? "ClassDeclaration" : "ClassExpression") }, St.parseClassElement = function (i) { if (this.eat(B.semi)) return null; var e = this.options.ecmaVersion, t = this.startNode(), s = "", r = !1, n = !1, o = "method", a = !1; if (this.eatContextual("static")) { if (e >= 13 && this.eat(B.braceL)) return this.parseClassStaticBlock(t), t; this.isClassElementNameStart() || this.type === B.star ? a = !0 : s = "static" } if (t.static = a, !s && e >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === B.star) && !this.canInsertSemicolon() ? n = !0 : s = "async"), !s && (e >= 9 || !n) && this.eat(B.star) && (r = !0), !s && !n && !r) { var l = this.value; (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? o = l : s = l) } if (s ? (t.computed = !1, t.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), t.key.name = s, this.finishNode(t.key, "Identifier")) : this.parseClassElementName(t), e < 13 || this.type === B.parenL || o !== "method" || r || n) { var c = !t.static && rb(t, "constructor"), h = c && i; c && o !== "method" && this.raise(t.key.start, "Constructor can't have get/set modifier"), t.kind = c ? "constructor" : o, this.parseClassMethod(t, r, n, h) } else this.parseClassField(t); return t }, St.isClassElementNameStart = function () { return this.type === B.name || this.type === B.privateId || this.type === B.num || this.type === B.string || this.type === B.bracketL || this.type.keyword }, St.parseClassElementName = function (i) { this.type === B.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), i.computed = !1, i.key = this.parsePrivateIdent()) : this.parsePropertyName(i) }, St.parseClassMethod = function (i, e, t, s) { var r = i.key; i.kind === "constructor" ? (e && this.raise(r.start, "Constructor can't be a generator"), t && this.raise(r.start, "Constructor can't be an async method")) : i.static && rb(i, "prototype") && this.raise(r.start, "Classes may not have a static property named prototype"); var n = i.value = this.parseMethod(e, t, s); return i.kind === "get" && n.params.length !== 0 && this.raiseRecoverable(n.start, "getter should have no params"), i.kind === "set" && n.params.length !== 1 && this.raiseRecoverable(n.start, "setter should have exactly one param"), i.kind === "set" && n.params[0].type === "RestElement" && this.raiseRecoverable(n.params[0].start, "Setter cannot use rest params"), this.finishNode(i, "MethodDefinition") }, St.parseClassField = function (i) { if (rb(i, "constructor") ? this.raise(i.key.start, "Classes can't have a field named 'constructor'") : i.static && rb(i, "prototype") && this.raise(i.key.start, "Classes can't have a static field named 'prototype'"), this.eat(B.eq)) { var e = this.currentThisScope(), t = e.inClassFieldInit; e.inClassFieldInit = !0, i.value = this.parseMaybeAssign(), e.inClassFieldInit = t } else i.value = null; return this.semicolon(), this.finishNode(i, "PropertyDefinition") }, St.parseClassStaticBlock = function (i) { i.body = []; var e = this.labels; for (this.labels = [], this.enterScope(Jg | eE); this.type !== B.braceR;) { var t = this.parseStatement(null); i.body.push(t) } return this.next(), this.exitScope(), this.labels = e, this.finishNode(i, "StaticBlock") }, St.parseClassId = function (i, e) { this.type === B.name ? (i.id = this.parseIdent(), e && this.checkLValSimple(i.id, hl, !1)) : (e === !0 && this.unexpected(), i.id = null) }, St.parseClassSuper = function (i) { i.superClass = this.eat(B._extends) ? this.parseExprSubscripts(!1) : null }, St.enterClassBody = function () { var i = { declared: Object.create(null), used: [] }; return this.privateNameStack.push(i), i.declared }, St.exitClassBody = function () { for (var i = this.privateNameStack.pop(), e = i.declared, t = i.used, s = this.privateNameStack.length, r = s === 0 ? null : this.privateNameStack[s - 1], n = 0; n < t.length; ++n) { var o = t[n]; qg(e, o.name) || (r ? r.used.push(o) : this.raiseRecoverable(o.start, "Private field '#" + o.name + "' must be declared in an enclosing class")) } }; function QK(i, e) { var t = e.key.name, s = i[t], r = "true"; return e.type === "MethodDefinition" && (e.kind === "get" || e.kind === "set") && (r = (e.static ? "s" : "i") + e.kind), s === "iget" && r === "iset" || s === "iset" && r === "iget" || s === "sget" && r === "sset" || s === "sset" && r === "sget" ? (i[t] = "true", !1) : s ? !0 : (i[t] = r, !1) } function rb(i, e) { var t = i.computed, s = i.key; return !t && (s.type === "Identifier" && s.name === e || s.type === "Literal" && s.value === e) } St.parseExport = function (i, e) { if (this.next(), this.eat(B.star)) return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (i.exported = this.parseModuleExportName(), this.checkExport(e, i.exported, this.lastTokStart)) : i.exported = null), this.expectContextual("from"), this.type !== B.string && this.unexpected(), i.source = this.parseExprAtom(), this.semicolon(), this.finishNode(i, "ExportAllDeclaration"); if (this.eat(B._default)) { this.checkExport(e, "default", this.lastTokStart); var t; if (this.type === B._function || (t = this.isAsyncFunction())) { var s = this.startNode(); this.next(), t && this.next(), i.declaration = this.parseFunction(s, Kg | P3, !1, t) } else if (this.type === B._class) { var r = this.startNode(); i.declaration = this.parseClass(r, "nullableID") } else i.declaration = this.parseMaybeAssign(), this.semicolon(); return this.finishNode(i, "ExportDefaultDeclaration") } if (this.shouldParseExportStatement()) i.declaration = this.parseStatement(null), i.declaration.type === "VariableDeclaration" ? this.checkVariableExport(e, i.declaration.declarations) : this.checkExport(e, i.declaration.id, i.declaration.id.start), i.specifiers = [], i.source = null; else { if (i.declaration = null, i.specifiers = this.parseExportSpecifiers(e), this.eatContextual("from")) this.type !== B.string && this.unexpected(), i.source = this.parseExprAtom(); else { for (var n = 0, o = i.specifiers; n < o.length; n += 1) { var a = o[n]; this.checkUnreserved(a.local), this.checkLocalExport(a.local), a.local.type === "Literal" && this.raise(a.local.start, "A string literal cannot be used as an exported binding without `from`.") } i.source = null } this.semicolon() } return this.finishNode(i, "ExportNamedDeclaration") }, St.checkExport = function (i, e, t) { i && (typeof e != "string" && (e = e.type === "Identifier" ? e.name : e.value), qg(i, e) && this.raiseRecoverable(t, "Duplicate export '" + e + "'"), i[e] = !0) }, St.checkPatternExport = function (i, e) { var t = e.type; if (t === "Identifier") this.checkExport(i, e, e.start); else if (t === "ObjectPattern") for (var s = 0, r = e.properties; s < r.length; s += 1) { var n = r[s]; this.checkPatternExport(i, n) } else if (t === "ArrayPattern") for (var o = 0, a = e.elements; o < a.length; o += 1) { var l = a[o]; l && this.checkPatternExport(i, l) } else t === "Property" ? this.checkPatternExport(i, e.value) : t === "AssignmentPattern" ? this.checkPatternExport(i, e.left) : t === "RestElement" ? this.checkPatternExport(i, e.argument) : t === "ParenthesizedExpression" && this.checkPatternExport(i, e.expression) }, St.checkVariableExport = function (i, e) { if (i) for (var t = 0, s = e; t < s.length; t += 1) { var r = s[t]; this.checkPatternExport(i, r.id) } }, St.shouldParseExportStatement = function () { return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction() }, St.parseExportSpecifiers = function (i) { var e = [], t = !0; for (this.expect(B.braceL); !this.eat(B.braceR);) { if (t) t = !1; else if (this.expect(B.comma), this.afterTrailingComma(B.braceR)) break; var s = this.startNode(); s.local = this.parseModuleExportName(), s.exported = this.eatContextual("as") ? this.parseModuleExportName() : s.local, this.checkExport(i, s.exported, s.exported.start), e.push(this.finishNode(s, "ExportSpecifier")) } return e }, St.parseImport = function (i) { return this.next(), this.type === B.string ? (i.specifiers = jK, i.source = this.parseExprAtom()) : (i.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), i.source = this.type === B.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(i, "ImportDeclaration") }, St.parseImportSpecifiers = function () { var i = [], e = !0; if (this.type === B.name) { var t = this.startNode(); if (t.local = this.parseIdent(), this.checkLValSimple(t.local, hl), i.push(this.finishNode(t, "ImportDefaultSpecifier")), !this.eat(B.comma)) return i } if (this.type === B.star) { var s = this.startNode(); return this.next(), this.expectContextual("as"), s.local = this.parseIdent(), this.checkLValSimple(s.local, hl), i.push(this.finishNode(s, "ImportNamespaceSpecifier")), i } for (this.expect(B.braceL); !this.eat(B.braceR);) { if (e) e = !1; else if (this.expect(B.comma), this.afterTrailingComma(B.braceR)) break; var r = this.startNode(); r.imported = this.parseModuleExportName(), this.eatContextual("as") ? r.local = this.parseIdent() : (this.checkUnreserved(r.imported), r.local = r.imported), this.checkLValSimple(r.local, hl), i.push(this.finishNode(r, "ImportSpecifier")) } return i }, St.parseModuleExportName = function () { if (this.options.ecmaVersion >= 13 && this.type === B.string) { var i = this.parseLiteral(this.value); return LK.test(i.value) && this.raise(i.start, "An export name cannot include a lone surrogate."), i } return this.parseIdent(!0) }, St.adaptDirectivePrologue = function (i) { for (var e = 0; e < i.length && this.isDirectiveCandidate(i[e]); ++e)i[e].directive = i[e].expression.raw.slice(1, -1) }, St.isDirectiveCandidate = function (i) { return this.options.ecmaVersion >= 5 && i.type === "ExpressionStatement" && i.expression.type === "Literal" && typeof i.expression.value == "string" && (this.input[i.start] === '"' || this.input[i.start] === "'") }; var _o = Rs.prototype; _o.toAssignable = function (i, e, t) { if (this.options.ecmaVersion >= 6 && i) switch (i.type) { case "Identifier": this.inAsync && i.name === "await" && this.raise(i.start, "Cannot use 'await' as identifier inside an async function"); break; case "ObjectPattern": case "ArrayPattern": case "AssignmentPattern": case "RestElement": break; case "ObjectExpression": i.type = "ObjectPattern", t && this.checkPatternErrors(t, !0); for (var s = 0, r = i.properties; s < r.length; s += 1) { var n = r[s]; this.toAssignable(n, e), n.type === "RestElement" && (n.argument.type === "ArrayPattern" || n.argument.type === "ObjectPattern") && this.raise(n.argument.start, "Unexpected token") } break; case "Property": i.kind !== "init" && this.raise(i.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(i.value, e); break; case "ArrayExpression": i.type = "ArrayPattern", t && this.checkPatternErrors(t, !0), this.toAssignableList(i.elements, e); break; case "SpreadElement": i.type = "RestElement", this.toAssignable(i.argument, e), i.argument.type === "AssignmentPattern" && this.raise(i.argument.start, "Rest elements cannot have a default value"); break; case "AssignmentExpression": i.operator !== "=" && this.raise(i.left.end, "Only '=' operator can be used for specifying default value."), i.type = "AssignmentPattern", delete i.operator, this.toAssignable(i.left, e); break; case "ParenthesizedExpression": this.toAssignable(i.expression, e, t); break; case "ChainExpression": this.raiseRecoverable(i.start, "Optional chaining cannot appear in left-hand side"); break; case "MemberExpression": if (!e) break; default: this.raise(i.start, "Assigning to rvalue") } else t && this.checkPatternErrors(t, !0); return i }, _o.toAssignableList = function (i, e) { for (var t = i.length, s = 0; s < t; s++) { var r = i[s]; r && this.toAssignable(r, e) } if (t) { var n = i[t - 1]; this.options.ecmaVersion === 6 && e && n && n.type === "RestElement" && n.argument.type !== "Identifier" && this.unexpected(n.argument.start) } return i }, _o.parseSpread = function (i) { var e = this.startNode(); return this.next(), e.argument = this.parseMaybeAssign(!1, i), this.finishNode(e, "SpreadElement") }, _o.parseRestBinding = function () { var i = this.startNode(); return this.next(), this.options.ecmaVersion === 6 && this.type !== B.name && this.unexpected(), i.argument = this.parseBindingAtom(), this.finishNode(i, "RestElement") }, _o.parseBindingAtom = function () { if (this.options.ecmaVersion >= 6) switch (this.type) { case B.bracketL: var i = this.startNode(); return this.next(), i.elements = this.parseBindingList(B.bracketR, !0, !0), this.finishNode(i, "ArrayPattern"); case B.braceL: return this.parseObj(!0) }return this.parseIdent() }, _o.parseBindingList = function (i, e, t) { for (var s = [], r = !0; !this.eat(i);)if (r ? r = !1 : this.expect(B.comma), e && this.type === B.comma) s.push(null); else { if (t && this.afterTrailingComma(i)) break; if (this.type === B.ellipsis) { var n = this.parseRestBinding(); this.parseBindingListItem(n), s.push(n), this.type === B.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(i); break } else { var o = this.parseMaybeDefault(this.start, this.startLoc); this.parseBindingListItem(o), s.push(o) } } return s }, _o.parseBindingListItem = function (i) { return i }, _o.parseMaybeDefault = function (i, e, t) { if (t = t || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(B.eq)) return t; var s = this.startNodeAt(i, e); return s.left = t, s.right = this.parseMaybeAssign(), this.finishNode(s, "AssignmentPattern") }, _o.checkLValSimple = function (i, e, t) { e === void 0 && (e = ib); var s = e !== ib; switch (i.type) { case "Identifier": this.strict && this.reservedWordsStrictBind.test(i.name) && this.raiseRecoverable(i.start, (s ? "Binding " : "Assigning to ") + i.name + " in strict mode"), s && (e === hl && i.name === "let" && this.raiseRecoverable(i.start, "let is disallowed as a lexically bound name"), t && (qg(t, i.name) && this.raiseRecoverable(i.start, "Argument name clash"), t[i.name] = !0), e !== R3 && this.declareName(i.name, e, i.start)); break; case "ChainExpression": this.raiseRecoverable(i.start, "Optional chaining cannot appear in left-hand side"); break; case "MemberExpression": s && this.raiseRecoverable(i.start, "Binding member expression"); break; case "ParenthesizedExpression": return s && this.raiseRecoverable(i.start, "Binding parenthesized expression"), this.checkLValSimple(i.expression, e, t); default: this.raise(i.start, (s ? "Binding" : "Assigning to") + " rvalue") } }, _o.checkLValPattern = function (i, e, t) { switch (e === void 0 && (e = ib), i.type) { case "ObjectPattern": for (var s = 0, r = i.properties; s < r.length; s += 1) { var n = r[s]; this.checkLValInnerPattern(n, e, t) } break; case "ArrayPattern": for (var o = 0, a = i.elements; o < a.length; o += 1) { var l = a[o]; l && this.checkLValInnerPattern(l, e, t) } break; default: this.checkLValSimple(i, e, t) } }, _o.checkLValInnerPattern = function (i, e, t) { switch (e === void 0 && (e = ib), i.type) { case "Property": this.checkLValInnerPattern(i.value, e, t); break; case "AssignmentPattern": this.checkLValPattern(i.left, e, t); break; case "RestElement": this.checkLValPattern(i.argument, e, t); break; default: this.checkLValPattern(i, e, t) } }; var xo = function (i, e, t, s, r) { this.token = i, this.isExpr = !!e, this.preserveSpace = !!t, this.override = s, this.generator = !!r }, Ci = { b_stat: new xo("{", !1), b_expr: new xo("{", !0), b_tmpl: new xo("${", !1), p_stat: new xo("(", !1), p_expr: new xo("(", !0), q_tmpl: new xo("`", !0, !0, function (i) { return i.tryReadTemplateToken() }), f_stat: new xo("function", !1), f_expr: new xo("function", !0), f_expr_gen: new xo("function", !0, !1, null, !0), f_gen: new xo("function", !1, !1, null, !0) }, ip = Rs.prototype; ip.initialContext = function () { return [Ci.b_stat] }, ip.curContext = function () { return this.context[this.context.length - 1] }, ip.braceIsBlock = function (i) { var e = this.curContext(); return e === Ci.f_expr || e === Ci.f_stat ? !0 : i === B.colon && (e === Ci.b_stat || e === Ci.b_expr) ? !e.isExpr : i === B._return || i === B.name && this.exprAllowed ? Nn.test(this.input.slice(this.lastTokEnd, this.start)) : i === B._else || i === B.semi || i === B.eof || i === B.parenR || i === B.arrow ? !0 : i === B.braceL ? e === Ci.b_stat : i === B._var || i === B._const || i === B.name ? !1 : !this.exprAllowed }, ip.inGeneratorContext = function () { for (var i = this.context.length - 1; i >= 1; i--) { var e = this.context[i]; if (e.token === "function") return e.generator } return !1 }, ip.updateContext = function (i) { var e, t = this.type; t.keyword && i === B.dot ? this.exprAllowed = !1 : (e = t.updateContext) ? e.call(this, i) : this.exprAllowed = t.beforeExpr }, ip.overrideContext = function (i) { this.curContext() !== i && (this.context[this.context.length - 1] = i) }, B.parenR.updateContext = B.braceR.updateContext = function () { if (this.context.length === 1) { this.exprAllowed = !0; return } var i = this.context.pop(); i === Ci.b_stat && this.curContext().token === "function" && (i = this.context.pop()), this.exprAllowed = !i.isExpr }, B.braceL.updateContext = function (i) { this.context.push(this.braceIsBlock(i) ? Ci.b_stat : Ci.b_expr), this.exprAllowed = !0 }, B.dollarBraceL.updateContext = function () { this.context.push(Ci.b_tmpl), this.exprAllowed = !0 }, B.parenL.updateContext = function (i) { var e = i === B._if || i === B._for || i === B._with || i === B._while; this.context.push(e ? Ci.p_stat : Ci.p_expr), this.exprAllowed = !0 }, B.incDec.updateContext = function () { }, B._function.updateContext = B._class.updateContext = function (i) { i.beforeExpr && i !== B._else && !(i === B.semi && this.curContext() !== Ci.p_stat) && !(i === B._return && Nn.test(this.input.slice(this.lastTokEnd, this.start))) && !((i === B.colon || i === B.braceL) && this.curContext() === Ci.b_stat) ? this.context.push(Ci.f_expr) : this.context.push(Ci.f_stat), this.exprAllowed = !1 }, B.backQuote.updateContext = function () { this.curContext() === Ci.q_tmpl ? this.context.pop() : this.context.push(Ci.q_tmpl), this.exprAllowed = !1 }, B.star.updateContext = function (i) { if (i === B._function) { var e = this.context.length - 1; this.context[e] === Ci.f_expr ? this.context[e] = Ci.f_expr_gen : this.context[e] = Ci.f_gen } this.exprAllowed = !0 }, B.name.updateContext = function (i) { var e = !1; this.options.ecmaVersion >= 6 && i !== B.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (e = !0), this.exprAllowed = e }; var Ut = Rs.prototype; Ut.checkPropClash = function (i, e, t) { if (!(this.options.ecmaVersion >= 9 && i.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (i.computed || i.method || i.shorthand))) { var s = i.key, r; switch (s.type) { case "Identifier": r = s.name; break; case "Literal": r = String(s.value); break; default: return }var n = i.kind; if (this.options.ecmaVersion >= 6) { r === "__proto__" && n === "init" && (e.proto && (t ? t.doubleProto < 0 && (t.doubleProto = s.start) : this.raiseRecoverable(s.start, "Redefinition of __proto__ property")), e.proto = !0); return } r = "$" + r; var o = e[r]; if (o) { var a; n === "init" ? a = this.strict && o.init || o.get || o.set : a = o.init || o[n], a && this.raiseRecoverable(s.start, "Redefinition of property") } else o = e[r] = { init: !1, get: !1, set: !1 }; o[n] = !0 } }, Ut.parseExpression = function (i, e) { var t = this.start, s = this.startLoc, r = this.parseMaybeAssign(i, e); if (this.type === B.comma) { var n = this.startNodeAt(t, s); for (n.expressions = [r]; this.eat(B.comma);)n.expressions.push(this.parseMaybeAssign(i, e)); return this.finishNode(n, "SequenceExpression") } return r }, Ut.parseMaybeAssign = function (i, e, t) { if (this.isContextual("yield")) { if (this.inGenerator) return this.parseYield(i); this.exprAllowed = !1 } var s = !1, r = -1, n = -1, o = -1; e ? (r = e.parenthesizedAssign, n = e.trailingComma, o = e.doubleProto, e.parenthesizedAssign = e.trailingComma = -1) : (e = new sb, s = !0); var a = this.start, l = this.startLoc; (this.type === B.parenL || this.type === B.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = i === "await"); var c = this.parseMaybeConditional(i, e); if (t && (c = t.call(this, c, a, l)), this.type.isAssign) { var h = this.startNodeAt(a, l); return h.operator = this.value, this.type === B.eq && (c = this.toAssignable(c, !1, e)), s || (e.parenthesizedAssign = e.trailingComma = e.doubleProto = -1), e.shorthandAssign >= c.start && (e.shorthandAssign = -1), this.type === B.eq ? this.checkLValPattern(c) : this.checkLValSimple(c), h.left = c, this.next(), h.right = this.parseMaybeAssign(i), o > -1 && (e.doubleProto = o), this.finishNode(h, "AssignmentExpression") } else s && this.checkExpressionErrors(e, !0); return r > -1 && (e.parenthesizedAssign = r), n > -1 && (e.trailingComma = n), c }, Ut.parseMaybeConditional = function (i, e) { var t = this.start, s = this.startLoc, r = this.parseExprOps(i, e); if (this.checkExpressionErrors(e)) return r; if (this.eat(B.question)) { var n = this.startNodeAt(t, s); return n.test = r, n.consequent = this.parseMaybeAssign(), this.expect(B.colon), n.alternate = this.parseMaybeAssign(i), this.finishNode(n, "ConditionalExpression") } return r }, Ut.parseExprOps = function (i, e) { var t = this.start, s = this.startLoc, r = this.parseMaybeUnary(e, !1, !1, i); return this.checkExpressionErrors(e) || r.start === t && r.type === "ArrowFunctionExpression" ? r : this.parseExprOp(r, t, s, -1, i) }, Ut.parseExprOp = function (i, e, t, s, r) { var n = this.type.binop; if (n != null && (!r || this.type !== B._in) && n > s) { var o = this.type === B.logicalOR || this.type === B.logicalAND, a = this.type === B.coalesce; a && (n = B.logicalAND.binop); var l = this.value; this.next(); var c = this.start, h = this.startLoc, d = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, r), c, h, n, r), p = this.buildBinary(e, t, i, d, l, o || a); return (o && this.type === B.coalesce || a && (this.type === B.logicalOR || this.type === B.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(p, e, t, s, r) } return i }, Ut.buildBinary = function (i, e, t, s, r, n) { s.type === "PrivateIdentifier" && this.raise(s.start, "Private identifier can only be left side of binary expression"); var o = this.startNodeAt(i, e); return o.left = t, o.operator = r, o.right = s, this.finishNode(o, n ? "LogicalExpression" : "BinaryExpression") }, Ut.parseMaybeUnary = function (i, e, t, s) { var r = this.start, n = this.startLoc, o; if (this.isContextual("await") && this.canAwait) o = this.parseAwait(s), e = !0; else if (this.type.prefix) { var a = this.startNode(), l = this.type === B.incDec; a.operator = this.value, a.prefix = !0, this.next(), a.argument = this.parseMaybeUnary(null, !0, l, s), this.checkExpressionErrors(i, !0), l ? this.checkLValSimple(a.argument) : this.strict && a.operator === "delete" && a.argument.type === "Identifier" ? this.raiseRecoverable(a.start, "Deleting local variable in strict mode") : a.operator === "delete" && B3(a.argument) ? this.raiseRecoverable(a.start, "Private fields can not be deleted") : e = !0, o = this.finishNode(a, l ? "UpdateExpression" : "UnaryExpression") } else if (!e && this.type === B.privateId) (s || this.privateNameStack.length === 0) && this.unexpected(), o = this.parsePrivateIdent(), this.type !== B._in && this.unexpected(); else { if (o = this.parseExprSubscripts(i, s), this.checkExpressionErrors(i)) return o; for (; this.type.postfix && !this.canInsertSemicolon();) { var c = this.startNodeAt(r, n); c.operator = this.value, c.prefix = !1, c.argument = o, this.checkLValSimple(o), this.next(), o = this.finishNode(c, "UpdateExpression") } } if (!t && this.eat(B.starstar)) if (e) this.unexpected(this.lastTokStart); else return this.buildBinary(r, n, o, this.parseMaybeUnary(null, !1, !1, s), "**", !1); else return o }; function B3(i) { return i.type === "MemberExpression" && i.property.type === "PrivateIdentifier" || i.type === "ChainExpression" && B3(i.expression) } Ut.parseExprSubscripts = function (i, e) { var t = this.start, s = this.startLoc, r = this.parseExprAtom(i, e); if (r.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return r; var n = this.parseSubscripts(r, t, s, !1, e); return i && n.type === "MemberExpression" && (i.parenthesizedAssign >= n.start && (i.parenthesizedAssign = -1), i.parenthesizedBind >= n.start && (i.parenthesizedBind = -1), i.trailingComma >= n.start && (i.trailingComma = -1)), n }, Ut.parseSubscripts = function (i, e, t, s, r) { for (var n = this.options.ecmaVersion >= 8 && i.type === "Identifier" && i.name === "async" && this.lastTokEnd === i.end && !this.canInsertSemicolon() && i.end - i.start === 5 && this.potentialArrowAt === i.start, o = !1; ;) { var a = this.parseSubscript(i, e, t, s, n, o, r); if (a.optional && (o = !0), a === i || a.type === "ArrowFunctionExpression") { if (o) { var l = this.startNodeAt(e, t); l.expression = a, a = this.finishNode(l, "ChainExpression") } return a } i = a } }, Ut.parseSubscript = function (i, e, t, s, r, n, o) { var a = this.options.ecmaVersion >= 11, l = a && this.eat(B.questionDot); s && l && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); var c = this.eat(B.bracketL); if (c || l && this.type !== B.parenL && this.type !== B.backQuote || this.eat(B.dot)) { var h = this.startNodeAt(e, t); h.object = i, c ? (h.property = this.parseExpression(), this.expect(B.bracketR)) : this.type === B.privateId && i.type !== "Super" ? h.property = this.parsePrivateIdent() : h.property = this.parseIdent(this.options.allowReserved !== "never"), h.computed = !!c, a && (h.optional = l), i = this.finishNode(h, "MemberExpression") } else if (!s && this.eat(B.parenL)) { var d = new sb, p = this.yieldPos, f = this.awaitPos, g = this.awaitIdentPos; this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0; var m = this.parseExprList(B.parenR, this.options.ecmaVersion >= 8, !1, d); if (r && !l && !this.canInsertSemicolon() && this.eat(B.arrow)) return this.checkPatternErrors(d, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = p, this.awaitPos = f, this.awaitIdentPos = g, this.parseArrowExpression(this.startNodeAt(e, t), m, !0, o); this.checkExpressionErrors(d, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = f || this.awaitPos, this.awaitIdentPos = g || this.awaitIdentPos; var v = this.startNodeAt(e, t); v.callee = i, v.arguments = m, a && (v.optional = l), i = this.finishNode(v, "CallExpression") } else if (this.type === B.backQuote) { (l || n) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions"); var A = this.startNodeAt(e, t); A.tag = i, A.quasi = this.parseTemplate({ isTagged: !0 }), i = this.finishNode(A, "TaggedTemplateExpression") } return i }, Ut.parseExprAtom = function (i, e) { this.type === B.slash && this.readRegexp(); var t, s = this.potentialArrowAt === this.start; switch (this.type) { case B._super: return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), t = this.startNode(), this.next(), this.type === B.parenL && !this.allowDirectSuper && this.raise(t.start, "super() call outside constructor of a subclass"), this.type !== B.dot && this.type !== B.bracketL && this.type !== B.parenL && this.unexpected(), this.finishNode(t, "Super"); case B._this: return t = this.startNode(), this.next(), this.finishNode(t, "ThisExpression"); case B.name: var r = this.start, n = this.startLoc, o = this.containsEsc, a = this.parseIdent(!1); if (this.options.ecmaVersion >= 8 && !o && a.name === "async" && !this.canInsertSemicolon() && this.eat(B._function)) return this.overrideContext(Ci.f_expr), this.parseFunction(this.startNodeAt(r, n), 0, !1, !0, e); if (s && !this.canInsertSemicolon()) { if (this.eat(B.arrow)) return this.parseArrowExpression(this.startNodeAt(r, n), [a], !1, e); if (this.options.ecmaVersion >= 8 && a.name === "async" && this.type === B.name && !o && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) return a = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(B.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(r, n), [a], !0, e) } return a; case B.regexp: var l = this.value; return t = this.parseLiteral(l.value), t.regex = { pattern: l.pattern, flags: l.flags }, t; case B.num: case B.string: return this.parseLiteral(this.value); case B._null: case B._true: case B._false: return t = this.startNode(), t.value = this.type === B._null ? null : this.type === B._true, t.raw = this.type.keyword, this.next(), this.finishNode(t, "Literal"); case B.parenL: var c = this.start, h = this.parseParenAndDistinguishExpression(s, e); return i && (i.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(h) && (i.parenthesizedAssign = c), i.parenthesizedBind < 0 && (i.parenthesizedBind = c)), h; case B.bracketL: return t = this.startNode(), this.next(), t.elements = this.parseExprList(B.bracketR, !0, !0, i), this.finishNode(t, "ArrayExpression"); case B.braceL: return this.overrideContext(Ci.b_expr), this.parseObj(!1, i); case B._function: return t = this.startNode(), this.next(), this.parseFunction(t, 0); case B._class: return this.parseClass(this.startNode(), !1); case B._new: return this.parseNew(); case B.backQuote: return this.parseTemplate(); case B._import: return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected(); default: this.unexpected() } }, Ut.parseExprImport = function () { var i = this.startNode(); this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"); var e = this.parseIdent(!0); switch (this.type) { case B.parenL: return this.parseDynamicImport(i); case B.dot: return i.meta = e, this.parseImportMeta(i); default: this.unexpected() } }, Ut.parseDynamicImport = function (i) { if (this.next(), i.source = this.parseMaybeAssign(), !this.eat(B.parenR)) { var e = this.start; this.eat(B.comma) && this.eat(B.parenR) ? this.raiseRecoverable(e, "Trailing comma is not allowed in import()") : this.unexpected(e) } return this.finishNode(i, "ImportExpression") }, Ut.parseImportMeta = function (i) { this.next(); var e = this.containsEsc; return i.property = this.parseIdent(!0), i.property.name !== "meta" && this.raiseRecoverable(i.property.start, "The only valid meta property for import is 'import.meta'"), e && this.raiseRecoverable(i.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(i.start, "Cannot use 'import.meta' outside a module"), this.finishNode(i, "MetaProperty") }, Ut.parseLiteral = function (i) { var e = this.startNode(); return e.value = i, e.raw = this.input.slice(this.start, this.end), e.raw.charCodeAt(e.raw.length - 1) === 110 && (e.bigint = e.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(e, "Literal") }, Ut.parseParenExpression = function () { this.expect(B.parenL); var i = this.parseExpression(); return this.expect(B.parenR), i }, Ut.parseParenAndDistinguishExpression = function (i, e) { var t = this.start, s = this.startLoc, r, n = this.options.ecmaVersion >= 8; if (this.options.ecmaVersion >= 6) { this.next(); var o = this.start, a = this.startLoc, l = [], c = !0, h = !1, d = new sb, p = this.yieldPos, f = this.awaitPos, g; for (this.yieldPos = 0, this.awaitPos = 0; this.type !== B.parenR;)if (c ? c = !1 : this.expect(B.comma), n && this.afterTrailingComma(B.parenR, !0)) { h = !0; break } else if (this.type === B.ellipsis) { g = this.start, l.push(this.parseParenItem(this.parseRestBinding())), this.type === B.comma && this.raise(this.start, "Comma is not permitted after the rest element"); break } else l.push(this.parseMaybeAssign(!1, d, this.parseParenItem)); var m = this.lastTokEnd, v = this.lastTokEndLoc; if (this.expect(B.parenR), i && !this.canInsertSemicolon() && this.eat(B.arrow)) return this.checkPatternErrors(d, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = p, this.awaitPos = f, this.parseParenArrowList(t, s, l, e); (!l.length || h) && this.unexpected(this.lastTokStart), g && this.unexpected(g), this.checkExpressionErrors(d, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = f || this.awaitPos, l.length > 1 ? (r = this.startNodeAt(o, a), r.expressions = l, this.finishNodeAt(r, "SequenceExpression", m, v)) : r = l[0] } else r = this.parseParenExpression(); if (this.options.preserveParens) { var A = this.startNodeAt(t, s); return A.expression = r, this.finishNode(A, "ParenthesizedExpression") } else return r }, Ut.parseParenItem = function (i) { return i }, Ut.parseParenArrowList = function (i, e, t, s) { return this.parseArrowExpression(this.startNodeAt(i, e), t, !1, s) }; var GK = []; Ut.parseNew = function () { this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new"); var i = this.startNode(), e = this.parseIdent(!0); if (this.options.ecmaVersion >= 6 && this.eat(B.dot)) { i.meta = e; var t = this.containsEsc; return i.property = this.parseIdent(!0), i.property.name !== "target" && this.raiseRecoverable(i.property.start, "The only valid meta property for new is 'new.target'"), t && this.raiseRecoverable(i.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(i.start, "'new.target' can only be used in functions and class static block"), this.finishNode(i, "MetaProperty") } var s = this.start, r = this.startLoc, n = this.type === B._import; return i.callee = this.parseSubscripts(this.parseExprAtom(), s, r, !0, !1), n && i.callee.type === "ImportExpression" && this.raise(s, "Cannot use new with import()"), this.eat(B.parenL) ? i.arguments = this.parseExprList(B.parenR, this.options.ecmaVersion >= 8, !1) : i.arguments = GK, this.finishNode(i, "NewExpression") }, Ut.parseTemplateElement = function (i) {
  var e = i.isTagged, t = this.startNode(); return this.type === B.invalidTemplate ? (e || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), t.value = { raw: this.value, cooked: null }) : t.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`), cooked: this.value
  }, this.next(), t.tail = this.type === B.backQuote, this.finishNode(t, "TemplateElement")
}, Ut.parseTemplate = function (i) { i === void 0 && (i = {}); var e = i.isTagged; e === void 0 && (e = !1); var t = this.startNode(); this.next(), t.expressions = []; var s = this.parseTemplateElement({ isTagged: e }); for (t.quasis = [s]; !s.tail;)this.type === B.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(B.dollarBraceL), t.expressions.push(this.parseExpression()), this.expect(B.braceR), t.quasis.push(s = this.parseTemplateElement({ isTagged: e })); return this.next(), this.finishNode(t, "TemplateLiteral") }, Ut.isAsyncProp = function (i) { return !i.computed && i.key.type === "Identifier" && i.key.name === "async" && (this.type === B.name || this.type === B.num || this.type === B.string || this.type === B.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === B.star) && !Nn.test(this.input.slice(this.lastTokEnd, this.start)) }, Ut.parseObj = function (i, e) { var t = this.startNode(), s = !0, r = {}; for (t.properties = [], this.next(); !this.eat(B.braceR);) { if (s) s = !1; else if (this.expect(B.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(B.braceR)) break; var n = this.parseProperty(i, e); i || this.checkPropClash(n, r, e), t.properties.push(n) } return this.finishNode(t, i ? "ObjectPattern" : "ObjectExpression") }, Ut.parseProperty = function (i, e) { var t = this.startNode(), s, r, n, o; if (this.options.ecmaVersion >= 9 && this.eat(B.ellipsis)) return i ? (t.argument = this.parseIdent(!1), this.type === B.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(t, "RestElement")) : (t.argument = this.parseMaybeAssign(!1, e), this.type === B.comma && e && e.trailingComma < 0 && (e.trailingComma = this.start), this.finishNode(t, "SpreadElement")); this.options.ecmaVersion >= 6 && (t.method = !1, t.shorthand = !1, (i || e) && (n = this.start, o = this.startLoc), i || (s = this.eat(B.star))); var a = this.containsEsc; return this.parsePropertyName(t), !i && !a && this.options.ecmaVersion >= 8 && !s && this.isAsyncProp(t) ? (r = !0, s = this.options.ecmaVersion >= 9 && this.eat(B.star), this.parsePropertyName(t, e)) : r = !1, this.parsePropertyValue(t, i, s, r, n, o, e, a), this.finishNode(t, "Property") }, Ut.parsePropertyValue = function (i, e, t, s, r, n, o, a) { if ((t || s) && this.type === B.colon && this.unexpected(), this.eat(B.colon)) i.value = e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, o), i.kind = "init"; else if (this.options.ecmaVersion >= 6 && this.type === B.parenL) e && this.unexpected(), i.kind = "init", i.method = !0, i.value = this.parseMethod(t, s); else if (!e && !a && this.options.ecmaVersion >= 5 && !i.computed && i.key.type === "Identifier" && (i.key.name === "get" || i.key.name === "set") && this.type !== B.comma && this.type !== B.braceR && this.type !== B.eq) { (t || s) && this.unexpected(), i.kind = i.key.name, this.parsePropertyName(i), i.value = this.parseMethod(!1); var l = i.kind === "get" ? 0 : 1; if (i.value.params.length !== l) { var c = i.value.start; i.kind === "get" ? this.raiseRecoverable(c, "getter should have no params") : this.raiseRecoverable(c, "setter should have exactly one param") } else i.kind === "set" && i.value.params[0].type === "RestElement" && this.raiseRecoverable(i.value.params[0].start, "Setter cannot use rest params") } else this.options.ecmaVersion >= 6 && !i.computed && i.key.type === "Identifier" ? ((t || s) && this.unexpected(), this.checkUnreserved(i.key), i.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = r), i.kind = "init", e ? i.value = this.parseMaybeDefault(r, n, this.copyNode(i.key)) : this.type === B.eq && o ? (o.shorthandAssign < 0 && (o.shorthandAssign = this.start), i.value = this.parseMaybeDefault(r, n, this.copyNode(i.key))) : i.value = this.copyNode(i.key), i.shorthand = !0) : this.unexpected() }, Ut.parsePropertyName = function (i) { if (this.options.ecmaVersion >= 6) { if (this.eat(B.bracketL)) return i.computed = !0, i.key = this.parseMaybeAssign(), this.expect(B.bracketR), i.key; i.computed = !1 } return i.key = this.type === B.num || this.type === B.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never") }, Ut.initFunction = function (i) { i.id = null, this.options.ecmaVersion >= 6 && (i.generator = i.expression = !1), this.options.ecmaVersion >= 8 && (i.async = !1) }, Ut.parseMethod = function (i, e, t) { var s = this.startNode(), r = this.yieldPos, n = this.awaitPos, o = this.awaitIdentPos; return this.initFunction(s), this.options.ecmaVersion >= 6 && (s.generator = i), this.options.ecmaVersion >= 8 && (s.async = !!e), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(iE(e, s.generator) | eE | (t ? M3 : 0)), this.expect(B.parenL), s.params = this.parseBindingList(B.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(s, !1, !0, !1), this.yieldPos = r, this.awaitPos = n, this.awaitIdentPos = o, this.finishNode(s, "FunctionExpression") }, Ut.parseArrowExpression = function (i, e, t, s) { var r = this.yieldPos, n = this.awaitPos, o = this.awaitIdentPos; return this.enterScope(iE(t, !1) | S3), this.initFunction(i), this.options.ecmaVersion >= 8 && (i.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, i.params = this.toAssignableList(e, !0), this.parseFunctionBody(i, !0, !1, s), this.yieldPos = r, this.awaitPos = n, this.awaitIdentPos = o, this.finishNode(i, "ArrowFunctionExpression") }, Ut.parseFunctionBody = function (i, e, t, s) { var r = e && this.type !== B.braceL, n = this.strict, o = !1; if (r) i.body = this.parseMaybeAssign(s), i.expression = !0, this.checkParams(i, !1); else { var a = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(i.params); (!n || a) && (o = this.strictDirective(this.end), o && a && this.raiseRecoverable(i.start, "Illegal 'use strict' directive in function with non-simple parameter list")); var l = this.labels; this.labels = [], o && (this.strict = !0), this.checkParams(i, !n && !o && !e && !t && this.isSimpleParamList(i.params)), this.strict && i.id && this.checkLValSimple(i.id, R3), i.body = this.parseBlock(!1, void 0, o && !n), i.expression = !1, this.adaptDirectivePrologue(i.body.body), this.labels = l } this.exitScope() }, Ut.isSimpleParamList = function (i) { for (var e = 0, t = i; e < t.length; e += 1) { var s = t[e]; if (s.type !== "Identifier") return !1 } return !0 }, Ut.checkParams = function (i, e) { for (var t = Object.create(null), s = 0, r = i.params; s < r.length; s += 1) { var n = r[s]; this.checkLValInnerPattern(n, sE, e ? null : t) } }, Ut.parseExprList = function (i, e, t, s) { for (var r = [], n = !0; !this.eat(i);) { if (n) n = !1; else if (this.expect(B.comma), e && this.afterTrailingComma(i)) break; var o = void 0; t && this.type === B.comma ? o = null : this.type === B.ellipsis ? (o = this.parseSpread(s), s && this.type === B.comma && s.trailingComma < 0 && (s.trailingComma = this.start)) : o = this.parseMaybeAssign(!1, s), r.push(o) } return r }, Ut.checkUnreserved = function (i) { var e = i.start, t = i.end, s = i.name; if (this.inGenerator && s === "yield" && this.raiseRecoverable(e, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && s === "await" && this.raiseRecoverable(e, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && s === "arguments" && this.raiseRecoverable(e, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (s === "arguments" || s === "await") && this.raise(e, "Cannot use " + s + " in class static initialization block"), this.keywords.test(s) && this.raise(e, "Unexpected keyword '" + s + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(e, t).indexOf("\\") !== -1)) { var r = this.strict ? this.reservedWordsStrict : this.reservedWords; r.test(s) && (!this.inAsync && s === "await" && this.raiseRecoverable(e, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(e, "The keyword '" + s + "' is reserved")) } }, Ut.parseIdent = function (i, e) { var t = this.startNode(); return this.type === B.name ? t.name = this.value : this.type.keyword ? (t.name = this.type.keyword, (t.name === "class" || t.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(!!i), this.finishNode(t, "Identifier"), i || (this.checkUnreserved(t), t.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = t.start)), t }, Ut.parsePrivateIdent = function () { var i = this.startNode(); return this.type === B.privateId ? i.name = this.value : this.unexpected(), this.next(), this.finishNode(i, "PrivateIdentifier"), this.privateNameStack.length === 0 ? this.raise(i.start, "Private field '#" + i.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(i), i }, Ut.parseYield = function (i) { this.yieldPos || (this.yieldPos = this.start); var e = this.startNode(); return this.next(), this.type === B.semi || this.canInsertSemicolon() || this.type !== B.star && !this.type.startsExpr ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat(B.star), e.argument = this.parseMaybeAssign(i)), this.finishNode(e, "YieldExpression") }, Ut.parseAwait = function (i) { this.awaitPos || (this.awaitPos = this.start); var e = this.startNode(); return this.next(), e.argument = this.parseMaybeUnary(null, !0, !1, i), this.finishNode(e, "AwaitExpression") }; var nb = Rs.prototype; nb.raise = function (i, e) { var t = x3(this.input, i); e += " (" + t.line + ":" + t.column + ")"; var s = new SyntaxError(e); throw s.pos = i, s.loc = t, s.raisedAt = this.pos, s }, nb.raiseRecoverable = nb.raise, nb.curPosition = function () { if (this.options.locations) return new Xg(this.curLine, this.pos - this.lineStart) }; var Rc = Rs.prototype, HK = function (i) { this.flags = i, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1 }; Rc.enterScope = function (i) { this.scopeStack.push(new HK(i)) }, Rc.exitScope = function () { this.scopeStack.pop() }, Rc.treatFunctionsAsVarInScope = function (i) { return i.flags & tp || !this.inModule && i.flags & Yg }, Rc.declareName = function (i, e, t) { var s = !1; if (e === hl) { var r = this.currentScope(); s = r.lexical.indexOf(i) > -1 || r.functions.indexOf(i) > -1 || r.var.indexOf(i) > -1, r.lexical.push(i), this.inModule && r.flags & Yg && delete this.undefinedExports[i] } else if (e === T3) { var n = this.currentScope(); n.lexical.push(i) } else if (e === I3) { var o = this.currentScope(); this.treatFunctionsAsVar ? s = o.lexical.indexOf(i) > -1 : s = o.lexical.indexOf(i) > -1 || o.var.indexOf(i) > -1, o.functions.push(i) } else for (var a = this.scopeStack.length - 1; a >= 0; --a) { var l = this.scopeStack[a]; if (l.lexical.indexOf(i) > -1 && !(l.flags & E3 && l.lexical[0] === i) || !this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(i) > -1) { s = !0; break } if (l.var.push(i), this.inModule && l.flags & Yg && delete this.undefinedExports[i], l.flags & tE) break } s && this.raiseRecoverable(t, "Identifier '" + i + "' has already been declared") }, Rc.checkLocalExport = function (i) { this.scopeStack[0].lexical.indexOf(i.name) === -1 && this.scopeStack[0].var.indexOf(i.name) === -1 && (this.undefinedExports[i.name] = i) }, Rc.currentScope = function () { return this.scopeStack[this.scopeStack.length - 1] }, Rc.currentVarScope = function () { for (var i = this.scopeStack.length - 1; ; i--) { var e = this.scopeStack[i]; if (e.flags & tE) return e } }, Rc.currentThisScope = function () { for (var i = this.scopeStack.length - 1; ; i--) { var e = this.scopeStack[i]; if (e.flags & tE && !(e.flags & S3)) return e } }; var ob = function (i, e, t) { this.type = "", this.start = e, this.end = 0, i.options.locations && (this.loc = new tb(i, t)), i.options.directSourceFile && (this.sourceFile = i.options.directSourceFile), i.options.ranges && (this.range = [e, 0]) }, Zg = Rs.prototype; Zg.startNode = function () { return new ob(this, this.start, this.startLoc) }, Zg.startNodeAt = function (i, e) { return new ob(this, i, e) }; function k3(i, e, t, s) { return i.type = e, i.end = t, this.options.locations && (i.loc.end = s), this.options.ranges && (i.range[1] = t), i } Zg.finishNode = function (i, e) { return k3.call(this, i, e, this.lastTokEnd, this.lastTokEndLoc) }, Zg.finishNodeAt = function (i, e, t, s) { return k3.call(this, i, e, t, s) }, Zg.copyNode = function (i) { var e = new ob(this, i.start, this.startLoc); for (var t in i) e[t] = i[t]; return e }; var D3 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", O3 = D3 + " Extended_Pictographic", L3 = O3, F3 = L3 + " EBase EComp EMod EPres ExtPict", VK = F3, WK = { 9: D3, 10: O3, 11: L3, 12: F3, 13: VK }, U3 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", N3 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", z3 = N3 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", j3 = z3 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Q3 = j3 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", qK = Q3 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", XK = { 9: N3, 10: z3, 11: j3, 12: Q3, 13: qK }, G3 = {}; function YK(i) { var e = G3[i] = { binary: Wh(WK[i] + " " + U3), nonBinary: { General_Category: Wh(U3), Script: Wh(XK[i]) } }; e.nonBinary.Script_Extensions = e.nonBinary.Script, e.nonBinary.gc = e.nonBinary.General_Category, e.nonBinary.sc = e.nonBinary.Script, e.nonBinary.scx = e.nonBinary.Script_Extensions } for (var oE = 0, H3 = [9, 10, 11, 12, 13]; oE < H3.length; oE += 1) { var JK = H3[oE]; YK(JK) } var bt = Rs.prototype, ul = function (i) { this.parser = i, this.validFlags = "gim" + (i.options.ecmaVersion >= 6 ? "uy" : "") + (i.options.ecmaVersion >= 9 ? "s" : "") + (i.options.ecmaVersion >= 13 ? "d" : ""), this.unicodeProperties = G3[i.options.ecmaVersion >= 13 ? 13 : i.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [] }; ul.prototype.reset = function (i, e, t) { var s = t.indexOf("u") !== -1; this.start = i | 0, this.source = e + "", this.flags = t, this.switchU = s && this.parser.options.ecmaVersion >= 6, this.switchN = s && this.parser.options.ecmaVersion >= 9 }, ul.prototype.raise = function (i) { this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + i) }, ul.prototype.at = function (i, e) { e === void 0 && (e = !1); var t = this.source, s = t.length; if (i >= s) return -1; var r = t.charCodeAt(i); if (!(e || this.switchU) || r <= 55295 || r >= 57344 || i + 1 >= s) return r; var n = t.charCodeAt(i + 1); return n >= 56320 && n <= 57343 ? (r << 10) + n - 56613888 : r }, ul.prototype.nextIndex = function (i, e) { e === void 0 && (e = !1); var t = this.source, s = t.length; if (i >= s) return s; var r = t.charCodeAt(i), n; return !(e || this.switchU) || r <= 55295 || r >= 57344 || i + 1 >= s || (n = t.charCodeAt(i + 1)) < 56320 || n > 57343 ? i + 1 : i + 2 }, ul.prototype.current = function (i) { return i === void 0 && (i = !1), this.at(this.pos, i) }, ul.prototype.lookahead = function (i) { return i === void 0 && (i = !1), this.at(this.nextIndex(this.pos, i), i) }, ul.prototype.advance = function (i) { i === void 0 && (i = !1), this.pos = this.nextIndex(this.pos, i) }, ul.prototype.eat = function (i, e) { return e === void 0 && (e = !1), this.current(e) === i ? (this.advance(e), !0) : !1 }, bt.validateRegExpFlags = function (i) { for (var e = i.validFlags, t = i.flags, s = 0; s < t.length; s++) { var r = t.charAt(s); e.indexOf(r) === -1 && this.raise(i.start, "Invalid regular expression flag"), t.indexOf(r, s + 1) > -1 && this.raise(i.start, "Duplicate regular expression flag") } }, bt.validateRegExpPattern = function (i) { this.regexp_pattern(i), !i.switchN && this.options.ecmaVersion >= 9 && i.groupNames.length > 0 && (i.switchN = !0, this.regexp_pattern(i)) }, bt.regexp_pattern = function (i) { i.pos = 0, i.lastIntValue = 0, i.lastStringValue = "", i.lastAssertionIsQuantifiable = !1, i.numCapturingParens = 0, i.maxBackReference = 0, i.groupNames.length = 0, i.backReferenceNames.length = 0, this.regexp_disjunction(i), i.pos !== i.source.length && (i.eat(41) && i.raise("Unmatched ')'"), (i.eat(93) || i.eat(125)) && i.raise("Lone quantifier brackets")), i.maxBackReference > i.numCapturingParens && i.raise("Invalid escape"); for (var e = 0, t = i.backReferenceNames; e < t.length; e += 1) { var s = t[e]; i.groupNames.indexOf(s) === -1 && i.raise("Invalid named capture referenced") } }, bt.regexp_disjunction = function (i) { for (this.regexp_alternative(i); i.eat(124);)this.regexp_alternative(i); this.regexp_eatQuantifier(i, !0) && i.raise("Nothing to repeat"), i.eat(123) && i.raise("Lone quantifier brackets") }, bt.regexp_alternative = function (i) { for (; i.pos < i.source.length && this.regexp_eatTerm(i);); }, bt.regexp_eatTerm = function (i) { return this.regexp_eatAssertion(i) ? (i.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(i) && i.switchU && i.raise("Invalid quantifier"), !0) : (i.switchU ? this.regexp_eatAtom(i) : this.regexp_eatExtendedAtom(i)) ? (this.regexp_eatQuantifier(i), !0) : !1 }, bt.regexp_eatAssertion = function (i) { var e = i.pos; if (i.lastAssertionIsQuantifiable = !1, i.eat(94) || i.eat(36)) return !0; if (i.eat(92)) { if (i.eat(66) || i.eat(98)) return !0; i.pos = e } if (i.eat(40) && i.eat(63)) { var t = !1; if (this.options.ecmaVersion >= 9 && (t = i.eat(60)), i.eat(61) || i.eat(33)) return this.regexp_disjunction(i), i.eat(41) || i.raise("Unterminated group"), i.lastAssertionIsQuantifiable = !t, !0 } return i.pos = e, !1 }, bt.regexp_eatQuantifier = function (i, e) { return e === void 0 && (e = !1), this.regexp_eatQuantifierPrefix(i, e) ? (i.eat(63), !0) : !1 }, bt.regexp_eatQuantifierPrefix = function (i, e) { return i.eat(42) || i.eat(43) || i.eat(63) || this.regexp_eatBracedQuantifier(i, e) }, bt.regexp_eatBracedQuantifier = function (i, e) { var t = i.pos; if (i.eat(123)) { var s = 0, r = -1; if (this.regexp_eatDecimalDigits(i) && (s = i.lastIntValue, i.eat(44) && this.regexp_eatDecimalDigits(i) && (r = i.lastIntValue), i.eat(125))) return r !== -1 && r < s && !e && i.raise("numbers out of order in {} quantifier"), !0; i.switchU && !e && i.raise("Incomplete quantifier"), i.pos = t } return !1 }, bt.regexp_eatAtom = function (i) { return this.regexp_eatPatternCharacters(i) || i.eat(46) || this.regexp_eatReverseSolidusAtomEscape(i) || this.regexp_eatCharacterClass(i) || this.regexp_eatUncapturingGroup(i) || this.regexp_eatCapturingGroup(i) }, bt.regexp_eatReverseSolidusAtomEscape = function (i) { var e = i.pos; if (i.eat(92)) { if (this.regexp_eatAtomEscape(i)) return !0; i.pos = e } return !1 }, bt.regexp_eatUncapturingGroup = function (i) { var e = i.pos; if (i.eat(40)) { if (i.eat(63) && i.eat(58)) { if (this.regexp_disjunction(i), i.eat(41)) return !0; i.raise("Unterminated group") } i.pos = e } return !1 }, bt.regexp_eatCapturingGroup = function (i) { if (i.eat(40)) { if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(i) : i.current() === 63 && i.raise("Invalid group"), this.regexp_disjunction(i), i.eat(41)) return i.numCapturingParens += 1, !0; i.raise("Unterminated group") } return !1 }, bt.regexp_eatExtendedAtom = function (i) { return i.eat(46) || this.regexp_eatReverseSolidusAtomEscape(i) || this.regexp_eatCharacterClass(i) || this.regexp_eatUncapturingGroup(i) || this.regexp_eatCapturingGroup(i) || this.regexp_eatInvalidBracedQuantifier(i) || this.regexp_eatExtendedPatternCharacter(i) }, bt.regexp_eatInvalidBracedQuantifier = function (i) { return this.regexp_eatBracedQuantifier(i, !0) && i.raise("Nothing to repeat"), !1 }, bt.regexp_eatSyntaxCharacter = function (i) { var e = i.current(); return V3(e) ? (i.lastIntValue = e, i.advance(), !0) : !1 }; function V3(i) { return i === 36 || i >= 40 && i <= 43 || i === 46 || i === 63 || i >= 91 && i <= 94 || i >= 123 && i <= 125 } bt.regexp_eatPatternCharacters = function (i) { for (var e = i.pos, t = 0; (t = i.current()) !== -1 && !V3(t);)i.advance(); return i.pos !== e }, bt.regexp_eatExtendedPatternCharacter = function (i) { var e = i.current(); return e !== -1 && e !== 36 && !(e >= 40 && e <= 43) && e !== 46 && e !== 63 && e !== 91 && e !== 94 && e !== 124 ? (i.advance(), !0) : !1 }, bt.regexp_groupSpecifier = function (i) { if (i.eat(63)) { if (this.regexp_eatGroupName(i)) { i.groupNames.indexOf(i.lastStringValue) !== -1 && i.raise("Duplicate capture group name"), i.groupNames.push(i.lastStringValue); return } i.raise("Invalid group") } }, bt.regexp_eatGroupName = function (i) { if (i.lastStringValue = "", i.eat(60)) { if (this.regexp_eatRegExpIdentifierName(i) && i.eat(62)) return !0; i.raise("Invalid capture group name") } return !1 }, bt.regexp_eatRegExpIdentifierName = function (i) { if (i.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(i)) { for (i.lastStringValue += Tc(i.lastIntValue); this.regexp_eatRegExpIdentifierPart(i);)i.lastStringValue += Tc(i.lastIntValue); return !0 } return !1 }, bt.regexp_eatRegExpIdentifierStart = function (i) { var e = i.pos, t = this.options.ecmaVersion >= 11, s = i.current(t); return i.advance(t), s === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(i, t) && (s = i.lastIntValue), KK(s) ? (i.lastIntValue = s, !0) : (i.pos = e, !1) }; function KK(i) { return cl(i, !0) || i === 36 || i === 95 } bt.regexp_eatRegExpIdentifierPart = function (i) { var e = i.pos, t = this.options.ecmaVersion >= 11, s = i.current(t); return i.advance(t), s === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(i, t) && (s = i.lastIntValue), ZK(s) ? (i.lastIntValue = s, !0) : (i.pos = e, !1) }; function ZK(i) { return $d(i, !0) || i === 36 || i === 95 || i === 8204 || i === 8205 } bt.regexp_eatAtomEscape = function (i) { return this.regexp_eatBackReference(i) || this.regexp_eatCharacterClassEscape(i) || this.regexp_eatCharacterEscape(i) || i.switchN && this.regexp_eatKGroupName(i) ? !0 : (i.switchU && (i.current() === 99 && i.raise("Invalid unicode escape"), i.raise("Invalid escape")), !1) }, bt.regexp_eatBackReference = function (i) { var e = i.pos; if (this.regexp_eatDecimalEscape(i)) { var t = i.lastIntValue; if (i.switchU) return t > i.maxBackReference && (i.maxBackReference = t), !0; if (t <= i.numCapturingParens) return !0; i.pos = e } return !1 }, bt.regexp_eatKGroupName = function (i) { if (i.eat(107)) { if (this.regexp_eatGroupName(i)) return i.backReferenceNames.push(i.lastStringValue), !0; i.raise("Invalid named reference") } return !1 }, bt.regexp_eatCharacterEscape = function (i) { return this.regexp_eatControlEscape(i) || this.regexp_eatCControlLetter(i) || this.regexp_eatZero(i) || this.regexp_eatHexEscapeSequence(i) || this.regexp_eatRegExpUnicodeEscapeSequence(i, !1) || !i.switchU && this.regexp_eatLegacyOctalEscapeSequence(i) || this.regexp_eatIdentityEscape(i) }, bt.regexp_eatCControlLetter = function (i) { var e = i.pos; if (i.eat(99)) { if (this.regexp_eatControlLetter(i)) return !0; i.pos = e } return !1 }, bt.regexp_eatZero = function (i) { return i.current() === 48 && !ab(i.lookahead()) ? (i.lastIntValue = 0, i.advance(), !0) : !1 }, bt.regexp_eatControlEscape = function (i) { var e = i.current(); return e === 116 ? (i.lastIntValue = 9, i.advance(), !0) : e === 110 ? (i.lastIntValue = 10, i.advance(), !0) : e === 118 ? (i.lastIntValue = 11, i.advance(), !0) : e === 102 ? (i.lastIntValue = 12, i.advance(), !0) : e === 114 ? (i.lastIntValue = 13, i.advance(), !0) : !1 }, bt.regexp_eatControlLetter = function (i) { var e = i.current(); return W3(e) ? (i.lastIntValue = e % 32, i.advance(), !0) : !1 }; function W3(i) { return i >= 65 && i <= 90 || i >= 97 && i <= 122 } bt.regexp_eatRegExpUnicodeEscapeSequence = function (i, e) { e === void 0 && (e = !1); var t = i.pos, s = e || i.switchU; if (i.eat(117)) { if (this.regexp_eatFixedHexDigits(i, 4)) { var r = i.lastIntValue; if (s && r >= 55296 && r <= 56319) { var n = i.pos; if (i.eat(92) && i.eat(117) && this.regexp_eatFixedHexDigits(i, 4)) { var o = i.lastIntValue; if (o >= 56320 && o <= 57343) return i.lastIntValue = (r - 55296) * 1024 + (o - 56320) + 65536, !0 } i.pos = n, i.lastIntValue = r } return !0 } if (s && i.eat(123) && this.regexp_eatHexDigits(i) && i.eat(125) && $K(i.lastIntValue)) return !0; s && i.raise("Invalid unicode escape"), i.pos = t } return !1 }; function $K(i) { return i >= 0 && i <= 1114111 } bt.regexp_eatIdentityEscape = function (i) { if (i.switchU) return this.regexp_eatSyntaxCharacter(i) ? !0 : i.eat(47) ? (i.lastIntValue = 47, !0) : !1; var e = i.current(); return e !== 99 && (!i.switchN || e !== 107) ? (i.lastIntValue = e, i.advance(), !0) : !1 }, bt.regexp_eatDecimalEscape = function (i) { i.lastIntValue = 0; var e = i.current(); if (e >= 49 && e <= 57) { do i.lastIntValue = 10 * i.lastIntValue + (e - 48), i.advance(); while ((e = i.current()) >= 48 && e <= 57); return !0 } return !1 }, bt.regexp_eatCharacterClassEscape = function (i) { var e = i.current(); if (eZ(e)) return i.lastIntValue = -1, i.advance(), !0; if (i.switchU && this.options.ecmaVersion >= 9 && (e === 80 || e === 112)) { if (i.lastIntValue = -1, i.advance(), i.eat(123) && this.regexp_eatUnicodePropertyValueExpression(i) && i.eat(125)) return !0; i.raise("Invalid property name") } return !1 }; function eZ(i) { return i === 100 || i === 68 || i === 115 || i === 83 || i === 119 || i === 87 } bt.regexp_eatUnicodePropertyValueExpression = function (i) { var e = i.pos; if (this.regexp_eatUnicodePropertyName(i) && i.eat(61)) { var t = i.lastStringValue; if (this.regexp_eatUnicodePropertyValue(i)) { var s = i.lastStringValue; return this.regexp_validateUnicodePropertyNameAndValue(i, t, s), !0 } } if (i.pos = e, this.regexp_eatLoneUnicodePropertyNameOrValue(i)) { var r = i.lastStringValue; return this.regexp_validateUnicodePropertyNameOrValue(i, r), !0 } return !1 }, bt.regexp_validateUnicodePropertyNameAndValue = function (i, e, t) { qg(i.unicodeProperties.nonBinary, e) || i.raise("Invalid property name"), i.unicodeProperties.nonBinary[e].test(t) || i.raise("Invalid property value") }, bt.regexp_validateUnicodePropertyNameOrValue = function (i, e) { i.unicodeProperties.binary.test(e) || i.raise("Invalid property name") }, bt.regexp_eatUnicodePropertyName = function (i) { var e = 0; for (i.lastStringValue = ""; q3(e = i.current());)i.lastStringValue += Tc(e), i.advance(); return i.lastStringValue !== "" }; function q3(i) { return W3(i) || i === 95 } bt.regexp_eatUnicodePropertyValue = function (i) { var e = 0; for (i.lastStringValue = ""; tZ(e = i.current());)i.lastStringValue += Tc(e), i.advance(); return i.lastStringValue !== "" }; function tZ(i) { return q3(i) || ab(i) } bt.regexp_eatLoneUnicodePropertyNameOrValue = function (i) { return this.regexp_eatUnicodePropertyValue(i) }, bt.regexp_eatCharacterClass = function (i) { if (i.eat(91)) { if (i.eat(94), this.regexp_classRanges(i), i.eat(93)) return !0; i.raise("Unterminated character class") } return !1 }, bt.regexp_classRanges = function (i) { for (; this.regexp_eatClassAtom(i);) { var e = i.lastIntValue; if (i.eat(45) && this.regexp_eatClassAtom(i)) { var t = i.lastIntValue; i.switchU && (e === -1 || t === -1) && i.raise("Invalid character class"), e !== -1 && t !== -1 && e > t && i.raise("Range out of order in character class") } } }, bt.regexp_eatClassAtom = function (i) { var e = i.pos; if (i.eat(92)) { if (this.regexp_eatClassEscape(i)) return !0; if (i.switchU) { var t = i.current(); (t === 99 || J3(t)) && i.raise("Invalid class escape"), i.raise("Invalid escape") } i.pos = e } var s = i.current(); return s !== 93 ? (i.lastIntValue = s, i.advance(), !0) : !1 }, bt.regexp_eatClassEscape = function (i) { var e = i.pos; if (i.eat(98)) return i.lastIntValue = 8, !0; if (i.switchU && i.eat(45)) return i.lastIntValue = 45, !0; if (!i.switchU && i.eat(99)) { if (this.regexp_eatClassControlLetter(i)) return !0; i.pos = e } return this.regexp_eatCharacterClassEscape(i) || this.regexp_eatCharacterEscape(i) }, bt.regexp_eatClassControlLetter = function (i) { var e = i.current(); return ab(e) || e === 95 ? (i.lastIntValue = e % 32, i.advance(), !0) : !1 }, bt.regexp_eatHexEscapeSequence = function (i) { var e = i.pos; if (i.eat(120)) { if (this.regexp_eatFixedHexDigits(i, 2)) return !0; i.switchU && i.raise("Invalid escape"), i.pos = e } return !1 }, bt.regexp_eatDecimalDigits = function (i) { var e = i.pos, t = 0; for (i.lastIntValue = 0; ab(t = i.current());)i.lastIntValue = 10 * i.lastIntValue + (t - 48), i.advance(); return i.pos !== e }; function ab(i) { return i >= 48 && i <= 57 } bt.regexp_eatHexDigits = function (i) { var e = i.pos, t = 0; for (i.lastIntValue = 0; X3(t = i.current());)i.lastIntValue = 16 * i.lastIntValue + Y3(t), i.advance(); return i.pos !== e }; function X3(i) { return i >= 48 && i <= 57 || i >= 65 && i <= 70 || i >= 97 && i <= 102 } function Y3(i) { return i >= 65 && i <= 70 ? 10 + (i - 65) : i >= 97 && i <= 102 ? 10 + (i - 97) : i - 48 } bt.regexp_eatLegacyOctalEscapeSequence = function (i) { if (this.regexp_eatOctalDigit(i)) { var e = i.lastIntValue; if (this.regexp_eatOctalDigit(i)) { var t = i.lastIntValue; e <= 3 && this.regexp_eatOctalDigit(i) ? i.lastIntValue = e * 64 + t * 8 + i.lastIntValue : i.lastIntValue = e * 8 + t } else i.lastIntValue = e; return !0 } return !1 }, bt.regexp_eatOctalDigit = function (i) { var e = i.current(); return J3(e) ? (i.lastIntValue = e - 48, i.advance(), !0) : (i.lastIntValue = 0, !1) }; function J3(i) { return i >= 48 && i <= 55 } bt.regexp_eatFixedHexDigits = function (i, e) { var t = i.pos; i.lastIntValue = 0; for (var s = 0; s < e; ++s) { var r = i.current(); if (!X3(r)) return i.pos = t, !1; i.lastIntValue = 16 * i.lastIntValue + Y3(r), i.advance() } return !0 }; var aE = function (i) { this.type = i.type, this.value = i.value, this.start = i.start, this.end = i.end, i.options.locations && (this.loc = new tb(i, i.startLoc, i.endLoc)), i.options.ranges && (this.range = [i.start, i.end]) }, qt = Rs.prototype; qt.next = function (i) { !i && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new aE(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken() }, qt.getToken = function () { return this.next(), new aE(this) }, typeof Symbol < "u" && (qt[Symbol.iterator] = function () { var i = this; return { next: function () { var e = i.getToken(); return { done: e.type === B.eof, value: e } } } }), qt.nextToken = function () { var i = this.curContext(); if ((!i || !i.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length) return this.finishToken(B.eof); if (i.override) return i.override(this); this.readToken(this.fullCharCodeAtPos()) }, qt.readToken = function (i) { return cl(i, this.options.ecmaVersion >= 6) || i === 92 ? this.readWord() : this.getTokenFromCode(i) }, qt.fullCharCodeAtPos = function () { var i = this.input.charCodeAt(this.pos); if (i <= 55295 || i >= 56320) return i; var e = this.input.charCodeAt(this.pos + 1); return e <= 56319 || e >= 57344 ? i : (i << 10) + e - 56613888 }, qt.skipBlockComment = function () { var i = this.options.onComment && this.curPosition(), e = this.pos, t = this.input.indexOf("*/", this.pos += 2); if (t === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = t + 2, this.options.locations) for (var s = void 0, r = e; (s = A3(this.input, r, this.pos)) > -1;)++this.curLine, r = this.lineStart = s; this.options.onComment && this.options.onComment(!0, this.input.slice(e + 2, t), e, this.pos, i, this.curPosition()) }, qt.skipLineComment = function (i) { for (var e = this.pos, t = this.options.onComment && this.curPosition(), s = this.input.charCodeAt(this.pos += i); this.pos < this.input.length && !ep(s);)s = this.input.charCodeAt(++this.pos); this.options.onComment && this.options.onComment(!1, this.input.slice(e + i, this.pos), e, this.pos, t, this.curPosition()) }, qt.skipSpace = function () { e: for (; this.pos < this.input.length;) { var i = this.input.charCodeAt(this.pos); switch (i) { case 32: case 160: ++this.pos; break; case 13: this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos; case 10: case 8232: case 8233: ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos); break; case 47: switch (this.input.charCodeAt(this.pos + 1)) { case 42: this.skipBlockComment(); break; case 47: this.skipLineComment(2); break; default: break e }break; default: if (i > 8 && i < 14 || i >= 5760 && y3.test(String.fromCharCode(i))) ++this.pos; else break e } } }, qt.finishToken = function (i, e) { this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition()); var t = this.type; this.type = i, this.value = e, this.updateContext(t) }, qt.readToken_dot = function () { var i = this.input.charCodeAt(this.pos + 1); if (i >= 48 && i <= 57) return this.readNumber(!0); var e = this.input.charCodeAt(this.pos + 2); return this.options.ecmaVersion >= 6 && i === 46 && e === 46 ? (this.pos += 3, this.finishToken(B.ellipsis)) : (++this.pos, this.finishToken(B.dot)) }, qt.readToken_slash = function () { var i = this.input.charCodeAt(this.pos + 1); return this.exprAllowed ? (++this.pos, this.readRegexp()) : i === 61 ? this.finishOp(B.assign, 2) : this.finishOp(B.slash, 1) }, qt.readToken_mult_modulo_exp = function (i) { var e = this.input.charCodeAt(this.pos + 1), t = 1, s = i === 42 ? B.star : B.modulo; return this.options.ecmaVersion >= 7 && i === 42 && e === 42 && (++t, s = B.starstar, e = this.input.charCodeAt(this.pos + 2)), e === 61 ? this.finishOp(B.assign, t + 1) : this.finishOp(s, t) }, qt.readToken_pipe_amp = function (i) { var e = this.input.charCodeAt(this.pos + 1); if (e === i) { if (this.options.ecmaVersion >= 12) { var t = this.input.charCodeAt(this.pos + 2); if (t === 61) return this.finishOp(B.assign, 3) } return this.finishOp(i === 124 ? B.logicalOR : B.logicalAND, 2) } return e === 61 ? this.finishOp(B.assign, 2) : this.finishOp(i === 124 ? B.bitwiseOR : B.bitwiseAND, 1) }, qt.readToken_caret = function () { var i = this.input.charCodeAt(this.pos + 1); return i === 61 ? this.finishOp(B.assign, 2) : this.finishOp(B.bitwiseXOR, 1) }, qt.readToken_plus_min = function (i) { var e = this.input.charCodeAt(this.pos + 1); return e === i ? e === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || Nn.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(B.incDec, 2) : e === 61 ? this.finishOp(B.assign, 2) : this.finishOp(B.plusMin, 1) }, qt.readToken_lt_gt = function (i) { var e = this.input.charCodeAt(this.pos + 1), t = 1; return e === i ? (t = i === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + t) === 61 ? this.finishOp(B.assign, t + 1) : this.finishOp(B.bitShift, t)) : e === 33 && i === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (e === 61 && (t = 2), this.finishOp(B.relational, t)) }, qt.readToken_eq_excl = function (i) { var e = this.input.charCodeAt(this.pos + 1); return e === 61 ? this.finishOp(B.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : i === 61 && e === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(B.arrow)) : this.finishOp(i === 61 ? B.eq : B.prefix, 1) }, qt.readToken_question = function () { var i = this.options.ecmaVersion; if (i >= 11) { var e = this.input.charCodeAt(this.pos + 1); if (e === 46) { var t = this.input.charCodeAt(this.pos + 2); if (t < 48 || t > 57) return this.finishOp(B.questionDot, 2) } if (e === 63) { if (i >= 12) { var s = this.input.charCodeAt(this.pos + 2); if (s === 61) return this.finishOp(B.assign, 3) } return this.finishOp(B.coalesce, 2) } } return this.finishOp(B.question, 1) }, qt.readToken_numberSign = function () { var i = this.options.ecmaVersion, e = 35; if (i >= 13 && (++this.pos, e = this.fullCharCodeAtPos(), cl(e, !0) || e === 92)) return this.finishToken(B.privateId, this.readWord1()); this.raise(this.pos, "Unexpected character '" + Tc(e) + "'") }, qt.getTokenFromCode = function (i) { switch (i) { case 46: return this.readToken_dot(); case 40: return ++this.pos, this.finishToken(B.parenL); case 41: return ++this.pos, this.finishToken(B.parenR); case 59: return ++this.pos, this.finishToken(B.semi); case 44: return ++this.pos, this.finishToken(B.comma); case 91: return ++this.pos, this.finishToken(B.bracketL); case 93: return ++this.pos, this.finishToken(B.bracketR); case 123: return ++this.pos, this.finishToken(B.braceL); case 125: return ++this.pos, this.finishToken(B.braceR); case 58: return ++this.pos, this.finishToken(B.colon); case 96: if (this.options.ecmaVersion < 6) break; return ++this.pos, this.finishToken(B.backQuote); case 48: var e = this.input.charCodeAt(this.pos + 1); if (e === 120 || e === 88) return this.readRadixNumber(16); if (this.options.ecmaVersion >= 6) { if (e === 111 || e === 79) return this.readRadixNumber(8); if (e === 98 || e === 66) return this.readRadixNumber(2) } case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return this.readNumber(!1); case 34: case 39: return this.readString(i); case 47: return this.readToken_slash(); case 37: case 42: return this.readToken_mult_modulo_exp(i); case 124: case 38: return this.readToken_pipe_amp(i); case 94: return this.readToken_caret(); case 43: case 45: return this.readToken_plus_min(i); case 60: case 62: return this.readToken_lt_gt(i); case 61: case 33: return this.readToken_eq_excl(i); case 63: return this.readToken_question(); case 126: return this.finishOp(B.prefix, 1); case 35: return this.readToken_numberSign() }this.raise(this.pos, "Unexpected character '" + Tc(i) + "'") }, qt.finishOp = function (i, e) { var t = this.input.slice(this.pos, this.pos + e); return this.pos += e, this.finishToken(i, t) }, qt.readRegexp = function () { for (var i, e, t = this.pos; ;) { this.pos >= this.input.length && this.raise(t, "Unterminated regular expression"); var s = this.input.charAt(this.pos); if (Nn.test(s) && this.raise(t, "Unterminated regular expression"), i) i = !1; else { if (s === "[") e = !0; else if (s === "]" && e) e = !1; else if (s === "/" && !e) break; i = s === "\\" } ++this.pos } var r = this.input.slice(t, this.pos); ++this.pos; var n = this.pos, o = this.readWord1(); this.containsEsc && this.unexpected(n); var a = this.regexpState || (this.regexpState = new ul(this)); a.reset(t, r, o), this.validateRegExpFlags(a), this.validateRegExpPattern(a); var l = null; try { l = new RegExp(r, o) } catch { } return this.finishToken(B.regexp, { pattern: r, flags: o, value: l }) }, qt.readInt = function (i, e, t) { for (var s = this.options.ecmaVersion >= 12 && e === void 0, r = t && this.input.charCodeAt(this.pos) === 48, n = this.pos, o = 0, a = 0, l = 0, c = e ?? 1 / 0; l < c; ++l, ++this.pos) { var h = this.input.charCodeAt(this.pos), d = void 0; if (s && h === 95) { r && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), a === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), l === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), a = h; continue } if (h >= 97 ? d = h - 97 + 10 : h >= 65 ? d = h - 65 + 10 : h >= 48 && h <= 57 ? d = h - 48 : d = 1 / 0, d >= i) break; a = h, o = o * i + d } return s && a === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === n || e != null && this.pos - n !== e ? null : o }; function iZ(i, e) { return e ? parseInt(i, 8) : parseFloat(i.replace(/_/g, "")) } function K3(i) { return typeof BigInt != "function" ? null : BigInt(i.replace(/_/g, "")) } qt.readRadixNumber = function (i) { var e = this.pos; this.pos += 2; var t = this.readInt(i); return t == null && this.raise(this.start + 2, "Expected number in radix " + i), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (t = K3(this.input.slice(e, this.pos)), ++this.pos) : cl(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(B.num, t) }, qt.readNumber = function (i) { var e = this.pos; !i && this.readInt(10, void 0, !0) === null && this.raise(e, "Invalid number"); var t = this.pos - e >= 2 && this.input.charCodeAt(e) === 48; t && this.strict && this.raise(e, "Invalid number"); var s = this.input.charCodeAt(this.pos); if (!t && !i && this.options.ecmaVersion >= 11 && s === 110) { var r = K3(this.input.slice(e, this.pos)); return ++this.pos, cl(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(B.num, r) } t && /[89]/.test(this.input.slice(e, this.pos)) && (t = !1), s === 46 && !t && (++this.pos, this.readInt(10), s = this.input.charCodeAt(this.pos)), (s === 69 || s === 101) && !t && (s = this.input.charCodeAt(++this.pos), (s === 43 || s === 45) && ++this.pos, this.readInt(10) === null && this.raise(e, "Invalid number")), cl(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"); var n = iZ(this.input.slice(e, this.pos), t); return this.finishToken(B.num, n) }, qt.readCodePoint = function () { var i = this.input.charCodeAt(this.pos), e; if (i === 123) { this.options.ecmaVersion < 6 && this.unexpected(); var t = ++this.pos; e = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, e > 1114111 && this.invalidStringToken(t, "Code point out of bounds") } else e = this.readHexChar(4); return e }, qt.readString = function (i) { for (var e = "", t = ++this.pos; ;) { this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant"); var s = this.input.charCodeAt(this.pos); if (s === i) break; s === 92 ? (e += this.input.slice(t, this.pos), e += this.readEscapedChar(!1), t = this.pos) : s === 8232 || s === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (ep(s) && this.raise(this.start, "Unterminated string constant"), ++this.pos) } return e += this.input.slice(t, this.pos++), this.finishToken(B.string, e) }; var Z3 = {}; qt.tryReadTemplateToken = function () { this.inTemplateElement = !0; try { this.readTmplToken() } catch (i) { if (i === Z3) this.readInvalidTemplateToken(); else throw i } this.inTemplateElement = !1 }, qt.invalidStringToken = function (i, e) { if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw Z3; this.raise(i, e) }, qt.readTmplToken = function () {
  for (var i = "", e = this.pos; ;) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template"); var t = this.input.charCodeAt(this.pos); if (t === 96 || t === 36 && this.input.charCodeAt(this.pos + 1) === 123) return this.pos === this.start && (this.type === B.template || this.type === B.invalidTemplate) ? t === 36 ? (this.pos += 2, this.finishToken(B.dollarBraceL)) : (++this.pos, this.finishToken(B.backQuote)) : (i += this.input.slice(e, this.pos), this.finishToken(B.template, i)); if (t === 92) i += this.input.slice(e, this.pos), i += this.readEscapedChar(!0), e = this.pos; else if (ep(t)) {
      switch (i += this.input.slice(e, this.pos), ++this.pos, t) {
        case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: i += `
`; break; default: i += String.fromCharCode(t); break
      }this.options.locations && (++this.curLine, this.lineStart = this.pos), e = this.pos
    } else ++this.pos
  }
}, qt.readInvalidTemplateToken = function () { for (; this.pos < this.input.length; this.pos++)switch (this.input[this.pos]) { case "\\": ++this.pos; break; case "$": if (this.input[this.pos + 1] !== "{") break; case "`": return this.finishToken(B.invalidTemplate, this.input.slice(this.start, this.pos)) }this.raise(this.start, "Unterminated template") }, qt.readEscapedChar = function (i) {
  var e = this.input.charCodeAt(++this.pos); switch (++this.pos, e) {
    case 110: return `
`; case 114: return "\r"; case 120: return String.fromCharCode(this.readHexChar(2)); case 117: return Tc(this.readCodePoint()); case 116: return "	"; case 98: return "\b"; case 118: return "\v"; case 102: return "\f"; case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: return this.options.locations && (this.lineStart = this.pos, ++this.curLine), ""; case 56: case 57: if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), i) { var t = this.pos - 1; return this.invalidStringToken(t, "Invalid escape sequence in template string"), null } default: if (e >= 48 && e <= 55) { var s = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], r = parseInt(s, 8); return r > 255 && (s = s.slice(0, -1), r = parseInt(s, 8)), this.pos += s.length - 1, e = this.input.charCodeAt(this.pos), (s !== "0" || e === 56 || e === 57) && (this.strict || i) && this.invalidStringToken(this.pos - 1 - s.length, i ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(r) } return ep(e) ? "" : String.fromCharCode(e)
  }
}, qt.readHexChar = function (i) { var e = this.pos, t = this.readInt(16, i); return t === null && this.invalidStringToken(e, "Bad character escape sequence"), t }, qt.readWord1 = function () { this.containsEsc = !1; for (var i = "", e = !0, t = this.pos, s = this.options.ecmaVersion >= 6; this.pos < this.input.length;) { var r = this.fullCharCodeAtPos(); if ($d(r, s)) this.pos += r <= 65535 ? 1 : 2; else if (r === 92) { this.containsEsc = !0, i += this.input.slice(t, this.pos); var n = this.pos; this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos; var o = this.readCodePoint(); (e ? cl : $d)(o, s) || this.invalidStringToken(n, "Invalid Unicode escape"), i += Tc(o), t = this.pos } else break; e = !1 } return i + this.input.slice(t, this.pos) }, qt.readWord = function () { var i = this.readWord1(), e = B.name; return this.keywords.test(i) && (e = KS[i]), this.finishToken(e, i) }; var sZ = "8.8.0"; Rs.acorn = { Parser: Rs, version: sZ, defaultOptions: ZS, Position: Xg, SourceLocation: tb, getLineInfo: x3, Node: ob, TokenType: ei, tokTypes: B, keywordTypes: KS, TokContext: xo, tokContexts: Ci, isIdentifierChar: $d, isIdentifierStart: cl, Token: aE, isNewLine: ep, lineBreak: Nn, lineBreakG: kK, nonASCIIwhitespace: y3 }; class $g extends Ze.Object3D { constructor(e, t) { super(), u(this, "_rebuildParentUI", () => { this._parent._needsUpdate = !0, this.parent && !this.parent.isUI ? (lb.register(this), this.activatePseudoState("root")) : (lb.remove(this), this.deactivatePseudoState("root")) }), Object.defineProperties(this, { isUI: { configurable: !1, enumerable: !0, value: !0 } }), this._backgroundMesh = null, this._backgroundMaterial = null, this._backgroundCustomDepthMaterial = null, this._backgroundMaterialMediation = {}, this._backgroundMeshMediation = { backgroundCastShadow: { m: "castShadow" }, backgroundReceiveShadow: { m: "receiveShadow" }, renderOrder: { m: "renderOrder" } }, this._fontMesh = null, this._fontMaterial = new g3("fontMaterial"), this._fontCustomDepthMaterial = new g3("fontCustomDepthMaterial"), this._fontMeshMediation = { fontMaterial: { m: "material" }, fontCustomDepthMaterial: { m: "customDepthMaterial", t: iJ }, fontCastShadow: { m: "castShadow" }, fontReceiveShadow: { m: "receiveShadow" }, renderOrder: { m: "renderOrder" } }, this._children = e.children ? new e.children : new ll("children"), this._parent = new sJ, this.addEventListener("added", this._rebuildParentUI), this.addEventListener("removed", this._rebuildParentUI), this._backgroundSide = new YL("backgroundSide"), this._fontSide = new YL("fontSide"), this._backgroundAlphaTest = new XL("backgroundAlphaTest", .02), this._fontAlphaTest = new XL("fontAlphaTest", .02), this._visible = new RJ("visible", !0), this._backgroundCastShadow = new eb("backgroundCastShadow"), this._fontCastShadow = new eb("fontCastShadow"), this._backgroundReceiveShadow = new eb("backgroundReceiveShadow"), this._fontReceiveShadow = new eb("fontReceiveShadow"), this._renderOrder = new XY, this._segments = e.segments ? new e.segments : new f3, this._bounds = e.bounds ? new e.bounds : new ll("bounds"), this._order = new zJ, this._padding = new eJ, this._margin = new tJ, this._position = new $L, this._flexDirection = e.flexDirection ? new e.flexDirection : new zS, this._justifyContent = e.justifyContent ? new e.justifyContent : new jS, this._alignItems = e.alignItems ? new e.alignItems : new US, this._display = new dJ("flex"), this._boxSizing = new gJ("border-box"), this._width = new GJ, this._height = new HJ, this._backgroundColor = e.backgroundColor ? new e.backgroundColor : new ZL, this._backgroundOpacity = new FS("backgroundOpacity", .5), this._backgroundImage = new yJ, this._backgroundSize = new _J("cover"), this._color = e.color ? new e.color : new Wg("color", "inherit"), this._fontOpacity = new FS("fontOpacity", "inherit"), this._whiteSpace = e.whiteSpace ? new e.whiteSpace : new d3, this._fontFamily = e.fontFamily ? new e.fontFamily : new h3, this._fontStyle = e.fontStyle ? new e.fontStyle : new i3("normal"), this._fontWeight = e.fontWeight ? new e.fontWeight : new s3, this._fontSize = e.fontSize ? new e.fontSize : new wK, this._lineHeight = e.lineHeight ? new e.lineHeight : new u3, this._fontKerning = e.fontKerning ? new e.fontKerning : new $y, this._letterSpacing = e.letterSpacing ? new e.letterSpacing : new p3, this._overflow = new CJ("visible"), this._borderRadius = new IJ(0), this._borderWidth = new TJ(0), this._borderColor = new Wg("borderColor", 16711935), this._borderOpacity = new FS("borderOpacity", 1), this._font = new cJ, this._lineBreak = e.lineBreak ? new e.lineBreak : new ll("lineBreak"), this._textContent = e.textContent ? new e.textContent : new t3, this._glyphs = e.glyphs ? new e.glyphs : new ll("glyphs"), this._inlines = e.inlines ? new e.inlines : new ll("inlines"), this._layouter = e.layouter ? new e.layouter : new ll("layouter"), this._inlineJustificator = new PJ, this._textAlign = e.textAlign ? new e.textAlign : new NS, this._autoSize = e.autoSize ? new e.autoSize : new ll("autoSize"), this._renderer = e.renderer ? new e.renderer : new ll("renderer"), this._offset = new YY, this._invertAlpha = new CK, this._fontSmooth = e.fontSmooth ? new e.fontSmooth : new JY, this._components = [this._textContent, this._children, this._parent, this._autoSize, this._fontFamily, this._fontStyle, this._fontWeight, this._font, this._whiteSpace, this._glyphs, this._inlines, this._visible, this._backgroundSide, this._fontSide, this._backgroundAlphaTest, this._fontAlphaTest, this._backgroundCastShadow, this._fontCastShadow, this._backgroundReceiveShadow, this._fontReceiveShadow, this._renderOrder, this._segments, this._padding, this._margin, this._width, this._height, this._borderWidth, this._boxSizing, this._bounds, this._position, this._flexDirection, this._justifyContent, this._alignItems, this._order, this._display, this._backgroundColor, this._backgroundOpacity, this._backgroundImage, this._backgroundSize, this._fontOpacity, this._color, this._fontSize, this._lineHeight, this._fontKerning, this._letterSpacing, this._borderRadius, this._borderColor, this._borderOpacity, this._lineBreak, this._offset, this._layouter, this._inlineJustificator, this._textAlign, this._invertAlpha, this._fontSmooth, this._fontMaterial, this._fontCustomDepthMaterial, this._overflow, this._renderer], this._onAfterUpdates = [], t.backgroundSide || (t.backgroundSide = 0), t && this.set(t) } update() { const e = {}; for (const t of this._components) t._needsUpdate && (t.update(this, e), t._needsUpdate = !1); this._transferToBackgroundMesh(e), this._transferToFontMesh(e), this._transferToBackgroundMaterial(e), this._transferToFontMaterial(e); for (const t of this._children._uis) t.update() } process() { for (const e of this._children._uis) e.process(); for (const e of this._components) e._needsProcess && (e.process(this), e._needsProcess = !1) } render() { for (let e = 0; e < this._components.length; e++) { const t = this._components[e]; t._needsRender && (t.render(this), t._needsRender = !1) } for (const e of this._children._uis) e.render() } set(e) { if (e.fontTexture && (console.warn("ThreeMeshUI::set( {fontTexture} ) is deprecated. Please use fontLibrary to register font families and variants."), e.fontFamily)) { const t = e.fontFamily.pages ? e.fontFamily.info.face : e.fontFamily; let s = Vh.getFontFamily(t); if (!s) { const r = e.fontStyle ? e.fontStyle : "normal", n = e.fontWeight ? e.fontWeight : "400"; s = Vh.addFontFamily(t).addVariant(n, r, e.fontFamily, e.fontTexture) } e.fontFamily = s, delete e.fontTexture } for (let t of Object.keys(e)) { const s = e[t]; switch (t) { case "contentDirection": console.warn("ThreeMeshUI v7xx: property `contentDirection` is deprecated and has been renamed as `flexDirection`"), t = "flexDirection"; break; case "interLine": console.warn("ThreeMeshUI v7xx: property `interLine` is deprecated and has been renamed as `lineHeight`"), t = "lineHeight"; break; case "content": console.warn("ThreeMeshUI v7xx: property `content` is deprecated and has been renamed as `textContent`"), t = "textContent"; break; case "fontColor": console.warn("ThreeMeshUI v7xx: property `fontColor` is deprecated and has been renamed as `color`"), t = "color"; break; case "hiddenOverflow": console.warn("ThreeMeshUI v7xx: property `hiddenOverflow` is deprecated and has been renamed as `overflow`"), t = "overflow"; break; case "backgroundTexture": console.warn("ThreeMeshUI v7xx: property `backgroundTexture` is deprecated and has been renamed as `backgroundImage`"), t = "backgroundImage"; break; case "alignContent": console.warn("ThreeMeshUI v7xx: property `alignContent` is deprecated and has been renamed as `alignItems`"), t = "alignItems"; break; case "borderTopColor": case "borderBottomColor": case "borderLeftColor": case "borderRightColor": t = "borderColor"; break }switch (t) { case "fontSmooth": case "renderOrder": case "segments": case "visible": case "offset": this[`_${t}`].value = s; break; case "flexDirection": case "justifyContent": case "alignItems": case "color": case "fontFamily": case "fontOpacity": case "fontKerning": case "fontSize": case "fontStyle": case "fontWeight": case "textAlign": case "letterSpacing": case "lineHeight": case "whiteSpace": case "breakOn": case "width": case "height": case "padding": case "margin": case "backgroundColor": case "backgroundOpacity": case "backgroundImage": case "backgroundSize": case "borderColor": case "borderOpacity": case "borderRadius": case "borderWidth": case "overflow": case "order": case "boxSizing": this[`_${t}`] && (this[`_${t}`].inline = s); break; case "paddingTop": this._padding.top = s; break; case "paddingRight": this._padding.right = s; break; case "paddingBottom": this._padding.bottom = s; break; case "paddingLeft": this._padding.left = s; break; case "marginTop": this._margin.top = s; break; case "marginRight": this._margin.right = s; break; case "marginBottom": this._margin.bottom = s; break; case "marginLeft": this._margin.left = s; break; case "borderTopWidth": this._borderWidth.top = s; break; case "borderRightWidth": this._borderWidth.right = s; break; case "borderBottomWidth": this._borderWidth.bottom = s; break; case "borderLeftWidth": this._borderWidth.left = s; break; case "borderTopLeftRadius": this._borderRadius.topLeft = s; break; case "borderTopRightRadius": this._borderRadius.topRight = s; break; case "borderBottomRightRadius": this._borderRadius.bottomRight = s; break; case "borderBottomLeftRadius": this._borderRadius.bottomLeft = s; break; case "side": case "castShadow": case "receiveShadow": const r = t.charAt(0).toUpperCase() + t.substr(1); this[`_background${r}`].value = s, this[`_font${r}`].value = s; break; case "fontSide": case "backgroundSide": case "fontCastShadow": case "backgroundCastShadow": case "fontReceiveShadow": case "backgroundReceiveShadow": case "fontMaterial": case "fontCustomDepthMaterial": this[`_${t}`].value = s; break; default: this[t] !== void 0 ? this[t] = s : this[`_${t}`] !== void 0 && (this[`_${t}`].value = s) } } } get(e) { switch (e) { case "overflow": case "width": case "height": return this[`_${e}`].inline } } _rebuildChildrenLists() { this._children._needsUpdate = !0 } add(e) { let t = !1; for (let s = 0; s < arguments.length; s++)super.add(arguments[s]), arguments[s].isUI && (t = !0); return t && this._rebuildChildrenLists(), this } remove(e) { for (const t of Object.keys(arguments)) arguments[t].isInline && this.update(null, !0); return super.remove(...arguments), this._rebuildChildrenLists(), this } clear() { return this.removeFromParent(), this.traverse(e => { e.material && e.material.dispose(), e.geometry && e.geometry.dispose() }), super.clear(), this._backgroundMesh = null, this._backgroundMaterial = null, this._backgroundMaterialMediation = null, this._backgroundMeshMediation = null, this._children.dispose(), this._children = null, this._parent.dispose(), this._parent = null, this._backgroundSide = null, this._backgroundAlphaTest = null, this._visible = null, this._backgroundCastShadow = null, this._backgroundReceiveShadow = null, this._renderOrder = null, this._segments = null, this._bounds = null, this._boxSizing = null, this._padding = null, this._margin = null, this._position = null, this._flexDirection = null, this._justifyContent = null, this._alignItems = null, this._display = null, this._backgroundColor = null, this._backgroundOpacity = null, this._backgroundSize = null, this._fontOpacity = null, this._color = null, this._whiteSpace = null, this._fontFamily = null, this._fontStyle = null, this._fontWeight = null, this._lineHeight = null, this._fontKerning = null, this._letterSpacing = null, this._overflow = null, this._textAlign = null, this._font = null, this._lineBreak = null, this._layouter = null, this } get textContent() { return this._textContent.process(this), this._textContent._value } get backgroundMaterial() { return this._backgroundMaterial } set backgroundMaterial(e) { this._backgroundMaterial = e, this._backgroundMaterialMediation = { ...e.constructor.mediation }, this._transferToBackgroundMaterial(), this._backgroundMesh && (this._backgroundMesh.material = this._backgroundMaterial, Ln(e, "frameSize", this._backgroundMesh.scale)) } set backgroundCustomDepthMaterial(e) { this._backgroundCustomDepthMaterial = e, this._transferToBackgroundMaterial(), this._backgroundMesh && (this._backgroundMesh.customDepthMaterial = this._backgroundCustomDepthMaterial) } get backgroundCustomDepthMaterial() { return this._backgroundCustomDepthMaterial } _transferToBackgroundMaterial(e = null) { if (!e) { e = {}; for (const t of this._components) t.output(e) } qy.mediate(this, this._backgroundMaterial, e, this._backgroundMaterialMediation, this._backgroundCustomDepthMaterial) } set backgroundSide(e) { this._backgroundSide.value = e, this._backgroundMaterial && (this._backgroundMaterial.side = e) } get backgroundSide() { return this._backgroundSide.value } set backgroundAlphaTest(e) { this._backgroundAlphaTest.value = e, this._backgroundMaterial && (this._backgroundMaterial.alphaTest = e) } get backgroundAlphaTest() { return this._backgroundAlphaTest.value } get fontMaterial() { return this._fontMaterial.value } set fontMaterial(e) { this._fontMaterial.value = e } set fontCustomDepthMaterial(e) { this._fontCustomDepthMaterial.value = e } get fontCustomDepthMaterial() { return this._fontCustomDepthMaterial.value } _transferToFontMaterial(e = null) { const t = this._fontMaterial.value; if (t) { if (!e) { e = {}; for (const s of this._components) s.output(e) } qy.mediate(this, t, e, this._fontMaterial._mediation, this._fontCustomDepthMaterial.value) } } set fontSide(e) { this._fontSide.value = e } get fontSide() { return this._fontSide.value } set fontAlphaTest(e) { this._fontAlphaTest.value = e } get fontAlphaTest() { return this._fontAlphaTest.value } _transferToBackgroundMesh(e = null) { if (!e) { e = {}; for (const t of this._components) t.output(e) } qy.mediate(this, this._backgroundMesh, e, this._backgroundMeshMediation) } setBackgroundMesh(e) { this._backgroundMesh && (this.remove(this._backgroundMesh), this.unbindBackgroundMeshProperties()), this._backgroundMesh = e, this._backgroundMesh && (this.bindBackgroundMeshProperties(), this._backgroundCustomDepthMaterial && (this._backgroundMesh.customDepthMaterial = this._backgroundCustomDepthMaterial), this._backgroundMaterial && Ln(this._backgroundMaterial, "frameSize", this._backgroundMesh.scale), this._transferToBackgroundMesh(), this.add(this._backgroundMesh)) } bindBackgroundMeshProperties() { } unbindBackgroundMeshProperties() { } activatePseudoState(e) { } deactivatePseudoState(e) { } togglePseudoState(e) { } hasPseudoState(e) { return !1 } set borderRadiusMediation(e) { this._borderRadius.mediation = e } set backgroundCastShadow(e) { this._backgroundCastShadow && (this._backgroundCastShadow.value = e) } get backgroundCastShadow() { return this._backgroundCastShadow } set backgroundReceiveShadow(e) { this._backgroundReceiveShadow && (this._backgroundReceiveShadow.value = e) } get backgroundReceiveShadow() { return this._backgroundReceiveShadow } set renderOrder(e) { this._renderOrder && (this._renderOrder.value = e) } get renderOrder() { return this._renderOrder.value } _transferToFontMesh(e = null) { if (this._fontMesh) { if (!e) { e = {}; for (const t of this._components) t.output(e) } qy.mediate(this, this._fontMesh, e, this._fontMeshMediation) } } setFontMesh(e) { this._fontMesh && (this.remove(this._fontMesh), this._fontMesh.material && this._fontMesh.material.dispose(), this._fontMesh.geometry && this._fontMesh.geometry.dispose(), this._fontMesh = null, this.unbindFontMeshProperties()), this._fontMesh = e, this._fontMesh && (this._fontMesh.raycast = () => { }, this.bindFontMeshProperties(), this._transferToFontMaterial(), this._transferToFontMesh(), this.add(this._fontMesh)) } bindFontMeshProperties() { } unbindFontMeshProperties() { } set fontCastShadow(e) { this._fontCastShadow && (this._fontCastShadow.value = e) } get fontCastShadow() { return this._fontCastShadow } set fontReceiveShadow(e) { this._fontReceiveShadow && (this._fontReceiveShadow.value = e) } get fontReceiveShadow() { return this._fontReceiveShadow } set segments(e) { this._segments.value = e } get segments() { return this._segments.value } set onAfterUpdate(e) { console.warn("ThreeMeshUI v7xx : `onAfterUpdate()` property has been deprecated, please rely on `addAfterUpdate` instead."), this.addAfterUpdate(e) } addAfterUpdate(e) { this._onAfterUpdates.push(e) } removeAfterUpdate(e) { const t = this._onAfterUpdates.indexOf(e); t !== -1 && this._onAfterUpdates.splice(t, 1) } performAfterUpdate() { for (let e = 0; e < this._onAfterUpdates.length; e++)this._onAfterUpdates[e]() } getProperty(e) { return this[`_${e}`] ? this[`_${e}`] : null } appendProperty(e, t) { this[`_${e}`] = t, this._components.push(t) } replaceProperty(e, t) { const s = this[`_${e}`], r = this._components.indexOf(s); return this._components[r] = this[`_${e}`] = t, t.needsUpdate = !0, s } } class lb { static register(e) { this.elements.includes(e) || this.elements.push(e) } static remove(e) { const t = this.elements.indexOf(e); t !== -1 && this.elements.splice(t, 1) } static update() { for (const e of this.elements) e.update(), e.process(), e.process(), e.render() } } lb.elements = []; const rZ = `

// FrameBorder vertex pars
attribute vec2 uvB;
varying vec2 vUvB;

`, lE = rZ, nZ = `

	// FrameBorder vertex shader
	vUvB = uvB;

`, cE = nZ, oZ = `

// borders sequences are : x:TOP, y:RIGHT, z:BOTTOM, w:LEFT
uniform vec4 borderWidth;
uniform vec3 borderColor;
uniform float borderOpacity;
uniform vec4 borderRadius;

uniform vec2 cornerTL;
uniform vec2 cornerTR;
uniform vec2 cornerBR;
uniform vec2 cornerBL;

varying vec2 vUvB;

float getEllipticFactor( vec2 uv, vec2 center, float radiusX, float radiusY )
{

		float edx = uv.x - center.x;
		float edy = uv.y - center.y;

		float ddx = (edx * edx) / (radiusX * radiusX);
		float ddy = (edy * edy) / (radiusY * radiusY);

		return ddx + ddy;

}

`, hE = oZ, aZ = `

vec4 borderColor = vec4( borderColor, borderOpacity );

// This could be tweak to produce more smoothing
float mult = 1.0;

// Step 1 ----------------------------------------------
// Draw the four borders ( top - right - bottom - left )
// Without worrying about radiuses ( Straight boorders )

// Top
float topBorderUVy = 1.0 - borderWidth.x;
if( borderWidth.x > 0.0 && vUvB.y > topBorderUVy )
{

	float w = fwidth( 1.0 - vUvB.y ) * mult;
	float step = smoothstep( topBorderUVy , topBorderUVy + w , vUvB.y );
	diffuseColor = mix( diffuseColor, borderColor, step );

}

// Left
float leftBorderUVx = borderWidth.w;
if( borderWidth.w > 0.0 && vUvB.x < leftBorderUVx )
{

	float w = fwidth( vUvB.x ) * mult ;
	float step = smoothstep( leftBorderUVx , leftBorderUVx - w , vUvB.x );
	diffuseColor = mix( diffuseColor, borderColor, step );

}

// Bottom
float bottomBorderUVy = borderWidth.z;
if( borderWidth.z > 0.0 && vUvB.y < bottomBorderUVy )
{
	float w = fwidth( vUvB.y ) * mult;
	float step = smoothstep( bottomBorderUVy , bottomBorderUVy - w , vUvB.y );
	diffuseColor = mix( diffuseColor, borderColor, step );
}

// Right
float rightBorderUVx = 1.0 - borderWidth.y;
if( borderWidth.y > 0.0 && vUvB.x > rightBorderUVx )
{
	float w = fwidth( 1.0 - vUvB.x ) * mult;
	float step = smoothstep( rightBorderUVx , rightBorderUVx + w , vUvB.x );
	diffuseColor = mix( diffuseColor, borderColor, step );
}


// Step 2 ----------------------------------------------
// Process each corners ( topLeft, topRight, bottomRight, bottomLeft )
// To transparentize outside radiuses
// To draw ellipse border on the corner


// Top Left corner
if( vUvB.x < cornerTL.x && vUvB.y > cornerTL.y ) {

		// Only draw border if width is set
		if( borderWidth.w + borderWidth.x > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerTL, cornerTL.x - borderWidth.w,  ( 1.0 - cornerTL.y ) - borderWidth.x );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}

		// Then then radius
		float radiusFactor = getEllipticFactor( vUvB, cornerTL, cornerTL.x, 1.0 - cornerTL.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}
// Bottom Left
if( vUvB.x < cornerBL.x && vUvB.y < cornerBL.y ) {

		if( borderWidth.w + borderWidth.z > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerBL, cornerBL.x - borderWidth.w,  cornerBL.y - borderWidth.z );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}


		float radiusFactor = getEllipticFactor( vUvB, cornerBL, cornerBL.x, cornerBL.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}
// Top Right
if( vUvB.x > cornerTR.x && vUvB.y > cornerTR.y ) {

		if( borderWidth.y + borderWidth.x > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerTR, ( 1.0 - cornerTR.x ) - borderWidth.y,  ( 1.0 - cornerTR.y ) - borderWidth.x );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}

		float radiusFactor = getEllipticFactor( vUvB, cornerTR, 1.0 - cornerTR.x, 1.0 - cornerTR.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}
// Bottom Right
if( vUvB.x > cornerBR.x && vUvB.y < cornerBR.y ) {

		if( borderWidth.y + borderWidth.z > 0.0 ){

			float borderFactor = getEllipticFactor( vUvB, cornerBR, ( 1.0 - cornerBR.x ) - borderWidth.y,  cornerBR.y - borderWidth.z );
			float step = smoothstep( 1.0, 1.0 + fwidth( borderFactor ) * mult, borderFactor );
			diffuseColor = mix( diffuseColor, borderColor, step );

		}

		float radiusFactor = getEllipticFactor( vUvB, cornerBR, 1.0 - cornerBR.x, cornerBR.y );
		float alphaStep = smoothstep( 1.0 , 1.0 + fwidth(radiusFactor) * mult , radiusFactor );
		diffuseColor.a = mix( diffuseColor.a, 0.0, alphaStep );

}

`, uE = aZ, lZ = `

// To be removed - required for both border and background
uniform vec3 frameSize;
uniform vec2 textureSize;

`, dE = lZ, cZ = `

#ifdef USE_MAP

vec4 sampleTexture() {

	vec2 uv = vUv;

	// default stretch
	#if BACKGROUND_MAPPING != 0

	float textureRatio = textureSize.x / textureSize.y;
	float panelRatio = frameSize.x / frameSize.y;
	float ratio = panelRatio / textureRatio;
	float ratio2 = textureRatio / panelRatio;

		// contain
		#if BACKGROUND_MAPPING == 1
		if ( textureRatio < panelRatio ) { // repeat on X
			float newX = uv.x * ratio;
			newX += 0.5 - 0.5 * ratio;
			uv.x = newX;
		} else { // repeat on Y
			float newY = uv.y * ratio2;
			newY += 0.5 - 0.5 * ratio2;
			uv.y = newY;
		}
		#else
		// cover
		if ( textureRatio < panelRatio ) { // stretch on Y
			float newY = uv.y * ratio2;
			newY += 0.5 - 0.5 * ratio2;
			uv.y = newY;
		} else { // stretch on X
			float newX = uv.x * ratio;
			newX += 0.5 - 0.5 * ratio;
			uv.x = newX;
		}

		#endif

	#endif

	return texture2D( map, uv );

}
#endif
`, pE = cZ, hZ = `
#ifdef USE_MAP

	vec4 textureSample = sampleTexture();
	diffuseColor *= textureSample;

#endif
`, fE = hZ, $3 = { msdfAlphaglyphParsVertexGlsl: QS, msdfAlphaglyphVertexGlsl: GS, msdfOffsetglyphVertexGlsl: HS, msdfAlphaglyphParsFragmentGlsl: VS, msdfAlphaglyphFragmentGlsl: WS, frameBorderParsVertexGlsl: lE, frameBorderVertexGlsl: cE, frameCommonParsFragmentGlsl: dE, frameBorderParsFragmentGlsl: hE, frameBorderFragmentGlsl: uE, frameBackgroundParsFragmentGlsl: pE, frameBackgroundFragmentGlsl: fE }, uZ = `
// Would be automatic on three materials and from USE_UV
#ifdef USE_MAP
varying vec2 vUv;
#endif

${lE}

#include <clipping_planes_pars_vertex>

void main() {

	#ifdef USE_MAP
	vUv = uv;
	#endif

	${cE}

	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;

	#include <clipping_planes_vertex>

}
`, dZ = `

// Basic
uniform vec3 diffuse;
uniform float opacity;

#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif

${dE}

${hE}


#ifdef USE_MAP
varying vec2 vUv;
uniform sampler2D map;
#endif

${pE}

#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );

	// map
	${fE}

	${uE}

	#ifdef USE_ALPHATEST

	if ( diffuseColor.a < alphaTest ) discard;

	#endif

	// output
	gl_FragColor = diffuseColor;


	#include <clipping_planes_fragment>
}
`; class L_ {
  static get mediation() { return fZ } static ensureMaterialOptions(e) { e.transparent = !0, e.alphaTest = e.alphaTest || .02 } static ensureDefines(e) { e.defines || (e.defines = {}) } static ensureUserData(e, t) { e.userData.borderColor = { value: null }, e.userData.borderRadius = { value: new Ze.Vector4(0, 0, 0, 0) }, e.userData.cornerTL = { value: new Ze.Vector2(0, 1) }, e.userData.cornerTR = { value: new Ze.Vector2(1, 1) }, e.userData.cornerBR = { value: new Ze.Vector2(1, 0) }, e.userData.cornerBL = { value: new Ze.Vector2(0, 0) }, e.userData.borderWidth = { value: new Ze.Vector4(0, 0, 0, 0) }, e.userData.borderOpacity = { value: null }, e.userData.frameSize = { value: new Ze.Vector3(1, 1, 1) }, e.userData.textureSize = { value: new Ze.Vector2(1, 1) } } static bindUniformsWithUserData(e, t) { e.uniforms.borderColor = t.userData.borderColor, e.uniforms.borderRadius = t.userData.borderRadius, e.uniforms.cornerTL = t.userData.cornerTL, e.uniforms.cornerTR = t.userData.cornerTR, e.uniforms.cornerBR = t.userData.cornerBR, e.uniforms.cornerBL = t.userData.cornerBL, e.uniforms.borderWidth = t.userData.borderWidth, e.uniforms.borderOpacity = t.userData.borderOpacity, e.uniforms.frameSize = t.userData.frameSize, e.uniforms.textureSize = t.userData.textureSize } static injectShaderChunks(e) { L_.injectVertexShaderChunks(e), L_.injectFragmentShaderChunks(e) } static injectVertexShaderChunks(e) {
    e.vertexShader = e.vertexShader.replace("#include <uv_pars_vertex>", `#include <uv_pars_vertex>
`+ lE), e.vertexShader = e.vertexShader.replace("#include <uv_vertex>", `#include <uv_vertex>
`+ cE)
  } static injectFragmentShaderChunks(e) {
    e.fragmentShader = e.fragmentShader.replace("#include <map_pars_fragment>", `#include <map_pars_fragment>
`+ pE), e.fragmentShader = e.fragmentShader.replace("#include <map_pars_fragment>", `#include <map_pars_fragment>
`+ hE), e.fragmentShader = e.fragmentShader.replace("#include <map_pars_fragment>", `#include <map_pars_fragment>
`+ dE), e.fragmentShader = e.fragmentShader.replace("#include <map_fragment>", fE), e.fragmentShader = e.fragmentShader.replace("#include <alphamap_fragment>", uE + `
#include <alphamap_fragment>`)
  }
} const pZ = function (i, e, t) { t = ["stretch", "contain", "cover"].indexOf(t), l3(i, "BACKGROUND_MAPPING", t) }, fZ = { clippingPlanes: { m: "clippingPlanes" }, backgroundAlphaTest: { m: "alphaTest", t: Jy }, backgroundSide: { m: "side" }, backgroundImage: { m: "map" }, backgroundColor: { m: "color" }, backgroundOpacity: { m: "opacity" }, backgroundSize: { m: "computedBackgroundSize", t: pZ }, borderWidth: { m: "borderWidth", t: Ln }, borderColor: { m: "borderColor", t: Ln }, cornerTL: { m: "cornerTL", t: Ln }, cornerTR: { m: "cornerTR", t: Ln }, cornerBR: { m: "cornerBR", t: Ln }, cornerBL: { m: "cornerBL", t: Ln }, borderOpacity: { m: "borderOpacity", t: Ln }, size: { m: "frameSize", t: Ln }, tSize: { m: "textureSize", t: Ln } }; class eF extends Ze.ShaderMaterial { static get mediation() { return L_.mediation } constructor() { super({ uniforms: { alphaTest: { value: .02 }, map: { value: null }, diffuse: { value: new Ze.Color(16777215) }, opacity: { value: 1 }, borderColor: { value: new Ze.Color(0) }, borderOpacity: { value: 0 }, borderRadius: { value: new Ze.Vector4(0, 0, 0, 0) }, cornerTL: { value: new Ze.Vector2(0, 1) }, cornerTR: { value: new Ze.Vector2(1, 1) }, cornerBR: { value: new Ze.Vector2(1, 0) }, cornerBL: { value: new Ze.Vector2(0, 0) }, borderWidth: { value: new Ze.Vector4(0, 0, 0, 0) }, frameSize: { value: new Ze.Vector3(1, 1, 1) }, textureSize: { value: new Ze.Vector2(1, 1) } }, side: Ze.FrontSide, transparent: !0, clipping: !0, vertexShader: uZ, fragmentShader: dZ, extensions: { derivatives: !0 } }), this.defines.USE_ALPHATEST = "", this.needsUpdate = !0 } set map(e) { this.uniforms.map.value = e, e ? this.defines.USE_UV === void 0 && (this.defines.USE_UV = "", this.needsUpdate = !0) : this.defines.USE_UV !== void 0 && (delete this.defines.USE_UV, this.needsUpdate = !0), this.needsUpdate = !0 } get map() { return this.uniforms.map.value } get alphaTest() { return this.uniforms.alphaTest.value } set alphaTest(e) { this.uniforms.alphaTest.value = e } set opacity(e) { this.uniforms && (this.uniforms.opacity.value = e) } get opacity() { return this.uniforms.opacity.value } get color() { return this.uniforms.diffuse.value } set color(e) { this.uniforms.diffuse.value = e } } class gZ extends ci { constructor() { super("children", null, !1), u(this, "_sortOrder", (e, t) => e._order._value < t._order._value ? -1 : e._order._value > t._order._value ? 1 : this._uis.indexOf(e) < this._uis.indexOf(t) ? -1 : 1), this._uis = [], this._boxes = [] } update(e, t) { this._compute(e), e._layouter._needsUpdate = !0, e._renderOrder._needsUpdate = !0 } process(e) { this._compute(e), e._flexDirection._needsProcess = !0, e._layouter._needsProcess = !0, e._overflow._needsRender = !0 } _compute(e) { this._uis = e.children.filter(t => t.visible && t.isUI), this._boxes = this._uis.filter(t => t.isBox).sort(this._sortOrder) } dispose() { this._uis = null, this._boxes = null } } class tF extends ci { constructor() { super("bounds", null, !1), this._size = new Ze.Vector3(1, 1, 1), this._offsetWidth = 0, this._offsetHeight = 0, this._innerWidth = 0, this._innerHeight = 0, this._centerX = .5, this._centerY = .5, this._needsProcess = !0 } setReferenceWidth(e, t) { const s = e._width, r = e._padding._value, n = e._borderWidth._value, o = e._margin._value, a = s._auto ? 1 : s._value, l = t * a - (o.y + o.w); LS(l, this._offsetWidth) || (this._offsetWidth = l, this._innerWidth = this._offsetWidth - (r.y + r.w + n.y + n.w), this._centerX = gE(e), this._propagateWidth(e), this._triggerCascadingDependencies(e)) } setReferenceHeight(e, t) { const s = e._height, r = e._padding._value, n = e._borderWidth._value, o = e._margin._value, a = s._auto ? 1 : s._value, l = t * a - (o.x + o.z); LS(l, this._offsetHeight) || (this._offsetHeight = l, this._innerHeight = this._offsetHeight - (r.x + r.z + n.x + n.z), this._centerY = mE(e), this._propagateHeight(e), this._triggerCascadingDependencies(e)) } setChildrenWidth(e, t) { const s = e._padding._value, r = e._borderWidth._value; this._innerWidth = t, this._offsetWidth = this._innerWidth + (s.y + s.w + r.y + r.w), this._centerX = gE(e), this._propagateWidth(e), this._triggerCascadingDependencies(e) } setChildrenHeight(e, t) { const s = e._padding._value, r = e._borderWidth._value; this._innerHeight = t, this._offsetHeight = this._innerHeight + (s.x + s.z + r.x + r.z), this._centerY = mE(e), this._propagateHeight(e), this._triggerCascadingDependencies(e) } update(e, t) { const s = e._padding._value, r = e._borderWidth._value, n = e._width; !n._auto && !n._relative && (e._boxSizing._value === "content-box" ? (this._innerWidth = n._value, this._offsetWidth = this._innerWidth + s.y + s.w + r.y + r.w) : (this._offsetWidth = n._value, this._innerWidth = this._offsetWidth - (s.y + s.w + r.y + r.w)), this._centerX = gE(e), this._needsProcess = !0, this._propagateWidth(e), this._triggerCascadingDependencies(e)); const o = e._height; !o._auto && !o._relative && (e._boxSizing._value === "content-box" ? (this._innerHeight = o._value, this._offsetHeight = this._innerHeight + s.x + s.z + r.x + r.z) : (this._offsetHeight = o._value, this._innerHeight = this._offsetHeight - (s.x + s.z + r.x + r.z)), this._centerY = mE(e), this._needsProcess = !0, this._propagateHeight(e), this._triggerCascadingDependencies(e)) } render(e) { this._size.x = this._offsetWidth, this._size.y = this._offsetHeight, e._renderer._needsRender = !0 } output(e) { e.size = this._size } process(e) { e._overflow._needsRender = !0 } _computeChildrenSideWidth(e) { return mZ(e) } _computeChildrenSideHeight(e) { return vZ(e) } _propagateWidth(e) { for (let t = 0; t < e._children._boxes.length; t++) { const s = e._children._boxes[t]; s._width._relative && s._bounds.setReferenceWidth(s, this._innerWidth) } } _propagateHeight(e) { for (let t = 0; t < e._children._boxes.length; t++) { const s = e._children._boxes[t]; s._height._relative && s._bounds.setReferenceHeight(s, this._innerHeight) } } _triggerCascadingDependencies(e) { e._parent._value && (e._parent._value._autoSize._needsProcess = !0), e._flexDirection._needsProcess = !0, e._fontSize._needsProcess = !0, e._layouter._needsProcess = !0, this._needsRender = !0, e._borderWidth._needsRender = !0, e._borderRadius._needsRender = !0, e._overflow._needsRender = !0 } } function gE(i) { const e = i._padding._value, t = i._borderWidth._value, s = e.w + t.w, r = e.y + t.y; return (s - r) / 2 } function mE(i) { const e = i._padding._value, t = i._borderWidth._value, s = e.x + t.x; return (e.z + t.z - s) / 2 } function mZ(i) { return i._children._boxes.reduce((e, t) => { const s = t._margin._value, r = t._bounds._offsetWidth + s.y + s.w; return e + r }, 0) } function vZ(i) { return i._children._boxes.reduce((e, t) => { const s = t._margin._value, r = t._bounds._offsetHeight + s.x + s.z; return e + r }, 0) } class AZ extends US { constructor() { super(), this._allowsInherit = !1, this._needsUpdate = !0, this._process = this.emptyStrategyLogic, this._childAlign = this.emptyStrategyLogic } computeOutputValue(e) { switch (this._value = this._inheritedInput, e._flexDirection._value) { case "row": case "row-reverse": switch (this._process = CZ, this._value) { case "start": this._childAlign = bZ; break; case "end": this._childAlign = yZ; break; default: this._childAlign = iF }break; case "column": case "column-reverse": switch (this._process = wZ, this._value) { case "start": this._childAlign = xZ; break; case "end": this._childAlign = _Z; break; default: this._childAlign = iF }break }this._needsProcess = !0, e._autoSize._needsProcess = !0, e._flexDirection._needsProcess = !0, e._justifyContent._needsProcess = !0, this._needsProcess = !0, e._fontSize._needsProcess = !0, e._layouter._needsProcess = !0 } process(e) { this._process(e, this._childAlign); let t = "center", s = "center", r = "center"; const n = e._padding._value, o = e._borderWidth._value; e._flexDirection._value.indexOf("column") !== -1 ? this._value === "start" ? t = s = "left" : this._value === "end" ? t = s = "right" : t = "centerX" : this._value === "start" ? t = r = "top" : this._value === "end" ? t = r = "bottom" : t = "centerY"; let a = -(n.x - n.z) / 2 - (o.x - o.z) / 2, l = -(n.y - n.w) / 2 - (o.y - o.w) / 2; s === "left" ? l = (n.w - n.y) / 2 + (o.w - o.y) / 2 : s === "right" && (l = -(n.y - n.w) / 2 - (o.y - o.w) / 2), r === "top" ? a = -(n.x - n.z) / 2 - (o.x - o.z) / 2 : r === "bottom" && (a = (n.z - n.x) / 2 + (o.z - o.x) / 2), e._children._boxes.forEach(c => { let h = 0, d = 0; t === "top" ? d = -c._margin._value.x : t === "bottom" ? d = c._margin._value.z : t === "left" ? h = c._margin._value.w : t === "right" ? h = -c._margin._value.y : t === "centerX" ? h = (c._margin._value.w - c._margin._value.y) / 2 : t === "centerY" && (d = (-c._margin._value.x + c._margin._value.z) / 2), e._layouter._childrenPos[c.id].x += l + h, e._layouter._childrenPos[c.id].y += a + d }) } } function iF() { return 0 } function yZ(i, e) { return -e + i._bounds._offsetHeight / 2 } function bZ(i, e) { return e - i._bounds._offsetHeight / 2 } function _Z(i, e) { return e - i._bounds._offsetWidth / 2 } function xZ(i, e) { return -e + i._bounds._offsetWidth / 2 } function wZ(i, e) { const t = i._bounds._innerWidth / 2; i._children._boxes.forEach(s => { i._layouter._childrenPos[s.id].x = e(s, t) }) } function CZ(i, e) { const t = i._bounds._innerHeight / 2; i._children._boxes.forEach(s => { i._layouter._childrenPos[s.id].y = e(s, t) }) } class SZ extends zS { constructor() { super(), this._allowsInherit = !1, this._needsUpdate = !0, this._offset = 0, this._reverse = 1, this._process = this.emptyStrategyLogic } computeOutputValue(e) { switch (this._value = this._inheritedInput, this._value) { case "row": this._process = EZ; break; case "row-reverse": this._process = MZ; break; case "column": this._process = IZ; break; case "column-reverse": this._process = TZ; break }e._justifyContent._needsUpdate || e._justifyContent.computeOutputValue(e), e._alignItems._needsUpdate || e._alignItems.computeOutputValue(e), this._needsProcess = !0 } process(e) { switch (this._value) { case "row": this._offset = -e._bounds._innerWidth / 2; break; case "row-reverse": this._offset = e._bounds._innerWidth / 2; break; case "column": this._offset = e._bounds._innerHeight / 2; break; case "column-reverse": this._offset = -e._bounds._innerHeight / 2; break }this._reverse = -Math.sign(this._offset), this._reverse === 0 && (this._reverse = 1), this._process(e), e._justifyContent._needsProcess = !0, e._layouter._needsProcess = !0 } } function EZ(i) { let e = i._flexDirection._offset; const t = i._flexDirection._reverse, s = i._children._boxes; for (let r = 0; r < s.length; r++) { const n = s[r], o = n.id, a = n._bounds._offsetWidth; e += n._margin._value.w * t; const l = i._layouter._childrenPos[o]; l.x = e + a / 2 * t, l.y = 0, e += t * (a + n._margin._value.y) } } function MZ(i) { let e = i._flexDirection._offset; const t = i._flexDirection._reverse, s = i._children._boxes; for (let r = 0; r < s.length; r++) { const n = s[r], o = n.id, a = n._bounds._offsetWidth; e += n._margin._value.y * t; const l = i._layouter._childrenPos[o]; l.x = e + a / 2 * t, l.y = 0, e += (a + n._margin._value.w) * t } } function IZ(i) { let e = i._flexDirection._offset; const t = i._flexDirection._reverse, s = i._children._boxes; for (let r = 0; r < s.length; r++) { const n = s[r], o = n.id, a = n._bounds._offsetHeight; e += n._margin._value.x * t; const l = i._layouter._childrenPos[o]; l.x = 0, l.y = e + a / 2 * t, e += (a + n._margin._value.z) * t } } function TZ(i) { let e = i._flexDirection._offset; const t = i._flexDirection._reverse, s = i._children._boxes; for (let r = 0; r < s.length; r++) { const n = s[r], o = n.id, a = n._bounds._offsetHeight; e += n._margin._value.z * t; const l = i._layouter._childrenPos[o]; l.x = 0, l.y = e + a / 2 * t, e += (a + n._margin._value.x) * t } } class RZ extends jS { constructor(e) { super("justifyContent", e, !0), this._allowsInherit = !1, this._needsUpdate = !0, this._computeOffset = this.emptyStrategyLogic, this._computeMargin = this.emptyStrategyLogic, this._process = this.emptyStrategyLogic } computeOutputValue(e) { switch (this._value = this._inheritedInput, e._flexDirection._value) { case "column-reverse": case "column": this._process = BZ.bind(this); break; case "row-reverse": case "row": this._process = PZ.bind(this); break }switch (this._value) { case "end": this._computeOffset = OZ, this._computeMargin = vE; break; case "center": this._computeOffset = LZ, this._computeMargin = vE; break; case "start": this._computeOffset = cb, this._computeMargin = vE; break; case "space-between": this._computeOffset = cb, this._computeMargin = FZ; break; case "space-around": this._computeOffset = cb, this._computeMargin = NZ; break; case "space-evenly": this._computeOffset = cb, this._computeMargin = UZ; break }e._flexDirection._needsProcess = !0 } process(e) { this._process(e), e._alignItems._needsProcess = !0 } } function PZ(i) { const e = i._flexDirection._offset, { usedDirectionSpace: t, remainingSpace: s } = kZ(i), r = e * 2 - t * Math.sign(e), n = this._computeOffset(r), o = this._computeMargin(i, s, i._flexDirection._reverse); i._children._boxes.forEach((a, l) => { i._layouter._childrenPos[a.id].x -= n - o[l] }) } function BZ(i) { const e = i._flexDirection._offset, { usedDirectionSpace: t, remainingSpace: s } = DZ(i), r = e * 2 - t * Math.sign(e), n = this._computeOffset(r), o = this._computeMargin(i, s, i._flexDirection._reverse); i._children._boxes.forEach((a, l) => { i._layouter._childrenPos[a.id].y -= n - o[l] }) } function kZ(i) { const e = i._bounds._computeChildrenSideWidth(i); return { usedDirectionSpace: e, remainingSpace: i._bounds._innerWidth - e } } function DZ(i) { const e = i._bounds._computeChildrenSideHeight(i); return { usedDirectionSpace: e, remainingSpace: i._bounds._innerHeight - e } } function cb(i) { return 0 } function OZ(i) { return i } function LZ(i) { return i / 2 } function vE(i, e = 0, t = 1) { return Array(i._children._boxes.length).fill(0) } function FZ(i, e = 0, t = 1) { const s = i._children._boxes.length, r = Array(s).fill(0); if (e > 0 && s > 1) { const n = e / (s - 1) * t; r[0] = 0; for (let o = 1; o < s; o++)r[o] = n * o } return r } function UZ(i, e = 0, t = 1) { const s = i._children._boxes.length, r = Array(s).fill(0); if (e > 0) { const n = e / (s + 1) * t; for (let o = 0; o < s; o++)r[o] = n * (o + 1) } return r } function NZ(i, e = 0, t = 1) { const s = i._children._boxes.length, r = Array(s).fill(0); if (e > 0) { const n = e / s * t, o = n / 2; r[0] = o; for (let a = 1; a < s; a++)r[a] = o + n * a } return r } class sF extends Ze.Mesh { constructor(e) { const t = new Ze.PlaneGeometry(1, 1, e._segments.value, e._segments.value), s = new Ze.BufferAttribute(new Float32Array(t.getAttribute("uv").array), 2); t.setAttribute("uvB", s).name = "uvB", super(t, e.backgroundMaterial), this.name = "UIBackgroundBox" } } class rF extends ci { constructor() { super("renderer") } render(e) { e._backgroundMesh || e.setBackgroundMesh(new sF(e)), e.performAfterUpdate() } } class zZ extends $L { constructor() { super("position") } update(e, t) { super.update(e, t), this._needsProcess = !0 } } class jZ extends ci { constructor() { super("autosize"), this._needsProcess = !0 } process(e) { e._width._auto && QZ(e), e._height._auto && GZ(e); const t = e._alignItems._value === "stretch", s = t && e._flexDirection._value.indexOf("column") !== -1, r = t && !s; for (const n of e._children._boxes) (n._width._auto && s || n._width._relative) && n._bounds.setReferenceWidth(n, e._bounds._innerWidth), (n._height._auto && r || n._height._relative) && n._bounds.setReferenceHeight(n, e._bounds._innerHeight) } } function QZ(i) { i._bounds.setChildrenWidth(i, VZ(i)) } function GZ(i) { i._bounds.setChildrenHeight(i, HZ(i)) } function HZ(i) { switch (i._flexDirection._value) { case "row": case "row-reverse": return YZ(i); case "column": case "column-reverse": return qZ(i) } } function VZ(i) { switch (i._flexDirection._value) { case "row": case "row-reverse": return WZ(i); case "column": case "column-reverse": return XZ(i) } } function WZ(i) { let e = 0; for (const t of i._children._boxes) { if (t._position._value !== "static") continue; const s = t._margin._value, r = t._bounds._offsetWidth + s.y + s.w; e += r } return e } function qZ(i) { let e = 0; for (const t of i._children._boxes) { if (t._position._value !== "static") continue; const s = t._margin._value, r = t._bounds._offsetHeight + s.x + s.z; e += r } return e } function XZ(i) { let e = 0; for (const t of i._children._boxes) { if (t._position._value !== "static") continue; const s = t._margin._value, r = t._bounds._offsetWidth + s.y + s.w; r > e && (e = r) } return e } function YZ(i) { let e = 0; for (const t of i._children._boxes) { if (t._position._value !== "static") continue; const s = t._margin._value, r = t._bounds._offsetHeight + s.x + s.z; r > e && (e = r) } return e } class Rv extends $g { constructor(e, t) { Rv.definePropertiesValues(e, t), super(e, t), Rv.init(this) } bindBackgroundMeshProperties() { this._bounds._size = this._backgroundMesh.scale, this._bounds._needsProcess = !0 } unbindBackgroundMeshProperties() { this._bounds._size = new Ze.Vector3(1, 1, 1), this._bounds._needsProcess = !0 } static definePropertiesValues(e, t) { e.children || (e.children = gZ), e.bounds || (e.bounds = tF), e.flexDirection || (e.flexDirection = SZ), e.justifyContent || (e.justifyContent = RZ), e.alignItems || (e.alignItems = AZ), e.position || (e.position = zZ), e.autoSize || (e.autoSize = jZ), e.renderer || (e.renderer = rF), t.fontSide || (t.fontSide = 0), t.invertAlpha || (t.invertAlpha = !1), t.fontCastShadow || (t.fontCastShadow = !1), t.fontReceiveShadow || (t.fontReceiveShadow = !1), t.backgroundCastShadow || (t.backgroundCastShadow = !1), t.backgroundReceiveShadow || (t.backgroundReceiveShadow = !1) } static init(e) { Object.defineProperties(e, { isBox: { configurable: !1, enumerable: !0, value: !0 } }), e.backgroundMaterial = new eF, e._renderer.render(e), e._backgroundMesh.visible = !1 } } class nF extends Array { constructor(...e) { super(...e), this.width = 0, this.lineBase = 0, this.lineHeight = 0, this.y = 0 } } class JZ extends ci { constructor() { super("layouter", null, !1), this._needsUpdate = !0, this._childrenPos = {} } update(e, t) { this._childrenPos = {}; for (const s of e._children._boxes) s._position._value === "static" && (this._childrenPos[s.id] = s.position) } process(e) { } } class Pv extends Rv { constructor(e = {}) { const t = {}; Pv.definePropertiesValues(t, e), super(t, e), Pv.init(this) } add(e) { const t = []; for (let s = 0; s < arguments.length; s++) { const r = arguments[s]; !r.isUI || r.isBox ? t.push(r) : console.warn("Block element can only contain Box elements.", r) } return super.add(...t) } static definePropertiesValues(e, t) { e.layouter = JZ } static init(e) { Object.defineProperties(e, { isBlock: { configurable: !1, enumerable: !0, value: !0 } }) } } class KZ extends ci { constructor() { super("textContent", null, !1) } update(e, t) { e._glyphs._needsUpdate = !0, e._whiteSpace._needsProcess = !0 } } class ZZ extends ci { constructor() { super("inlines", null, !1), this._value = null } process(e) { if (this._value = e._glyphs._value.map(t => t.asInlineGlyph()), this._value.length) { this._value[0].paddingLeft = e._padding._value.w, this._value[0].marginLeft = e._margin._value.w; const t = this._value.length - 1; this._value[t].paddingRight = e._padding._value.y, this._value[t].marginRight = e._margin._value.y } e._fontSize._needsProcess = !0, e._lineBreak._needsProcess = !0, e._fontKerning._needsProcess = !0, e._layouter._needsProcess = !0 } get value() { return this._value } } class $Z extends ci { constructor() { super("glyphs", null, !1), this._needsUpdate = !1, this._value = null } process(e) { e._font._fontVariant && e._font._fontVariant.isReady && (this._value = e._whiteSpace._whiteSpacedContent.split("").map(t => e._font._fontVariant.getTypographicGlyph(t)), this._value && (e._inlines._needsProcess = !0)) } get value() { return this._value } } class e$ extends Wg { constructor() { super("color", "inherit", !1), this.output = this._outputValue } computeOutputValue(e) { this._input === "inherit" ? this._value.set(this.getInheritedInput(e)) : this._value.set(this._input) } } class oF extends ci {
  constructor(e = `- ,.:?!
`) { super("lineBreak", e, !0), this._newLineBreakability = null } update(e, t) { this._needsProcess = !0 } process(e) { const t = e._whiteSpace._newLineBreakability; if (e._inlines._value) for (let s = 0; s < e._inlines._value.length; s++) { const r = e._inlines._value[s], n = r.char; let o = null; n !== void 0 && (t !== "nowrap" && (this._value.includes(n) || n.match(/\s/g)) && (o = "possible"), n.match(/\n/g) && (o = t)), r.lineBreak = o } } get value() { return this._value }
} class aF extends ci { constructor() { super("layouter", null, !1), this._value = null } update(e, t) { this._value = e._parent.find(s => s.isUI && s.isText), this._needsProcess = !0 } process(e) { this._value && (this._value._layouter._needsProcess = !0) } } class t$ extends Wg { constructor(e) { super("backgroundColor", e, !1), this._allowsInherit = !1, this._input = 0 } computeOutputValue(e) { this._input === "inherit" ? this._value.set(this.getInheritedInput(e)) : this._value.set(this._input) } } class lF extends i3 { constructor() { super(), this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited } } class cF extends s3 { constructor() { super() } computeOutputValue(e) { const t = this.getInheritedInput(e), s = i$[t]; s ? this._value = s : this._value = t } } const i$ = { light: "100", normal: "400", bold: "700", bolder: "900" }; class hF extends h3 { constructor() { super("fontFamily", "inherit", !0), this._input = "inherit", this._needsUpdate = !0, this._allowsInherit = !1 } computeOutputValue(e) { let t = this._inheritedInput; if (t === "inherit" && (t = this.getInheritedInput(e)), t instanceof Ky) this._value = t, e._font._needsUpdate = !0; else if (typeof t == "string") { const s = Vh.getFontFamily(t); s ? (this._value = s, e._font._needsUpdate = !0) : console.warn(`(.style) fontFamily, the font '${t}' is not registered. Aborted.`) } else console.warn("(.style) fontFamily requires a registered fontFamily instance, or the id of a registered fontFamily."), console.warn("If you want to set a specific font, please use .font property instead.") } get value() { return this._value } } class AE extends d3 { constructor() { super(), this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited, this._whiteSpacedContent = "", this._stringCollapser = this.emptyStrategyLogic, this._inlineCollapser = this.emptyStrategyLogic, this._inlineWrapper = this.emptyStrategyLogic } _computeFromInherited(e) { switch (super._computeFromInherited(e), this._newLineBreakability = s$(this._value), this._value) { case "nowrap": case "normal": this._stringCollapser = r$; break; case "pre-line": this._stringCollapser = dF; break; default: this._stringCollapser = n$ }switch (this._value) { case "pre-line": case "nowrap": case "normal": this._inlineCollapser = h$; break; case "pre-wrap": this._inlineCollapser = c$; break; default: this._inlineCollapser = u$ }switch (this._value) { case "pre-line": case "pre-wrap": case "normal": this._inlineWrapper = o$; break; case "pre": this._inlineWrapper = a$; break; default: this._inlineWrapper = l$ }this._needsProcess = !0 } process(e) { e.isInline && !e.isInlineBlock && (this._whiteSpacedContent = this._stringCollapser(e._textContent._value), e._glyphs._needsProcess = !0) } } const uF = {
  "	": "	", "\n": `
`, "\r": "\r", " ": " "
}, s$ = function (i) { switch (i) { case "pre": case "pre-wrap": case "pre-line": return "mandatory" }return null }; function r$(i) { return dF(i.replace(/\n/g, " ")) } function dF(i) { return i.replace(/[ ]{2,}/g, " ") } function n$(i) { return i } function o$(i, e, t, s) { const r = i[e]; if (r.lineBreak === "mandatory" || t + r.xadvance + r.xoffset + r.kerning > s.INNER_WIDTH) return !0; const n = gF(i, e, s); return d$(i[e - 1], t, n, s) } function a$(i, e, t, s) { return i[e].lineBreak === "mandatory" } function l$() { return !1 } function c$(i) {
  if (!i[0]) return 0; const e = i[0], t = i[i.length - 1]; return e.char && e.char === `
`&& i.length > 1 && fF([e], i[1]), t.char && t.char === `
`&& i.length > 1 && pF([t], i[i.length - 2]), e.offsetX
} function h$(i) { if (!i[0]) return 0; let e = [], t; for (let s = 0; s < i.length; s++) { const r = i[s]; if (r.char && uF[r.char] && i.length > s) { e.push(r), t = i[s + 1]; continue } break } fF(e, t), e = [], t = null; for (let s = i.length - 1; s > 0; s--) { const r = i[s]; if (r.char && uF[r.char] && s > 0) { e.push(r), t = i[s - 1]; continue } break } return pF(e, t), i[0].offsetX } function u$(i) { return i[0] ? i[0].offsetX : 0 } function pF(i, e) { if (e) for (let t = 0; t < i.length; t++) { const s = i[t]; s.fontFactor = 0, s.offsetX = e.offsetX + e.cumulativeWidth, s.cumulativeWidth = 0 } } function fF(i, e) { if (e) for (let t = 0; t < i.length; t++) { const s = i[t]; s.fontFactor = 0, s.offsetX = e.offsetX, s.cumulativeWidth = 0 } } function gF(i, e, t, s) { if (s = s || 0, !i[e]) return s; const r = i[e]; return r.lineBreak ? s + r.xadvance : gF(i, e + 1, t, s + r.xadvance + r.xoffset + r.kerning + t.LETTERSPACING) } function d$(i, e, t, s) { return !i || !i.char || e + t < s.INNER_WIDTH ? !1 : s.BREAKON.indexOf(i.char) > -1 } class mF extends p3 { constructor() { super(), this._input = "inherit", this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited } _computeFromInherited(e) { super._computeFromInherited(e), e._fontSize._needsProcess = !0, e._layouter._needsProcess = !0 } } class vF extends wi { constructor() { super("fontSize", "inherit", !0), this._allowsInherit = !1 } computeOutputValue(e) { this._value = this._inheritedInput, e._font._fontVariant && (e._bounds._needsProcess = !0, e._layouter._needsProcess = !0) } process(e) { if (!e._font._fontVariant || !e._font._fontVariant.isReady) return; const t = this._value / e._font._fontVariant.typographic.size, s = e._inlines._value; for (let r = 0; r < s.length; r++) { const n = s[r]; n.resetOffsets(), n.fontSize = this._value, n.fontFactor = t } } get value() { return this._value } } class AF extends f3 { constructor() { super("segments", 1, !1), this._notInheritedValue = void 0 } update(e, t) { this._notInheritedValue = this._value, this._notInheritedValue === "inherit" && (this._notInheritedValue = this.getInheritedInput(e)), e._layouter._needsUpdate = !0 } set value(e) { this._value !== e && (this._value = e, this._needsUpdate = !0) } get value() { return this._value === "inherit" ? this._notInheritedValue : this._value } } class p$ extends AF { constructor() { super(), this._value = "inherit" } } class f$ extends $y { constructor() { super(), this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited } _computeFromInherited(e) { super._computeFromInherited(e), e._parent._value._layouter._needsProcess = !1 } process(e) { if (this._value !== "none") { const t = e._whiteSpace._whiteSpacedContent, s = e._inlines._value; for (let r = 1; r < s.length; r++) { const n = t[r - 1] + t[r]; s[r].kerning = e._font._fontVariant.getKerningAmount(n) } } } } class yF extends ci { constructor() { super("children", null, !1), this._uis = [] } update(e, t) { } process(e) { } _compute(e) { } dispose() { } } function g$(i, e = !1) { const t = i[0].index !== null, s = new Set(Object.keys(i[0].attributes)), r = new Set(Object.keys(i[0].morphAttributes)), n = {}, o = {}, a = i[0].morphTargetsRelative, l = new Ze.BufferGeometry; let c = 0; for (let h = 0; h < i.length; ++h) { const d = i[h]; let p = 0; if (t !== (d.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null; for (const f in d.attributes) { if (!s.has(f)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'), null; n[f] === void 0 && (n[f] = []), n[f].push(d.attributes[f]), p++ } if (p !== s.size) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."), null; if (a !== d.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."), null; for (const f in d.morphAttributes) { if (!r.has(f)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."), null; o[f] === void 0 && (o[f] = []), o[f].push(d.morphAttributes[f]) } if (l.userData.mergedUserData = l.userData.mergedUserData || [], l.userData.mergedUserData.push(d.userData), e) { let f; if (t) f = d.index.count; else if (d.attributes.position !== void 0) f = d.attributes.position.count; else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"), null; l.addGroup(c, f, h), c += f } } if (t) { let h = 0; const d = []; for (let p = 0; p < i.length; ++p) { const f = i[p].index; for (let g = 0; g < f.count; ++g)d.push(f.getX(g) + h); h += i[p].attributes.position.count } l.setIndex(d) } for (const h in n) { const d = bF(n[h]); if (!d) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + h + " attribute."), null; l.setAttribute(h, d) } for (const h in o) { const d = o[h][0].length; if (d === 0) break; l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[h] = []; for (let p = 0; p < d; ++p) { const f = []; for (let m = 0; m < o[h].length; ++m)f.push(o[h][m][p]); const g = bF(f); if (!g) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + h + " morphAttribute."), null; l.morphAttributes[h].push(g) } } return l } function bF(i) { let e, t, s, r = 0; for (let a = 0; a < i.length; ++a) { const l = i[a]; if (l.isInterleavedBufferAttribute) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."), null; if (e === void 0 && (e = l.array.constructor), e !== l.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null; if (t === void 0 && (t = l.itemSize), t !== l.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null; if (s === void 0 && (s = l.normalized), s !== l.normalized) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null; r += l.array.length } const n = new e(r); let o = 0; for (let a = 0; a < i.length; ++a)n.set(i[a].array, o), o += i[a].array.length; return new Ze.BufferAttribute(n, t, s) } class m$ extends ci { constructor() { super("renderer") } render(e) { if (!e._inlines._value || !e._inlines._value.length) return; const t = e._inlines._value.map(r => e._font._fontVariant.getGeometricGlyph(r, e).translate(r.offsetX, r.offsetY, 0)), s = g$(t); e.setFontMesh(new Ze.Mesh(s, e.fontMaterial)), e._fontMesh.renderOrder = 1 / 0 } } class v$ extends NS { constructor() { super(), this._allowsInherit = !1, this._needsUpdate = !1 } computeOutputValue(e) { this._value = this._inheritedInput, e._layouter._needsProcess = !0 } } class ef extends $g { constructor(e = {}) { const t = {}; ef.definePropertiesValues(t, e), super(t, e), u(this, "_rebuildParentUI", () => { super._rebuildParentUI(), this._layouter._needsUpdate = !0 }), ef.init(this) } add(e) { const t = []; for (let s = 0; s < arguments.length; s++) { const r = arguments[s]; !r.isUI || r.isInline ? (t.push(r), r.position.z = .005) : console.warn("Block element can only contain Box elements.", r) } return super.add(...t) } set textContent(e) { this._textContent.value = e } get textContent() { return this._textContent._value } set invertAlpha(e) { this._invertAlpha.value = e } get invertAlpha() { return this._invertAlpha._value } static definePropertiesValues(e, t) { e.children || (e.children = yF), e.textContent || (e.textContent = KZ), e.glyphs || (e.glyphs = $Z), e.inlines || (e.inlines = ZZ), e.layouter || (e.layouter = aF), e.renderer || (e.renderer = m$), e.fontFamily || (e.fontFamily = hF), e.fontWeight || (e.fontWeight = cF), e.fontStyle || (e.fontStyle = lF), e.fontSize || (e.fontSize = vF), e.color || (e.color = e$), e.backgroundColor || (e.backgroundColor = t$), e.lineBreak || (e.lineBreak = oF), e.letterSpacing || (e.letterSpacing = mF), e.whiteSpace || (e.whiteSpace = AE), e.segments || (e.segments = p$), e.textAlign || (e.textAlign = v$), e.fontKerning || (e.fontKerning = f$) } static init(e) { Object.defineProperties(e, { isInline: { configurable: !1, enumerable: !0, value: !0 } }) } } class A$ extends t3 { constructor() { super("textContent", null, !1), this._needsUpdate = !1 } set value(e) { this._value !== e && (this._value = e, this._needsUpdate = !0) } update(e, t) { this._needsUpdate = !1; for (let s = e.children.length - 1; s >= 0; s--) { const r = e.children[s]; r.isUI && (e.remove(r), r.clear()) } e._children._uis = [], this._value && e.add(new ef({ name: "anonymousInline", textContent: this._value })) } } class y$ extends Array { constructor(...e) { super(...e), this.width = 0, this.height = 0 } } class b$ extends ci { constructor() { super("layouter", null, !1), this._value = null } update(e, t) { } process(e) { let t = e._width._value; e._width._auto ? t = 1 / 0 : t = e._bounds._innerWidth; const s = e._lineHeight._value, r = new y$(new nF); let n = 0; e._children._inlines.forEach(d => { if (!d._inlines.value) return; this._resetInlines(d); const p = d._fontSize._value, f = d._letterSpacing._value * p, g = d._whiteSpace._value, m = d._lineBreak._value, v = { WHITESPACE: g, LETTERSPACING: f, BREAKON: m, INNER_WIDTH: t }, A = d._whiteSpace._inlineWrapper; n += d._margin._value.w + d._padding._value.w, d._inlines.value.forEach((b, y, _) => { const w = r[r.length - 1]; if (A(_, y, n, v)) { if (r.push(new nF(b)), b.offsetX = b.xoffset, b.width === 0) { n = 0; return } b.cumulativeWidth = b.xadvance + f, n = b.cumulativeWidth; return } r[r.length - 1].push(b), b.offsetX = n + b.xoffset + b.kerning, b.cumulativeWidth = b.xadvance + b.kerning + f, n += b.cumulativeWidth, w.length - 1 === 1 && w[w.length - 2].width === 0 && (b.offsetX -= b.xoffset, n -= b.xoffset) }), n += d._margin._value.y + d._padding._value.y }); const o = e._whiteSpace._inlineCollapser; let a = 0, l = 0, c = 0; r.forEach((d, p) => { const f = o(d); let g = 0, m = 0; if (d.forEach(v => { g = Math.max(g, v.lineHeight), m = Math.max(m, v.lineBase), v.offsetX -= f }), d.lineHeight = g, d.lineBase = m, p === 0 ? c = -(g * s - g) * .5 : c -= r[p - 1].lineHeight * s, d.y = c, d.x = 0, d.forEach(v => { v.offsetY = c - v.anchor, v.lineHeight < d.lineHeight && (v.offsetY -= d.lineBase - v.lineBase) }), l += d.lineHeight * s, d.width = 0, d[0]) { const v = d[d.length - 1]; d.width = v.offsetX + v.cumulativeWidth + v.paddingRight + v.marginRight + d[0].offsetX, a = Math.max(a, d.width) } }), r.height = l, r.width = a, this._value = r, t === 1 / 0 && e._bounds.setChildrenWidth(e, r.width), e._height._auto && e._bounds.setChildrenHeight(e, r.height); const h = e._parent._value; h && (h._autoSize._needsProcess = !0, h._flexDirection._needsProcess = !0), e._inlineJustificator._needsProcess = !0, e._textAlign._needsProcess = !0, e._overflow._needsUpdate = !0 } _resetInlines(e) { e._fontSize.process(e) } } class _$ extends NS { constructor() { super(), this._allowsInherit = !1, this._needsUpdate = !0 } computeOutputValue(e) { this._value = this._inheritedInput, this._needsProcess = !0 } process(e) { x$(e), e._renderer._needsRender = !0 } } function x$(i) { const e = i._layouter._value, t = i._textAlign._value, s = i._bounds._innerWidth; for (let r = 0; r < e.length; r++) { const n = e[r], o = w$(i, n, r === e.length - 1), a = i._padding._value, l = i._borderWidth._value, c = (-a.w + a.y) / 2 + (-l.w + l.y) / 2; n.x += o; for (let h = 0; h < n.length; h++)n[h].offsetX += o - c } if (t.indexOf("justify") === 0) for (let r = 0; r < e.length; r++) { const n = e[r]; if (t.indexOf("-") !== -1 && r === e.length - 1) return; const o = s - n.width; if (o <= 0) return; let a = 0; for (let d = 1; d < n.length - 1; d++)a += n[d].char === " " ? 1 : 0; const l = o / a; let c = 1; t === "justify-right" && (n.reverse(), c = -1); let h = 0; for (let d = 1; d <= n.length - 1; d++) { const p = n[d]; p.offsetX += h * c, h += p.char === " " ? l : 0 } t === "justify-right" && n.reverse() } } function w$(i, e, t) { switch (i._textAlign._value) { case "justify-left": case "justify": case "left": return -i._bounds._innerWidth / 2; case "justify-right": case "right": return -e.width + i._bounds._innerWidth / 2; case "center": return -e.width / 2; case "justify-center": return t ? -e.width / 2 : -i._bounds._innerWidth / 2; default: console.warn(`textAlign: '${i._textAlign._value}' is not valid`) } } class C$ extends zS { constructor() { super(), this._value = this._input = "column", this._allowsInherit = !1, this._needsUpdate = !0 } computeOutputValue(e) { this._value = this._inheritedInput } } class S$ extends u3 { constructor() { super(), this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited } } class E$ extends $y { constructor() { super(), this._value = this._input = this.getDefaultValue(), this._allowsInherit = !1, this.computeOutputValue = this._computeFromInherited } _computeFromInherited(e) { super._computeFromInherited(e) } } class M$ extends tF { constructor() { super(), this._innerWidth = 1 / 0, this._innerHeight = 0 } } class I$ extends ci { constructor() { super("children", null, !1), u(this, "_sortOrder", (e, t) => e._order._value < t._order._value ? -1 : e._order._value > t._order._value ? 1 : this._uis.indexOf(e) < this._uis.indexOf(t) ? -1 : 1), this._uis = [], this._inlines = [], this._boxes = [] } update(e, t) { this._compute(e), this._needsProcess = !0 } process(e) { this._compute(e), e._overflow._needsRender = !0 } _compute(e) { this._uis = e.children.filter(t => t.visible && t.isUI), this._inlines = this._uis.filter(t => t.isInline).sort(this._sortOrder) } dispose() { this._inlines = null } } class T$ extends ci { constructor() { super("autosize") } process(e) { if (e._layouter._value && e._layouter._value.length) { const t = e._layouter._value, s = e._padding._value, r = e._borderWidth._value; e._width._auto && e._bounds.setOffsetWidth(e, t.width + s.w + s.y + r.w + r.y), e._height._auto && e._bounds.setOffsetHeight(e, t.height + s.x + s.z + r.x + r.z) } } } class R$ extends rF { constructor() { super("renderer"), this._needsUpdate = !1 } render(e) { super.render(e); for (const t of e._children._inlines) t._renderer.render(t); e.performAfterUpdate() } } class Bv extends Rv { constructor(e = {}, t = {}) { Bv.definePropertiesValues(t, e), super(t, e), Bv.init(this) } add(e) { const t = []; let s = !1; for (let r = 0; r < arguments.length; r++) { const n = arguments[r]; !n.isUI || n.isInline ? (n.isInline && (s = !0), t.push(n)) : console.warn("Block element can only contain Box elements.", n) } return t.length > 0 && super.add(...t), s && (this._children._needsUpdate = !0, this._layouter._needsProcess = !0), this } set textContent(e) { this._textContent.value = e } get textContent() { return super.textContent } set invertAlpha(e) { this._invertAlpha.value = e } get invertAlpha() { return this._invertAlpha._value } get lines() { return this._layouter._value } static definePropertiesValues(e, t) { e.flexDirection = C$, e.justifyContent = jS, e.alignItems = US, e.bounds = M$, e.autoSize = T$, e.renderer = R$, e.children || (e.children = I$), e.textContent || (e.textContent = A$), e.layouter || (e.layouter = b$), e.lineHeight || (e.lineHeight = S$), e.textAlign || (e.textAlign = _$), e.whiteSpace || (e.whiteSpace = AE), e.fontKerning || (e.fontKerning = E$), e.segments || (e.segments = AF), t.width || (t.width = "100%"), t.fontSide || (t.fontSide = 0) } static init(e) { Object.defineProperties(e, { isText: { configurable: !1, enumerable: !0, value: !0 } }) } } class P$ extends ci { constructor() { super("inlines", null, !1), this._value = [] } process(e) { this._value[0].paddingLeft = e._padding._value.w, this._value[0].marginLeft = e._margin._value.w; const t = this._value.length - 1; this._value[t].paddingRight = e._padding._value.y, this._value[t].marginRight = e._margin._value.y } } class B$ extends ci { constructor() { super("renderer") } render(e) { e._backgroundMesh || e.setBackgroundMesh(new sF(e)), e._backgroundMesh.position.x = e._inlines._value[0].offsetX + e._inlines._value[0].width / 2, e._backgroundMesh.position.y = e._inlines._value[0].offsetY + e._inlines._value[0].lineBase / 2, e._bounds.render(e) } } class k$ extends ci { constructor() { super("bounds", null, !1), this._size = new Ze.Vector3(1, 1, 1), this._offsetWidth = 0, this._offsetHeight = 0, this._innerWidth = 0, this._innerHeight = 0 } update(e, t) { this.output(t), this._needsProcess = !0 } process(e) { this._offsetWidth = this._innerWidth = e._inlines._value[0].width, this._offsetHeight = this._innerHeight = e._inlines._value[0].height, this._needsRender = !0, e._borderWidth._needsRender = !0, e._borderRadius._needsRender = !0 } render(e) { this._size.x = this._offsetWidth, this._size.y = this._offsetHeight } output(e) { e.size = this._size } } class kv extends $g { constructor(e = {}) { const t = {}; kv.definePropertiesValues(t, e), super(t, e), kv.init(this) } clear() { for (const e of this._inlines._value) e.clear(); return super.clear() } bindBackgroundMeshProperties() { this._backgroundMesh.raycast = () => { }, this._bounds._size = this._backgroundMesh.scale, this._bounds._needsUpdate = !0 } unbindBackgroundMeshProperties() { this._bounds._size = new Ze.Vector3(1, 1, 1), this._bounds._needsUpdate = !0 } add(e) { const t = []; for (let s = 0; s < arguments.length; s++) { const r = arguments[s]; r.isUI ? console.warn("ThreeMeshUI::InlineBlockElement cannot contains UI Elements.", r) : (t.push(r), r.position.z = .005) } return super.add(...t) } static definePropertiesValues(e, t) { e.children || (e.children = yF), e.bounds || (e.bounds = k$), e.inlines || (e.inlines = P$), e.layouter || (e.layouter = aF), e.renderer || (e.renderer = B$), e.fontFamily || (e.fontFamily = hF), e.fontWeight || (e.fontWeight = cF), e.fontStyle || (e.fontStyle = lF), e.fontSize || (e.fontSize = vF), e.backgroundColor || (e.backgroundColor = ZL), e.lineBreak || (e.lineBreak = oF), e.letterSpacing || (e.letterSpacing = mF), e.whiteSpace || (e.whiteSpace = AE), e.fontKerning || (e.fontKerning = $y), t.backgroundSize || (t.backgroundSize = "cover"), t.width || (t.width = "100%"), t.height || (t.height = "100%"), t.boxSizing || (t.boxSizing = "border-box") } static init(e) { Object.defineProperties(e, { isInline: { configurable: !1, enumerable: !0, value: !0 }, isInlineBlock: { configurable: !1, enumerable: !0, value: !0 } }), e._inlines._value = [new D$(e)], e.backgroundMaterial = new eF, e._renderer.render(e) } } class D$ extends o3 { constructor(e) { super(), this._uiElement = e } get xadvance() { const e = this._uiElement._padding._value, t = this._uiElement._width; return t._relative ? t._value * this._uiElement._fontSize.getInheritedInput(this._uiElement) : e.w + e.y + t.value } get width() { const e = this._uiElement._width; return e._relative ? e._value * this._uiElement._fontSize.getInheritedInput(this._uiElement) : e.value } get height() { const e = this._uiElement._height; return e._relative ? e._value * this._uiElement._fontSize.getInheritedInput(this._uiElement) : e.value } get anchor() { return this.height } get lineHeight() { const e = this._uiElement._height; return e._relative ? e._value * this._uiElement._fontSize.getInheritedInput(this._uiElement) : e.value } get lineBase() { const e = this._uiElement._height; return e._relative ? e._value * this._uiElement._fontSize.getInheritedInput(this._uiElement) : e.value } clear() { this._uiElement = null } } class _F { constructor(e) { this._subject = e } attach() { console.error(`Behavior::attach() - Is abstract and therefore should be overridden in ${this.constructor.name}`) } act() { throw new Error(`Behavior::act() - Is abstract and therefore should be overridden in ${this.constructor.name}`) } detach() { console.error(`Behavior::detach() - Is abstract and therefore should be overridden in ${this.constructor.name}`) } clear() { } } const xF = () => lb.update(), wF = { BaseProperty: ci, Block: Pv, Text: Bv, Inline: ef, InlineBlock: kv, MeshUIBaseElement: $g, FontLibrary: Vh, update: xF, MSDFFontMaterialUtils: $n, ShaderChunkUI: $3, Behavior: _F, FontVariant: Vg }; typeof global < "u" && (global.ThreeMeshUI = wF); const O$ = wF; var L$ = ns.w8, CF = ns.cg, yE = ns.gO, F$ = ns.wb, bE = ns.zV, U$ = ns.HS, N$ = ns.Ec, hb = ns.gF, z$ = ns.ol, j$ = ns.pz, Q$ = ns.tx, G$ = ns.hj, H$ = ns.FV, V$ = ns.sV, SF = ns.xv, W$ = ns.mx, q$ = ns.gE, X$ = ns.ZP, EF = ns.Vx; const MF = Object.freeze(Object.defineProperty({ __proto__: null, BaseProperty: L$, Behavior: CF, Block: yE, DefaultValues: F$, FontLibrary: bE, FontVariant: U$, InheritableProperty: N$, Inline: hb, InlineBlock: z$, InlineGlyph: j$, MSDFFontMaterialUtils: Q$, MaterialTransformers: G$, MeshUIBaseElement: H$, ShaderChunkUI: V$, Text: SF, TypographicFont: W$, TypographicGlyph: q$, default: X$, update: EF }, Symbol.toStringTag, { value: "Module" })); yE.prototype.interactable = { get() { return this.interactive }, set(i) { this.interactable = i } }; const dl = Symbol("shadowDomOwner"); class ba extends Ee { constructor() { super(...arguments), u(this, "shadowComponent", null), u(this, "_controlsChildLayout", !0), u(this, "_root"), u(this, "_parentComponent") } isRoot() { var e; return ((e = this.Root) == null ? void 0 : e.gameObject) === this.gameObject } get canvas() { const e = this.Root; return e != null && e.isCanvas ? e : null } markDirty() { jn.markUIDirty(this.context) } get controlsChildLayout() { return this._controlsChildLayout } set controlsChildLayout(e) { this._controlsChildLayout = e, this.shadowComponent && (this.shadowComponent.autoLayout = e) } get Root() { return this._root === void 0 && (this._root = $.getComponentInParent(this.gameObject, em)), this._root } get Canvas() { return this.canvas } __internalNewInstanceCreated() { super.__internalNewInstanceCreated(), this.shadowComponent = null, this._root = void 0, this._parentComponent = void 0 } onEnable() { super.onEnable() } addShadowComponent(e, t) { var s; this.removeShadowComponent(); const r = this.isRoot() ? this.gameObject : this.gameObject.parent; if (this._parentComponent = $.getComponentInParent(r, ba), !this._parentComponent) { console.warn(`Component "${this.name}" doesn't have a UI parent anywhere. Do you have an UI element outside a Canvas? UI components must be a child of a Canvas component`, this); return } e.name = this.name + " (" + (this.constructor.name ?? "UI") + ")", e.autoLayout = this._parentComponent.controlsChildLayout, e[dl] = this, this.setShadowComponentOwner(e); let n = !1; if (((s = this.Root) == null ? void 0 : s.gameObject) === this.gameObject) this.gameObject.add(e); else { let o = this._parentComponent.shadowComponent; o && (o?.add(e), n = !0) } this.shadowComponent = e, t && t.shadowComponent && this.shadowComponent && t.shadowComponent.add(this.shadowComponent), Vf && e.add(new ud(.5)), this.onAfterAddedToScene(), n && EF() } set(e) { } setShadowComponentOwner(e) { if (e && (e[dl] === void 0 || e[dl] === this) && (e[dl] = this, e.children)) for (const t of e.children) this.setShadowComponentOwner(t) } traverseOwnedShadowComponents(e, t, s) { if (e && e[dl] === t) { s(e); for (const r of e.children) this.traverseOwnedShadowComponents(r, t, s) } } removeShadowComponent() { this.shadowComponent && this.shadowComponent.removeFromParent() } onAfterAddedToScene() { } setInteractable(e) { this.shadowComponent && (this.shadowComponent.interactable = e) } } class em extends ba { awake() { super.awake() } } class sp { static getObject(e) { const t = e[dl]; return t && (t.isComponent === !0 ? e = t.gameObject : e = t), e } static isInteractable(e, t) { if (t && (t.canvasGroup = void 0, t.graphic = void 0), e == null || !e.visible || (e = this.getObject(e), !e.visible)) return !1; const s = this.tryFindCanvasGroup(e); if (s?.isCanvasGroup === !0 && (t && (t.canvasGroup = s), s.blocksRaycasts === !1 || s.interactable === !1)) return !1; const r = Dh(e, n => { if (n.isGraphic === !0) return n }, !1); return t && r?.isGraphic === !0 && (t.graphic = r), !(r?.raycastTarget === !1 || r?.layer === 2) } static tryFindCanvasGroup(e) { if (!e) return null; const t = Dh(e, s => { const r = s; if (r.blocksRaycasts !== void 0 && r.interactable !== void 0) return r }, !1); return t !== void 0 ? t : this.tryFindCanvasGroup(e.parent) } } const tm = oe("debugwebxrcontroller"); var rp = (i => (i[i.PhysicalDevice = 0] = "PhysicalDevice", i[i.Touch = 1] = "Touch", i))(rp || {}), pl = (i => (i.SelectStart = "select-start", i.SelectEnd = "select-end", i.Update = "update", i))(pl || {}); class ub extends Ee { } const Qs = class extends Ee { constructor() { super(...arguments), u(this, "webXR"), u(this, "index", -1), u(this, "controllerModel"), u(this, "controller"), u(this, "controllerGrip"), u(this, "hand"), u(this, "handPointerModel"), u(this, "grabbed", null), u(this, "input", null), u(this, "type", 0), u(this, "showRaycastLine", !0), u(this, "_wristQuaternion", null), u(this, "movementVector", new S), u(this, "worldRot", new we), u(this, "joystick", new W), u(this, "didRotate", !1), u(this, "didTeleport", !1), u(this, "didChangeScale", !1), u(this, "lastHit", null), u(this, "raycastLine", null), u(this, "_raycastHitPoint", null), u(this, "_connnectedCallback", null), u(this, "_disconnectedCallback", null), u(this, "_selectStartEvt", null), u(this, "_selectEndEvt", null), u(this, "_selectionPressed", !1), u(this, "_selectionPressedLastFrame", !1), u(this, "_selectionStartTime", 0), u(this, "_selectionEndTime", 0), u(this, "_useSmoothing", !0), u(this, "_isConnected", !1), u(this, "rayRotation", new we), u(this, "_pinchStartTime"), u(this, "selectStartCallback", null), u(this, "lastSelectStartObject", null), u(this, "_didNotEndSelection", !1), u(this, "closeGrabBoundingBoxHelper") } static CreateRaycastLine() { const i = new Vi(this.geometry), e = i.material; return e.color = this.raycastColor, i.layers.set(2), i.name = "line", i.scale.z = 1, i } static CreateRaycastHitPoint() { const i = new Zn(.5, 22, 22), e = new di({ color: this.raycastColor }), t = new ye(i, e); return t.visible = !1, t.layers.set(2), t } static Create(i, e, t, s) { const r = t ? $.addNewComponent(t, Qs, !1) : new Qs; r.webXR = i, r.index = e, r.type = s; const n = i.context; r.controller = n.renderer.xr.getController(e), r.controllerGrip = n.renderer.xr.getControllerGrip(e), r.controllerModel = this.Factory.createControllerModel(r.controller), r.controllerGrip.add(r.controllerModel), r.hand = n.renderer.xr.getHand(e); const o = new Sd; wg(o, n), r.webXR.handModelPath && r.webXR.handModelPath !== "" ? o.setPath(Pl(i.sourceId, r.webXR.handModelPath)) : o.setPath("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/"); const a = new _Y(r.hand, o); return r.hand.add(a), r.hand.traverse(l => l.layers.set(2)), r.handPointerModel = new IY(r.hand, r.controller), r.controller.addEventListener("connected", l => { r.setControllerLayers(r.controllerModel, 2), r.setControllerLayers(r.controllerGrip, 2), r.setControllerLayers(r.hand, 2), setTimeout(() => { r.setControllerLayers(r.controllerModel, 2), r.setControllerLayers(r.controllerGrip, 2), r.setControllerLayers(r.hand, 2) }, 1e3) }), r.hand.addEventListener("connected", l => { var c; if (l.data.hand) { i.Rig && i.Rig.add(r.hand), r.type = 0, r.handPointerModel.traverse(d => d.layers.set(2)), (c = r.handPointerModel.pointerObject) == null || c.traverse(d => d.layers.set(2)); const h = r.hand.joints; if (h) for (const d of Object.keys(h)) { const p = h[d]; p.parent || r.hand.add(p) } } }), r } static addEventListener(i, e) { const t = this.eventSubs[i] ?? []; t.push(e), this.eventSubs[i] = t } static removeEventListener(i, e) { if (!e) return; const t = this.eventSubs[i] ?? [], s = t.indexOf(e); s >= 0 && t.splice(s, 1), this.eventSubs[i] = t } get isUsingHands() { var i; return ((i = this.input) == null ? void 0 : i.hand) != null } get wrist() { if (!this.hand) return null; const i = this.hand.joints; return i ? i.wrist : null } getWristQuaternion() { const i = this.wrist; return i ? (this._wristQuaternion || (this._wristQuaternion = new we), _s(i).multiply(this._wristQuaternion.setFromEuler(new ps(-Math.PI / 4, 0, 0)))) : null } get selectionDown() { return this._selectionPressed && !this._selectionPressedLastFrame } get selectionUp() { return !this._selectionPressed && this._selectionPressedLastFrame } get selectionPressed() { return this._selectionPressed } get selectionClick() { return this._selectionEndTime - this._selectionStartTime < .3 } get raycastHitPoint() { return this._raycastHitPoint } get useSmoothing() { return this._useSmoothing } awake() { if (!this.controller) { console.warn("Missing Controller!!!", this); return } this._connnectedCallback = this.onSourceConnected.bind(this), this._disconnectedCallback = this.onSourceDisconnected.bind(this), this._selectStartEvt = this.onSelectStart.bind(this), this._selectEndEvt = this.onSelectEnd.bind(this), this.type === 1 && (this.controllerGrip.addEventListener("connected", this._connnectedCallback), this.controllerGrip.addEventListener("disconnected", this._disconnectedCallback), this.controller.addEventListener("selectstart", this._selectStartEvt), this.controller.addEventListener("selectend", this._selectEndEvt)), this.type === 0 && (this.controller.addEventListener("selectstart", this._selectStartEvt), this.controller.addEventListener("selectend", this._selectEndEvt)) } onDestroy() { var i, e, t; this.type === 1 && (this.controllerGrip.removeEventListener("connected", this._connnectedCallback), this.controllerGrip.removeEventListener("disconnected", this._disconnectedCallback), this.controller.removeEventListener("selectstart", this._selectStartEvt), this.controller.removeEventListener("selectend", this._selectEndEvt)), this.type === 0 && (this.controller.removeEventListener("selectstart", this._selectStartEvt), this.controller.removeEventListener("selectend", this._selectEndEvt)), (i = this.hand) == null || i.clear(), (e = this.controllerGrip) == null || e.clear(), (t = this.controller) == null || t.clear() } onEnable() { var i, e, t, s, r; this.hand && (this.hand.name = "Hand"), this.controllerGrip && (this.controllerGrip.name = "ControllerGrip"), this.controller && (this.controller.name = "Controller"), this.raycastLine && (this.raycastLine.name = "RaycastLine;"), this.webXR.Controllers.indexOf(this) < 0 && this.webXR.Controllers.push(this), this.raycastLine || (this.raycastLine = Qs.CreateRaycastLine()), this._raycastHitPoint || (this._raycastHitPoint = Qs.CreateRaycastHitPoint()), (i = this.webXR.Rig) == null || i.add(this.hand), (e = this.webXR.Rig) == null || e.add(this.controllerGrip), (t = this.webXR.Rig) == null || t.add(this.controller), (s = this.webXR.Rig) == null || s.add(this.raycastLine), (r = this.raycastLine) == null || r.add(this._raycastHitPoint), this._raycastHitPoint.visible = !1, this.hand.add(this.handPointerModel), tm && console.log("ADDED TO RIG", this.webXR.Rig) } onDisable() { var i, e, t, s, r; (i = this.hand) == null || i.removeFromParent(), (e = this.controllerGrip) == null || e.removeFromParent(), (t = this.controller) == null || t.removeFromParent(), (s = this.raycastLine) == null || s.removeFromParent(), (r = this._raycastHitPoint) == null || r.removeFromParent(); const n = this.webXR.Controllers.indexOf(this); n >= 0 && this.webXR.Controllers.splice(n, 1) } onSourceConnected(i) { if (this._isConnected) { console.warn("Received connected event for controller that is already connected", this.index, i); return } this._isConnected = !0, this.input = i.data, this.type === 1 && (this.onSelectStart(), this.createPointerEvent("down")) } onSourceDisconnected(i) { if (!this._isConnected) { console.warn("Received discnnected event for controller that is not connected", i); return } this._isConnected = !1, this.type === 1 && (this.onSelectEnd(), this.createPointerEvent("up")), this.input = null } createPointerEvent(i) { switch (i) { case "down": this.context.input.createPointerDown({ clientX: 0, clientY: 0, button: this.index, pointerType: "touch" }); break; case "move": break; case "up": this.context.input.createPointerUp({ clientX: 0, clientY: 0, button: this.index, pointerType: "touch" }); break } } update() { this.context.time.frameCount % 60 === 0 && (this.setControllerLayers(this.controller, 2), this.setControllerLayers(this.controllerGrip, 2), this.setControllerLayers(this.hand, 2)); const i = Qs.eventSubs.update; if (i && i.length > 0) for (const s of i) s(this); let e = 1; this.type === 0 ? e = this.context.time.deltaTime / .1 : this.isUsingHands && this.handPointerModel.pinched && (e = this.context.time.deltaTime / .3), this.rayRotation.slerp(_s(this.controller), this.useSmoothing ? e : 1); const t = xt(this.controller); if (this.isUsingHands && this.handPointerModel.cursorObject && (this.handPointerModel.cursorObject.visible = !1), this.raycastLine) { const s = this.showRaycastLine && this.type !== 1; if (this.type === 1) this.raycastLine.visible = !1; else if (this.isUsingHands) { this.raycastLine.visible = !this.grabbed && s, ts(this.raycastLine, t); const r = this.hand.joints; if (r && r.wrist && this.grabbed && this.grabbed.isCloseGrab) { const n = this.getWristQuaternion(); n && this.rayRotation.copy(n) } Dr(this.raycastLine, this.rayRotation) } else this.raycastLine.visible = s, Dr(this.raycastLine, this.rayRotation), ts(this.raycastLine, t) } this.lastHit = this.updateLastHit(), this.grabbed && this.grabbed.update(), this._selectionPressedLastFrame = this._selectionPressed, this.selectStartCallback && this.selectStartCallback() } onUpdate(i) { var e, t; if (this.lastHit = null, !i || i.inputSources.length <= this.index) { this.input = null; return } if (this.type === 0 && (this.input = i.inputSources[this.index]), !this.input) return; const s = this.webXR.Rig; if (!s) return; this._didNotEndSelection && !this.handPointerModel.pinched && (this._didNotEndSelection = !1, this.onSelectEnd()), this.updateStick(this.input); const r = (t = (e = this.input) == null ? void 0 : e.gamepad) == null ? void 0 : t.buttons; switch (this.input.handedness) { case "left": const n = 3 * Qs.MovementSpeedFactor, o = 2, a = Ke.clamp01(this.joystick.length() * 2), l = this.joystick.x > 0 ? 1 : -1; let c = Math.pow(this.joystick.x, o); c *= l, c *= a; const h = this.joystick.y > 0 ? 1 : -1; let d = Math.pow(this.joystick.y, o); d *= h, c *= a, s.getWorldQuaternion(this.worldRot), this.movementVector.set(c, 0, d), this.movementVector.applyQuaternion(this.webXR.TransformOrientation), this.movementVector.y = 0, this.movementVector.applyQuaternion(this.worldRot), this.movementVector.multiplyScalar(n * this.context.time.deltaTime), s.position.add(this.movementVector), this.isUsingHands && this.runTeleport(s, r); break; case "right": const p = this.joystick.x, f = Math.abs(p); if (f < .4) this.didRotate = !1; else if (f > .5 && !this.didRotate) { const g = p > 0 ? -1 : 1; s.rotateY(Ke.toRadians(30 * g)), this.didRotate = !0 } this.runTeleport(s, r); break } } runTeleport(i, e) { var t, s, r; let n = -this.joystick.y; if ((t = this.hand) != null && t.visible && !this.grabbed) { const c = this.handPointerModel.isPinched(); c && this._pinchStartTime === void 0 && (this._pinchStartTime = this.context.time.time), c && this._pinchStartTime && this.context.time.time - this._pinchStartTime > .8 && (n = this.handPointerModel.isPinched() ? 1 : 0), c || (this._pinchStartTime = void 0) } else this._pinchStartTime = void 0; let o = n > .5 && this.webXR.IsInVR, a = this.webXR.Rig ? ((r = (s = this.webXR.Rig) == null ? void 0 : s.scale) == null ? void 0 : r.x) < .999 : !1, l = null; if (e && this.input && !this.input.hand) for (let c = 0; c < e.length; c++) { const h = e[c]; if (c === 4) if (h.pressed && !this.didChangeScale && this.webXR.IsInVR) { this.didChangeScale = !0; const d = this.webXR.Rig; if (d) if (a) { a = !1, d.scale.set(1, 1, 1), l = 1, Qs.MovementSpeedFactor = 1; const p = this.context.mainCamera; Qs.PreviousCameraFarDistance && (p.far = Qs.PreviousCameraFarDistance) } else { a = !0, o = !0, l = .1, Qs.MovementSpeedFactor = l * 2; const p = this.context.mainCamera; Qs.PreviousCameraFarDistance = p.far, p.far /= l } } else h.pressed || (this.didChangeScale = !1) } if (o) { if (!this.didTeleport) { const c = this.raycast(); if (this.didTeleport = !0, c && c.length > 0) { const h = c[0]; if (a || this.isValidTeleportTarget(h.object)) { const d = h.point; ts(i, d) } } } } else n < .1 && (this.didTeleport = !1); l !== null && (i.scale.set(l, l, l), i.updateMatrixWorld()) } isValidTeleportTarget(i) { return $.getComponentInParent(i, ub) != null } updateStick(i) { var e; !i || !i.gamepad || ((e = i.gamepad.axes) == null ? void 0 : e.length) < 4 || (this.joystick.x = i.gamepad.axes[2], this.joystick.y = i.gamepad.axes[3]) } updateLastHit() { var i; const e = this.raycast(), t = e ? e[0] : null; this.lastHit = t; let s = 1; if (this.webXR.Rig && (s /= this.webXR.Rig.scale.x), this.raycastLine) { this.raycastLine.scale.z = s * (((i = this.lastHit) == null ? void 0 : i.distance) ?? 9999); const r = this.raycastLine.material; t != null ? r.color = Qs.raycastColor : r.color = Qs.raycastNoHitColor } if (this._raycastHitPoint) { if (this.lastHit != null) { this._raycastHitPoint.position.z = -1; const r = Ke.clamp(this.lastHit.distance * .01 * s, .015, .1); this._raycastHitPoint.scale.set(r, r, r) } this._raycastHitPoint.visible = this.lastHit !== null && this.lastHit !== void 0 } return t } onSelectStart() { this.context.connection.allowEditing && (this.selectStartCallback = () => this.onHandleSelectStart()) } onHandleSelectStart() { this.selectStartCallback = null, this._selectionPressed = !0, this._selectionStartTime = this.context.time.time, this._selectionEndTime = 1e3; let i = null, e = !1; if (this.isUsingHands ? (i = this.overlap(), i.length <= 0 ? (i = this.raycast(), e = !1) : e = !0) : i = this.raycast(), tm && console.log("onHandleSelectStart", "close grab? " + e, "intersections", i), i && i.length > 0) for (const t of i) { const s = t.object; this.lastSelectStartObject = s; const r = { selected: s, grab: s }, n = Qs.eventSubs["select-start"]; if (n && n.length > 0) for (const o of n) o(this, r); r.grab !== s && tm && console.log("Grabbed object changed", "original", s, "new", r.grab), r.grab && (this.grabbed = ea.TryTake(this, r.grab, t, e)); break } else { const t = Qs.eventSubs["select-start"], s = { selected: null, grab: null }; if (t && t.length > 0) for (const r of t) r(this, s) } } onSelectEnd() { var i; if (this.isUsingHands && this.handPointerModel.pinched) { this._didNotEndSelection = !0; return } if (!this._selectionPressed) return; this.selectStartCallback = null, this._selectionPressed = !1, this._selectionEndTime = this.context.time.time; const e = { grab: ((i = this.grabbed) == null ? void 0 : i.selected) ?? this.lastSelectStartObject }, t = Qs.eventSubs["select-end"]; if (t && t.length > 0) for (const s of t) s(this, e); this.grabbed && (this.grabbed.free(), this.grabbed = null) } testIsVisible(i) { return !(!i || $.isActiveInHierarchy(i) === !1 || sp.isInteractable(i) === !1) } setControllerLayers(i, e) { var t, s; if (i && (i.layers.set(e), i.children)) for (const r of i.children) ((t = this.grabbed) == null ? void 0 : t.selected) === r || ((s = this.grabbed) == null ? void 0 : s.selectedMesh) === r || this.setControllerLayers(r, e) } getRay() { const i = new Oa; return i.origin.copy(xt(this.controller)), i.direction.set(0, 0, -1).applyQuaternion(this.rayRotation), i } overlap() { const i = this.isUsingHands && this.handPointerModel ? this.handPointerModel.pointerObject : this.controllerGrip; if (tm && (!this.closeGrabBoundingBoxHelper && i && (this.closeGrabBoundingBoxHelper = new l0(i, 16776960), this.scene.add(this.closeGrabBoundingBoxHelper)), this.closeGrabBoundingBoxHelper && i && this.closeGrabBoundingBoxHelper.setFromObject(i)), !i) return new Array; const e = xt(i).clone(); return this.context.physics.sphereOverlap(e, .02) } raycast() { const i = new co; i.layerMask = new bn, i.layerMask.enableAll(), i.layerMask.disable(2), i.ray = this.getRay(); const e = this.context.physics.raycast(i); for (let t = 0; t < e.length; t++) { const s = e[t], r = s.object; if (!this.testIsVisible(r)) { e.splice(t, 1), t--; continue } s.object = sp.getObject(r); break } return e } }; let os = Qs; u(os, "Factory", new zY), u(os, "raycastColor", new xe(.9, .3, .3)), u(os, "raycastNoHitColor", new xe(.6, .6, .6)), u(os, "geometry", new yt().setFromPoints([new S(0, 0, 0), new S(0, 0, -1)])), u(os, "handModels", {}), u(os, "eventSubs", {}), u(os, "PreviousCameraFarDistance"), u(os, "MovementSpeedFactor", 1); var db = (i => (i.WillTake = "WillTake", i.DidTake = "DidTake", i.WillFree = "WillFree", i.DidFree = "DidFree", i))(db || {}); const Gr = class { constructor() { u(this, "sync", null), u(this, "selected", null), u(this, "selectedParent", null), u(this, "selectedMesh", null), u(this, "controller", null), u(this, "grabTime", 0), u(this, "grabUUID", ""), u(this, "isCloseGrab", !1), u(this, "originalMaterial", null), u(this, "usageMarker", null), u(this, "rigidbodies", null), u(this, "didReparent", !1), u(this, "grabDistance", 0), u(this, "interactable", null), u(this, "positionSource", null), u(this, "grabPoint", new S), u(this, "localPositionOffsetToGrab", null), u(this, "localPositionOffsetToGrab_worldSpace", new S), u(this, "localQuaternionToGrab", new we(0, 0, 0, 1)), u(this, "targetDir", null), u(this, "quaternionLerp", null), u(this, "controllerDir", new S), u(this, "controllerWorldPos", new S), u(this, "lastControllerWorldPos", new S), u(this, "controllerPosDelta", new S), u(this, "totalChangeAlongDirection", 0), u(this, "rigPositionLastFrame", new S) } static AddEventListener(i, e) { return Gr.Events[i] || (Gr.Events[i] = []), Gr.Events[i].push(e), e } static RemoveEventListener(i, e) { if (!e || !Gr.Events[i]) return; const t = Gr.Events[i].indexOf(e); t >= 0 && Gr.Events[i].splice(t, 1) } static Register(i) { this.Current.find(e => e === i) || this.Current.push(i) } static Remove(i) { const e = this.Current.indexOf(i); e >= 0 && this.Current.splice(e, 1) } static TryTake(i, e, t, s) { const r = $.getComponentInParent(e, Yd); if (r) e = r.gameObject; else return tm && console.warn("Prevented taking object that is not interactable", e), null; let n = e; const o = $.getComponentInParent(e, Ic); o && (o.requestOwnership(), n = o.gameObject); for (const l of this.Current) if (l.selected === n) return l.controller === i || (l.free(), l.Take(i, n, e, o, r, t, s)), l; const a = new Gr; return a.Take(i, n, e, o, r, t, s), a } Take(i, e, t, s, r, n, o) { var a, l; if (console.assert(e !== null, "Expected object to be taken but was", e), i.isUsingHands ? this.positionSource = o ? i.wrist : i.controller : this.positionSource = i.controller, !this.positionSource) return console.warn("No position source"), this; const c = { controller: i, take: e, hit: t, sync: s, interactable: r }; (a = Gr.Events.WillTake) == null || a.forEach(g => g(this, c)); const h = t; h != null && h.material && (this.originalMaterial = h.material, Array.isArray(h.material) || (h.material = h.material.clone(), h.material && h.material.emissive && (h.material.emissive.b = .2))), this.selected = e, this.selectedParent || (this.selectedParent = e.parent), this.selectedMesh = h, this.controller = i, this.interactable = r, this.isCloseGrab = o, this.didReparent = !1, this.sync = s, this.grabTime = i.context.time.time, this.grabUUID = Date.now().toString(), this.usageMarker = $.addNewComponent(this.selected, Jd), this.rigidbodies = $.getComponentsInChildren(this.selected, ki), xt(this.positionSource, this.lastControllerWorldPos); const d = () => o ? this.lastControllerWorldPos.clone() : n.point.clone(); this.grabDistance = d().distanceTo(this.lastControllerWorldPos), this.totalChangeAlongDirection = 0, this.localPositionOffsetToGrab = this.selected.worldToLocal(d()); const p = i.isUsingHands && o ? this.controller.getWristQuaternion().clone() : i.rayRotation.clone(); _s(this.selected, this.localQuaternionToGrab).premultiply(p.invert()); const f = this.controller.webXR.Rig; return f && this.rigPositionLastFrame.copy(xt(f)), Er.Add(i.context, this.selected), Gr.Register(this), this.sync && (this.sync.fastMode = !0), (l = Gr.Events.DidTake) == null || l.forEach(g => g(this, c)), this } free() { var i, e, t, s; if (!this.selected) return; const r = { controller: this.controller, take: this.selected, hit: this.selected, sync: this.sync, interactable: null }; (i = Gr.Events.WillFree) == null || i.forEach(a => a(this, r)), Er.Remove(this.controller.context, this.selected), Gr.Remove(this), this.sync && (this.sync.fastMode = !1); const n = this.selectedMesh; n && this.originalMaterial && n.material && (n.material = this.originalMaterial); const o = this.selected; if (this.didReparent && o.parent) { const a = this.selectedParent; a ? a.attach(o) : (e = this.controller) == null || e.context.scene.attach(o) } if ((t = this.usageMarker) == null || t.destroy(), this.controller && (this.controller.grabbed = null), this.selected = null, this.selectedParent = null, this.selectedMesh = null, this.sync = null, this.rigidbodies) for (const a of this.rigidbodies) a.wakeUp(), a.setVelocity(a.smoothedVelocity); this.rigidbodies = null, this.localPositionOffsetToGrab = null, this.quaternionLerp = null, (s = Gr.Events.DidFree) == null || s.forEach(a => a(this, r)) } controllerMovementSinceLastFrame() { if (!this.positionSource || !this.controller) return 0; this.controllerDir.set(0, 0, -1), this.controllerDir.applyQuaternion(this.controller.rayRotation), xt(this.positionSource, this.controllerWorldPos), this.controllerPosDelta.copy(this.controllerWorldPos), this.controllerPosDelta.sub(this.lastControllerWorldPos), this.lastControllerWorldPos.copy(this.controllerWorldPos); const i = this.controller.webXR.Rig; if (i) { const e = xt(i), t = this.rigPositionLastFrame.sub(e); this.controllerPosDelta.add(t), this.rigPositionLastFrame.copy(e) } return this.controllerDir.dot(this.controllerPosDelta) } update() { var i; if (this.rigidbodies) for (const e of this.rigidbodies) e.resetVelocities(); if (this.sync && this.controller && this.controller.context.connection.isInRoom && this.controller.context.time.time - this.grabTime > 3 && this.sync.hasOwnership() === !1 && (console.log("no ownership, will leave", this.sync.guid), this.free()), !(this.interactable && !this.interactable.canGrab)) { if (!this.didReparent && this.selected && this.controller) { const e = ((i = this.controller.webXR.Rig) == null ? void 0 : i.scale.x) ?? 1; this.totalChangeAlongDirection += this.controllerMovementSinceLastFrame(); let t = 1; this.controller.type === 0 && (t = Math.max(0, 1 + this.totalChangeAlongDirection * 2 / e), t = t * t * t), this.grabDistance / e < .8 && (t = 1), this.targetDir || (this.targetDir = new S), this.targetDir.set(0, 0, -this.grabDistance * t); const s = this.targetDir.applyQuaternion(this.controller.rayRotation).add(this.controllerWorldPos), r = this.controller.rayRotation.clone().multiplyQuaternions(this.controller.rayRotation, this.localQuaternionToGrab); this.quaternionLerp || (this.quaternionLerp = r.clone()), this.quaternionLerp.slerp(r, this.controller.useSmoothing ? this.controller.context.time.deltaTime / .03 : 1), Dr(this.selected, this.quaternionLerp), this.selected.updateWorldMatrix(!1, !1), this.grabPoint.copy(s), this.localPositionOffsetToGrab && (this.localPositionOffsetToGrab_worldSpace.copy(this.localPositionOffsetToGrab), this.selected.localToWorld(this.localPositionOffsetToGrab_worldSpace).sub(xt(this.selected)), s.sub(this.localPositionOffsetToGrab_worldSpace)), ts(this.selected, s) } if (this.rigidbodies != null) for (const e of this.rigidbodies) e.wakeUp(); Xr.markDirty(this.selected, !0) } } }; let ea = Gr; u(ea, "Events", {}), u(ea, "Current", []); var Y$ = Object.defineProperty, J$ = Object.getOwnPropertyDescriptor, _E = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? J$(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Y$(e, t, r), r }; class qh extends Ee { constructor() { super(...arguments), u(this, "objectBounds", !1), u(this, "color"), u(this, "isGizmo", !0), u(this, "_gizmoObject", null), u(this, "_boxHelper", null) } onEnable() { this.isGizmo && !Vf || (this._gizmoObject || (this.objectBounds && this.gameObject.isMesh === !0 ? this._gizmoObject = new l0(this.gameObject, this.color ?? 16776960) : (this.objectBounds = !1, this._gizmoObject = nL(this.color ?? 16776960))), this.objectBounds ? (this.scene.add(this._gizmoObject), this._boxHelper = this._gizmoObject, this.startCoroutine(this.syncObjectBounds(), on.OnBeforeRender)) : this.gameObject.add(this._gizmoObject)) } onDisable() { this._gizmoObject && this.gameObject.remove(this._gizmoObject) } *syncObjectBounds() { for (var e; this._boxHelper;)(e = this._boxHelper) == null || e.update(), yield } } _E([x()], qh.prototype, "objectBounds", 2), _E([x(xe)], qh.prototype, "color", 2), _E([x()], qh.prototype, "isGizmo", 2); const K$ = oe("debugrig"); class pb extends Ee { awake() { if (K$) { const e = new Me; e.position.y += .5, this.gameObject.add(e); const t = e.addNewComponent(qh); t && (t.isGizmo = !1) } } } class np { constructor() { u(this, "bb", null), u(this, "bb_pos", 0) } __init(e, t) { return this.bb_pos = e, this.bb = t, this } x() { return this.bb.readFloat32(this.bb_pos) } y() { return this.bb.readFloat32(this.bb_pos + 4) } z() { return this.bb.readFloat32(this.bb_pos + 8) } w() { return this.bb.readFloat32(this.bb_pos + 12) } static sizeOf() { return 16 } static createVec4(e, t, s, r, n) { return e.prep(4, 16), e.writeFloat32(n), e.writeFloat32(r), e.writeFloat32(s), e.writeFloat32(t), e.offset() } } class hr { constructor() { u(this, "bb", null), u(this, "bb_pos", 0) } __init(e, t) { return this.bb_pos = e, this.bb = t, this } static getRootAsVrUserStateBuffer(e, t) { return (t || new hr).__init(e.readInt32(e.position()) + e.position(), e) } static getSizePrefixedRootAsVrUserStateBuffer(e, t) { return e.setPosition(e.position() + E0), (t || new hr).__init(e.readInt32(e.position()) + e.position(), e) } guid(e) { const t = this.bb.__offset(this.bb_pos, 4); return t ? this.bb.__string(this.bb_pos + t, e) : null } time() { const e = this.bb.__offset(this.bb_pos, 6); return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0) } avatarId(e) { const t = this.bb.__offset(this.bb_pos, 8); return t ? this.bb.__string(this.bb_pos + t, e) : null } position(e) { const t = this.bb.__offset(this.bb_pos, 10); return t ? (e || new an).__init(this.bb_pos + t, this.bb) : null } rotation(e) { const t = this.bb.__offset(this.bb_pos, 12); return t ? (e || new np).__init(this.bb_pos + t, this.bb) : null } scale() { const e = this.bb.__offset(this.bb_pos, 14); return e ? this.bb.readFloat32(this.bb_pos + e) : 0 } posLeftHand(e) { const t = this.bb.__offset(this.bb_pos, 16); return t ? (e || new an).__init(this.bb_pos + t, this.bb) : null } posRightHand(e) { const t = this.bb.__offset(this.bb_pos, 18); return t ? (e || new an).__init(this.bb_pos + t, this.bb) : null } rotLeftHand(e) { const t = this.bb.__offset(this.bb_pos, 20); return t ? (e || new np).__init(this.bb_pos + t, this.bb) : null } rotRightHand(e) { const t = this.bb.__offset(this.bb_pos, 22); return t ? (e || new np).__init(this.bb_pos + t, this.bb) : null } static startVrUserStateBuffer(e) { e.startObject(10) } static addGuid(e, t) { e.addFieldOffset(0, t, 0) } static addTime(e, t) { e.addFieldInt64(1, t, e.createLong(0, 0)) } static addAvatarId(e, t) { e.addFieldOffset(2, t, 0) } static addPosition(e, t) { e.addFieldStruct(3, t, 0) } static addRotation(e, t) { e.addFieldStruct(4, t, 0) } static addScale(e, t) { e.addFieldFloat32(5, t, 0) } static addPosLeftHand(e, t) { e.addFieldStruct(6, t, 0) } static addPosRightHand(e, t) { e.addFieldStruct(7, t, 0) } static addRotLeftHand(e, t) { e.addFieldStruct(8, t, 0) } static addRotRightHand(e, t) { e.addFieldStruct(9, t, 0) } static endVrUserStateBuffer(e) { return e.endObject() } static finishVrUserStateBufferBuffer(e, t) { e.finish(t) } static finishSizePrefixedVrUserStateBufferBuffer(e, t) { e.finish(t, void 0, !0) } } const IF = oe("debugxr"), im = oe("debugavatar"), xE = "VRUS"; C1(xE, hr.getRootAsVrUserStateBuffer); function wE() { return new Date().getTime() } function Z$(i) { let e = i & 4294967295, t = i / Math.pow(2, 32) & 1048575; return _a.create(e, t) } const fb = class { constructor(i) { u(this, "guid"), u(this, "time"), u(this, "avatarId"), u(this, "position", new S), u(this, "rotation", new st), u(this, "scale", 1), u(this, "posLeftHand", new S), u(this, "posRightHand", new S), u(this, "rotLeftHand", new we), u(this, "rotRightHand", new we), this.guid = i } update(i, e, t, s, r) { var n, o, a, l, c, h; this.time = wE(), this.avatarId = r, this.position.set(e.x, e.y, e.z), i && this.position.applyMatrix4(i.matrixWorld); let d = fb.quat0; const p = fb.quat1; d.set(t.x, t.y, t.z, t.w), d = d.multiplyQuaternions(d, fb.invertRotation), i && (i.getWorldQuaternion(p), d.multiplyQuaternions(p, d)), this.rotation.set(d.x, d.y, d.z, d.w), this.scale = i.scale.x; const f = (n = s.LeftController) == null ? void 0 : n.controllerGrip; f && (f.getWorldPosition(this.posLeftHand), f.getWorldQuaternion(this.rotLeftHand)); const g = (o = s.RightController) == null ? void 0 : o.controllerGrip; if (g && (g.getWorldPosition(this.posRightHand), g.getWorldQuaternion(this.rotRightHand)), (l = (a = s.LeftController) == null ? void 0 : a.hand) != null && l.visible) { const m = s.LeftController.wrist; m && (m.getWorldPosition(this.posLeftHand), m.getWorldQuaternion(this.rotLeftHand)) } if ((h = (c = s.RightController) == null ? void 0 : c.hand) != null && h.visible) { const m = s.RightController.wrist; m && (m.getWorldPosition(this.posRightHand), m.getWorldQuaternion(this.rotRightHand)) } } sendAsBuffer(i, e) { i.clear(); const t = i.createString(this.guid), s = i.createString(this.avatarId); hr.startVrUserStateBuffer(i), hr.addGuid(i, t), hr.addTime(i, Z$(this.time)), hr.addAvatarId(i, s), hr.addPosition(i, an.createVec3(i, this.position.x, this.position.y, this.position.z)), hr.addRotation(i, np.createVec4(i, this.rotation.x, this.rotation.y, this.rotation.z, this.rotation.w)), hr.addScale(i, this.scale), hr.addPosLeftHand(i, an.createVec3(i, this.posLeftHand.x, this.posLeftHand.y, this.posLeftHand.z)), hr.addPosRightHand(i, an.createVec3(i, this.posRightHand.x, this.posRightHand.y, this.posRightHand.z)), hr.addRotLeftHand(i, np.createVec4(i, this.rotLeftHand.x, this.rotLeftHand.y, this.rotLeftHand.z, this.rotLeftHand.w)), hr.addRotRightHand(i, np.createVec4(i, this.rotRightHand.x, this.rotRightHand.y, this.rotRightHand.z, this.rotRightHand.w)); const r = hr.endVrUserStateBuffer(i); i.finish(r, xE); const n = i.asUint8Array(); e.sendBinary(n) } setFromBuffer(i, e) { if (!i) return; this.guid = i, this.time = e.time().toFloat64(); const t = e.avatarId(); t && (this.avatarId = t); const s = e.position(); s && this.position.set(s.x(), s.y(), s.z()); const r = e.rotation(); r && this.rotation.set(r.x(), r.y(), r.z(), r.w()); const n = e.posLeftHand(); n && this.posLeftHand.set(n.x(), n.y(), n.z()); const o = e.posRightHand(); o && this.posRightHand.set(o.x(), o.y(), o.z()); const a = e.rotLeftHand(); a && this.rotLeftHand.set(a.x(), a.y(), a.z(), a.w()); const l = e.rotRightHand(); l && this.rotRightHand.set(l.x(), l.y(), l.z(), l.w()), this.scale = e.scale() } }; let fl = fb; u(fl, "invertRotation", new we().setFromAxisAngle(new S(0, 1, 0), Math.PI)), u(fl, "quat0", new we), u(fl, "quat1", new we); class sm extends Ee { constructor() { super(...arguments), u(this, "webXR", null), u(this, "debugAvatarUser", null), u(this, "voip", null), u(this, "tempState", new fl("")), u(this, "_removeAvatarsList", []), u(this, "eventSub_ConnectionEvent", null), u(this, "eventSub_WebXRStartEvent", null), u(this, "eventSub_WebXREndEvent", null), u(this, "eventSub_WebXRUpdateEvent", null), u(this, "avatars", {}), u(this, "localAvatar", null), u(this, "k_LocalAvatarNoNetworkingGuid", "local"), u(this, "ownership", null), u(this, "xrState", null), u(this, "builder", new Zp(1024)) } async awake() { if (this.webXR || (this.webXR = $.getComponent(this.gameObject, wt)), this.webXR || (this.webXR = $.findObjectOfType(wt, this.context)), !this.webXR && (console.log("Missing webxr component"), this.webXR = $.findObjectOfType(wt, this.context), !this.webXR)) { console.error("Could not find webxr component"); return } if (this.voip || (this.voip = $.findObjectOfType(Il, this.context)), im) { const e = "debug-avatar-" + im, t = new Ec(this.context, e, this.webXR); if (this.debugAvatarUser = t, typeof im == "string" && im.length > 0) if (await t.setAvatarOverride(im)) { const s = new fl(e); s.position.y += 1; const r = .5; s.posLeftHand.y += r, s.posLeftHand.x += r, s.posRightHand.y += r, s.posRightHand.x -= r, t.tryUpdate(s, 0) } else t.destroy() } } onEnable() { if (!this.webXR && (this.webXR = $.getComponent(this.gameObject, wt), !this.webXR)) { console.warn("Missing webxr component on " + this.gameObject.name); return } this.eventSub_WebXRStartEvent = this.onXRSessionStart.bind(this), wt.addEventListener(bi.XRStarted, this.eventSub_WebXRStartEvent), this.eventSub_WebXRUpdateEvent = this.onXRSessionUpdate.bind(this), wt.addEventListener(bi.XRUpdate, this.eventSub_WebXRUpdateEvent), this.eventSub_WebXREndEvent = this.onXRSessionEnded.bind(this), wt.addEventListener(bi.XRStopped, this.eventSub_WebXREndEvent), this.eventSub_ConnectionEvent = this.onConnected.bind(this), this.context.connection.beginListen(Li.JoinedRoom, this.eventSub_ConnectionEvent), this.context.connection.beginListen("webxr-user-joined", e => { console.log("webxr user joined evt") }), this.context.connection.beginListen("webxr-user-left", e => { const t = e.id !== null && e.id !== void 0; if (t && (console.log("webxr user left evt"), t)) { const s = this.avatars[e.id]; s?.destroy(), this.avatars[e.id] = void 0 } }), this.context.connection.beginListenBinary(xE, e => { const t = e.guid(); if (!t) return; const s = e.time().toFloat64(), r = this.tempState; r.setFromBuffer(t, e); const n = this.onTryGetAvatar(t, s); n?.tryUpdate(r, s) }), this.context.connection.beginListen("vr-session-update", e => { const t = e.guid, s = e.time, r = this.onTryGetAvatar(t, s); r?.tryUpdate(e, s) }) } onTryGetAvatar(e, t) { if (e === this.context.connection.connectionId) return null; const s = new Date().getTime() - t; if (s > 5e3) return IF && console.log("old data", s, e), null; let r = this.avatars[e]; if (r === void 0) try { console.log("create new avatar"); const n = new Ec(this.context, e, this.webXR); r = n, this.avatars[e] = n } catch (n) { this.avatars[e] = null, console.error(n) } return r } onDisable() { this.eventSub_ConnectionEvent && this.context.connection.stopListen(Li.JoinedRoom, this.eventSub_ConnectionEvent), wt.removeEventListener(bi.XRStarted, this.eventSub_WebXRStartEvent), wt.removeEventListener(bi.XRUpdate, this.eventSub_WebXRUpdateEvent), wt.removeEventListener(bi.XRStopped, this.eventSub_WebXREndEvent) } update() { const e = wE(); this.debugAvatarUser && (this.debugAvatarUser.lastUpdate = e), this.detectPotentiallyDisconnectedAvatarsAndRemove(); for (const t in this.avatars) { const s = this.avatars[t]; s && s.update() } } detectPotentiallyDisconnectedAvatarsAndRemove() { const e = wE(); for (const t in this.avatars) { const s = this.avatars[t]; if (!s) { this._removeAvatarsList.push(t); continue } e - s.lastUpdate > 1e4 && (console.log("avatar timed out (didnt receive any updates in  a while) - destroying it now"), s.destroy(), this.avatars[t] = void 0) } for (const t of this._removeAvatarsList) delete this.avatars[t]; this._removeAvatarsList.length = 0 } buildLocalAvatar() { var e; if (this.localAvatar) return; const t = ((e = this.context.connection) == null ? void 0 : e.connectionId) ?? this.k_LocalAvatarNoNetworkingGuid; this.localAvatar = new Ec(this.context, t, this.webXR), this.localAvatar.isLocalAvatar = !0, this.localAvatar.setAvatarOverride(this.getAvatarId()), this.avatars[this.localAvatar.guid] = this.localAvatar } onConnected() { var e, t, s; IF && console.log("Hey you are connected as " + this.context.connection.connectionId), ((e = this.localAvatar) == null ? void 0 : e.guid) === this.k_LocalAvatarNoNetworkingGuid && (this.localAvatar && ((t = this.localAvatar) == null || t.destroy(), this.avatars[this.localAvatar.guid] = void 0), this.localAvatar = null, this.xrState = null, (s = this.ownership) == null || s.freeOwnership(), this.ownership = null) } onXRSessionStart(e) { var t, s, r; if (console.log("XR session started"), this.context.connection.send("webxr-user-joined", { id: this.context.connection.connectionId, mode: "vr" }), this.localAvatar && ((t = this.localAvatar) == null || t.destroy(), this.avatars[this.localAvatar.guid] = void 0, this.localAvatar = null), this.xrState = null, (s = this.ownership) == null || s.freeOwnership(), this.ownership = null, this.avatars) for (const n in this.avatars) (r = this.avatars[n]) == null || r.updateFlags() } onXRSessionEnded(e) { var t; console.log("XR session ended"), this.context.connection.send("webxr-user-left", { id: this.context.connection.connectionId, mode: "vr" }), this.localAvatar && ((t = this.localAvatar) == null || t.destroy(), this.avatars[this.localAvatar.guid] = void 0, this.localAvatar = null) } onXRSessionUpdate(e) { this.xrState ?? (this.xrState = new fl(this.context.connection.connectionId ?? this.k_LocalAvatarNoNetworkingGuid)), this.ownership ?? (this.ownership = new z0(this.context.connection, this.context.connection.connectionId ?? this.k_LocalAvatarNoNetworkingGuid)), this.ownership.guid = this.context.connection.connectionId ?? this.k_LocalAvatarNoNetworkingGuid, this.buildLocalAvatar(); const { frame: t, xr: s, rig: r } = e, n = t.getViewerPose(s.getReferenceSpace()); if (!n) return; const o = n?.transform, a = o.position, l = o.orientation; this.xrState.update(r, a, l, this.webXR, this.getAvatarId()), this.localAvatar && (this.context.connection.connectionId && (this.localAvatar.guid = this.context.connection.connectionId), this.localAvatar.tryUpdate(this.xrState, 0)), !(this.ownership && !this.ownership.hasOwnership && this.context.connection.isConnected && (this.context.time.frameCount % 120 === 0 && this.ownership.requestOwnership(), !this.ownership.hasOwnership)) && (!this.context.connection.isConnected || !this.context.connection.connectionId || this.xrState.sendAsBuffer(this.builder, this.context.connection)) } getAvatarId() { return oe("avatar") ?? null } } var $$ = Object.defineProperty, eee = Object.getOwnPropertyDescriptor, op = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? eee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && $$(e, t, r), r }; async function TF() { return X_() ? !0 : "xr" in navigator ? await navigator.xr.isSessionSupported("immersive-ar") === !0 : !1 } async function RF() { return "xr" in navigator ? await navigator.xr.isSessionSupported("immersive-vr") === !0 : !1 } let CE = !1, gb = !1; TF().then(i => CE = i), RF().then(i => gb = i); var bi = (i => (i.XRStarted = "xrStarted", i.XRStopped = "xrStopped", i.XRUpdate = "xrUpdate", i.RequestVRSession = "requestVRSession", i.ModifyAROptions = "modify-ar-options", i))(bi || {}), ap; const ws = (ap = class extends Ee { constructor() { super(...arguments), u(this, "enableVR", !0), u(this, "enableAR", !0), u(this, "defaultAvatar"), u(this, "handModelPath", ""), u(this, "createVRButton", !0), u(this, "createARButton", !0), u(this, "controllers", []), u(this, "rig"), u(this, "isInit", !1), u(this, "_requestedAR", !1), u(this, "_requestedVR", !1), u(this, "_isInAR", !1), u(this, "_isInVR", !1), u(this, "_arButton"), u(this, "_vrButton"), u(this, "webAR", null), u(this, "_transformOrientation", new we), u(this, "_currentHeadPose", null), u(this, "_originalCameraParent", null), u(this, "_originalCameraPosition", new S), u(this, "_originalCameraRotation", new we), u(this, "_originalXRRigParent", null), u(this, "_originalXRRigPosition", new S), u(this, "_originalXRRigRotation", new we), u(this, "xrMirrorWindow", null) } static get IsInWebXR() { return this._isInXr } static get XRSupported() { return "xr" in navigator && (CE || gb) } static get IsARSupported() { return CE } static get IsVRSupported() { return gb } static get OptionalFeatures_VR() { return this._optionalFeatures_VR } static get OptionalFeatures_AR() { return this._optionalFeatures_AR } static addEventListener(i, e) { return this.events.addEventListener(i, e), e } static removeEventListener(i, e) { return this.events.removeEventListener(i, e), e } static dispatchEvent(i, e) { this.events.dispatchEvent({ type: i, detail: e }) } static createVRButton(i, e) { ws.XRSupported ? i.__internalAwake() : console.warn("WebXR is not supported on this device"); const t = { optionalFeatures: ws.OptionalFeatures_VR }, s = TS.createButton(i.context.renderer, t); return s.classList.add("webxr-ar-button"), s.classList.add("webxr-button"), this.resetButtonStyles(s), (e?.registerClick ?? !0) && s.addEventListener("click", i.onClickedVRButton.bind(i)), s } static createARButton(i, e) { var t; i.__internalAwake(); const s = (t = i.webAR) == null ? void 0 : t.getAROverlayContainer(), r = { optionalFeatures: [...this.OptionalFeatures_AR] }; s ? (r.domOverlay = { root: s }, r.optionalFeatures.push("dom-overlay"), r.optionalFeatures.push("hit-test")) : console.warn("No dom overlay root found, HTML overlays on top of screen-based AR will not work."); const n = hY.createButton(i.context.renderer, r, this.onModifyAROptions.bind(this)); return n.classList.add("webxr-ar-button"), n.classList.add("webxr-button"), ws.resetButtonStyles(n), (e?.registerClick ?? !0) && n.addEventListener("click", i.onClickedARButton.bind(i)), n } static onModifyAROptions(i) { ws.dispatchEvent("modify-ar-options", i) } static resetButtonStyles(i) { i && (i.style.position = "", i.style.bottom = "", i.style.left = "") } endSession() { const i = this.context.renderer.xr.getSession(); i && i.end() } get Rig() { return this.rig || this.ensureRig(), this.rig } get Controllers() { return this.controllers } get LeftController() { var i, e; return this.controllers.length > 0 && ((i = this.controllers[0].input) == null ? void 0 : i.handedness) === "left" ? this.controllers[0] : this.controllers.length > 1 && ((e = this.controllers[1].input) == null ? void 0 : e.handedness) === "left" ? this.controllers[1] : null } get RightController() { var i, e; return this.controllers.length > 0 && ((i = this.controllers[0].input) == null ? void 0 : i.handedness) === "right" ? this.controllers[0] : this.controllers.length > 1 && ((e = this.controllers[1].input) == null ? void 0 : e.handedness) === "right" ? this.controllers[1] : null } get ARButton() { return this._arButton } get VRButton() { return this._vrButton } get IsInVR() { return this._isInVR } get IsInAR() { return this._isInAR } awake() { if (this.defaultAvatar && typeof this.defaultAvatar == "string" && (this.defaultAvatar = or.getOrCreate(this.sourceId ?? "/", this.defaultAvatar, this.context)), !$.findObjectOfType(sm, this.context)) { const i = $.addNewComponent(this.gameObject, sm, !1); i.webXR = this } this.webAR = new nm(this) } start() { location.protocol == "http:" && location.host.indexOf("localhost") < 0 && (ao("WebXR only works on https"), console.warn("WebXR only works on https. https://engine.needle.tools/docs/xr.html")) } onEnable() { if (this.isInit || !this.enableAR && !this.enableVR) return; this.isInit = !0, this.context.renderer.xr.enabled = !0, ws.XRSupported; let i, e; const t = document.createElement("div"); t.classList.add("webxr-buttons"), this.context.domElement.append(t), i = ws.createARButton(this), this._arButton = i, t.appendChild(i), this.createVRButton && this.enableVR && gb && (e = ws.createVRButton(this), this._vrButton = e, t.appendChild(e)), setTimeout(() => { ws.resetButtonStyles(e), ws.resetButtonStyles(i) }, 1e3) } get TransformOrientation() { return this._transformOrientation } get HeadPose() { return this._currentHeadPose } onBeforeRender(i) { var e; if (!i) return; const t = this.context.renderer.xr.getSession(); if (t) { const s = i.getViewerPose(this.context.renderer.xr.getReferenceSpace()); if (!s) return; this._currentHeadPose = s; const r = s?.transform; r && this._transformOrientation.set(r.orientation.x, r.orientation.y, r.orientation.z, r.orientation.w), ws._isInXr === !1 && t && this.onEnterXR(t, i); for (const n of this.controllers) n.onUpdate(t); this._isInAR && ((e = this.webAR) == null || e.onUpdate(t, i)) } ws.events.dispatchEvent({ type: "xrUpdate", frame: i, xr: this.context.renderer.xr, rig: this.rig }) } onClickedARButton() { this._isInAR || (this._requestedAR = !0, this._requestedVR = !1, this.captureStateBeforeXR()) } onClickedVRButton() { if (!this._isInVR) { if (this._requestedVR) { this.onExitXR(null); return } this._requestedAR = !1, this._requestedVR = !0, this.captureStateBeforeXR(), this.ensureRig(); for (let i = 0; i < 2; i++)os.Create(this, i, this.gameObject, rp.PhysicalDevice); ws.events.dispatchEvent({ type: "requestVRSession" }) } } captureStateBeforeXR() { this.context.mainCamera && (this._originalCameraPosition.copy(xt(this.context.mainCamera)), this._originalCameraRotation.copy(_s(this.context.mainCamera)), this._originalCameraParent = this.context.mainCamera.parent), this.Rig && (this._originalXRRigParent = this.Rig.parent, this._originalXRRigPosition.copy(this.Rig.position), this._originalXRRigRotation.copy(this.Rig.quaternion)) } ensureRig() { if (!this.rig) { const i = $.findObjectOfType(pb, this.context); i ? this.rig = i.gameObject : (this.rig = new wn, this.rig.rotateY(Math.PI), this.rig.name = "XRRig", this.context.scene.add(this.rig)) } } onEnterXR(i, e) { var t, s; console.log("[XR] session begin", i), ws._isInXr = !0, this.ensureRig(); const r = this.context.renderer.xr.getReferenceSpace(); if (r && this.rig) { const a = e.getViewerPose(r), l = a?.transform.orientation; if (l) { const c = new we(l.x, l.y, l.z, l.w), h = new ps().setFromQuaternion(c); this.rig.rotateY(h.y) } } const n = this.context.renderer.xr; if (this.context.mainCamera) { const a = n.getCamera(this.context.mainCamera), l = (t = this.context.mainCameraComponent) == null ? void 0 : t.cullingMask; if (l !== void 0) { for (const c of a.cameras) c.layers.mask = l; a.layers.mask = l } else { for (const c of a.cameras) c.layers.enableAll(); a.layers.enableAll() } this.rig.add(this.context.mainCamera), this._requestedAR && this.context.scene.add(this.rig) } const o = this._requestedAR ? rs.AR : rs.VR; switch (Xo.Global.Set(o), o) { case rs.AR: this.context.xrSessionMode = yg.ImmersiveAR, this._isInAR = !0, (s = this.webAR) == null || s.onBegin(i); break; case rs.VR: this.context.xrSessionMode = yg.ImmersiveVR, this._isInVR = !0, this.onEnterVR(i); break }i.addEventListener("end", () => { console.log("[XR] session end"), ws._isInXr = !1, this.onExitXR(i) }), this.onEnterXR_HandleMirrorWindow(i), ws.events.dispatchEvent({ type: "xrStarted", session: i }) } onExitXR(i) { var e, t, s; const r = this._isInAR; this._isInAR && i && ((e = this.webAR) == null || e.onEnd(i)), this._isInAR = !1, this._isInVR = !1, this._requestedAR = !1, this._requestedVR = !1, this.context.xrSessionMode = void 0, this.xrMirrorWindow && (this.xrMirrorWindow.close(), this.xrMirrorWindow = null), this.destroyControllers(), this.context.mainCamera && ((t = this._originalCameraParent) == null || t.add(this.context.mainCamera), ts(this.context.mainCamera, this._originalCameraPosition), Dr(this.context.mainCamera, this._originalCameraRotation), this.context.mainCamera.scale.set(1, 1, 1)), r && ((s = this._originalXRRigParent) == null || s.add(this.rig), this.rig.position.copy(this._originalXRRigPosition), this.rig.quaternion.copy(this._originalXRRigRotation)), Xo.Global.Set(rs.Browser | rs.ThirdPerson), ws.events.dispatchEvent({ type: "xrStopped", session: i }) } onEnterVR(i) { } destroyControllers() { var i; for (let e = this.controllers.length - 1; e >= 0; e -= 1)(i = this.controllers[e]) == null || i.destroy(); this.controllers.length = 0 } onEnterXR_HandleMirrorWindow(i) { oe("mirror") && setTimeout(() => { if (!ws.IsInWebXR) return; const e = new URL(window.location.href); rf(e.searchParams, Ny, 1), rf(e.searchParams, "isMirror", 1); const t = e.toString(); this.xrMirrorWindow = window.open(t, "webxr sync", "popup=yes"), this.xrMirrorWindow && (this.xrMirrorWindow.onload = () => { this.xrMirrorWindow && (this.xrMirrorWindow.onbeforeunload = () => { ws.IsInWebXR && i.end() }) }) }, 1e3) } }, u(ap, "_isInXr", !1), u(ap, "events", new ms), u(ap, "_optionalFeatures_VR", ["local-floor", "bounded-floor", "hand-tracking", "high-fixed-foveation-level", "layers"]), u(ap, "_optionalFeatures_AR", ["anchors", "local-floor", "hand-tracking", "layers"]), ap); let wt = ws; op([x()], wt.prototype, "enableVR", 2), op([x()], wt.prototype, "enableAR", 2), op([x(or)], wt.prototype, "defaultAvatar", 2), op([x()], wt.prototype, "handModelPath", 2), op([x()], wt.prototype, "createVRButton", 2), op([x()], wt.prototype, "createARButton", 2); const rm = class { constructor(i) { u(this, "_webxr"), u(this, "reticle", null), u(this, "reticleParent", null), u(this, "hitTestSource", null), u(this, "reticleActive", !0), u(this, "previousBackground", null), u(this, "previousEnvironment", null), u(this, "sessionRoot", null), u(this, "_previousParent", null), u(this, "arDomOverlay", null), u(this, "arOverlayElement", null), u(this, "noHitTestAvailable", !1), u(this, "didPlaceARSessionRoot", !1), this._webxr = i } get webxr() { return this._webxr } get context() { return this.webxr.context } getAROverlayContainer() { this.arDomOverlay = this.webxr.context.domElement; const i = this.arDomOverlay; return i.getAROverlayContainer ? this.arOverlayElement = i.getAROverlayContainer() : this.arOverlayElement = this.arDomOverlay, this.arOverlayElement } setReticleActive(i) { this.reticleActive = i } async onBegin(i) { var e, t, s, r; const n = this.webxr.context; this.reticleActive = !0, this.didPlaceARSessionRoot = !1, this.getAROverlayContainer(); const o = (e = navigator.userAgent) != null && e.includes("OculusBrowser") ? rp.PhysicalDevice : rp.Touch, a = o === rp.Touch ? 4 : 2; for (let c = 0; c < a; c++)os.Create(this.webxr, c, this.webxr.gameObject, o); (!this.sessionRoot || this.sessionRoot.destroyed || !this.sessionRoot.activeAndEnabled) && (this.sessionRoot = $.findObjectOfType(Cc, n)), this.previousBackground = n.scene.background, this.previousEnvironment = n.scene.environment, n.scene.background = null, i.requestReferenceSpace("viewer").then(c => { var h, d; (d = (h = i.requestHitTestSource) == null ? void 0 : h.call(i, { space: c })) == null || d.then(p => { this.hitTestSource = p }).catch(p => { this.noHitTestAvailable = !0, console.warn("WebXR: Hit test not supported", p) }) }), !this.reticle && this.sessionRoot && (this.reticle = new ye(new Kp(.07, .09, 32).rotateX(-Math.PI / 2), new di), this.reticle.name = "AR Placement reticle", this.reticle.matrixAutoUpdate = !1, this.reticle.visible = !1, this.reticleParent = new Me, this.reticleParent.name = "AR Reticle Parent", this.reticleParent.matrixAutoUpdate = !1, this.reticleParent.add(this.reticle), this.webxr.scene ? (this.context.scene.add(this.reticleParent), this.context.scene.visible = !0) : console.warn("Could not found WebXR Rig")), this._previousParent = this.webxr.gameObject, rm.tempWebXRObject || (rm.tempWebXRObject = new Me), this.context.scene.add(rm.tempWebXRObject), $.addComponent(rm.tempWebXRObject, this.webxr), this.sessionRoot ? (this.sessionRoot.webAR = this, (t = this.sessionRoot) == null || t.onBegin(i)) : console.warn("No WebARSessionRoot found in scene"); const l = this.context.domElement; (s = l?.onEnterAR) == null || s.call(l, i, this.arOverlayElement), (r = this.context.mainCameraComponent) == null || r.applyClearFlagsIfIsActiveCamera() } onEnd(i) { var e, t; this._previousParent && ($.addComponent(this._previousParent, this.webxr), this._previousParent = null), this.hitTestSource = null; const s = this.webxr.context; s.scene.background = this.previousBackground, s.scene.environment = this.previousEnvironment, this.sessionRoot && this.sessionRoot.onEnd(this.webxr.Rig, i); const r = this.context.domElement; (e = r.onExitAR) == null || e.call(r, i), (t = this.context.mainCameraComponent) == null || t.applyClearFlagsIfIsActiveCamera() } onUpdate(i, e) { var t, s; if (this.noHitTestAvailable === !0) { if (this.reticle && (this.reticle.visible = !1), !this.didPlaceARSessionRoot) { this.didPlaceARSessionRoot = !0; const n = this.webxr.Rig, o = tee.clone(); (t = this.sessionRoot) == null || t.placeAt(n, o) } return } if (!this.hitTestSource) return; const r = e.getHitTestResults(this.hitTestSource); if (r.length) { const n = r[0], o = this.webxr.context.renderer.xr.getReferenceSpace(); if (o) { const a = n.getPose(o); if (this.sessionRoot) { const l = this.sessionRoot.onUpdate(this.webxr.Rig, i, a); this.didPlaceARSessionRoot = l } if (this.reticle && (this.reticle.visible = this.reticleActive, this.reticleActive && a)) { const l = a.transform.matrix; this.reticle.matrix.fromArray(l), this.webxr.Rig && this.reticle.matrix.premultiply(this.webxr.Rig.matrix) } } } else (s = this.sessionRoot) == null || s.onUpdate(this.webxr.Rig, i, null), this.reticle && (this.reticle.visible = !1) } }; let nm = rm; u(nm, "tempWebXRObject"); const tee = new He().identity().makeTranslation(0, 0, 0); class Xh { constructor(e, t) { u(this, "used", !1), u(this, "inputSource"), u(this, "object"), u(this, "pointerId"), u(this, "isDown"), u(this, "isUp"), u(this, "isPressed"), u(this, "isClicked"), u(this, "input"), u(this, "event"), this.event = t, this.input = e } use() { this.used = !0, this.pointerId !== void 0 && this.input.setPointerUsed(this.pointerId) } stopPropagation() { var e; (e = this.event) == null || e.stopImmediatePropagation() } Use() { this.use() } StopPropagation() { var e; (e = this.event) == null || e.stopImmediatePropagation() } } class lp extends Ee { awake() { jn.createIfNoneExists(this.context) } onEnable() { var e; (e = jn.get(this.context)) == null || e.register(this) } onDisable() { var e; (e = jn.get(this.context)) == null || e.unregister(this) } performRaycast(e = null) { return null } } class Yh extends lp { constructor() { super(...arguments), u(this, "targets", null), u(this, "raycastHits", []) } start() { this.targets = [this.gameObject] } performRaycast(e = null) { return this.targets ? (e ?? (e = new co), e.targets = this.targets, e.results = this.raycastHits, this.context.physics.raycast(e)) : null } } class SE extends Yh { } const om = oe("debugeventsystem"); var EE = (i => (i.BeforeHandleInput = "BeforeHandleInput", i.AfterHandleInput = "AfterHandleInput", i))(EE || {}); const gl = class extends Ee { constructor() { super(), u(this, "raycaster", []), u(this, "_selectStartFn"), u(this, "_selectEndFn"), u(this, "_selectUpdateFn"), u(this, "_handleEventFn"), u(this, "lastPointerEvent", null), u(this, "objectsHoveredThisFrame", []), u(this, "objectsHoveredLastFrame", []), u(this, "raisedPointerDownEvents", []), u(this, "raisedPointerDownObjects", []), u(this, "_didMove", !1), u(this, "_tempComponentsArray", []), u(this, "_sortedHits", []), u(this, "_sortingBuffer", []), u(this, "_noDepthTestingResults", []), u(this, "handleEventsArray", []), u(this, "out", {}), u(this, "currentActiveMeshUIComponents", []), gl.systems.push(this) } static createIfNoneExists(i) { this.didSearchEventSystem || (this.didSearchEventSystem = !0, gl.systems.length <= 0 && gl.systems.push(...$.findObjectsOfType(gl, i))); for (const t of gl.systems) if (t.context === i) return; const e = new Me; $.addNewComponent(e, gl), i.scene.add(e) } static get systems() { const i = _t.Current; return this._eventSystemMap.has(i) || this._eventSystemMap.set(i, []), this._eventSystemMap.get(i) } static get(i) { const e = this._eventSystemMap.get(i); return e && e.length > 0 ? e[0] : null } static get instance() { return this.systems[0] } static ensureUpdateMeshUI(i, e) { ml.update(i, e) } static markUIDirty(i) { ml.markDirty() } get hasActiveUI() { return this.currentActiveMeshUIComponents.length > 0 } get isHoveringObjects() { return this.objectsHoveredThisFrame.length > 0 } onDestroy() { gl.systems.splice(gl.systems.indexOf(this), 1) } start() { if (this.raycaster.length <= 0 && !$.findObjectOfType(lp, this.context)) { const i = $.addNewComponent(this.context.scene, Yh); this.raycaster.push(i), Mn() && console.warn("Added an ObjectRaycaster to the scene because no raycaster was found", this) } } register(i) { var e; i && this.raycaster && !this.raycaster.includes(i) && ((e = this.raycaster) == null || e.push(i)) } unregister(i) { var e, t; const s = (e = this.raycaster) == null ? void 0 : e.indexOf(i); s !== void 0 && s !== -1 && ((t = this.raycaster) == null || t.splice(s, 1)) } onEnable() { const i = new Map; this._selectStartFn ?? (this._selectStartFn = (t, s) => { if (!s.grab) return; ml.resetLastSelected(); const r = new Xh(this.context.input); r.inputSource = t, r.isDown = t.selectionDown, r.isUp = t.selectionUp, r.isPressed = t.selectionPressed, r.isClicked = !1, i.set(t, s.grab), s.grab && !this.handleEvents(s.grab, r) && (s.grab = null) }), this._selectEndFn ?? (this._selectEndFn = (t, s) => { var r; if (!s.grab) return; const n = new Xh(this.context.input); n.inputSource = t, n.isDown = t.selectionDown, n.isUp = t.selectionUp, n.isPressed = t.selectionPressed, n.isClicked = t.selectionClick, this.handleEvents(s.grab, n); const o = i.get(t); if (i.set(t, null), o) for (let a = 0; a < this.raisedPointerDownEvents.length; a++) { const l = this.raisedPointerDownEvents[a]; this.raisedPointerDownObjects[a] === o && l && ((r = l.onPointerUp) == null || r.call(l, n), this.raisedPointerDownEvents.splice(a, 1), this.raisedPointerDownObjects.splice(a, 1), a--) } }); const e = new co; this._selectUpdateFn ?? (this._selectUpdateFn = t => { e.ray = t.getRay(); const s = this.performRaycast(e); if (!s) return; const r = new Xh(this.context.input); r.inputSource = t, this.handleIntersections(s, r) }), os.addEventListener(pl.SelectStart, this._selectStartFn), os.addEventListener(pl.SelectEnd, this._selectEndFn), os.addEventListener(pl.Update, this._selectUpdateFn), this._handleEventFn ?? (this._handleEventFn = this.onHandleEvents.bind(this)), this.context.pre_update_callbacks.push(this._handleEventFn) } onDisable() { os.removeEventListener(pl.SelectStart, this._selectStartFn), os.removeEventListener(pl.SelectEnd, this._selectEndFn), os.removeEventListener(pl.Update, this._selectUpdateFn), this.context.pre_update_callbacks.splice(this.context.pre_update_callbacks.indexOf(this._handleEventFn), 1) } onHandleEvents() { if (this.objectsHoveredThisFrame.length = 0, this.resetMeshUIStates(), wt.IsInWebXR || this.context.input.isKeyPressed("AltLeft") || this.context.input.isKeyPressed("AltRight")) return; if (!this._didMove) { const n = this.context.input.getPointerPositionRC(0); if (n && n.x === 0 && n.y === 0) return; this._didMove = !0 } let i = 0; for (const n of this.context.input.foreachPointerId()) { const o = this.context.input.getPointerDown(n), a = this.context.input.getPointerUp(n); if (o || a) { i = n; break } } const e = this.context.input.getPointerEvent(i), t = new Xh(this.context.input, e); t.inputSource = this.context.input, t.pointerId = i, t.isClicked = this.context.input.getPointerClicked(i), t.isDown = this.context.input.getPointerDown(i), t.isUp = this.context.input.getPointerUp(i), t.isPressed = this.context.input.getPointerPressed(i), om && t.isClicked && console.log("CLICK", i); const s = this.performRaycast(null); if (!s) return; this.lastPointerEvent = t; const r = { sender: this, args: t, hasActiveUI: this.currentActiveMeshUIComponents.length > 0 }; om && t.isClicked && Ls("EventSystem: " + t.pointerId + " - " + this.context.time.frame + " - Up:" + t.isUp + ", Down:" + t.isDown), this.dispatchEvent(new CustomEvent("BeforeHandleInput", { detail: r })), this.handleIntersections(s, t), this.dispatchEvent(new CustomEvent("AfterHandleInput", { detail: r })) } onBeforeRender() { if (this.lastPointerEvent) this.lastPointerEvent.used = !1; else return; if (this.lastPointerEvent.isUp) { for (const e of this.raisedPointerDownEvents) e.onPointerUp && e.onPointerUp(this.lastPointerEvent); this.raisedPointerDownEvents.length = 0, this.raisedPointerDownObjects.length = 0 } for (const e of this.objectsHoveredLastFrame) if (this.objectsHoveredThisFrame.indexOf(e) < 0) { this._tempComponentsArray.length = 0; const t = $.getComponentsInParent(e, Ee, this._tempComponentsArray); this.lastPointerEvent.object = e; for (let s = 0; s < t.length; s++) { const r = t[s]; if (!r.gameObject || r.destroyed) continue; const n = r; n.onPointerExit && n.onPointerExit(this.lastPointerEvent) } } const i = this.objectsHoveredLastFrame; this.objectsHoveredLastFrame = this.objectsHoveredThisFrame, this.objectsHoveredThisFrame = i } performRaycast(i) { if (!this.raycaster) return null; this._sortedHits.length = 0; for (const e of this.raycaster) { if (!e.activeAndEnabled) continue; const t = e.performRaycast(i); t && t.length > 0 && this._sortedHits.push(...t) } return this._sortedHits.sort((e, t) => e.distance - t.distance), this._sortedHits } handleIntersections(i, e) { if (!i || i.length <= 0) return !1; i = this.sortCandidates(i); for (const t of i) { const { object: s } = t; if (this.handleEvents(s, e)) return !0 } return !1 } sortCandidates(i) { this._sortingBuffer.length = 0, this._noDepthTestingResults.length = 0; for (let e = 0; e < i.length; e++) { const t = i[e], s = t.object; if (s.material && s.material.depthTest === !1) { this._noDepthTestingResults.push(t); continue } this._sortingBuffer.push(t) } for (const e of this._sortingBuffer) this._noDepthTestingResults.push(e); return this._noDepthTestingResults } handleEvents(i, e) { if (!this.testIsVisible(i)) return e.isClicked && om && console.log("not allowed", i), !1; const t = i; e.object = i, this.lastPointerEvent = e; const s = i.parent; let r = !1; const n = e.isClicked ?? !1; let o = null; if (s && s.isUI) { const a = (e.isPressed || e.isClicked) ?? !1; if (s[dl]) { const l = s[dl].gameObject; if (l) { if (!sp.isInteractable(l, this.out)) return !1; o = this.out.canvasGroup ?? null, this.handleMeshUIIntersection(i, a), i = l, r = !0 } } if (!r && this.handleMeshUiObjectWithoutShadowDom(s, a)) return !0 } if (n && om && console.log(this.context.time.frame, i), this.objectsHoveredThisFrame.push(i), o === null || o.interactable) { const a = this.objectsHoveredLastFrame.indexOf(i) >= 0; this.handleEventsArray.length = 0; const l = $.getComponentsInParent(i, Ee, this.handleEventsArray); for (let c = 0; c < l.length; c++) { if (e.used) return !0; if (l[c].destroyed) continue; const h = l[c]; if (h.interactable !== !1) { if (h.onPointerEnter && (a || h.onPointerEnter(e)), h.onPointerMove && h.onPointerMove(e), e.isDown && h.onPointerDown && !this.raisedPointerDownEvents.includes(h) && (h.onPointerDown(e), this.raisedPointerDownEvents.push(h), this.raisedPointerDownObjects.push(t)), e.isUp && h.onPointerUp) { const d = this.raisedPointerDownEvents.indexOf(h); d !== -1 && this.raisedPointerDownEvents.splice(d, 1), h.onPointerUp(e) } e.isClicked && h.onPointerClick && h.onPointerClick(e) } } } return !0 } handleMeshUiObjectWithoutShadowDom(i, e) { return !i || !i.isUI ? !0 : this.handleMeshUIIntersection(i, e) } handleMeshUIIntersection(i, e) { const t = ml.updateState(i, e); return t && this.currentActiveMeshUIComponents.push(t), t !== null } resetMeshUIStates() { if (this.context.input.getPointerPressedCount() > 0 && ml.resetLastSelected(), !(!this.currentActiveMeshUIComponents || this.currentActiveMeshUIComponents.length <= 0)) { for (let i = 0; i < this.currentActiveMeshUIComponents.length; i++) { const e = this.currentActiveMeshUIComponents[i]; ml.resetState(e) } this.currentActiveMeshUIComponents.length = 0 } } testIsVisible(i) { return i ? $.isActiveSelf(i) ? this.testIsVisible(i.parent) : !1 : !0 } }; let jn = gl; u(jn, "_eventSystemMap", new Map), u(jn, "didSearchEventSystem", !1); class ml { static markDirty() { this.needsUpdate = !0 } static update(e, t) { const s = t.time.frameCount; for (const r of this.lastUpdateFrame) if (r.context === t) { if (s === r.frame) return; r.frame = s; let n = this.needsUpdate || s < 1; r.nextUpdate === t.time.frameCount && (n = !0), n && (om && console.log("Update threemeshui"), this.needsUpdate = !1, e.update()); return } this.lastUpdateFrame = [{ context: t, frame: s, nextUpdate: s }], e.update() } static updateState(e, t) { let s = null; if (e && (s = this.findBlockInParent(e), s && s !== this.lastSelected)) { if (s.interactable === !1) return null; this.needsUpdate = !0 } return s } static resetLastSelected() { const e = this.lastSelected; e && (this.lastSelected = null, this.resetState(e)) } static resetState(e) { e && (this.needsUpdate = !0) } static findBlockInParent(e) { return e ? e.isBlock ? e : this.findBlockInParent(e.parent) : null } } u(ml, "lastSelected", null), u(ml, "lastUpdateFrame", []), u(ml, "needsUpdate", !1); const mb = Symbol("cameraController"); function iee(i) { return i[mb] } function PF(i, e, t) { t ? i[mb] = e : i[mb] === e && (i[mb] = null) } var see = Object.defineProperty, ree = Object.getOwnPropertyDescriptor, nee = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? ree(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && see(e, t, r), r }; const vb = oe("freecam"), oee = { LEFT: "", UP: "", RIGHT: "", BOTTOM: "" }; let ME; class Pc extends Ee { constructor() { super(...arguments), u(this, "autoRotate", !1), u(this, "autoRotateSpeed", 1), u(this, "enableKeys", !0), u(this, "enableDamping", !0), u(this, "dampingFactor", .1), u(this, "enableZoom", !0), u(this, "minZoom", 0), u(this, "maxZoom", 1 / 0), u(this, "enablePan", !0), u(this, "lookAtConstraint", null), u(this, "lookAtConstraint01", 1), u(this, "middleClickToFocus", !0), u(this, "doubleClickToFocus", !0), u(this, "useSlerp", !0), u(this, "debugLog", !1), u(this, "targetLerpSpeed", 5), u(this, "_lookTargetPosition"), u(this, "_controls", null), u(this, "_cameraObject", null), u(this, "_lerpToTargetPosition", !1), u(this, "_lerpCameraToTarget", !1), u(this, "_cameraTargetPosition", null), u(this, "_inputs", 0), u(this, "_enableTime", 0), u(this, "_startedListeningToKeyEvents", !1), u(this, "_eventSystem"), u(this, "_afterHandleInputFn"), u(this, "_camera", null), u(this, "_syncedTransform"), u(this, "targetElement", null), u(this, "_shouldDisable", !1) } get isCameraController() { return !0 } get controls() { return this._controls } get controllerObject() { return this._cameraObject } onStartInteraction(e) { var t; (t = this.controls) == null || t.addEventListener("start", e) } awake() { this._lookTargetPosition = new S, this._startedListeningToKeyEvents = !1 } start() { if (this._controls) { const e = $.getComponent(this.gameObject, Si); if (e && !this.setFromTargetPosition()) { this.debugLog && console.log("NO TARGET"); const t = new S(0, 0, -1).applyMatrix4(e.cam.matrixWorld); this.setTarget(t, !0) } } this.startCoroutine(this.startRaycastDelayed()), this._eventSystem = jn.get(this.context) ?? void 0, this._eventSystem && (this._afterHandleInputFn = this.afterHandleInput.bind(this), this._eventSystem.addEventListener(EE.AfterHandleInput, this._afterHandleInputFn)) } onDestroy() { var e, t; (e = this._controls) == null || e.dispose(), (t = this._eventSystem) == null || t.removeEventListener(EE.AfterHandleInput, this._afterHandleInputFn) } onEnable() { this._enableTime = this.context.time.time; const e = $.getComponent(this.gameObject, Si); this._camera = e; const t = e?.cam; if (t && PF(t, this, !0), !this._controls) { console.assert(t != null, "Missing camera", this), t && (this._cameraObject = t); const s = this.targetElement ?? this.context.domElement; this._controls = new OL(t, s), ME === void 0 && (ME = { ...this._controls.keys }) } this._controls && (vb && (this.enablePan = !0, this.enableZoom = !0, this.middleClickToFocus = !0, Su() && (this.doubleClickToFocus = !0)), this._controls.enableDamping = this.enableDamping, this._controls.keys = this.enableKeys ? ME : oee, this._controls.autoRotate = this.autoRotate, this._controls.autoRotateSpeed = this.autoRotateSpeed, this._controls.enableZoom = this.enableZoom, this._controls.addEventListener("start", this.onControlsChangeStarted.bind(this)), t?.type === "PerspectiveCamera" ? vb || (this._controls.minDistance = this.minZoom, this._controls.maxDistance = this.maxZoom) : vb || (this._controls.minZoom = this.minZoom, this._controls.maxZoom = this.maxZoom), this._controls.dampingFactor = this.dampingFactor, this._controls.enablePan = this.enablePan, this._startedListeningToKeyEvents || (this._startedListeningToKeyEvents = !0, this._controls.listenToKeyEvents(window.document.body))), this._syncedTransform = $.getComponent(this.gameObject, Ic) ?? void 0 } onDisable() { var e; (e = this._camera) != null && e.cam && PF(this._camera.cam, this, !1), this._controls && (this._controls.enabled = !1, this._controls.autoRotate = !1) } onControlsChangeStarted() { this._syncedTransform && this._syncedTransform.requestOwnership() } afterHandleInput(e) { e.detail.args.pointerId === 0 && (e.detail.args.isDown ? this._controls && this._eventSystem && (this._shouldDisable = this._eventSystem.hasActiveUI) : (!e.detail.args.isPressed || e.detail.args.isUp) && (this._shouldDisable = !1)) } *startRaycastDelayed() { if (yield, !this.setFromTargetPosition()) { const e = new co; e.screenPoint = new W(0, 0), e.lineThreshold = .1; const t = this.context.physics.raycast(e); t.length > 0 && this.setTarget(t[0].point, !0) } } onBeforeRender() { var e, t, s; if (!this._controls || this._cameraObject !== this.context.mainCamera) return; (this.context.input.getPointerDown(0) || this.context.input.getPointerDown(1) || this.context.input.getPointerDown(2)) && (this._inputs += 1), this._inputs > 0 && (this.autoRotate = !1, this._controls.autoRotate = !1, this._lerpCameraToTarget = !1, this._lerpToTargetPosition = !1), this._inputs = 0; let r = this.middleClickToFocus && this.context.input.getPointerClicked(1); if (r || (r = this.doubleClickToFocus && this.context.input.getPointerDoubleClicked(0) && this.context.time.time - this._enableTime > .3), r ? this.setTargetFromRaycast() : (this.context.input.getPointerDown(0) || this.context.input.mouseWheelChanged) && (this._lerpToTargetPosition = !1, this._lerpCameraToTarget = !1), this._lerpToTargetPosition || this._lerpCameraToTarget) { const n = this.context.time.deltaTime * this.targetLerpSpeed; if (this._lerpCameraToTarget && this._cameraTargetPosition && this._cameraObject) { if (this.useSlerp) { const o = (e = this._cameraObject) == null ? void 0 : e.position; pB(o, this._cameraTargetPosition, n) } else (t = this._cameraObject) == null || t.position.lerp(this._cameraTargetPosition, n); this._cameraObject.position.distanceTo(this._cameraTargetPosition) < 1e-4 && (this._lerpCameraToTarget = !1) } this._lerpToTargetPosition && (this.lerpTarget(this._lookTargetPosition, n), this._lookTargetPosition.distanceTo(this._controls.target) < 1e-5 && (this._lerpToTargetPosition = !1)) } !vb && (s = this.lookAtConstraint) != null && s.locked && this.setFromTargetPosition(0, this.lookAtConstraint01), this._controls && !this.context.isInXR && (this.debugLog && (this._controls.domElement = this.context.renderer.domElement), this._controls.enabled = !this._shouldDisable && this._camera === this.context.mainCameraComponent, this._controls.update()) } setCameraTarget(e, t = !1) { var s; e ? (this._lerpCameraToTarget = !0, this._cameraTargetPosition = e.clone(), t && this._cameraTargetPosition && ((s = this.controllerObject) == null || s.position.copy(this._cameraTargetPosition))) : this._lerpCameraToTarget = !1 } setFromTargetPosition(e = 0, t = 1) { var s; if (!this._controls) return !1; const r = (s = this.lookAtConstraint) == null ? void 0 : s.sources; if (r && r.length > 0) { const n = r[e]; if (n) return n.getWorldPosition(this._lookTargetPosition), this.lerpTarget(this._lookTargetPosition, t), !0 } return !1 } setTarget(e = null, t = !1) { this._controls && (e !== null && this._lookTargetPosition.copy(e), t ? this._controls.target.copy(this._lookTargetPosition) : this._lerpToTargetPosition = !0) } lerpTarget(e, t) { this._controls && this._controls.target.lerp(e, t) } distanceToTarget(e) { return this._controls ? this._controls.target.distanceTo(e) : -1 } setTargetFromRaycast() { var e, t; if (!this.controls) return; const s = this.context.physics.raycast(); for (const r of s) if (r.distance > 0 && $.isActiveInHierarchy(r.object)) { if (this._lookTargetPosition.copy(r.point), this._lerpToTargetPosition = !0, this._cameraTargetPosition = null, this.context.mainCamera) { this._lerpCameraToTarget = !0; const n = xt(this.context.mainCamera); this._cameraTargetPosition = n.clone().sub(this.controls.target).add(this._lookTargetPosition), (t = (e = this._cameraObject) == null ? void 0 : e.parent) == null || t.worldToLocal(this._cameraTargetPosition) } break } } fitCameraToObjects(e, t = 1.5) { const s = this._cameraObject, r = this._controls; if (!s || !r) return; const n = new S, o = new S, a = new er; a.makeEmpty(); for (const p of e) a.expandByObject(p); a.getSize(n), a.getCenter(o); const l = Math.max(n.x, n.y, n.z) / (2 * Math.atan(Math.PI * s.fov / 360)), c = l / s.aspect, h = t * Math.max(l, c), d = r.target.clone().sub(s.position).normalize().multiplyScalar(h); r.maxDistance = h * 10, r.minDistance = h * .01, r.target.copy(o), s.near = h / 100, s.far = h * 100, s.updateProjectionMatrix(), s.position.copy(r.target).sub(d), r.update() } } nee([x(zg)], Pc.prototype, "lookAtConstraint", 2); var aee = Object.defineProperty, lee = Object.getOwnPropertyDescriptor, Qn = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? lee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && aee(e, t, r), r }, BF = (i => (i[i.Skybox = 1] = "Skybox", i[i.SolidColor = 2] = "SolidColor", i[i.Uninitialized = 4] = "Uninitialized", i))(BF || {}); const am = oe("debugcam"), kF = oe("debugscreenpointtoray"); var Ab; const lm = (Ab = class extends Ee { constructor() { super(...arguments), u(this, "_nearClipPlane", .1), u(this, "_farClipPlane", 1e3), u(this, "orthographic", !1), u(this, "orthographicSize", 5), u(this, "ARBackgroundAlpha", 0), u(this, "_cullingMask", 4294967295), u(this, "_backgroundBlurriness"), u(this, "_backgroundIntensity"), u(this, "_targetTexture", null), u(this, "_backgroundColor"), u(this, "_fov"), u(this, "_cam", null), u(this, "_clearFlags", 2), u(this, "_skybox") } get isCamera() { return !0 } get aspect() { return this._cam instanceof Xt ? this._cam.aspect : this.context.domWidth / this.context.domHeight } get fieldOfView() { return this._cam instanceof Xt ? this._cam.fov : this._fov } set fieldOfView(i) { const e = this._fov != i; if (this._fov = i, e && this._cam && this._cam instanceof Xt) { if (this._fov === void 0) { console.error("Can not set undefined fov on PerspectiveCamera"); return } this._cam.fov = this._fov, this._cam.updateProjectionMatrix() } } get nearClipPlane() { return this._nearClipPlane } set nearClipPlane(i) { const e = this._nearClipPlane != i; this._nearClipPlane = i, this._cam && e && (this._cam.near = i, this._cam.updateProjectionMatrix()) } get farClipPlane() { return this._farClipPlane } set farClipPlane(i) { const e = this._farClipPlane != i; this._farClipPlane = i, this._cam && e && (this._cam.far = i, this._cam.updateProjectionMatrix()) } get clearFlags() { return this._clearFlags } set clearFlags(i) { i !== this._clearFlags && (this._clearFlags = i, this.applyClearFlagsIfIsActiveCamera()) } set cullingMask(i) { this._cullingMask = i, this._cam && (this._cam.layers.mask = i) } get cullingMask() { return this._cam ? this._cam.layers.mask : this._cullingMask } set backgroundBlurriness(i) { i !== this._backgroundBlurriness && (i === void 0 ? this._backgroundBlurriness = void 0 : this._backgroundBlurriness = Math.min(Math.max(i, 0), 1), this.applyClearFlagsIfIsActiveCamera()) } get backgroundBlurriness() { return this._backgroundBlurriness } set backgroundIntensity(i) { i !== this._backgroundIntensity && (i === void 0 ? this._backgroundIntensity = void 0 : this._backgroundIntensity = Math.min(Math.max(i, 0), 10), this.applyClearFlagsIfIsActiveCamera()) } get backgroundIntensity() { return this._backgroundIntensity } get backgroundColor() { return this._backgroundColor ?? null } set backgroundColor(i) { if (i) { if (this._backgroundColor) this._backgroundColor.copy(i); else { if (!i.clone) return; this._backgroundColor = i.clone() } i.alpha === void 0 && (this._backgroundColor.alpha = 1), this.applyClearFlagsIfIsActiveCamera() } } set targetTexture(i) { this._targetTexture = i } get targetTexture() { return this._targetTexture } get cam() { return this.activeAndEnabled && this.buildCamera(), this._cam } screenPointToRay(i, e, t) { let s = this.cam; const r = lm._origin; r.set(i, e, -1), this.context.input.convertScreenspaceToRaycastSpace(r), kF && console.log("screenPointToRay", i.toFixed(2), e.toFixed(2), "now:", r.x.toFixed(2), r.y.toFixed(2), "isInXR:" + this.context.isInXR), r.z = -1, r.unproject(s); const n = lm._direction.set(r.x, r.y, r.z), o = xt(s); return n.sub(o), n.normalize(), t ? (t.set(o, n), t) : new Oa(o.clone(), n.clone()) } awake() { this.sourceId || console.warn("Camera has no source - the camera should be exported inside a gltf", this.name), kF && window.addEventListener("pointerdown", i => { const e = i.clientX, t = i.clientY; console.log("touch", e.toFixed(2), t.toFixed(2)); const s = this.screenPointToRay(e, t), r = "#" + Math.floor(Math.random() * 16777215).toString(16); Wo.DrawRay(s.origin, s.direction, r, 10) }) } onEnable() { am && console.log(this), this.buildCamera(), (this.tag == "MainCamera" || !this.context.mainCameraComponent) && (this.context.setCurrentCamera(this), hee(this)), this.applyClearFlagsIfIsActiveCamera() } onDisable() { this.context.removeCamera(this) } onBeforeRender() { if (this._cam && this._targetTexture) { this.context.isManagedExternally && (this._warnedAboutExternalRenderer || (this._warnedAboutExternalRenderer = !0, console.warn("Rendering with external renderer is not supported yet. This may not work or throw errors. Please remove the the target texture from your camera: " + this.name, this.targetTexture))), this.context.composer; const i = this.context.renderer; i && this._targetTexture.render(this.context.scene, this._cam, i) } } buildCamera() { if (this._cam) return; const i = this.gameObject.isCamera; let e = null; if (i ? (e = this.gameObject, e?.layers.enableAll(), e instanceof Xt && (this._fov = e.fov)) : e = this.gameObject.children[0], e && e.isCamera) e.type === "PerspectiveCamera" && (this._fov && (e.fov = this._fov), e.near = this._nearClipPlane, e.far = this._farClipPlane, e.updateProjectionMatrix()); else if (!this.orthographic) e = new Xt(this.fieldOfView, window.innerWidth / window.innerHeight, this._nearClipPlane, this._farClipPlane), this.fieldOfView && (e.fov = this.fieldOfView), this.gameObject.add(e); else { const t = this.orthographicSize * 100; e = new Yu(window.innerWidth / -t, window.innerWidth / t, window.innerHeight / t, window.innerHeight / -t, this._nearClipPlane, this._farClipPlane), this.gameObject.add(e) } this._cam = e, this._cam.layers.mask = this._cullingMask, this.tag == "MainCamera" && this.context.setCurrentCamera(this) } applyClearFlagsIfIsActiveCamera() { this.context.mainCameraComponent === this && this.applyClearFlags() } applyClearFlags() { if (!this._cam) { am && console.log("Camera does not exist (apply clear flags)"); return } switch (am && Ls("apply Camera clear flags: " + this._clearFlags), this._clearFlags) { case 1: if (lm.backgroundShouldBeTransparent(this.context) && (!this.ARBackgroundAlpha || this.ARBackgroundAlpha < .001)) { this.context.scene.background = null, this.context.renderer.setClearColor(0, 0); return } this.enableSkybox(), this._backgroundBlurriness !== void 0 && (this.context.scene.backgroundBlurriness = this._backgroundBlurriness), this._backgroundIntensity !== void 0 && (this.context.scene.backgroundIntensity = this._backgroundIntensity); break; case 2: if (this._backgroundColor) { let i = this._backgroundColor.alpha; lm.backgroundShouldBeTransparent(this.context) && (i = this.ARBackgroundAlpha ?? 0), this.context.scene.background = null, this.context.renderer.setClearColor(this._backgroundColor, i) } break; case 4: this.context.scene.background = null, this.context.renderer.setClearColor(0, 0); break } } enableSkybox() { this._skybox || (this._skybox = new cee(this)), this._skybox.enable() } static backgroundShouldBeTransparent(i) { var e, t, s, r; const n = (e = i.renderer.xr) == null ? void 0 : e.getSession(); if (!n) return !1; const o = n.environmentBlendMode; am && Ls("Environment blend mode: " + o + " on " + navigator.userAgent); const a = o === "additive" || o === "alpha-blend"; return i.xrSessionMode === yg.ImmersiveAR && o === "opaque" && ((t = navigator.userAgent) != null && t.includes("OculusBrowser") || (s = navigator.userAgent) != null && s.includes("Mozilla") && (r = navigator.userAgent) != null && r.includes("Mobile WebXRViewer/v2")) ? !0 : a } }, u(Ab, "_origin", new S), u(Ab, "_direction", new S), Ab); let Si = lm; Qn([x()], Si.prototype, "fieldOfView", 1), Qn([x()], Si.prototype, "nearClipPlane", 1), Qn([x()], Si.prototype, "farClipPlane", 1), Qn([x()], Si.prototype, "clearFlags", 1), Qn([x()], Si.prototype, "orthographic", 2), Qn([x()], Si.prototype, "orthographicSize", 2), Qn([x()], Si.prototype, "ARBackgroundAlpha", 2), Qn([x()], Si.prototype, "cullingMask", 1), Qn([x()], Si.prototype, "backgroundBlurriness", 1), Qn([x()], Si.prototype, "backgroundIntensity", 1), Qn([x(mi)], Si.prototype, "backgroundColor", 1), Qn([x(jd)], Si.prototype, "targetTexture", 1); class cee { constructor(e) { u(this, "_camera"), u(this, "_skybox"), this._camera = e } get context() { var e; return (e = this._camera) == null ? void 0 : e.context } enable() { this._skybox = this.context.lightmaps.tryGetSkybox(this._camera.sourceId), this._skybox ? this.context.scene.background !== this._skybox && (am && console.log("Set skybox", this._camera, this._skybox), this._skybox.encoding = Xe, this._skybox.mapping = An, this.context.scene.background = this._skybox) : console.warn("Failed to load/find skybox texture", this._camera.sourceId, this.context.lightmaps) } } function hee(i) { oe("freecam") && i.context.mainCameraComponent === i && $.getOrAddComponent(i.gameObject, Pc) } class cp extends Ee { constructor() { super(...arguments), u(this, "_listener", null) } get listener() { return this._listener == null && (this._listener = new $w), this._listener } awake() { ss.registerWaitForAllowAudio(() => { if (this.destroyed) return; const e = this.listener; if (e == null || e.parent) return; const t = $.getComponentInParent(this.gameObject, Si); t ? t.cam.add(e) : this.gameObject.add(e) }) } } var uee = Object.defineProperty, dee = Object.getOwnPropertyDescriptor, yb = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? dee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && uee(e, t, r), r }; class cm { constructor() { u(this, "guid") } } yb([x()], cm.prototype, "guid", 2); class hp { constructor() { u(this, "signal"), u(this, "reaction") } } yb([x(cm)], hp.prototype, "signal", 2), yb([x(Nr)], hp.prototype, "reaction", 2); var IE; const vl = (IE = class extends Ee { constructor() { super(...arguments), u(this, "events") } static invoke(i) { if (vl.receivers[i]) { const e = vl.receivers[i]; if (!e) return; for (const t of e) t.invoke(i) } } onEnable() { if (this.events) for (const i of this.events) vl.receivers[i.signal.guid] || (vl.receivers[i.signal.guid] = []), vl.receivers[i.signal.guid].push(this) } onDisable() { if (this.events) { for (const i of this.events) if (vl.receivers[i.signal.guid]) { const e = vl.receivers[i.signal.guid].indexOf(this); e >= 0 && vl.receivers[i.signal.guid].splice(e, 1) } } } invoke(i) { if (!this.events || !Array.isArray(this.events)) return; let e = typeof i == "object" ? i.guid : i; for (const t of this.events) if (t.signal.guid === e) try { if (t.reaction) { if (!t.reaction.invoke) { console.warn("Missing invoke - possibly a serialization error", t, this); continue } } else { console.warn("Missing reaction for signal", t, this); continue } t.reaction.invoke() } catch (s) { console.error(s) } } }, u(IE, "receivers", {}), IE); let up = vl; yb([x(hp)], up.prototype, "events", 2); var ln = (i => (i.Activation = "ActivationTrack", i.Animation = "AnimationTrack", i.Audio = "AudioTrack", i.Control = "ControlTrack", i.Marker = "MarkerTrack", i.Signal = "SignalTrack", i))(ln || {}), Bc = (i => (i[i.None = 0] = "None", i[i.Hold = 1] = "Hold", i[i.Loop = 2] = "Loop", i[i.PingPong = 3] = "PingPong", i[i.Continue = 4] = "Continue", i))(Bc || {}), TE = (i => (i.Signal = "SignalEmitter", i))(TE || {}); const hm = oe("debugtimeline"), RE = class extends Ee { constructor() { super(...arguments), u(this, "playableAsset"), u(this, "playOnAwake"), u(this, "extrapolationMode", 1), u(this, "waitForAudio", !0), u(this, "_visibilityChangeEvt"), u(this, "_clonedPlayableAsset", !1), u(this, "_speed", 1), u(this, "_guidsMap"), u(this, "_isPlaying", !1), u(this, "_internalUpdateRoutine"), u(this, "_isPaused", !1), u(this, "_time", 0), u(this, "_duration", 0), u(this, "_weight", 1), u(this, "_animationTracks", []), u(this, "_audioTracks", []), u(this, "_signalTracks", []), u(this, "_controlTracks", []), u(this, "_customTracks", []), u(this, "_allTracks", [this._animationTracks, this._audioTracks, this._signalTracks, this._controlTracks, this._customTracks]) } static registerCreateTrack(i, e) { this.createTrackFunctions[i] = e } get isPlaying() { return this._isPlaying } get isPaused() { return this._isPaused } get time() { return this._time } set time(i) { typeof i == "number" && !Number.isNaN(i) ? this._time = i : (hm || dr()) && console.error("INVALID TIMELINE.TIME VALUE", i, this.name) } get duration() { return this._duration } set duration(i) { this._duration = i } get weight() { return this._weight } set weight(i) { this._weight = i } get speed() { return this._speed } set speed(i) { this._speed = i } awake() { var i, e, t; hm && console.log(this, (i = this.playableAsset) == null ? void 0 : i.tracks), this.rebuildGraph(), this.isValid() || console.warn("PlayableDirector is not valid", this.playableAsset, (e = this.playableAsset) == null ? void 0 : e.tracks, Array.isArray((t = this.playableAsset) == null ? void 0 : t.tracks), this) } onEnable() { var i, e; for (const t of this._audioTracks) (i = t.onEnable) == null || i.call(t); for (const t of this._customTracks) (e = t.onEnable) == null || e.call(t); this.playOnAwake && this.play(), this._visibilityChangeEvt || (this._visibilityChangeEvt = () => { switch (document.visibilityState) { case "hidden": this.setAudioTracksAllowPlaying(!1); break; case "visible": this.setAudioTracksAllowPlaying(!0); break } }), window.addEventListener("visibilitychange", this._visibilityChangeEvt) } onDisable() { var i, e; this.stop(); for (const t of this._audioTracks) (i = t.onDisable) == null || i.call(t); for (const t of this._customTracks) (e = t.onDisable) == null || e.call(t); this._visibilityChangeEvt && window.removeEventListener("visibilitychange", this._visibilityChangeEvt) } onDestroy() { var i; for (const e of this._allTracks) for (const t of e) (i = t.onDestroy) == null || i.call(t) } rebuildGraph() { this.isValid() && (this.resolveBindings(), this.updateTimelineDuration(), this.setupAndCreateTrackHandlers()) } async play() { if (!this.isValid()) return; const i = this._isPaused == !0; if (this._isPaused = !1, i && this.invokePauseChangedMethodsOnTracks(), !this._isPlaying) { if (this._isPlaying = !0, this.waitForAudio) { const e = []; for (const t of this._audioTracks) { const s = t.loadAudio(this._time, 1, 0); s && e.push(s) } if (e.length > 0 && (await Promise.all(e), !this._isPlaying)) return; for (; this._audioTracks.length > 0 && this._isPlaying && !ss.userInteractionRegistered && this.waitForAudio;)await nf(200) } this._internalUpdateRoutine = this.startCoroutine(this.internalUpdate()) } } pause() { this.isValid() && (this._isPlaying = !1, !this._isPaused && (this._isPaused = !0, this.evaluate(), this.invokePauseChangedMethodsOnTracks())) } stop() { for (const t of this._audioTracks) t.stop(); const i = this._isPaused == !0, e = this._isPlaying; this._isPlaying && (this._time = 0, this._isPlaying = !1, this._isPaused = !1, this.evaluate(), i && this.invokePauseChangedMethodsOnTracks()), this._isPlaying = !1, this._isPaused = !1, i && !e && this.invokePauseChangedMethodsOnTracks(), this._internalUpdateRoutine && this.stopCoroutine(this._internalUpdateRoutine), this._internalUpdateRoutine = null } evaluate() { if (!this.isValid()) return; let i = this._time; switch (this.extrapolationMode) { case 0: this._speed > 0 ? i = Math.min(i, this._duration) : this._speed < 0 && (i = Math.max(i, 0)), this._time = i; break; case 1: i %= this._duration, this._time = i; break; case 2: if (i > this._duration) { this.stop(); return } break }this.internalEvaluate(i) } isValid() { return this.playableAsset && this.playableAsset.tracks && Array.isArray(this.playableAsset.tracks) } *forEachTrack() { for (const i of this._allTracks) for (const e of i) yield e } get audioTracks() { return this._audioTracks } resolveGuids(i) { this._guidsMap = i } invokePauseChangedMethodsOnTracks() { var i; for (const e of this.forEachTrack()) (i = e.onPauseChanged) == null || i.call(e) } *internalUpdate() { for (; this._isPlaying && this.activeAndEnabled;)!this._isPaused && this._isPlaying && (this._time += this.context.time.deltaTime * this.speed, this.evaluate()), yield } internalEvaluate(i) { for (const e of this.playableAsset.tracks) if (!e.muted) switch (e.type) { case ln.Activation: for (let t = 0; t < e.outputs.length; t++) { const s = e.outputs[t]; if (typeof s == "object") { let r = !1; for (const o of e.clips) o.start <= i && i <= o.end && (r = !0); const n = s; n.visible !== void 0 && (n.visible = r) } } break }for (const e of this._animationTracks) e.evaluate(i); for (const e of this._audioTracks) e.evaluate(i); for (const e of this._signalTracks) e.evaluate(i); for (const e of this._controlTracks) e.evaluate(i); for (const e of this._customTracks) e.evaluate(i) } resolveBindings() { if (this._clonedPlayableAsset || (this._clonedPlayableAsset = !0, this.playableAsset = Ov(this.playableAsset)), !this.playableAsset || !this.playableAsset.tracks) return; const i = this.findRoot(this.gameObject); for (const e of this.playableAsset.tracks) { for (let t = e.outputs.length - 1; t >= 0; t--) { let s = e.outputs[t]; if (typeof s == "string") { this._guidsMap && this._guidsMap[s] && (s = this._guidsMap[s]); const r = $.findByGuid(s, i); r === null || typeof r != "object" ? (e.outputs.splice(t, 1), console.warn("Failed to resolve binding", s, e.name, e.type)) : (hm && console.log("Resolved binding", s, "to", r), e.outputs[t] = r) } else if (s === null) { if (e.outputs.splice(t, 1), RE.createTrackFunctions[e.type]) continue; e.type !== ln.Audio && e.type !== ln.Control && e.type !== ln.Marker && e.type !== ln.Signal && console.warn("Missing binding", s, e.name, e.type, this.name, this.playableAsset.name) } } if (e.type === ln.Control) for (let t = 0; t < e.clips.length; t++) { const s = e.clips[t]; let r = s.asset.sourceObject; if (typeof r == "string") { this._guidsMap && this._guidsMap[r] && (r = this._guidsMap[r]); const n = $.findByGuid(r, i); n === null || typeof n != "object" ? console.warn("Failed to resolve sourceObject binding", r, e.name, s) : (hm && console.log("Resolved binding", r, "to", n), s.asset.sourceObject = n) } } } } findRoot(i) { return i.parent ? this.findRoot(i.parent) : i } updateTimelineDuration() { if (this._duration = 0, !(!this.playableAsset || !this.playableAsset.tracks)) { for (const i of this.playableAsset.tracks) if (i.muted !== !0) { for (const e of i.clips) e.end > this._duration && (this._duration = e.end); for (const e of i.markers) e.time > this._duration && (this._duration = e.time + .001) } } } setupAndCreateTrackHandlers() { var i, e; if (this._animationTracks.length = 0, this._audioTracks.length = 0, this._signalTracks.length = 0, !this.playableAsset) return; const t = $.findObjectOfType(cp, this.context); for (const s of this.playableAsset.tracks) { const r = s.type, n = RE.createTrackFunctions[r]; if (n != null) { const o = n(this, s); if (typeof o.evaluate == "function") { o.director = this, o.track = s, this._customTracks.push(o); continue } } if (s.type === ln.Animation) { if (s.clips.length <= 0) { hm && console.warn("Animation track has no clips", s); continue } for (let o = s.outputs.length - 1; o >= 0; o--) { let a = s.outputs[o]; if (a instanceof Me) { const c = $.getOrAddComponent(a, Fr); c && (a = c) } const l = (i = a?.gameObject) == null ? void 0 : i.animations; if (l) { const c = new bb; c.trackOffset = s.trackOffset, c.director = this, c.track = s; for (let h = 0; h < s.clips.length; h++) { const d = s.clips[h], p = d.asset; if (!p) { console.error("MISSING anim model?", "clip#" + h, d, s, this.playableAsset, this.name); continue } const f = p.clip; let g = f; if ((typeof g == "string" || typeof g == "number") && (g = l.find(v => v.name === f)), !g) { console.warn("Could not find animationClip for model", d, s.name, this.name, (e = this.playableAsset) == null ? void 0 : e.name); continue } c.mixer || (c.mixer = new i0(a.gameObject)), c.clips.push(g), c.mixer.uncacheAction(g), c.createHooks(d.asset, g); const m = c.mixer.clipAction(g); c.actions.push(m), c.models.push(d) } this._animationTracks.push(c) } } } else if (s.type === ln.Audio) { if (s.clips.length <= 0) continue; const o = new fm; if (o.director = this, o.track = s, this._audioTracks.push(o), !t) continue; o.listener = t.listener; for (let a = 0; a < s.clips.length; a++) { const l = s.clips[a]; o.addModel(l) } } else if (s.type === ln.Marker) { const o = new gm; o.director = this, o.track = s; for (const a of s.markers) switch (a.type) { case TE.Signal: o.models.push(a), o.didTrigger.push(!1); break }if (o !== null && o.models.length > 0) { const a = $.getComponent(this.gameObject, up); a && (o.receivers.push(a), this._signalTracks.push(o)) } } else if (s.type === ln.Signal) { const o = new gm; o.director = this, o.track = s; for (const a of s.markers) o.models.push(a), o.didTrigger.push(!1); for (const a of s.outputs) o.receivers.push(a); this._signalTracks.push(o) } else if (s.type === ln.Control) { const o = new _b; o.director = this, o.track = s; for (const a of s.clips) o.models.push(a); o.resolveSourceObjects(this.context), this._controlTracks.push(o) } } } setAudioTracksAllowPlaying(i) { for (const e of this._audioTracks) e.onAllowAudioChanged(i) } }; let um = RE; u(um, "createTrackFunctions", {}); const Jh = oe("debugtimeline"); class dm { constructor() { u(this, "director"), u(this, "track") } get muted() { return this.track.muted } set muted(e) { var t; e !== this.track.muted && (this.track.muted = e, (t = this.onMuteChanged) == null || t.call(this)) } *forEachClip(e = !1) { var t; if ((t = this.track) != null && t.clips) if (e) for (let s = this.track.clips.length - 1; s >= 0; s--)yield this.track.clips[s]; else for (const s of this.track.clips) yield s } getClipTime(e, t) { return t.clipIn + (e - t.start) * t.timeScale } getClipTimeNormalized(e, t) { return (e - t.start) / t.duration } evaluateWeight(e, t, s, r = !0) { if (t < 0 || t >= s.length) return 0; const n = s[t]; if (r || e >= n.start && e <= n.end) { let o = 1, a = !1; if (n.easeInDuration > 0) { const l = Math.min((e - n.start) / n.easeInDuration, 1); o *= l } if (n.easeOutDuration > 0 && !a) { const l = Math.min((n.end - e) / n.easeOutDuration, 1); o *= l } return o } return 0 } } class pee { constructor(e) { u(this, "clip"), u(this, "rootPositionOffset"), u(this, "rootQuaternionOffset"), u(this, "rootStartPosition"), u(this, "rootEndPosition"), u(this, "rootStartQuaternion"), u(this, "rootEndQuaternion"); const t = e.getClip(); this.clip = t; const s = e.getRoot(), r = s.name + ".position", n = s.name + ".quaternion"; Jh && console.log(t.name, t.tracks, r); for (const o of t.tracks) if (!(o.times.length <= 0)) { if (o.name.endsWith(r)) this.rootStartPosition = new S().fromArray(o.values, 0), this.rootEndPosition = new S().fromArray(o.values, o.values.length - 3), this.rootPositionOffset = this.rootEndPosition.clone().sub(this.rootStartPosition), Jh && console.log(this.rootPositionOffset); else if (o.name.endsWith(n) && (this.rootStartQuaternion = new we().fromArray(o.values, 0), this.rootEndQuaternion = new we().fromArray(o.values, o.values.length - 4), this.rootQuaternionOffset = this.rootEndQuaternion.clone().multiply(this.rootStartQuaternion), Jh)) { const a = new ps().setFromQuaternion(this.rootQuaternionOffset); console.log("ROT", a) } } } get hasOffsets() { return this.rootPositionOffset !== void 0 || this.rootQuaternionOffset !== void 0 } } class bb extends dm { constructor() { super(...arguments), u(this, "models", []), u(this, "trackOffset"), u(this, "target"), u(this, "mixer"), u(this, "clips", []), u(this, "actions", []), u(this, "_actionOffsets", []), u(this, "_didBind", !1), u(this, "_animator", null), u(this, "_animatorWasEnabled", !1), u(this, "_useclipOffsets", !0), u(this, "_totalOffsetPosition", new S), u(this, "_totalOffsetRotation", new we), u(this, "_totalOffsetPosition2", new S), u(this, "_totalOffsetRotation2", new we), u(this, "_summedPos", new S), u(this, "_tempPos", new S), u(this, "_summedRot", new we), u(this, "_tempRot", new we), u(this, "_clipRotQuat", new we) } onPauseChanged() { this._animator && this._animatorWasEnabled !== void 0 && (this._animator.enabled = this.director.isPlaying === !1 ? this._animatorWasEnabled : !1) } createHooks(e, t) { var s, r; if (((s = t.tracks) == null ? void 0 : s.length) <= 0) { console.warn("No tracks in AnimationClip", t); return } const n = t.tracks[0].name.split("."), o = n[n.length - 2], a = o + ".position", l = o + ".quaternion"; let c = !1, h = !1; for (const d of t.tracks) d.name.endsWith(a) ? (c = !0, this.createPositionInterpolant(t, e, d)) : d.name.endsWith(l) && (h = !0, this.createRotationInterpolant(t, e, d)); if (!c || !h) { const d = (r = this.mixer) == null ? void 0 : r.getRoot(), p = t.tracks[0], f = p.name.lastIndexOf("."), g = p.name.substring(0, f), m = g.substring(g.lastIndexOf(".") + 1), v = d.getObjectByName(m); if (v) if (c) { if (!h) { const A = t.tracks[0].name.substring(0, f) + ".quaternion"; Jh && console.warn("Create quaternion track", m, v); const b = v.quaternion, y = new ko(A, [0, t.duration], [b.x, b.y, b.z, b.w, b.x, b.y, b.z, b.w]); t.tracks.push(y), this.createRotationInterpolant(t, e, y) } } else { const A = g + ".position"; Jh && console.warn("Create position track", m, v); const b = v.position, y = new Xl(A, [0, t.duration], [b.x, b.y, b.z, b.x, b.y, b.z]); t.tracks.push(y), this.createPositionInterpolant(t, e, y) } } } bind() { if (!this._didBind) { this._didBind = !0, Jh && console.log(this.models), this.mixer ? this.target = this.mixer.getRoot() : console.warn("No mixer was assigned to animation track"); for (const e of this.actions) { const t = new pee(e); this._actionOffsets.push(t) } this.target && (this._animator = $.getComponent(this.target, Fr) ?? null, this._animator ? (this._animatorWasEnabled = this._animator.enabled, this._animator.enabled = !1) : this._animatorWasEnabled = !1); for (const e of this.models) { const t = e.asset, s = t.position, r = t.rotation; s && s.x !== void 0 && (s.isVector3 || (t.position = new S(s.x, s.y, s.z)), r.isQuaternion || (t.rotation = new we(r.x, r.y, r.z, r.w))) } this.ensureTrackOffsets() } } ensureTrackOffsets() { if (this.trackOffset) { const e = this.trackOffset.position; e && (e.isVector3 || (this.trackOffset.position = new S(e.x, e.y, e.z))); const t = this.trackOffset.rotation; t && (t.isQuaternion || (this.trackOffset.rotation = new we(t.x, t.y, t.z, t.w))) } } evaluate(e) { if (this.track.muted || !this.mixer) return; this.bind(), this._animator && this.director.isPlaying && this.director.weight > 0 && (this._animator.enabled = !1), this._totalOffsetPosition.set(0, 0, 0), this._totalOffsetRotation.set(0, 0, 0, 1), this._totalOffsetPosition2.set(0, 0, 0), this._totalOffsetRotation2.set(0, 0, 0, 1); let t = 0, s = 0, r = !1, n = !1; for (let o = 0; o < this.clips.length; o++) { const a = this.models[o], l = this.actions[o], c = a.asset; l.weight = 0; const h = e >= a.start && e <= a.end, d = a.preExtrapolationMode, p = a.postExtrapolationMode, f = o < this.clips.length - 1 ? this.models[o + 1] : null; let g = h, m = !1; if (!g && !r && a.end < e && p !== Bc.None ? (!f || f.start > e) && (g = !0, r = !0) : o == 0 && !g && !n && a.start > e && d !== Bc.None && (!f || f.start < e) && (g = !0, m = !0, n = !0), g) { let v = 1; v *= this.evaluateWeight(e, o, this.models, g), v *= this.director.weight; let A = h; m && d !== Bc.Hold && (e += a.start, A = !0); let b = this.getClipTime(e, a), y = 0; const _ = c.duration; if (m && d === Bc.Hold && (b = 0), A) { if (c.loop) for (y += Math.floor(b / (_ + 1e-6)); b > _;)b -= _ } else if (!h) switch (p) { case Bc.Loop: b %= _; break; case Bc.PingPong: const E = Math.floor(b / _) % 2 !== 0; b %= _, E && (b = _ - b); break }a.reversed === !0 ? l.time = l.getClip().duration - b : l.time = b, l.timeScale = 0; const w = v; if (l.weight = w, l.clampWhenFinished = !0, l.isRunning() || l.play(), this._useclipOffsets) { const E = t == 0 ? this._totalOffsetPosition : this._totalOffsetPosition2, P = t == 0 ? this._totalOffsetRotation : this._totalOffsetRotation2; t < 1 && (s = 1 - v), t += 1; const C = this._summedPos.set(0, 0, 0), R = this._tempPos.set(0, 0, 0), T = this._summedRot.identity(), z = this._tempRot.identity(), H = c.rotation; H && (this._clipRotQuat.identity(), this._clipRotQuat.slerp(H, v)); const N = this._actionOffsets[o]; if (N.hasOffsets) for (let F = 0; F < y; F++)N.rootPositionOffset ? R.copy(N.rootPositionOffset) : R.set(0, 0, 0), R.applyQuaternion(T), this._clipRotQuat && R.applyQuaternion(this._clipRotQuat), N.rootQuaternionOffset && (z.copy(N.rootQuaternionOffset), T.multiply(z)), C.add(R); this._clipRotQuat && P.multiply(this._clipRotQuat), P.multiply(T), c.position && C.add(c.position), E.add(C) } } } this._useclipOffsets && (this._totalOffsetPosition.lerp(this._totalOffsetPosition2, s), this._totalOffsetRotation.slerp(this._totalOffsetRotation2, s)), this.mixer.update(e) } createRotationInterpolant(e, t, s) { var r; const n = s.createInterpolant.bind(s), o = new we; this.ensureTrackOffsets(); const a = (r = this.trackOffset) == null ? void 0 : r.rotation; s.createInterpolant = () => { const l = n(), c = l.evaluate.bind(l); return l.evaluate = h => { const d = c(h); return o.set(d[0], d[1], d[2], d[3]), o.premultiply(this._totalOffsetRotation), a && o.premultiply(a), d[0] = o.x, d[1] = o.y, d[2] = o.z, d[3] = o.w, d }, l } } createPositionInterpolant(e, t, s) { var r, n; const o = s.createInterpolant.bind(s), a = new S; this.ensureTrackOffsets(); const l = (r = this.trackOffset) == null ? void 0 : r.rotation, c = (n = this.trackOffset) == null ? void 0 : n.position; let h; s.createInterpolant = () => { const d = o(), p = d.evaluate.bind(d); return d.evaluate = f => { var g, m; const v = p(f); return a.set(v[0], v[1], v[2]), t.removeStartOffset && (h === void 0 ? (h = null, h = (m = (g = this._actionOffsets.find(A => A.clip === e)) == null ? void 0 : g.rootStartPosition) == null ? void 0 : m.clone()) : h != null && h.isVector3 && a.sub(h)), a.applyQuaternion(this._totalOffsetRotation), a.add(this._totalOffsetPosition), l && a.applyQuaternion(l), c && (a.x -= c.x, a.y += c.y, a.z += c.z), v[0] = a.x, v[1] = a.y, v[2] = a.z, v }, d } } } const fee = oe("mutetimeline"), pm = class extends dm { constructor() { super(...arguments), u(this, "models", []), u(this, "listener"), u(this, "audio", []), u(this, "audioContextTimeOffset", []), u(this, "lastTime", 0), u(this, "_audioLoader", null) } getAudioFilePath(i) { const e = this.director.sourceId; return Pl(e, i) } onAllowAudioChanged(i) { for (let e = 0; e < this.models.length; e++) { const t = this.models[e]; this.audio[e].setVolume(i ? t.asset.volume : 0) } } addModel(i) { const e = new t0(this.listener); this.audio.push(e), this.models.push(i) } onDisable() { for (const i of this.audio) i.isPlaying && i.stop() } onMuteChanged() { if (this.muted) for (let i = 0; i < this.audio.length; i++) { const e = this.audio[i]; e != null && e.isPlaying && e.stop() } } stop() { for (let i = 0; i < this.audio.length; i++) { const e = this.audio[i]; e != null && e.isPlaying && e.stop() } } evaluate(i) { if (fee || this.track.muted || this.director.speed < 0) return; const e = this.director.context.application.muted, t = e ? .1 : 0; for (let s = 0; s < this.models.length; s++) { const r = this.models[s], n = this.audio[s]; if ((!n || !n.buffer) && this.isInTimeRange(r, i - 1, i + 1) && this.handleAudioLoading(r, n), ss.userInteractionRegistered !== !1 && !(n === null || !n.buffer)) if (n.playbackRate = this.director.context.time.timeScale, n.loop = r.asset.loop, i >= r.start && i <= r.end && i < this.director.duration) { if (this.director.isPlaying == !1) { if (n.isPlaying && n.stop(), this.lastTime === i) continue } else if (!n.isPlaying) n.offset = r.clipIn + (i - r.start) * r.timeScale, n.play(t); else { const a = r.clipIn + (i - r.start) * r.timeScale, l = n.context.currentTime - n._startedAt + n.offset; Math.abs(a - l) > .3 && (n.offset = a, n.stop(), n.play(t)) } let o = r.asset.volume; if (e && (o = 0), r.easeInDuration > 0) { const a = Math.min((i - r.start) / r.easeInDuration, 1); o *= a } if (r.easeOutDuration > 0) { const a = Math.min((r.end - i) / r.easeOutDuration, 1); o *= a } n.setVolume(o * this.director.weight) } else n.isPlaying && n.stop() } this.lastTime = i } loadAudio(i, e = 0, t = 0) { let s = null; const r = i - t, n = i + e; for (const o of this.models) if (this.isInTimeRange(o, r, n)) { const a = this.audio[this.models.indexOf(o)], l = this.handleAudioLoading(o, a); l !== null && (s === null && (s = []), s.push(l)) } return s !== null ? Promise.all(s) : null } isInTimeRange(i, e, t) { return e <= i.start && t >= i.end || e >= i.start && e <= i.end || t >= i.start && t <= i.end } static dispose() { pm._currentlyLoading.clear() } handleAudioLoading(i, e) { this._audioLoader || (this._audioLoader = new $A); const t = this.getAudioFilePath(i.asset.clip); if (pm._currentlyLoading.get(t)) { const r = pm._currentlyLoading.get(t); return r.then(n => { n && e.setBuffer(n) }), r } Jh && console.warn("LOAD audio track", t, this.director.sourceId); const s = new Promise((r, n) => { this._audioLoader.load(t, o => { e.setBuffer(o), r(o) }, void 0, o => { console.error("Error loading audio", o), r(null) }) }); return pm._currentlyLoading.set(t, s), s } }; let fm = pm; u(fm, "_currentlyLoading", new Map); class gm extends dm { constructor() { super(...arguments), u(this, "models", []), u(this, "didTrigger", []), u(this, "receivers", []) } evaluate(e) { var t; if (!this.track.muted) for (let s = 0; s < this.models.length; s++) { const r = this.models[s], n = this.didTrigger[s], o = r.time - e; let a = !1; if (r.retroActive) a = o <= 1e-6; else { const l = Math.abs(o); l >= 1e-5 && l < .1 && (a = !0) } if (a) { if (!n) if (this.didTrigger[s] = !0, ((t = this.receivers) == null ? void 0 : t.length) <= 0) up.invoke(r.asset); else for (const l of this.receivers) l && l.invoke(r.asset) } else r.emitOnce || (this.didTrigger[s] = !1) } } } class _b extends dm { constructor() { super(...arguments), u(this, "models", []), u(this, "timelines", []), u(this, "_previousActiveModel", null) } resolveSourceObjects(e) { for (let t = this.models.length - 1; t >= 0; t--) { const s = this.models[t].asset; if (!s.sourceObject || typeof s.sourceObject != "object") { console.log("no source object, removing model", t, s), this.models.splice(t, 1); continue } else { const r = $.getComponent(s.sourceObject, um); this.timelines.push(r), r && s.updateDirector && (r.playOnAwake = !1) } } } evaluate(e) { var t; this._previousActiveModel = null; for (let s = 0; s < this.models.length; s++) { const r = this.models[s], n = r.asset; if (e >= r.start && e <= r.end) { this._previousActiveModel = r; const o = this.getClipTime(e, r); if (n.controlActivation) { const a = n.sourceObject; a.visible = !0 } if (n.updateDirector) { const a = this.timelines[s]; a && (a.isPlaying && a.pause(), a.time = o, a.evaluate()) } } else { const o = (t = this._previousActiveModel) == null ? void 0 : t.asset; if (n.controlActivation) { const a = n.sourceObject; o?.sourceObject !== a && (a.visible = !1) } } } } } var gee = Object.defineProperty, mee = Object.getOwnPropertyDescriptor, DF = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? mee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && gee(e, t, r), r }; class Dt { constructor(e) { u(this, "_active", !0), u(this, "_value"), u(this, "_valueRaw"), u(this, "_defaultValue"), u(this, "valueProcessor"), u(this, "onValueChanged"), this._value = e, this._defaultValue = e } get overrideState() { return this._active } set overrideState(e) { if (this._active === e) return; this._active = e; const t = e ? this._valueRaw : this._defaultValue; this.processValue(t, !0) } get value() { return this._valueRaw } set value(e) { this.processValue(e, !1) } set defaultValue(e) { this._defaultValue = e } __init() { this.processValue(this._valueRaw, !0) } processValue(e, t) { if (e == null || !t && this.testIfValueChanged(e) === !1) return; const s = this._value; !this._active && this._defaultValue !== void 0 ? (this._value = this._defaultValue, e = this._defaultValue, this._valueRaw = e) : (this._valueRaw = e, this._active && this.valueProcessor && (e = this.valueProcessor(e)), this._value = e), this.onValueChanged && this.onValueChanged(e, s, this) } testIfValueChanged(e) { return this._valueRaw !== e } } DF([x()], Dt.prototype, "overrideState", 1), DF([x()], Dt.prototype, "value", 1); var vee = Object.defineProperty, Aee = Object.getOwnPropertyDescriptor, yee = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Aee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && vee(e, t, r), r }; const bee = oe("debugpost"); class Ir extends ac { constructor() { super(...arguments), u(this, "active", !0), u(this, "_result") } onEnable() { this.__internalDidAwakeAndStart && (this.active = !0) } onDisable() { this.active = !1 } init() { } apply() { var e; return this._result || (this._result = (e = this.onCreateEffect) == null ? void 0 : e.call(this)), this._result && this.initParameters(), this._result } unapply() { } dispose() { bee && console.warn("DISPOSE", this), this._result && (Array.isArray(this._result) ? this._result.forEach(e => e.dispose()) : this._result.dispose()), this._result = void 0 } initParameters() { const e = Object.keys(this); for (const t of e) { const s = this[t]; s instanceof Dt && s.__init() } } onAfterDeserialize(e, t) { if (typeof e == "object") { const s = this.$serializedTypes; if (s) { for (const r of Object.keys(s)) if (s[r] === Dt) { const n = e[r]; if (n !== void 0) { const o = this[r]; o.value = n } } } } } onEditorModification(e) { const t = e.propertyName; if (this[t] instanceof Dt) { const s = e.value; return this[t].value = s, !0 } } } yee([x()], Ir.prototype, "active", 2); var _ee = Object.defineProperty, xee = Object.getOwnPropertyDescriptor, wee = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? xee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && _ee(e, t, r), r }; const Cee = oe("debugpost"), PE = {}; function ta(i, e) { PE[i] = e } function See(i) { return i.__type in PE ? PE[i.__type] : (Cee && i.__type && console.warn("Unknown postprocessing type", i.__type, i), Ir) } class mm { constructor() { u(this, "components") } init() { var e; (e = this.components) == null || e.forEach(t => t.init()) } } wee([Cd([i => See(i), Ir])], mm.prototype, "components", 2); var Eee = Object.defineProperty, Mee = Object.getOwnPropertyDescriptor, Iee = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Mee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Eee(e, t, r), r }; class vm extends Ir { constructor() { super(...arguments), u(this, "preset") } get typeName() { return "Antialiasing" } onCreateEffect() { const e = new JW({ preset: _d.HIGH, edgeDetectionMode: $1.DEPTH }); return this.preset.onValueChanged = t => { e.applyPreset(t) }, e } } Iee([x(Dt)], vm.prototype, "preset", 2), ta("Antialiasing", vm); class xb { constructor() { u(this, "files", []) } get extensionName() { return "Audio" } onExportObject(e, t, s) { const r = $.getComponents(e, ss); if (r.length) for (const n of r) { if (!n.playOnAwake) continue; const o = n.clip.split("/").pop(); this.files.includes(n.clip) || this.files.push(n.clip), t.addEventListener("serialize", (a, l) => { a.appendLine(), a.beginBlock(`def SpatialAudio "${t.name}"`), a.appendLine(`uniform asset filePath = @audio/${o}@`), a.appendLine(`uniform token auralMode = "${n.spatialBlend > 0 ? "spatial" : "nonSpatial"}"`), a.appendLine(`uniform token playbackMode = "${n.loop ? "loopFromStage" : "onceFromStart"}"`), a.appendLine(`uniform float gain = ${n.volume}`), a.closeBlock() }) } } async onAfterSerialize(e) { console.warn("onAfterSerialize", this); for (const t of this.files) { const s = t.split("/").pop(), r = await (await (await fetch(t)).blob()).arrayBuffer(), n = new Uint8Array(r); e.files["audio/" + s] = n } } } var Tee = Object.defineProperty, Ree = Object.getOwnPropertyDescriptor, OF = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Ree(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Tee(e, t, r), r }; const Pee = oe("debugmouth"); class Am extends Ee { constructor() { super(...arguments), u(this, "idle", []), u(this, "talking", []), u(this, "marker", null), u(this, "voip", null), u(this, "lastMouthChangeTime", 0), u(this, "mouthChangeLength", 0) } awake() { setTimeout(() => { this.voip = $.findObjectOfType(Il, this.context), this.marker || (this.marker = $.getComponentInParent(this.gameObject, lr)) }, 3e3) } update() { var e; if (!this.voip || this.context.time.frameCount % 10 !== 0) return; let t = ((e = this.marker) == null ? void 0 : e.connectionId) ?? null; if (!t) { Pee && (t = null); return } const s = this.voip.getFrequency(t) ?? 0; this.updateLips(s) } updateLips(e) { if (this.context.time.time - this.lastMouthChangeTime > this.mouthChangeLength) { if (this.mouthChangeLength = .05 + Math.random() * .1, this.talking && this.talking.length > 0 && e > 30) { this.lastMouthChangeTime = this.context.time.time; const t = Math.floor(Math.random() * this.talking.length); this.setMouthShapeActive(this.talking, t) } else if (this.idle.length > 0 && this.context.time.time - this.lastMouthChangeTime > .5) { this.lastMouthChangeTime = this.context.time.time; const t = Math.floor(Math.random() * this.idle.length); this.setMouthShapeActive(this.idle, t) } } } setMouthShapeActive(e, t) { if (e) { e != this.idle ? this.idle.map(s => s.visible = !1) : this.talking.map(s => s.visible = !1); for (let s = 0; s < e.length; s++) { const r = e[s]; r && (r.visible = s === t) } } } } OF([x(Me)], Am.prototype, "idle", 2), OF([x(Me)], Am.prototype, "talking", 2); class BE extends Ee { constructor() { super(...arguments), u(this, "voip", null), u(this, "marker", null), u(this, "_startPosition", null) } awake() { this.voip = $.findObjectOfType(Il, this.context), this.marker = $.getComponentInParent(this.gameObject, lr) } update() { if (!this.voip || !this.marker || this.context.time.frameCount % 10 !== 0) return; const e = this.marker.connectionId, t = this.voip.getFrequency(e); if (t == null) return; this._startPosition || (this._startPosition = this.gameObject.position.clone()); let s = t / 100; this.gameObject.position.y = this._startPosition.y + s * .07 } } var Bee = Object.defineProperty, kee = Object.getOwnPropertyDescriptor, wb = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? kee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Bee(e, t, r), r }; class Kh extends Ee { constructor() { super(...arguments), u(this, "eyes", []), u(this, "lastBlinkTime", 0), u(this, "blinkLength", 0), u(this, "eyesOpen", !0), u(this, "state", null) } awake() { this.state = $.getComponentInParent(this.gameObject, Sr) } update() { if (!(!this.gameObject || !this.gameObject.visible || !this.eyes || !Array.isArray(this.eyes) || this.eyes.length === 0) && this.context.time.time - this.lastBlinkTime > this.blinkLength) { if (this.lastBlinkTime = this.context.time.time, this.state && !this.state.isOn || !this.activeAndEnabled) return; if (this.eyesOpen = !this.eyesOpen, this.blinkLength = Math.random(), this.eyesOpen ? (this.blinkLength *= 3, this.blinkLength += .5, Math.random() < .1 && (this.blinkLength = .1 + Math.random() * .2)) : (this.blinkLength *= Math.random() * .2, this.blinkLength += .1), Math.random() < .1 && (this.blinkLength *= 3), this.blinkLength = Math.max(.2, this.blinkLength), this.blinkLength = Math.min(3, this.blinkLength), this.eyes) for (const e of this.eyes) e && (e.visible = this.eyesOpen) } } } wb([x(Me)], Kh.prototype, "eyes", 2), wb([x()], Kh.prototype, "lastBlinkTime", 2), wb([x()], Kh.prototype, "blinkLength", 2), wb([x()], Kh.prototype, "eyesOpen", 2); var Dee = Object.defineProperty, Oee = Object.getOwnPropertyDescriptor, kE = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Oee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Dee(e, t, r), r }, DE; const LF = (DE = class extends Ee { constructor() { super(...arguments), u(this, "head", null), u(this, "eyes", null), u(this, "target", null), u(this, "brain", null), u(this, "vec", new S), u(this, "currentTargetPoint", new S) } awake() { this.brain || (this.brain = $.getComponentInParent(this.gameObject, Gg)), this.brain || (console.log("No look at brain found, adding it now"), this.brain = $.addNewComponent(this.gameObject, Gg)), this.brain && this.target && (this.brain.controlledTarget = this.target) } update() { const i = this.target; if (i && this.head) { const e = this.eyes; if (e) { const t = xt(i); this.currentTargetPoint.lerp(t, this.context.time.deltaTime / .1); const s = xt(this.head), r = this.vec.copy(this.currentTargetPoint).sub(s).normalize(); if (r.length() < .1) return; const n = LF.forward; if (n.set(0, 0, 1), n.applyQuaternion(_s(this.head)), n.dot(r) > .45) for (let o = 0; o < e.length; o++)e[o].lookAt(this.currentTargetPoint) } } } }, u(DE, "forward", new S(0, 0, 1)), DE); let dp = LF; kE([x(Me)], dp.prototype, "head", 2), kE([x(Me)], dp.prototype, "eyes", 2), kE([x(Me)], dp.prototype, "target", 2); var Lee = Object.defineProperty, Fee = Object.getOwnPropertyDescriptor, OE = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Fee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Lee(e, t, r), r }; class pp extends Ee { constructor() { super(...arguments), u(this, "length", 1), u(this, "depthTest", !0), u(this, "isGizmo", !0), u(this, "_axes", null) } onEnable() { if (this.isGizmo && !Vf) return; this._axes || (this._axes = new ud(this.length)), this.gameObject.add(this._axes); const e = this._axes.material; e && e.depthTest !== void 0 && (e.depthTest = this.depthTest) } onDisable() { this._axes && this.gameObject.remove(this._axes) } } OE([x()], pp.prototype, "length", 2), OE([x()], pp.prototype, "depthTest", 2), OE([x()], pp.prototype, "isGizmo", 2); class LE extends Ee { constructor() { super(...arguments), u(this, "from"), u(this, "to"), u(this, "hint"), u(this, "desiredDistance", 1) } onEnable() { } update() { if (!this.from || !this.to || !this.hint) return; let e = xt(this.to).clone(), t = xt(this.from).clone(), s = e.distanceTo(t), r = e.clone(); r.sub(t); let n = t.clone(); n.add(e), n.multiplyScalar(.5); let o = xt(this.hint).clone(); o.sub(n); let a = new S; a.crossVectors(o, r), a.crossVectors(r, a), a.normalize(); let l = s * .5, c = Math.max(this.desiredDistance, l), h = Math.sqrt(c * c - l * l), d = a.clone(); d.multiplyScalar(h), d.add(n), ts(this.gameObject, d); let p = n.clone(); p.sub(a), this.gameObject.lookAt(p) } } class Cb { constructor() { u(this, "behaviours", []), u(this, "behaviourComponents", []), u(this, "behaviourComponentsCopy", []) } get extensionName() { return "Behaviour" } addBehavior(e) { this.behaviours.push(e) } onBeforeBuildDocument(e) { e.root.traverse(t => { $.foreachComponent(t, s => { var r; const n = s; (typeof n.createBehaviours == "function" || typeof n.beforeCreateDocument == "function" || typeof n.afterCreateDocument == "function") && (this.behaviourComponents.push(n), (r = n.beforeCreateDocument) == null || r.call(n, this, e)) }, !1) }) } onExportObject(e, t, s) { var r; for (const n of this.behaviourComponents) (r = n.createBehaviours) == null || r.call(n, this, t, s) } onAfterBuildDocument(e) { for (const t of this.behaviourComponents) typeof t.afterCreateDocument == "function" && t.afterCreateDocument(this, e); this.behaviourComponentsCopy = this.behaviourComponents.slice(), this.behaviourComponents.length = 0 } onAfterHierarchy(e, t) { var s; if ((s = this.behaviours) != null && s.length) { t.beginBlock('def Scope "Behaviors"'); for (const r of this.behaviours) r.writeTo(this, e.document, t); t.closeBlock() } } async onAfterSerialize(e) { console.log("onAfterSerialize", this.behaviourComponentsCopy); for (const t of this.behaviourComponentsCopy) console.log("behaviour", t), typeof t.afterSerialize == "function" && (console.log("beh has afterSerialize", t), t.afterSerialize.constructor.name === "AsyncFunction" ? await t.afterSerialize(this, e) : t.afterSerialize(this, e)) } } var Uee = Object.defineProperty, Nee = Object.getOwnPropertyDescriptor, FE = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Nee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Uee(e, t, r), r }; class Zh extends Ir { constructor() { super(...arguments), u(this, "threshold"), u(this, "intensity"), u(this, "scatter"), u(this, "selectiveBloom", !0) } get typeName() { return "Bloom" } init() { this.threshold.defaultValue = 1, this.intensity.defaultValue = 0, this.scatter.defaultValue = .2, this.selectiveBloom ? (this.threshold.valueProcessor = e => e, this.intensity.valueProcessor = e => e, this.scatter.valueProcessor = e => 1 * Math.PI * (1 - e)) : (this.threshold.valueProcessor = e => e, this.intensity.valueProcessor = e => e, this.scatter.valueProcessor = e => 100 * (1 - e)) } onCreateEffect() { let e; if (this.selectiveBloom) { const t = e = new Y2(this.context.scene, this.context.mainCamera, { blendFunction: kt.ADD, mipmapBlur: !0, luminanceThreshold: this.threshold.value, luminanceSmoothing: this.scatter.value, intensity: this.intensity.value }); t.inverted = !0 } else e = new nC; return this.intensity.onValueChanged = t => { e.intensity = t }, this.threshold.onValueChanged = t => { e.luminanceMaterial.threshold = t }, this.scatter.onValueChanged = t => { e.luminancePass.enabled = !0, e.luminanceMaterial.smoothing = t }, e } } FE([x(Dt)], Zh.prototype, "threshold", 2), FE([x(Dt)], Zh.prototype, "intensity", 2), FE([x(Dt)], Zh.prototype, "scatter", 2), ta("Bloom", Zh); var zee = Object.defineProperty, jee = Object.getOwnPropertyDescriptor, wo = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? jee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && zee(e, t, r), r }; class ia extends Ee { constructor() { super(...arguments), u(this, "attachedRigidbody", null), u(this, "isTrigger", !1), u(this, "sharedMaterial") } get isCollider() { return !0 } awake() { super.awake(), this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(ki)) } start() { this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(ki)) } onEnable() { this.attachedRigidbody || (this.attachedRigidbody = this.gameObject.getComponentInParent(ki)) } onDisable() { var e; (e = this.context.physics.engine) == null || e.removeBody(this) } } wo([x(ki)], ia.prototype, "attachedRigidbody", 2), wo([x()], ia.prototype, "isTrigger", 2), wo([x()], ia.prototype, "sharedMaterial", 2); class ym extends ia { constructor() { super(...arguments), u(this, "radius", .5), u(this, "center", new S(0, 0, 0)) } onEnable() { var e; super.onEnable(), (e = this.context.physics.engine) == null || e.addSphereCollider(this, this.center, this.radius) } } wo([x()], ym.prototype, "radius", 2), wo([x(S)], ym.prototype, "center", 2); class bm extends ia { constructor() { super(...arguments), u(this, "size", new S(1, 1, 1)), u(this, "center", new S(0, 0, 0)) } onEnable() { var e; super.onEnable(), (e = this.context.physics.engine) == null || e.addBoxCollider(this, this.center, this.size) } } wo([x(S)], bm.prototype, "size", 2), wo([x(S)], bm.prototype, "center", 2); class _m extends ia { constructor() { super(...arguments), u(this, "sharedMesh"), u(this, "convex", !1) } onEnable() { var e, t, s, r, n; if (super.onEnable(), (e = this.sharedMesh) != null && e.isMesh || this.gameObject instanceof ye && (this.sharedMesh = this.gameObject), (t = this.sharedMesh) != null && t.isMesh) (s = this.context.physics.engine) == null || s.addMeshCollider(this, this.sharedMesh, this.convex, Fs(this.gameObject)); else { const o = this.sharedMesh; if (o != null && o.isGroup) { console.warn(`MeshCollider mesh is a group "${(r = this.sharedMesh) == null ? void 0 : r.name}", adding all children as colliders. This is currently not fully supported (colliders can not be removed from world again)`, this); for (const a in o.children) { const l = o.children[a]; l.isMesh && ((n = this.context.physics.engine) == null || n.addMeshCollider(this, l, this.convex, Fs(this.gameObject))) } } } } } wo([x()], _m.prototype, "convex", 2); class kc extends ia { constructor() { super(...arguments), u(this, "center", new S(0, 0, 0)), u(this, "radius", .5), u(this, "height", 2) } onEnable() { var e; super.onEnable(), (e = this.context.physics.engine) == null || e.addCapsuleCollider(this, this.center, this.height, this.radius) } } wo([x(S)], kc.prototype, "center", 2), wo([x()], kc.prototype, "radius", 2), wo([x()], kc.prototype, "height", 2); function UE(i) { return i[dl] || (i.parent ? UE(i.parent) : null) } function Sb(i, e) { if (!i) return; const t = i.material; if (t?.isMaterial === !0) { const s = i.parent; s && s.isText, t.side = e.doubleSided ?? !0 ? yi : pr, t.shadowSide = e.doubleSided ? yi : pr, i.castShadow = e.castShadows ? e.castShadows : !1, i.receiveShadow = e.receiveShadows ? e.receiveShadows : !1 } for (const s of i.children) Sb(s, e) } function fp(i, e, t) { i[e] === void 0 && console.warn("Field", e, "is undefined on", i); const s = Proxy.revocable(i[e], { set(o, a, l, c) { const h = o[a], d = Reflect.set(o, a, l, c); return t(l, h), d } }), r = s.revoke, n = i[e]; return s.revoke = () => { i[e] = n, r() }, i[e] = s.proxy, s } const FF = Symbol("Scheduled action"); function Qee(i, e, t = on.OnBeforeRender) { let s = i[FF]; s || (s = i[FF] = {}); const r = e.name; s[t] || (s[t] = {}); const n = s[t]; if (n[r]) return; function* o() { e?.call(i), n[r] = null } const a = i.startCoroutine(o(), t); n[r] = a } var Gee = Object.defineProperty, Hee = Object.getOwnPropertyDescriptor, $h = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Hee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Gee(e, t, r), r }; const NE = oe("debugui"), zE = oe("debuguilayout"); class jE { constructor() { u(this, "width"), u(this, "height") } } class QE { constructor() { u(this, "x"), u(this, "y"), u(this, "width"), u(this, "height") } } const Co = new S, xm = new He, Eb = new we, UF = class extends ba { constructor() { super(...arguments), u(this, "offset", .01), u(this, "_anchoredPosition"), u(this, "sizeDelta", new W(100, 100)), u(this, "pivot", new W(.5, .5)), u(this, "anchorMin", new W(0, 0)), u(this, "anchorMax", new W(1, 1)), u(this, "offsetMin", new W(0, 0)), u(this, "offsetMax", new W(0, 0)), u(this, "lastMatrix"), u(this, "rectBlock"), u(this, "_transformNeedsUpdate", !1), u(this, "_parentRectTransform"), u(this, "_lastUpdateFrame", -1), u(this, "_createdBlocks", []), u(this, "_createdTextBlocks", []) } get parent() { return this._parentRectTransform } get translation() { return this.gameObject.position } get rotation() { return this.gameObject.quaternion } get scale() { return this.gameObject.scale } get anchoredPosition() { return this._anchoredPosition || (this._anchoredPosition = new S), this._anchoredPosition } set anchoredPosition(i) { this._anchoredPosition = i } get width() { if (this.anchorMin.x !== this.anchorMax.x && this._parentRectTransform) { const i = this._parentRectTransform.width, e = this.anchorMax.x - this.anchorMin.x; let t = i * e; return t += this.sizeDelta.x, t } return this.sizeDelta.x } get height() { if (this.anchorMin.y !== this.anchorMax.y && this._parentRectTransform) { const i = this._parentRectTransform.height, e = this.anchorMax.y - this.anchorMin.y; let t = i * e; return t += this.sizeDelta.y, t } return this.sizeDelta.y } awake() { super.awake(), this.lastMatrix = new He, this.rectBlock = new Me, this.rectBlock.position.z = .1, this.rectBlock.name = this.name, this._anchoredPosition || (this._anchoredPosition = new S), fp(this, "_anchoredPosition", () => { this.markDirty() }), fp(this, "sizeDelta", () => { this.markDirty() }), fp(this, "pivot", () => { this.markDirty() }), fp(this, "anchorMin", () => { this.markDirty() }), fp(this, "anchorMax", () => { this.markDirty() }), this.isRoot() || (this.gameObject.position.x += this.anchoredPosition.x, this.gameObject.position.y -= this.anchoredPosition.y) } onEnable() { var i; super.onEnable(), this.addShadowComponent(this.rectBlock), this._transformNeedsUpdate = !0, (i = this.Canvas) == null || i.registerTransform(this) } onDisable() { var i; super.onDisable(), this.removeShadowComponent(), (i = this.Canvas) == null || i.unregisterTransform(this) } onParentRectTransformChanged(i) { this._transformNeedsUpdate || this.onApplyTransform(zE ? `${i.name} changed` : void 0) } get isDirty() { return this._transformNeedsUpdate || (this._transformNeedsUpdate = !this.lastMatrix.equals(this.gameObject.matrix)), this._transformNeedsUpdate } markDirty() { this._transformNeedsUpdate || (zE && console.warn("RectTransform markDirty()", this.name), this._transformNeedsUpdate = !0, this._lastUpdateFrame = -1) } updateTransform() { (this._transformNeedsUpdate || !this.lastMatrix.equals(this.gameObject.matrix)) && this.canUpdate() && this.onApplyTransform(this._transformNeedsUpdate ? "Marked dirty" : "Matrix changed") } canUpdate() { return this._transformNeedsUpdate && this.activeAndEnabled && this._lastUpdateFrame !== this.context.time.frame } onApplyTransform(i) { if (this.context.time.frameCount === this._lastUpdateFrame) return; this._lastUpdateFrame = this.context.time.frameCount; const e = this.shadowComponent; if (!e) return; this.gameObject.parent ? this._parentRectTransform = $.getComponentInParent(this.gameObject.parent, UF) : this._parentRectTransform = void 0, this._transformNeedsUpdate = !1, this.lastMatrix.copy(this.gameObject.matrix), zE && console.warn("RectTransform \u2192 ApplyTransform", this.name + " because " + i), this.isRoot() ? this.Root.screenspace || (e.rotation.y = Math.PI) : (e.matrix.identity(), e.matrixAutoUpdate = !1, Co.set(0, 0, 0), this.applyPivot(Co), e.matrix.setPosition(Co.x, Co.y, 0), (this.gameObject.quaternion.x || this.gameObject.quaternion.y || this.gameObject.quaternion.z) && (Eb.copy(this.gameObject.quaternion), Eb.x *= -1, Eb.z *= -1, xm.makeRotationFromQuaternion(Eb), e.matrix.premultiply(xm)), Co.set(0, 0, 0), this.applyAnchoring(Co), Co.z += this.offset, Co.z -= this.gameObject.position.z, xm.identity(), xm.setPosition(Co.x, Co.y, Co.z), e.matrix.premultiply(xm), e.matrix.scale(this.gameObject.scale)); const t = !0; for (const s of q1(this.gameObject, ba, t, 1)) { if (s === this || !s.activeAndEnabled) continue; const r = s; r.onParentRectTransformChanged && r.onParentRectTransformChanged(this) } } applyAnchoring(i) { i.x += this.anchoredPosition.x, i.y += this.anchoredPosition.y; const e = this._parentRectTransform; if (e) { let t = 0; const s = 1 - this.anchorMax.y - this.anchorMin.y; t -= e.height * .5 * s, i.y += t; let r = 0; const n = 1 - this.anchorMax.x - this.anchorMin.x; r -= e.width * .5 * n, i.x += r } } applyPivot(i) { if (this.pivot && !this.isRoot()) { const e = this.pivot.x - .5; i.x -= e * this.sizeDelta.x * this.gameObject.scale.x; const t = this.pivot.y - .5; i.y -= t * this.sizeDelta.y * this.gameObject.scale.y } } getBasicOptions() { const i = { width: this.sizeDelta.x, height: this.sizeDelta.y, offset: this.offset, backgroundOpacity: 0, borderWidth: 0, borderRadius: 0, borderOpacity: 0, letterSpacing: -.03 }; return this.ensureValidSize(i), i } ensureValidSize(i, e = 1e-4) { return i.width <= 0 && (i.width = e), i.height <= 0 && (i.height = 1e-4), i } createNewBlock(i) { i = { ...this.getBasicOptions(), ...i }, NE && console.log(this.name, i); const e = new yE(i); return this._createdBlocks.push(e), e } createNewText(i) { NE && console.log(i), i = { ...this.getBasicOptions(), ...i }, NE && console.log(this.name, i); const e = new SF(i); return this._createdTextBlocks.push(e), e } }; let Tr = UF; $h([x(S)], Tr.prototype, "anchoredPosition", 1), $h([x(W)], Tr.prototype, "sizeDelta", 2), $h([x(W)], Tr.prototype, "pivot", 2), $h([x(W)], Tr.prototype, "anchorMin", 2), $h([x(W)], Tr.prototype, "anchorMax", 2), $h([x(W)], Tr.prototype, "offsetMin", 2), $h([x(W)], Tr.prototype, "offsetMax", 2); class Vee extends CF { constructor(e, t = {}) { super(e), e._simpleState__activeStates = [], e._simpleState__normalStyles = {}, e._simpleState__states = t, e._simpleState__statesProperties = {}; for (const s in t) for (const r in t[s]) e._simpleState__statesProperties[r] || (e._simpleState__statesProperties[r] = []), e._simpleState__statesProperties[r].push(s); for (const s of e._components) e._simpleState__statesProperties[s.id] && (e._simpleState__normalStyles[s.id] = s.inline ? s.inline : s._value); e.__overridedSet = e.set, e.set = this.storeSet.bind(e), e.renderStates = this.renderStates.bind(e), e.setupState = this.setupState.bind(e), e.setState = this.setState.bind(e), e.activatePseudoState = this.activatePseudoState.bind(e), e.deactivatePseudoState = this.deactivatePseudoState.bind(e), e.togglePseudoState = this.togglePseudoState.bind(e) } act() { } attach() { } detach() { } setupState(e, t) { this._simpleState__states[e] = t; const s = []; for (const r in t) this._simpleState__statesProperties[r] || (this._simpleState__statesProperties[r] = [], s.push(r)), this._simpleState__statesProperties[r].push(e); for (const r of this._components) s.indexOf(r.id) > -1 && (this._simpleState__normalStyles[r.id] = r.inline ? r.inline : r._value) } renderStates() { let e = { ...this._simpleState__normalStyles }; for (const t in this._simpleState__states) this._simpleState__activeStates.indexOf(t) > -1 && (e = { ...e, ...this._simpleState__states[t] }); this.set(e, !1) } storeSet(e, t = !0) { if (t) for (const s in e) this._simpleState__statesProperties[s] && (this._simpleState__normalStyles[s] = e[s]); this.__overridedSet(e) } activatePseudoState(e) { this._simpleState__activeStates.indexOf(e) === -1 && (this._simpleState__activeStates.push(e), this.renderStates()) } deactivatePseudoState(e) { const t = this._simpleState__activeStates.indexOf(e); t > -1 && (this._simpleState__activeStates.splice(t, 1), this.renderStates()) } togglePseudoState(e) { const t = this._simpleState__activeStates.indexOf(e); t > -1 ? this._simpleState__activeStates.splice(t, 1) : this._simpleState__activeStates.push(e), this.renderStates() } setState(e) { Array.isArray(e) ? this._simpleState__activeStates = e : this._simpleState__activeStates = [e], this.renderStates() } } var Wee = Object.defineProperty, qee = Object.getOwnPropertyDescriptor, NF = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? qee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Wee(e, t, r), r }; class gp extends Ee { constructor() { super(...arguments), u(this, "effectColor"), u(this, "effectDistance") } } NF([x(mi)], gp.prototype, "effectColor", 2), NF([x(W)], gp.prototype, "effectDistance", 2); var Xee = Object.defineProperty, Yee = Object.getOwnPropertyDescriptor, zF = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Yee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Xee(e, t, r), r }; const Mb = { backgroundColor: new xe(1, 1, 1), backgroundOpacity: 1, borderColor: new xe(1, 1, 1), borderOpacity: 1 }; var GE; const Ib = (GE = class extends ba { constructor() { super(...arguments), u(this, "_alphaFactor", 1), u(this, "raycastTarget", !0), u(this, "uiObject", null), u(this, "_color", null), u(this, "_rect", null), u(this, "_stateManager", null), u(this, "_currentlyCreatingPanel", !1) } get isGraphic() { return !0 } get color() { return this._color || (this._color = new mi(1, 1, 1, 1)), this._color } set color(i) { (!this._color || this._color.r !== i.r || this._color.g !== i.g || this._color.b !== i.b || this._color.alpha !== i.alpha) && (this._color || (this._color = new mi(1, 1, 1, 1)), this._color.copy(i)) } setAlphaFactor(i) { this._alphaFactor = i, this.onColorChanged() } onColorChanged() { this.uiObject && (Mb.backgroundColor = this._color, Mb.backgroundOpacity = this._color.alpha * this._alphaFactor, this.applyEffects(Mb, this._alphaFactor), this.uiObject.set(Mb), this.markDirty()) } get m_Color() { return this._color } get rectTransform() { return this._rect || (this._rect = $.getComponent(this.gameObject, Tr)), this._rect } onParentRectTransformChanged() { var i; (i = this.uiObject) == null || i.set({ width: this.rectTransform.width, height: this.rectTransform.height }), this.markDirty() } __internalNewInstanceCreated() { super.__internalNewInstanceCreated(), this._rect = null, this.uiObject = null, this._color && (this._color = this._color.clone()) } setState(i) { this.makePanel(), this.uiObject && (this.uiObject.setState(i), this == null || this.markDirty()) } setupState(i) { this.makePanel(), this.uiObject && (this._stateManager || (this._stateManager = new Vee(this.uiObject)), this.uiObject.setupState(i.state, i.attributes)) } setOptions(i) { this.makePanel(), this.uiObject && this.uiObject.set(i) } awake() { super.awake(), this.makePanel(), fp(this, "_color", () => Qee(this, this.onColorChanged)) } onEnable() { var i; super.onEnable(), this.uiObject && ((i = this.rectTransform.shadowComponent) == null || i.add(this.uiObject), this.addShadowComponent(this.uiObject, this.rectTransform)) } onDisable() { super.onDisable(), this.uiObject && this.removeShadowComponent() } makePanel() { if (this.uiObject || this._currentlyCreatingPanel) return; this._currentlyCreatingPanel = !0; const i = { backgroundColor: this.color, backgroundOpacity: this.color.alpha, offset: 1 }; this.onBeforeCreate(i), this.applyEffects(i), this.onCreate(i), this.controlsChildLayout = !1, this._currentlyCreatingPanel = !1, this.onAfterCreated() } onBeforeCreate(i) { } onCreate(i) { this.uiObject = this.rectTransform.createNewBlock(i), this.uiObject.name = this.name } onAfterCreated() { } applyEffects(i, e = 1) { var t; const s = (t = this.gameObject) == null ? void 0 : t.getComponent(gp); s && (s.effectDistance && (i.borderWidth = Math.max(Math.abs(s.effectDistance.x), Math.abs(s.effectDistance.y))), s.effectColor && (i.borderColor = s.effectColor, i.borderOpacity = s.effectColor.alpha * e)) } async setTexture(i) { if (this.setOptions({ backgroundOpacity: 0 }), i) { if (i.encoding === Xe) if (Ib.textureCache.has(i)) i = Ib.textureCache.get(i); else { const e = i.clone(); e.encoding = Qi, Ib.textureCache.set(i, e), i = e } this.setOptions({ backgroundImage: i, borderRadius: 0, backgroundOpacity: this.color.alpha, backgroundSize: "stretch" }) } else this.setOptions({ backgroundImage: null, borderRadius: 0, backgroundOpacity: this.color.alpha }) } onAfterAddedToScene() { super.onAfterAddedToScene(), this.shadowComponent && (this.shadowComponent.offset = this.shadowComponent.position.z) } }, u(GE, "textureCache", new Map), GE); let Dc = Ib; zF([x(mi)], Dc.prototype, "color", 1), zF([x()], Dc.prototype, "raycastTarget", 2); class wm extends Dc { constructor() { super(...arguments), u(this, "_flippedObject", !1) } onAfterCreated() { this.uiObject && !this._flippedObject && (this._flippedObject = !0, this.uiObject.scale.y *= -1) } } var Jee = Object.defineProperty, Kee = Object.getOwnPropertyDescriptor, Tb = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Kee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Jee(e, t, r), r }; let HE = class { constructor() { u(this, "texture", null), u(this, "rect") } }; Tb([x(Nt)], HE.prototype, "texture", 2); let mp = class extends wm { constructor() { super(...arguments), u(this, "_sprite"), u(this, "pixelsPerUnitMultiplier", 1) } set image(i) { this.sprite ? this.sprite.texture = i : (this.sprite = new HE, this.sprite.texture = i), this.onAfterCreated() } get image() { return this.sprite ? this.sprite.texture : null } get sprite() { return this._sprite } set sprite(i) { this._sprite !== i && (this._sprite = i, this.onAfterCreated()) } isBuiltinSprite() { var i, e, t, s, r, n, o, a; switch ((e = (i = this.sprite) == null ? void 0 : i.texture) == null ? void 0 : e.name) { case "InputFieldBackground": case "UISprite": case "Background": case "Knob": return !0 }return ((r = (s = (t = this.sprite) == null ? void 0 : t.texture) == null ? void 0 : s.image) == null ? void 0 : r.width) === 32 && ((a = (o = (n = this.sprite) == null ? void 0 : n.texture) == null ? void 0 : o.image) == null ? void 0 : a.height) === 32 } onBeforeCreate(i) { var e, t; super.onBeforeCreate(i), this.isBuiltinSprite() && (i.borderRadius = 5 / this.pixelsPerUnitMultiplier, ((t = (e = this.sprite) == null ? void 0 : e.texture) == null ? void 0 : t.name) === "Knob" && (i.borderRadius = 999)) } onAfterCreated() { var i; this.__didAwake && (super.onAfterCreated(), !this.isBuiltinSprite() && this.setTexture((i = this.sprite) == null ? void 0 : i.texture)) } }; Tb([x(HE)], mp.prototype, "sprite", 1), Tb([x()], mp.prototype, "pixelsPerUnitMultiplier", 2); class Rb extends wm { constructor() { super(...arguments), u(this, "_mainTexture") } get mainTexture() { return this._mainTexture } set mainTexture(e) { this._mainTexture !== e && (this._mainTexture = e, this.onAfterCreated()) } onAfterCreated() { this.__didAwake && (super.onAfterCreated(), this.setTexture(this.mainTexture)) } } Tb([x(Nt)], Rb.prototype, "mainTexture", 1); var Zee = Object.defineProperty, $ee = Object.getOwnPropertyDescriptor, cn = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? $ee(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Zee(e, t, r), r }; const vp = oe("debugbutton"); class eu { constructor() { u(this, "colorMultiplier"), u(this, "disabledColor"), u(this, "fadeDuration"), u(this, "highlightedColor"), u(this, "normalColor"), u(this, "pressedColor"), u(this, "selectedColor") } } cn([x()], eu.prototype, "colorMultiplier", 2), cn([x(mi)], eu.prototype, "disabledColor", 2), cn([x()], eu.prototype, "fadeDuration", 2), cn([x(mi)], eu.prototype, "highlightedColor", 2), cn([x(mi)], eu.prototype, "normalColor", 2), cn([x(mi)], eu.prototype, "pressedColor", 2), cn([x(mi)], eu.prototype, "selectedColor", 2); class Al extends Ee { constructor() { super(...arguments), u(this, "onClick"), u(this, "_isHovered", !1), u(this, "colors"), u(this, "transition"), u(this, "animationTriggers"), u(this, "animator"), u(this, "_interactable", !0), u(this, "_requestedAnimatorTrigger"), u(this, "_isInit", !1), u(this, "_image") } onPointerEnter(e) { var t, s; vp && console.log("Button Enter", (t = this.animationTriggers) == null ? void 0 : t.highlightedTrigger, this.animator), this._isHovered = !0, this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.highlightedTrigger) : this.transition === 1 && this.colors && ((s = this._image) == null || s.setState("hovered")), this.context.input.setCursorPointer()) } onPointerExit() { var e, t; vp && console.log("Button Exit", (e = this.animationTriggers) == null ? void 0 : e.highlightedTrigger, this.animator), this._isHovered = !1, this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.normalTrigger) : this.transition === 1 && this.colors && ((t = this._image) == null || t.setState("normal")), this.context.input.setCursorNormal()) } onPointerDown(e) { var t, s; vp && console.log("Button Down", (t = this.animationTriggers) == null ? void 0 : t.highlightedTrigger, this.animator), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this.animationTriggers.pressedTrigger) : this.transition === 1 && this.colors && ((s = this._image) == null || s.setState("pressed"))) } onPointerUp(e) { var t, s; vp && console.warn("Button Up", (t = this.animationTriggers) == null ? void 0 : t.highlightedTrigger, this.animator, this._isHovered), this.interactable && (this.transition == 3 && this.animationTriggers && this.animator ? this.animator.setTrigger(this._isHovered ? this.animationTriggers.highlightedTrigger : this.animationTriggers.normalTrigger) : this.transition === 1 && this.colors && ((s = this._image) == null || s.setState(this._isHovered ? "hovered" : "normal"))) } onPointerClick(e) { var t; this.interactable && (vp && (console.warn("Button Click", this.onClick), Ls("CLICKED button " + this.name + " at " + this.context.time.frameCount)), (t = this.onClick) == null || t.invoke()) } set interactable(e) { this._interactable = e, this._image && (this._image.setInteractable(e), e ? this._image.setState("normal") : this._image.setState("disabled")) } get interactable() { return this._interactable } set_interactable(e) { this.interactable = e } awake() { super.awake(), vp && console.log(this), this._isInit = !1, this.init() } start() { var e; (e = this._image) == null || e.setInteractable(this.interactable) } onEnable() { super.onEnable() } *setAnimatorTriggerAtEndOfFrame(e) { var t; this._requestedAnimatorTrigger = e, yield, yield, this._requestedAnimatorTrigger == e && ((t = this.animator) == null || t.SetTrigger(e)) } init() { this._isInit || (this._isInit = !0, this._image = $.getComponent(this.gameObject, mp), this._image && (this.stateSetup(this._image), this.interactable ? this._image.setState("normal") : this._image.setState("disabled"))) } stateSetup(e) { var t, s, r, n, o; e.setInteractable(this.interactable); const a = this.getFinalColor(e.color, (t = this.colors) == null ? void 0 : t.normalColor), l = { state: "normal", attributes: { backgroundColor: a, backgroundOpacity: a.alpha } }; e.setupState(l); const c = this.getFinalColor(e.color, (s = this.colors) == null ? void 0 : s.highlightedColor), h = { state: "hovered", attributes: { backgroundColor: c, backgroundOpacity: c.alpha } }; e.setupState(h); const d = this.getFinalColor(e.color, (r = this.colors) == null ? void 0 : r.pressedColor), p = { state: "pressed", attributes: { backgroundColor: d, backgroundOpacity: d.alpha } }; e.setupState(p); const f = this.getFinalColor(e.color, (n = this.colors) == null ? void 0 : n.selectedColor), g = { state: "selected", attributes: { backgroundColor: f, backgroundOpacity: f.alpha } }; e.setupState(g); const m = this.getFinalColor(e.color, (o = this.colors) == null ? void 0 : o.disabledColor), v = { state: "disabled", attributes: { backgroundColor: m, backgroundOpacity: m.alpha } }; e.setupState(v) } getFinalColor(e, t) { return t ? e.clone().multiply(t) : e.clone() } } cn([x(Nr)], Al.prototype, "onClick", 2), cn([x()], Al.prototype, "colors", 2), cn([x()], Al.prototype, "transition", 2), cn([x()], Al.prototype, "animationTriggers", 2), cn([x(Fr)], Al.prototype, "animator", 2), cn([x()], Al.prototype, "interactable", 1); var ete = Object.defineProperty, tte = Object.getOwnPropertyDescriptor, as = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? tte(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && ete(e, t, r), r }; const jF = oe("debuguilayout"); class Oc { constructor() { u(this, "left", 0), u(this, "right", 0), u(this, "top", 0), u(this, "bottom", 0) } get vertical() { return this.top + this.bottom } get horizontal() { return this.left + this.right } } as([x()], Oc.prototype, "left", 2), as([x()], Oc.prototype, "right", 2), as([x()], Oc.prototype, "top", 2), as([x()], Oc.prototype, "bottom", 2); class hn extends Ee { constructor() { super(...arguments), u(this, "_rectTransform", null), u(this, "_needsUpdate", !1), u(this, "childAlignment", 0), u(this, "reverseArrangement", !1), u(this, "spacing", 0), u(this, "padding"), u(this, "minWidth", 0), u(this, "minHeight", 0), u(this, "flexibleHeight", 0), u(this, "flexibleWidth", 0), u(this, "preferredHeight", 0), u(this, "preferredWidth", 0) } get rectTransform() { return this._rectTransform } onParentRectTransformChanged(e) { this._needsUpdate = !0 } get isDirty() { return this._needsUpdate } get isLayoutGroup() { return !0 } updateLayout() { this._rectTransform && (jF && console.warn("Layout Update", this.context.time.frame, this.name), this._needsUpdate = !1, this.onCalculateLayout(this._rectTransform)) } start() { this._needsUpdate = !0 } onEnable() { jF && console.log(this.name, this), this._rectTransform = this.gameObject.getComponent(Tr); const e = this.gameObject.getComponentInParent(cr); e && e.registerLayoutGroup(this), this._needsUpdate = !0 } onDisable() { const e = this.gameObject.getComponentInParent(cr); e && e.unregisterLayoutGroup(this) } set m_Spacing(e) { e !== this.spacing && (this._needsUpdate = !0, this.spacing = e) } get m_Spacing() { return this.spacing } } as([x()], hn.prototype, "childAlignment", 2), as([x()], hn.prototype, "reverseArrangement", 2), as([x()], hn.prototype, "spacing", 2), as([x(Oc)], hn.prototype, "padding", 2), as([x()], hn.prototype, "minWidth", 2), as([x()], hn.prototype, "minHeight", 2), as([x()], hn.prototype, "flexibleHeight", 2), as([x()], hn.prototype, "flexibleWidth", 2), as([x()], hn.prototype, "preferredHeight", 2), as([x()], hn.prototype, "preferredWidth", 2); class Lc extends hn { constructor() { super(...arguments), u(this, "childControlHeight", !0), u(this, "childControlWidth", !0), u(this, "childForceExpandHeight", !1), u(this, "childForceExpandWidth", !1), u(this, "childScaleHeight", !1), u(this, "childScaleWidth", !1) } onCalculateLayout(e) { var t; const s = this.primaryAxis, r = e.width; let n = r; const o = e.height; let a = o; n -= this.padding.horizontal, a -= this.padding.vertical, s === "x" ? this.padding.horizontal : this.padding.vertical; const l = s === "x", c = l ? "y" : "x", h = l ? this.childControlWidth : this.childControlHeight, d = l ? this.childControlHeight : this.childControlWidth, p = l ? this.childForceExpandWidth : this.childForceExpandHeight, f = l ? this.childForceExpandHeight : this.childForceExpandWidth, g = l ? a : n, m = l ? r : o, v = .5 * (l ? this.childAlignment % 3 : Math.floor(this.childAlignment / 3)); let A = 0; l ? A += this.padding.left : A += this.padding.top; let b = 0, y = 0; for (let C = 0; C < this.gameObject.children.length; C++) { const R = this.gameObject.children[C], T = $.getComponent(R, Tr); T != null && T.activeAndEnabled && (y += 1, l ? b += T.width : b += T.height) } let _ = 0; const w = this.spacing * (y - 1); if (p || h) { let C = 0; l ? C = n -= w : C = a -= w, y > 0 && (_ = C / y) } let E = 0; E += this.padding.left, E -= this.padding.right, v !== 0 && (A = m - b, A *= v, A -= w * v, l ? (A -= this.padding.right * v, A += this.padding.left * (1 - v), A < this.padding.left && (A = this.padding.left)) : (A -= this.padding.bottom * v, A += this.padding.top * (1 - v), A < this.padding.top && (A = this.padding.top))); let P = 1; for (let C = 0; C < this.gameObject.children.length; C++) { const R = this.gameObject.children[C], T = $.getComponent(R, Tr); if (T != null && T.activeAndEnabled) { (t = T.pivot) == null || t.set(.5, .5), T.anchorMin.set(0, 1), T.anchorMax.set(0, 1); const z = r * .5 + E * .5; T.anchoredPosition.x !== z && (T.anchoredPosition.x = z); const H = o * -.5; T.anchoredPosition.y !== H && (T.anchoredPosition.y = H), f && d && T.sizeDelta[c] !== g && (T.sizeDelta[c] = g), p && h && T.sizeDelta[s] !== _ && (T.sizeDelta[s] = _); const N = l ? T.width : T.height; let F = N * .5; if (A += F, p) { let te = _ * P - _ * .5; te > A && (A = te - _ * .5 + N + this.padding.left, A -= F) } let X = A; s === "y" && (X = -X), T.anchoredPosition[s] !== X && (T.anchoredPosition[s] = X), A += F, A += this.spacing, P += 1 } } } } as([x()], Lc.prototype, "childControlHeight", 2), as([x()], Lc.prototype, "childControlWidth", 2), as([x()], Lc.prototype, "childForceExpandHeight", 2), as([x()], Lc.prototype, "childForceExpandWidth", 2), as([x()], Lc.prototype, "childScaleHeight", 2), as([x()], Lc.prototype, "childScaleWidth", 2); class VE extends Lc { get primaryAxis() { return "y" } } class WE extends Lc { get primaryAxis() { return "x" } } class qE extends hn { onCalculateLayout() { } } var ite = Object.defineProperty, ste = Object.getOwnPropertyDescriptor, sa = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? ste(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && ite(e, t, r), r }; const XE = oe("debuguilayout"), QF = class extends em { constructor() { super(...arguments), u(this, "_renderOnTop"), u(this, "_depthWrite", !1), u(this, "_doubleSided", !0), u(this, "_castShadows", !1), u(this, "_receiveShadows", !1), u(this, "_renderMode", -1), u(this, "_rootCanvas"), u(this, "_scaleFactor", 1), u(this, "worldCamera"), u(this, "planeDistance", -1), u(this, "_boundRenderSettingsChanged", this.onRenderSettingsChanged.bind(this)), u(this, "previousParent", null), u(this, "_lastMatrixWorld", null), u(this, "_rectTransforms", []), u(this, "_layoutGroups", new Map), u(this, "onBeforeRenderRoutine", () => { var i, e; this.previousParent = this.gameObject.parent, this.renderOnTop || this.screenspace ? this.gameObject.removeFromParent() : (this.onUpdateRenderMode(), this.handleLayoutUpdates(), (i = this.shadowComponent) == null || i.updateMatrixWorld(!0), (e = this.shadowComponent) == null || e.updateWorldMatrix(!0, !0), jn.ensureUpdateMeshUI(MF, this.context)) }), u(this, "onAfterRenderRoutine", () => { var i, e; if ((this.screenspace || this.renderMode) && this.previousParent && this.context.mainCamera) { if (this.screenspace) { const t = this.context.mainCamera; t?.add(this.gameObject) } else this.previousParent.add(this.gameObject); this.context.renderer.autoClear = !1, this.context.renderer.clearDepth(), this.onUpdateRenderMode(!0), this.handleLayoutUpdates(), (i = this.shadowComponent) == null || i.updateMatrixWorld(!0), jn.ensureUpdateMeshUI(MF, this.context), this.context.renderer.render(this.gameObject, this.context.mainCamera), this.context.renderer.autoClear = !0, this.previousParent.add(this.gameObject) } (e = this._lastMatrixWorld) == null || e.copy(this.gameObject.matrixWorld) }), u(this, "_updateRenderSettingsRoutine"), u(this, "_activeRenderMode", -1), u(this, "_lastWidth", -1), u(this, "_lastHeight", -1) } get isCanvas() { return !0 } get screenspace() { return this.renderMode !== 2 } set renderOnTop(i) { i !== this._renderOnTop && (this._renderOnTop = i, this.onRenderSettingsChanged()) } get renderOnTop() { return this._renderOnTop !== void 0 ? this._renderOnTop : !!(this.screenspace && this._renderMode === 0) } set depthWrite(i) { this._depthWrite !== i && (this._depthWrite = i, this.onRenderSettingsChanged()) } get depthWrite() { return this._depthWrite } set doubleSided(i) { this._doubleSided !== i && (this._doubleSided = i, this.onRenderSettingsChanged()) } get doubleSided() { return this._doubleSided } set castShadows(i) { this._castShadows !== i && (this._castShadows = i, this.onRenderSettingsChanged()) } get castShadows() { return this._castShadows } set receiveShadows(i) { this._receiveShadows !== i && (this._receiveShadows = i, this.onRenderSettingsChanged()) } get receiveShadows() { return this._receiveShadows } get renderMode() { return this._renderMode } set renderMode(i) { this._renderMode !== i && (this._renderMode = i, this.onRenderSettingsChanged()) } set rootCanvas(i) { this._rootCanvas instanceof QF || (this._rootCanvas = i) } get rootCanvas() { return this._rootCanvas } get scaleFactor() { return this._scaleFactor } set scaleFactor(i) { this._scaleFactor = i } awake() { var i; this.shadowComponent = this.gameObject, this.previousParent = this.gameObject.parent, XE && console.log("Canvas.Awake()", ((i = this.previousParent) == null ? void 0 : i.name) + "/" + this.gameObject.name), super.awake() } start() { this.onUpdateRenderMode() } onEnable() { super.onEnable(), this._updateRenderSettingsRoutine = void 0, this._lastMatrixWorld = new He, this.onUpdateRenderMode(), document.addEventListener("resize", this._boundRenderSettingsChanged), this.context.pre_render_callbacks.push(this.onBeforeRenderRoutine), this.context.post_render_callbacks.push(this.onAfterRenderRoutine) } onDisable() { super.onDisable(), document.removeEventListener("resize", this._boundRenderSettingsChanged); const i = this.context.pre_render_callbacks.indexOf(this.onBeforeRenderRoutine); i !== -1 && this.context.pre_render_callbacks.splice(i, 1); const e = this.context.post_render_callbacks.indexOf(this.onAfterRenderRoutine); e !== -1 && this.context.post_render_callbacks.splice(e, 1) } registerTransform(i) { this._rectTransforms.push(i) } unregisterTransform(i) { const e = this._rectTransforms.indexOf(i); e !== -1 && this._rectTransforms.splice(e, 1) } registerLayoutGroup(i) { const e = i.gameObject; this._layoutGroups.set(e, i) } unregisterLayoutGroup(i) { const e = i.gameObject; this._layoutGroups.delete(e) } handleLayoutUpdates() { this._lastMatrixWorld === null && (this._lastMatrixWorld = new He); const i = !this._lastMatrixWorld.equals(this.gameObject.matrixWorld); XE && i && console.log("Canvas Layout changed", this.context.time.frameCount, this.name); let e = !1; for (const t of this._rectTransforms) { i && t.markDirty(); let s = this._layoutGroups.get(t.gameObject); t.isDirty && !s && (s = t.gameObject.getComponentInParent(hn)), (t.isDirty || s != null && s.isDirty) && (XE && !e && console.log("CANVAS UPDATE ### " + t.name + " ##################################### " + this.context.time.frame), s?.updateLayout(), t.updateTransform()) } } applyRenderSettings() { this.onRenderSettingsChanged() } onRenderSettingsChanged() { this._updateRenderSettingsRoutine || (this._updateRenderSettingsRoutine = this.startCoroutine(this._updateRenderSettingsDelayed(), on.OnBeforeRender)) } *_updateRenderSettingsDelayed() { if (yield, this._updateRenderSettingsRoutine = void 0, this.shadowComponent) { this.onUpdateRenderMode(), Sb(this.shadowComponent, this); for (const i of $.getComponentsInChildren(this.gameObject, ba)) Sb(i.shadowComponent, this) } } onUpdateRenderMode(i = !1) { if (!i && this._renderMode === this._activeRenderMode && this._lastWidth === this.context.domWidth && this._lastHeight === this.context.domHeight) return; this._activeRenderMode = this._renderMode; let e = this.context.mainCameraComponent, t = 10; switch (e && e.nearClipPlane > 0 && e.farClipPlane > 0 && (t = Ke.lerp(e.nearClipPlane, e.farClipPlane, .15)), this._renderMode === 1 && (this.worldCamera && (e = this.worldCamera), this.planeDistance > 0 && (t = this.planeDistance)), this._renderMode) { case 0: case 1: if (this._lastWidth = this.context.domWidth, this._lastHeight = this.context.domHeight, !e) return; const s = t + .01; this.gameObject.position.x = 0, this.gameObject.position.y = 0, this.gameObject.position.z = -s, this.gameObject.quaternion.identity(); const r = this.gameObject.getComponent(Tr); let n = !1; r.sizeDelta.x !== this.context.domWidth && (n = !0), r.sizeDelta.y !== this.context.domHeight && (n = !0); const o = e.fieldOfView * Math.PI / 180, a = 2 * Math.tan(o / 2) * Math.abs(s); this.gameObject.scale.x = a / this.context.domHeight, this.gameObject.scale.y = a / this.context.domHeight, this.gameObject.scale.z = .01, n && (r.sizeDelta.x = this.context.domWidth, r.sizeDelta.y = this.context.domHeight, r?.markDirty()); break; case 2: this._lastWidth = -1, this._lastHeight = -1; break } } }; let cr = QF; sa([x()], cr.prototype, "renderOnTop", 1), sa([x()], cr.prototype, "depthWrite", 1), sa([x()], cr.prototype, "doubleSided", 1), sa([x()], cr.prototype, "castShadows", 1), sa([x()], cr.prototype, "receiveShadows", 1), sa([x()], cr.prototype, "renderMode", 1), sa([x(cr)], cr.prototype, "rootCanvas", 1), sa([x()], cr.prototype, "scaleFactor", 1), sa([x(Si)], cr.prototype, "worldCamera", 2), sa([x()], cr.prototype, "planeDistance", 2); var rte = Object.defineProperty, nte = Object.getOwnPropertyDescriptor, YE = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? nte(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && rte(e, t, r), r }; class Ap extends Ee { constructor() { super(...arguments), u(this, "_alpha", 1), u(this, "interactable", !0), u(this, "blocksRaycasts", !0), u(this, "_isDirty", !1), u(this, "_buffer", []) } get alpha() { return this._alpha } set alpha(e) { e !== this._alpha && (this._alpha = e, this.markDirty()) } get isCanvasGroup() { return !0 } markDirty() { this._isDirty || (this._isDirty = !0, this.startCoroutine(this.applyChangesDelayed(), on.OnBeforeRender)) } *applyChangesDelayed() { this._isDirty = !1, this.applyChangesNow() } applyChangesNow() { for (const e of $.getComponentsInChildren(this.gameObject, Dc, this._buffer)) e.setAlphaFactor(this._alpha) } } YE([x()], Ap.prototype, "alpha", 1), YE([x()], Ap.prototype, "interactable", 2), YE([x()], Ap.prototype, "blocksRaycasts", 2); var ote = Object.defineProperty, ate = Object.getOwnPropertyDescriptor, Ei = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? ate(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && ote(e, t, r), r }; class tu extends Ee { constructor() { super(...arguments), u(this, "object"), u(this, "target"), u(this, "duration", 1), u(this, "relativeMotion", !1), u(this, "coroutine", null), u(this, "targetPos", new S), u(this, "targetRot", new we), u(this, "targetScale", new S) } *moveToTarget() { if (!this.target || !this.object) return; const e = xt(this.object).clone(), t = xt(this.target).clone(), s = _s(this.object).clone(), r = _s(this.target).clone(), n = Fs(this.object).clone(), o = Fs(this.target).clone(), a = e.distanceTo(t), l = s.angleTo(r), c = n.distanceTo(o); if (a < .01 && l < .01 && c < .01) { ts(this.object, t), Dr(this.object, r), A1(this.object, o), this.coroutine = null; return } let h = 0, d = 0; for (; h < 1;)h += this.context.time.deltaTime / this.duration, h > 1 && (h = 1), d = h < .5 ? 4 * h * h * h : 1 - Math.pow(-2 * h + 2, 3) / 2, this.targetPos.lerpVectors(e, t, d), this.targetRot.slerpQuaternions(s, r, d), this.targetScale.lerpVectors(n, o, d), ts(this.object, this.targetPos), Dr(this.object, this.targetRot), A1(this.object, this.targetScale), yield; this.coroutine = null } *moveRelative() { if (!this.target || !this.object) return; const e = this.object.position.clone(), t = this.object.quaternion.clone(), s = this.object.scale.clone(), r = this.target.position.clone(), n = this.target.quaternion.clone(), o = this.target.scale.clone(); r.applyQuaternion(this.object.quaternion), this.targetPos.copy(this.object.position).add(r), this.targetRot.copy(this.object.quaternion).multiply(n), this.targetScale.copy(this.object.scale).multiply(o); let a = 0, l = 0; for (; a < 1;)a += this.context.time.deltaTime / this.duration, a > 1 && (a = 1), l = a < .5 ? 4 * a * a * a : 1 - Math.pow(-2 * a + 2, 3) / 2, this.object.position.lerpVectors(e, this.targetPos, l), this.object.quaternion.slerpQuaternions(t, this.targetRot, l), this.object.scale.lerpVectors(s, this.targetScale, l), yield; this.coroutine = null } onPointerClick() { this.coroutine && this.stopCoroutine(this.coroutine), this.relativeMotion ? this.coroutine = this.startCoroutine(this.moveRelative()) : this.coroutine = this.startCoroutine(this.moveToTarget()) } beforeCreateDocument(e) { var t; if (this.target && this.object && this.gameObject) { const s = new Cr("Move to " + ((t = this.target) == null ? void 0 : t.name), zr.tapTrigger(this.gameObject), ni.transformAction(this.object, this.target, this.duration, this.relativeMotion ? xS.Relative : xS.Absolute)); e.addBehavior(s) } } } Ei([x(Me)], tu.prototype, "object", 2), Ei([x(Me)], tu.prototype, "target", 2), Ei([x()], tu.prototype, "duration", 2), Ei([x()], tu.prototype, "relativeMotion", 2); var JE; const yp = (JE = class extends Ee { constructor() { super(...arguments), u(this, "materialToSwitch"), u(this, "variantMaterial"), u(this, "_objectsWithThisMaterial", []), u(this, "selfModel"), u(this, "targetModels", []) } awake() { if (this.variantMaterial && this.materialToSwitch) { const i = $.findObjectsOfType(Ui); for (const e of i) e.sharedMaterial === this.materialToSwitch && this._objectsWithThisMaterial.push(e) } } onPointerClick() { if (this.variantMaterial) for (const i of this._objectsWithThisMaterial) i.sharedMaterial = this.variantMaterial } createBehaviours(i, e, t) { this._objectsWithThisMaterial.find(s => s.gameObject.uuid === e.uuid) && this.targetModels.push(e), this.gameObject.uuid === e.uuid && (this.selfModel = e, this.materialToSwitch && (yp._materialTriggersPerId[this.materialToSwitch.uuid] || (yp._materialTriggersPerId[this.materialToSwitch.uuid] = []), yp._materialTriggersPerId[this.materialToSwitch.uuid].push(this))) } afterCreateDocument(i, e) { if (!this.materialToSwitch) return; const t = yp._materialTriggersPerId[this.materialToSwitch.uuid]; if (t) { const s = {}; for (const n of t) { const o = n.createVariants(); o && o.length > 0 && (s[n.selfModel.uuid] = o) } const r = []; for (const n of t) { for (const o in s) o !== n.selfModel.uuid && r.push(s[o]); n.createAndAttachBehaviors(i, s[n.selfModel.uuid], r) } } delete yp._materialTriggersPerId[this.materialToSwitch.uuid] } createAndAttachBehaviors(i, e, t) { const s = [], r = []; for (const n of this.targetModels) { const o = ni.fadeAction(n, 0, !1); r.push(o) } for (const n of t) r.push(ni.fadeAction(n, 0, !1)); for (const n of e) s.push(ni.fadeAction(n, 0, !1)), r.push(ni.fadeAction(n, 0, !0)); i.addBehavior(new Cr("Select " + this.selfModel.name, zr.tapTrigger(this.selfModel), ni.parallel(...r))), i.addBehavior(new Cr("Start hidden " + this.selfModel.name, zr.sceneStartTrigger(), ni.parallel(...s))) } createVariants() { if (!this.variantMaterial) return null; const i = []; for (const e of this.targetModels) { const t = e.clone(); t.name += " variant_" + this.variantMaterial.name, t.name = t.name.replace(/\s/g, "_"), t.material = this.variantMaterial, t.geometry = e.geometry, t.matrix = e.matrix, (!e.parent || !e.parent.isEmpty()) && nl.createEmptyParent(e), e.parent && e.parent.add(t), i.push(t) } return i } }, u(JE, "_materialTriggersPerId", {}), JE); let Cm = yp; Ei([x(Tt)], Cm.prototype, "materialToSwitch", 2), Ei([x(Tt)], Cm.prototype, "variantMaterial", 2); class bp extends Ee { constructor() { super(...arguments), u(this, "target"), u(this, "toggleOnClick", !1), u(this, "targetState", !0), u(this, "hideSelf", !0), u(this, "selfModel"), u(this, "otherModel"), u(this, "toggleModel"), u(this, "stateBeforeCreatingDocument", !1) } onPointerClick() { !this.toggleOnClick && this.hideSelf && (this.gameObject.visible = !1), this.target && (this.target.visible = this.toggleOnClick ? !this.target.visible : this.targetState) } createBehaviours(e, t, s) { t.uuid === this.gameObject.uuid && (this.selfModel = t) } beforeCreateDocument() { this.stateBeforeCreatingDocument = this.gameObject.visible, this.gameObject.visible = !0 } afterCreateDocument(e, t) { if (this.target) { if (this.otherModel = t.document.findById(this.target.uuid), this.selfModel && this.otherModel) { let s = this.hideSelf; this.targetState, this.toggleOnClick && (s = !0, this.target.visible, (!this.selfModel.parent || this.selfModel.parent.isEmpty()) && AL.createEmptyParent(this.selfModel), this.toggleModel = this.selfModel.clone(), this.toggleModel.name += "_toggle", this.selfModel.parent.add(this.toggleModel)); const r = []; if (s && r.push(ni.fadeAction(this.selfModel, 0, !1)), this.toggleModel && r.push(ni.fadeAction(this.toggleModel, 0, !0)), r.push(ni.fadeAction(this.otherModel, 0, this.targetState)), e.addBehavior(new Cr("Toggle_" + this.selfModel.name + "_hideSelf", zr.tapTrigger(this.selfModel), ni.sequence(...r))), this.toggleOnClick && this.toggleModel) { const n = []; n.push(ni.fadeAction(this.toggleModel, 0, !1)), n.push(ni.fadeAction(this.selfModel, 0, !0)), n.push(ni.fadeAction(this.otherModel, 0, !this.targetState)), e.addBehavior(new Cr("Toggle_" + this.selfModel.name + "_toggleSelf", zr.tapTrigger(this.toggleModel), ni.sequence(...n))), e.addBehavior(new Cr("HideOnStart_" + this.gameObject.name, zr.sceneStartTrigger(), ni.fadeAction(this.toggleModel, 0, !1))) } } this.gameObject.visible = this.stateBeforeCreatingDocument } } } Ei([x(Me)], bp.prototype, "target", 2), Ei([x()], bp.prototype, "targetState", 2), Ei([x()], bp.prototype, "hideSelf", 2); class KE extends Ee { start() { this.gameObject.visible = !1 } createBehaviours(e, t, s) { t.uuid === this.gameObject.uuid && e.addBehavior(new Cr("HideOnStart_" + this.gameObject.name, zr.sceneStartTrigger(), ni.fadeAction(t, 0, !1))) } beforeCreateDocument() { this.gameObject.visible = !0 } afterCreateDocument() { this.gameObject.visible = !1 } } class _p extends Ee { constructor() { super(...arguments), u(this, "target"), u(this, "duration", .5), u(this, "motionType", _S.bounce) } beforeCreateDocument() { } createBehaviours(e, t, s) { if (this.target && t.uuid === this.gameObject.uuid) { const r = new Cr("emphasize " + this.name, zr.tapTrigger(this.gameObject), ni.emphasize(this.target, this.duration, this.motionType, void 0, "basic")); e.addBehavior(r) } } afterCreateDocument(e, t) { } } Ei([x()], _p.prototype, "target", 2), Ei([x()], _p.prototype, "duration", 2), Ei([x()], _p.prototype, "motionType", 2); class xp extends Ee { constructor() { super(...arguments), u(this, "target"), u(this, "clip", ""), u(this, "toggleOnClick", !1) } onPointerClick() { if (!(!this.target && !this.clip)) { if (!this.target) { const e = this.gameObject.addNewComponent(ss); e && (e.spatialBlend = 1, e.volume = 1, e.loop = !1, this.target = e) } this.target && (this.target.isPlaying && this.toggleOnClick ? this.target.stop() : (!this.toggleOnClick && this.target.isPlaying && this.target.stop(), this.clip ? this.target.play(this.clip) : this.target.play())) } } createBehaviours(e, t, s) { if (!(!this.target && !this.clip) && t.uuid === this.gameObject.uuid) { const r = this.clip ? this.clip : this.target ? this.target.clip : void 0; if (!r) return; const n = this.target ? this.target.gameObject : this.gameObject, o = r.split("/").pop(), a = this.target ? this.target.volume : 1, l = this.target && this.target.spatialBlend == 0 ? CS.NonSpatial : CS.Spatial, c = new Cr("playAudio " + this.name, zr.tapTrigger(this.gameObject), ni.playAudioAction(n, "audio/" + o, PL.Play, a, l)); e.addBehavior(c) } } async afterSerialize(e, t) { if (!this.target && !this.clip) return; const s = this.clip ? this.clip : this.target ? this.target.clip : void 0; if (!s) return; const r = s.split("/").pop(), n = await (await (await fetch(this.clip)).blob()).arrayBuffer(), o = new Uint8Array(n); t.files["audio/" + r] = o } } Ei([x(ss)], xp.prototype, "target", 2), Ei([x(URL)], xp.prototype, "clip", 2), Ei([x()], xp.prototype, "toggleOnClick", 2); var ZE; const wp = (ZE = class extends Ee { constructor() { super(...arguments), u(this, "target"), u(this, "animator"), u(this, "stateName"), u(this, "stateNameAfterPlaying"), u(this, "loopAfterPlaying", !1), u(this, "selfModel"), u(this, "stateAnimationModel"), u(this, "stateAnimation"), u(this, "stateAfterPlayingAnimationModel"), u(this, "stateAfterPlayingAnimation") } onPointerClick() { var i; this.target && this.stateName && ((i = this.animator) == null || i.play(this.stateName, 0, 0, .1)) } createBehaviours(i, e, t) { e.uuid === this.gameObject.uuid && (this.selfModel = e) } onAfterHierarchy() { wp.animationActions = [] } afterCreateDocument(i, e) { !this.stateAnimation || !this.stateAnimationModel || e.document.traverse(t => { var s, r; if (t.uuid === ((s = this.target) == null ? void 0 : s.uuid) && this.stateAnimation) { const n = []; let o = wp.animationActions.find(l => l.affectedObjects == t && l.start == this.stateAnimation.start && l.duration == this.stateAnimation.duration); if (o || (o = ni.startAnimationAction(t, this.stateAnimation.start, this.stateAnimation.duration), wp.animationActions.push(o)), n.push(o), this.stateAfterPlayingAnimation && this.stateAfterPlayingAnimationModel) { let l = wp.animationActions.find(h => h.affectedObjects == t && h.start == this.stateAfterPlayingAnimation.start && h.duration == this.stateAfterPlayingAnimation.duration); l || (l = ni.startAnimationAction(t, this.stateAfterPlayingAnimation.start, this.stateAfterPlayingAnimation.duration), wp.animationActions.push(l)); const c = ni.sequence(l); this.loopAfterPlaying && c.makeLooping(), n.push(c) } const a = new Cr("tap " + this.name + " for " + this.stateName + " on " + ((r = this.target) == null ? void 0 : r.name), zr.tapTrigger(this.selfModel), ni.sequence(...n)); i.addBehavior(a) } }) } createAnimation(i, e, t) { var s, r, n, o; if (this.target && this.animator) { const a = (r = (s = this.animator) == null ? void 0 : s.runtimeAnimatorController) == null ? void 0 : r.findState(this.stateName); this.stateAnimationModel = e, this.stateAnimation = i.registerAnimation(this.target, a?.motion.clip); const l = (o = (n = this.animator) == null ? void 0 : n.runtimeAnimatorController) == null ? void 0 : o.findState(this.stateNameAfterPlaying); this.stateAfterPlayingAnimationModel = e, this.stateAfterPlayingAnimation = i.registerAnimation(this.target, l?.motion.clip) } } }, u(ZE, "animationActions", []), ZE); let Fc = wp; Ei([x(Me)], Fc.prototype, "target", 2), Ei([x(Fr)], Fc.prototype, "animator", 2), Ei([x()], Fc.prototype, "stateName", 2), Ei([x()], Fc.prototype, "stateNameAfterPlaying", 2), Ei([x()], Fc.prototype, "loopAfterPlaying", 2); class Cp extends Ee { constructor() { super(...arguments), u(this, "target") } getType() { } getDuration() { } } Ei([x(Me)], Cp.prototype, "target", 2); class Sm extends Ee { constructor() { super(...arguments), u(this, "target") } } Ei([x(Cp)], Sm.prototype, "target", 2); class Em extends Cp { constructor() { super(...arguments), u(this, "type", 1), u(this, "duration", 1) } getType() { switch (this.type) { case 1: return "hide"; case 0: return "show" } } getDuration() { return this.duration } } Ei([x()], Em.prototype, "type", 2), Ei([x()], Em.prototype, "duration", 2); class $E extends Sm { } var lte = Object.defineProperty, cte = Object.getOwnPropertyDescriptor, yl = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? cte(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && lte(e, t, r), r }; class iu extends Ee { constructor() { super(...arguments), u(this, "center", new S(0, 0, 0)), u(this, "radius", .5), u(this, "height", 2), u(this, "_rigidbody", null), u(this, "_activeGroundCollisions", new Set) } get rigidbody() { return this._rigidbody ? this._rigidbody : (this._rigidbody = this.gameObject.getComponent(ki), this._rigidbody || (this._rigidbody = this.gameObject.addNewComponent(ki)), this.rigidbody) } onEnable() { let e = this.rigidbody, t = this.gameObject.getComponent(kc); t || (t = this.gameObject.addNewComponent(kc)), t.center.copy(this.center), t.radius = this.radius, t.height = this.height, this.gameObject.rotation.x = 0, this.gameObject.rotation.z = 0, e.lockRotationX = !0, e.lockRotationY = !0, e.lockRotationZ = !0 } move(e) { this.gameObject.position.add(e) } onCollisionEnter(e) { for (const t of e.contacts) if (t.normal.y > .1) { this._activeGroundCollisions.add(e); break } } onCollisionExit(e) { this._activeGroundCollisions.delete(e) } get isGrounded() { return this._activeGroundCollisions.size > 0 } } yl([x(S)], iu.prototype, "center", 2), yl([x()], iu.prototype, "radius", 2), yl([x()], iu.prototype, "height", 2); class bl extends Ee { constructor() { super(...arguments), u(this, "controller"), u(this, "movementSpeed", 2), u(this, "rotationSpeed", 2), u(this, "jumpForce", 1), u(this, "doubleJumpForce", 2), u(this, "animator"), u(this, "lookForward", !0), u(this, "_currentSpeed", new S(0, 0, 0)), u(this, "_currentAngularSpeed", new S(0, 0, 0)), u(this, "_temp", new S(0, 0, 0)), u(this, "_jumpCount", 0), u(this, "_currentRotation"), u(this, "_raycastOptions", new co) } awake() { this._currentRotation = new we } update() { var e, t, s, r, n, o, a, l, c, h, d; (e = this.controller) != null && e.isGrounded && (this._jumpCount = 0, this.doubleJumpForce > 0 && ((t = this.animator) == null || t.setBool("doubleJump", !1))); const p = this.context.input.isKeyPressed("w"), f = this.context.input.isKeyPressed("s"), g = this.context.input.isKeyPressed("a"), m = this.context.input.isKeyPressed("d"), v = this.context.input.isKeyDown(" "), A = (p ? 1 : 0) + (f ? -1 : 0); this._currentSpeed.z += A * this.movementSpeed * this.context.time.deltaTime, (s = this.animator) == null || s.setBool("running", A != 0), (n = this.animator) == null || n.setBool("jumping", ((r = this.controller) == null ? void 0 : r.isGrounded) === !0 && v), this._temp.copy(this._currentSpeed), this._temp.applyQuaternion(this.gameObject.quaternion), this.controller ? this.controller.move(this._temp) : this.gameObject.position.add(this._temp); const b = (g ? 1 : 0) + (m ? -1 : 0); if (this._currentAngularSpeed.y += Ke.toRadians(b * this.rotationSpeed) * this.context.time.deltaTime, this.lookForward && Math.abs(this._currentAngularSpeed.y) < .01) { const y = this.context.mainCameraComponent.forward; y.y = 0, y.normalize(), this._currentRotation.setFromUnitVectors(new S(0, 0, 1), y), this.gameObject.quaternion.slerp(this._currentRotation, this.context.time.deltaTime * 10) } if (this.gameObject.rotateY(this._currentAngularSpeed.y), this._currentSpeed.multiplyScalar(1 - this.context.time.deltaTime * 10), this._currentAngularSpeed.y *= 1 - this.context.time.deltaTime * 10, this.controller && v && this.jumpForce > 0) { let y = (o = this.controller) == null ? void 0 : o.isGrounded; if (this.doubleJumpForce > 0 && !((a = this.controller) != null && a.isGrounded) && this._jumpCount === 1 && (y = !0, (l = this.animator) == null || l.setBool("doubleJump", !0)), y) { this._jumpCount += 1; const _ = this.controller.rigidbody, w = this._jumpCount === 2 ? this.doubleJumpForce : this.jumpForce; _.applyImpulse(new S(0, 1, 0).multiplyScalar(w)) } } if (this.controller) { const y = (c = this.controller) == null ? void 0 : c.rigidbody.getVelocity().y; if (y < -1) { this._raycastOptions.ray || (this._raycastOptions.ray = new Oa), this._raycastOptions.ray.origin.copy(xt(this.gameObject)), this._raycastOptions.ray.direction.set(0, -1, 0); const _ = this.layer; this.gameObject.layers.disableAll(), this.gameObject.layers.set(2); const w = this.context.physics.raycast(this._raycastOptions); this.gameObject.layers.set(_), (w.length && w[0].distance > 2 || y < -10) && ((h = this.animator) == null || h.setBool("falling", !0)) } else (d = this.animator) == null || d.setBool("falling", !1) } } } yl([x(iu)], bl.prototype, "controller", 2), yl([x()], bl.prototype, "movementSpeed", 2), yl([x()], bl.prototype, "rotationSpeed", 2), yl([x()], bl.prototype, "jumpForce", 2), yl([x()], bl.prototype, "doubleJumpForce", 2), yl([x(Fr)], bl.prototype, "animator", 2); var hte = Object.defineProperty, ute = Object.getOwnPropertyDescriptor, dte = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? ute(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && hte(e, t, r), r }; class Mm extends Ir { constructor() { super(...arguments), u(this, "intensity") } get typeName() { return "ChromaticAberration" } init() { this.intensity.defaultValue = 0 } onCreateEffect() { const e = new V2; return e.offset = new W(0, 0), e.radialModulation = !0, e.modulationOffset = .15, this.intensity.valueProcessor = t => t * .02, this.intensity.onValueChanged = t => { e.offset.x = -t, e.offset.y = t }, e } } dte([x(Dt)], Mm.prototype, "intensity", 2), ta("ChromaticAberration", Mm); var pte = Object.defineProperty, fte = Object.getOwnPropertyDescriptor, Pb = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? fte(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && pte(e, t, r), r }; class Uc extends Ir { constructor() { super(...arguments), u(this, "postExposure"), u(this, "contrast"), u(this, "hueShift"), u(this, "saturation") } get typeName() { return "ColorAdjustments" } init() { this.postExposure.valueProcessor = e => (e = Math.pow(2, e), e), this.postExposure.defaultValue = 0, this.contrast.valueProcessor = e => { let t = 1; return e > 0 ? t = 200 : e < 0 && (t = 100), e / t }, this.contrast.defaultValue = 0, this.hueShift.valueProcessor = e => Math.PI * e / 180, this.hueShift.defaultValue = 0, this.saturation.valueProcessor = e => e < 0 ? e / 100 : e / (100 * Math.PI), this.saturation.defaultValue = 0 } unapply() { this.context.renderer.toneMappingExposure = 1 } onCreateEffect() { this.context.renderer.toneMapping === fr && this.postExposure.overrideState && (this.context.renderer.toneMapping = uf); const e = new H2; this.postExposure.onValueChanged = s => { this.context.renderer.toneMapping === fr && (this.context.renderer.toneMapping = uf), this.context.renderer.toneMappingExposure = s }, this.contrast.onValueChanged = s => { e.contrast = s }; const t = new q2; return this.hueShift.onValueChanged = s => t.hue = s, this.saturation.onValueChanged = s => t.saturation = s, [t, e] } } Pb([x(Dt)], Uc.prototype, "postExposure", 2), Pb([x(Dt)], Uc.prototype, "contrast", 2), Pb([x(Dt)], Uc.prototype, "hueShift", 2), Pb([x(Dt)], Uc.prototype, "saturation", 2), ta("ColorAdjustments", Uc); const gte = (Math.sqrt(5) - 1) / 4, Gs = (5 - Math.sqrt(5)) / 20, Bb = i => Math.floor(i) | 0, kb = new Float64Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]); function mte(i = Math.random) { const e = vte(i), t = new Float64Array(e).map(o => kb[o % 32 * 4]), s = new Float64Array(e).map(o => kb[o % 32 * 4 + 1]), r = new Float64Array(e).map(o => kb[o % 32 * 4 + 2]), n = new Float64Array(e).map(o => kb[o % 32 * 4 + 3]); return function (o, a, l, c) { let h, d, p, f, g; const m = (o + a + l + c) * gte, v = Bb(o + m), A = Bb(a + m), b = Bb(l + m), y = Bb(c + m), _ = (v + A + b + y) * Gs, w = v - _, E = A - _, P = b - _, C = y - _, R = o - w, T = a - E, z = l - P, H = c - C; let N = 0, F = 0, X = 0, te = 0; R > T ? N++ : F++, R > z ? N++ : X++, R > H ? N++ : te++, T > z ? F++ : X++, T > H ? F++ : te++, z > H ? X++ : te++; const re = N >= 3 ? 1 : 0, Z = F >= 3 ? 1 : 0, fe = X >= 3 ? 1 : 0, ae = te >= 3 ? 1 : 0, De = N >= 2 ? 1 : 0, Se = F >= 2 ? 1 : 0, ie = X >= 2 ? 1 : 0, ce = te >= 2 ? 1 : 0, Te = N >= 1 ? 1 : 0, K = F >= 1 ? 1 : 0, je = X >= 1 ? 1 : 0, Ue = te >= 1 ? 1 : 0, Pe = R - re + Gs, ve = T - Z + Gs, de = z - fe + Gs, Ae = H - ae + Gs, pe = R - De + 2 * Gs, Fe = T - Se + 2 * Gs, Re = z - ie + 2 * Gs, ht = H - ce + 2 * Gs, me = R - Te + 3 * Gs, ut = T - K + 3 * Gs, dt = z - je + 3 * Gs, Pt = H - Ue + 3 * Gs, ii = R - 1 + 4 * Gs, U = T - 1 + 4 * Gs, D = z - 1 + 4 * Gs, le = H - 1 + 4 * Gs, Ie = v & 255, Be = A & 255, Qe = b & 255, rt = y & 255; let j = .6 - R * R - T * T - z * z - H * H; if (j < 0) h = 0; else { const ge = Ie + e[Be + e[Qe + e[rt]]]; j *= j, h = j * j * (t[ge] * R + s[ge] * T + r[ge] * z + n[ge] * H) } let J = .6 - Pe * Pe - ve * ve - de * de - Ae * Ae; if (J < 0) d = 0; else { const ge = Ie + re + e[Be + Z + e[Qe + fe + e[rt + ae]]]; J *= J, d = J * J * (t[ge] * Pe + s[ge] * ve + r[ge] * de + n[ge] * Ae) } let Ve = .6 - pe * pe - Fe * Fe - Re * Re - ht * ht; if (Ve < 0) p = 0; else { const ge = Ie + De + e[Be + Se + e[Qe + ie + e[rt + ce]]]; Ve *= Ve, p = Ve * Ve * (t[ge] * pe + s[ge] * Fe + r[ge] * Re + n[ge] * ht) } let qe = .6 - me * me - ut * ut - dt * dt - Pt * Pt; if (qe < 0) f = 0; else { const ge = Ie + Te + e[Be + K + e[Qe + je + e[rt + Ue]]]; qe *= qe, f = qe * qe * (t[ge] * me + s[ge] * ut + r[ge] * dt + n[ge] * Pt) } let ze = .6 - ii * ii - U * U - D * D - le * le; if (ze < 0) g = 0; else { const ge = Ie + 1 + e[Be + 1 + e[Qe + 1 + e[rt + 1]]]; ze *= ze, g = ze * ze * (t[ge] * ii + s[ge] * U + r[ge] * D + n[ge] * le) } return 27 * (h + d + p + f + g) } } function vte(i) { const e = new Uint8Array(512); for (let t = 0; t < 512 / 2; t++)e[t] = t; for (let t = 0; t < 512 / 2 - 1; t++) { const s = t + ~~(i() * (256 - t)), r = e[t]; e[t] = e[s], e[s] = r } for (let t = 256; t < 512; t++)e[t] = e[t - 256]; return e } var Ate = Object.defineProperty, yte = Object.getOwnPropertyDescriptor, q = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? yte(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Ate(e, t, r), r }; const Db = oe("debugparticles"); var ra = (i => (i[i.Billboard = 0] = "Billboard", i[i.Stretch = 1] = "Stretch", i[i.HorizontalBillboard = 2] = "HorizontalBillboard", i[i.VerticalBillboard = 3] = "VerticalBillboard", i[i.Mesh = 4] = "Mesh", i))(ra || {}); class Nc { constructor() { u(this, "alphaKeys"), u(this, "colorKeys") } get duration() { return 1 } evaluate(e, t) { let s, r = 0, n = null, o = 0; for (let a = 0; a < this.alphaKeys.length; a++) { const l = this.alphaKeys[a]; (l.time < e || !s) && (s = l, r = a) } for (let a = 0; a < this.colorKeys.length; a++) { const l = this.colorKeys[a]; (l.time < e || !n) && (n = l, o = a) } if (n) if (o + 1 < this.colorKeys.length) { const a = this.colorKeys[o + 1], l = Ke.remap(e, n.time, a.time, 0, 1); t.r = Ke.lerp(n.color.r, a.color.r, l), t.g = Ke.lerp(n.color.g, a.color.g, l), t.b = Ke.lerp(n.color.b, a.color.b, l) } else t.r = n.color.r, t.g = n.color.g, t.b = n.color.b; if (s) if (r + 1 < this.alphaKeys.length) { const a = this.alphaKeys[r + 1], l = Ke.remap(e, s.time, a.time, 0, 1); t.alpha = Ke.lerp(s.alpha, a.alpha, l) } else t.alpha = s.alpha; return t } } q([x()], Nc.prototype, "alphaKeys", 2), q([x()], Nc.prototype, "colorKeys", 2); var Ob = (i => (i[i.Local = 0] = "Local", i[i.World = 1] = "World", i[i.Custom = 2] = "Custom", i))(Ob || {}), GF = (i => (i[i.Sphere = 0] = "Sphere", i[i.SphereShell = 1] = "SphereShell", i[i.Hemisphere = 2] = "Hemisphere", i[i.HemisphereShell = 3] = "HemisphereShell", i[i.Cone = 4] = "Cone", i[i.Box = 5] = "Box", i[i.Mesh = 6] = "Mesh", i[i.ConeShell = 7] = "ConeShell", i[i.ConeVolume = 8] = "ConeVolume", i[i.ConeVolumeShell = 9] = "ConeVolumeShell", i[i.Circle = 10] = "Circle", i[i.CircleEdge = 11] = "CircleEdge", i[i.SingleSidedEdge = 12] = "SingleSidedEdge", i[i.MeshRenderer = 13] = "MeshRenderer", i[i.SkinnedMeshRenderer = 14] = "SkinnedMeshRenderer", i[i.BoxShell = 15] = "BoxShell", i[i.BoxEdge = 16] = "BoxEdge", i[i.Donut = 17] = "Donut", i[i.Rectangle = 18] = "Rectangle", i[i.Sprite = 19] = "Sprite", i[i.SpriteRenderer = 20] = "SpriteRenderer", i))(GF || {}); class it { constructor() { u(this, "mode"), u(this, "constant"), u(this, "constantMin"), u(this, "constantMax"), u(this, "curve"), u(this, "curveMin"), u(this, "curveMax"), u(this, "curveMultiplier") } evaluate(e, t) { const s = t === void 0 ? Math.random() : t; switch (this.mode) { case 0: return this.constant; case 1: return e = Ke.clamp01(e), this.curve.evaluate(e) * this.curveMultiplier; case 2: const r = e * this.curveMin.duration, n = e * this.curveMax.duration; return Ke.lerp(this.curveMin.evaluate(r), this.curveMax.evaluate(n), s % 1) * this.curveMultiplier; case 3: return Ke.lerp(this.constantMin, this.constantMax, s % 1); default: this.curveMax.evaluate(e) * this.curveMultiplier; break }return 0 } getMax() { switch (this.mode) { case 0: return this.constant; case 1: return this.getMaxFromCurve(this.curve) * this.curveMultiplier; case 2: return Math.max(this.getMaxFromCurve(this.curveMin), this.getMaxFromCurve(this.curveMax)) * this.curveMultiplier; case 3: return Math.max(this.constantMin, this.constantMax); default: return 0 } } getMaxFromCurve(e) { if (!e) return 0; let t = Number.MIN_VALUE; for (let s = 0; s < e.keys.length; s++) { const r = e.keys[s]; r.value > t && (t = r.value) } return t } } q([x()], it.prototype, "mode", 2), q([x()], it.prototype, "constant", 2), q([x()], it.prototype, "constantMin", 2), q([x()], it.prototype, "constantMax", 2), q([x(Gh)], it.prototype, "curve", 2), q([x(Gh)], it.prototype, "curveMin", 2), q([x(Gh)], it.prototype, "curveMax", 2), q([x()], it.prototype, "curveMultiplier", 2); var Lb; const So = (Lb = class { constructor() { u(this, "mode"), u(this, "color"), u(this, "colorMin"), u(this, "colorMax"), u(this, "gradient"), u(this, "gradientMin"), u(this, "gradientMax") } evaluate(i, e) { const t = e === void 0 ? Math.random() : e; switch (this.mode) { case 0: return this.color; case 1: return this.gradient.evaluate(i, So._temp), So._temp; case 2: return So._temp.lerpColors(this.colorMin, this.colorMax, t); case 3: return this.gradientMin.evaluate(i, So._temp), this.gradientMax.evaluate(i, So._temp2), So._temp.lerp(So._temp2, t) }return So._temp.set(16711935), So._temp.alpha = 1, So._temp } }, u(Lb, "_temp", new mi(0, 0, 0, 1)), u(Lb, "_temp2", new mi(0, 0, 0, 1)), Lb); let Hr = So; q([x(mi)], Hr.prototype, "color", 2), q([x(mi)], Hr.prototype, "colorMin", 2), q([x(mi)], Hr.prototype, "colorMax", 2), q([x(Nc)], Hr.prototype, "gradient", 2), q([x(Nc)], Hr.prototype, "gradientMin", 2), q([x(Nc)], Hr.prototype, "gradientMax", 2); class Hs { constructor() { u(this, "cullingMode"), u(this, "duration"), u(this, "emitterVelocityMode"), u(this, "flipRotation"), u(this, "gravityModifier"), u(this, "gravityModifierMultiplier"), u(this, "loop"), u(this, "maxParticles"), u(this, "playOnAwake"), u(this, "prewarm"), u(this, "ringBufferLoopRange"), u(this, "ringBufferMode"), u(this, "scalingMode"), u(this, "simulationSpace"), u(this, "simulationSpeed"), u(this, "startColor"), u(this, "startDelay"), u(this, "startDelayMultiplier"), u(this, "startLifetime"), u(this, "startLifetimeMultiplier"), u(this, "startRotation"), u(this, "startRotationMultiplier"), u(this, "startRotation3D"), u(this, "startRotationX"), u(this, "startRotationXMultiplier"), u(this, "startRotationY"), u(this, "startRotationYMultiplier"), u(this, "startRotationZ"), u(this, "startRotationZMultiplier"), u(this, "startSize"), u(this, "startSize3D"), u(this, "startSizeMultiplier"), u(this, "startSizeX"), u(this, "startSizeXMultiplier"), u(this, "startSizeY"), u(this, "startSizeYMultiplier"), u(this, "startSizeZ"), u(this, "startSizeZMultiplier"), u(this, "startSpeed"), u(this, "startSpeedMultiplier"), u(this, "stopAction"), u(this, "useUnscaledTime") } } q([x(it)], Hs.prototype, "gravityModifier", 2), q([x(Hr)], Hs.prototype, "startColor", 2), q([x(it)], Hs.prototype, "startDelay", 2), q([x(it)], Hs.prototype, "startLifetime", 2), q([x(it)], Hs.prototype, "startRotation", 2), q([x(it)], Hs.prototype, "startRotationX", 2), q([x(it)], Hs.prototype, "startRotationY", 2), q([x(it)], Hs.prototype, "startRotationZ", 2), q([x(it)], Hs.prototype, "startSize", 2), q([x(it)], Hs.prototype, "startSizeX", 2), q([x(it)], Hs.prototype, "startSizeY", 2), q([x(it)], Hs.prototype, "startSizeZ", 2), q([x(it)], Hs.prototype, "startSpeed", 2); class Im { constructor() { u(this, "cycleCount"), u(this, "maxCount"), u(this, "minCount"), u(this, "probability"), u(this, "repeatInterval"), u(this, "time"), u(this, "count"), u(this, "_performed", 0) } reset() { this._performed = 0 } run(e) { if (e <= this.time) return this.reset(), 0; let t = 0; if (this.cycleCount === 0 || this._performed < this.cycleCount) { const s = this.time + this.repeatInterval * this._performed; if (e >= s && (this._performed += 1, Math.random() < this.probability)) switch (this.count.mode) { case 0: t = this.count.constant; break; case 3: t = Ke.lerp(this.count.constantMin, this.count.constantMax, Math.random()); break; case 1: t = this.count.curve.evaluate(Math.random()); break; case 2: const r = Math.random(); t = Ke.lerp(this.count.curveMin.evaluate(r), this.count.curveMax.evaluate(r), Math.random()); break } } return t } } class na { constructor() { u(this, "enabled"), u(this, "bursts"), u(this, "rateOverTime"), u(this, "rateOverTimeMultiplier"), u(this, "rateOverDistance"), u(this, "rateOverDistanceMultiplier"), u(this, "system") } get burstCount() { var e; return ((e = this.bursts) == null ? void 0 : e.length) ?? 0 } reset() { var e; (e = this.bursts) == null || e.forEach(t => t.reset()) } getBurst() { let e = 0; if (this.burstCount > 0) for (let t = 0; t < this.burstCount; t++) { const s = this.bursts[t]; s.time >= this.system.time && s.reset(), e += Math.round(s.run(this.system.time)) } return e } } q([x()], na.prototype, "enabled", 2), q([x()], na.prototype, "bursts", 2), q([x(it)], na.prototype, "rateOverTime", 2), q([x()], na.prototype, "rateOverTimeMultiplier", 2), q([x(it)], na.prototype, "rateOverDistance", 2), q([x()], na.prototype, "rateOverDistanceMultiplier", 2); class Tm { constructor() { u(this, "enabled"), u(this, "color") } } q([x(Hr)], Tm.prototype, "color", 2); class zc { constructor() { u(this, "enabled"), u(this, "separateAxes"), u(this, "size"), u(this, "sizeMultiplier"), u(this, "x"), u(this, "xMultiplier"), u(this, "y"), u(this, "yMultiplier"), u(this, "z"), u(this, "zMultiplier"), u(this, "_time", 0), u(this, "_temp", new S) } evaluate(e, t, s) { if (t || (t = this._temp), !this.enabled) return t.x = t.y = t.z = 1, t; if (this.separateAxes) t.x = this.x.evaluate(e, s) * this.xMultiplier, t.y = this.y.evaluate(e, s) * this.yMultiplier, t.z = this.z.evaluate(e, s) * this.zMultiplier; else { const r = this.size.evaluate(e, s) * this.sizeMultiplier; t.x = r } return t } } q([x(it)], zc.prototype, "size", 2), q([x(it)], zc.prototype, "x", 2), q([x(it)], zc.prototype, "y", 2), q([x(it)], zc.prototype, "z", 2); var Fb; const Rm = (Fb = class { constructor() { u(this, "shapeType", 5), u(this, "enabled", !0), u(this, "alignToDirection", !1), u(this, "angle", 0), u(this, "arc", 360), u(this, "arcSpread"), u(this, "arcSpeedMultiplier"), u(this, "arcMode"), u(this, "boxThickness"), u(this, "position"), u(this, "rotation"), u(this, "_rotation", new ps), u(this, "scale"), u(this, "radius"), u(this, "radiusThickness"), u(this, "sphericalDirectionAmount"), u(this, "randomDirectionAmount"), u(this, "randomPositionAmount"), u(this, "system"), u(this, "_space"), u(this, "_worldSpaceMatrix", new He), u(this, "_worldSpaceMatrixInverse", new He), u(this, "_vector", new S(0, 0, 0)), u(this, "_temp", new S(0, 0, 0)), u(this, "_dir", new S), u(this, "_loopTime", 0), u(this, "_loopDirection", 1), Db && console.log(this) } get type() { return GF[this.shapeType] } initialize(i) { this.getPosition(), i.position.copy(this._vector) } toJSON() { return this } clone() { return new Rm } update(i, e, t, s) { this.system = i, this._space = t, t === 1 && (this._worldSpaceMatrix.copy(s.matrixWorld), this._worldSpaceMatrix.elements[0] = 1, this._worldSpaceMatrix.elements[5] = 1, this._worldSpaceMatrix.elements[10] = 1, this._worldSpaceMatrixInverse.copy(this._worldSpaceMatrix).invert()) } applyRotation(i) { const e = this.rotation.x !== 0 || this.rotation.y !== 0 || this.rotation.z !== 0; return e && (this._rotation.x = Ke.toRadians(this.rotation.x), this._rotation.y = Ke.toRadians(this.rotation.y), this._rotation.z = Ke.toRadians(this.rotation.z), this._rotation.order = "ZYX", i.applyEuler(this._rotation)), e } get vector() { return this._vector } getPosition() { this._vector.set(0, 0, 0); const i = this._temp.copy(this.position), e = this._space === 1; e && i.applyQuaternion(this.system.worldQuaternion); let t = this.radius; if (e && (t *= this.system.worldScale.x), this.enabled) { switch (this.shapeType) { case 5: Db && Wo.DrawBox(this.position, this.scale, 14540253, 1), this._vector.x = Math.random() * this.scale.x - this.scale.x / 2, this._vector.y = Math.random() * this.scale.y - this.scale.y / 2, this._vector.z = Math.random() * this.scale.z - this.scale.z / 2, this._vector.add(i); break; case 4: this.randomConePoint(this.position, this.angle, t, this.radiusThickness, this.arc, this.arcMode, this._vector); break; case 0: this.randomSpherePoint(this.position, t, this.radiusThickness, this.arc, this._vector); break; case 10: this.randomCirclePoint(this.position, t, this.radiusThickness, this.arc, this._vector); break; default: this._vector.set(0, 0, 0); break }this.randomizePosition(this._vector, this.randomPositionAmount) } this.applyRotation(this._vector), e && (this._vector.applyQuaternion(this.system.worldQuaternion), this._vector.add(this.system.worldPos)), Db && Wo.DrawSphere(this._vector, .03, 16711680, .5, !0) } getDirection(i) { var e; if (!this.enabled) return this._dir.set(0, 0, 1), this._dir; switch (this.shapeType) { case 5: this._dir.set(0, 0, 1); break; case 4: this._dir.set(0, 0, 1); break; case 10: case 0: const t = i.x, s = i.y, r = i.z; this._dir.set(t, s, r), (e = this.system) != null && e.worldspace ? this._dir.sub(this.system.worldPos) : this._dir.sub(this.position); break; default: this._dir.set(0, 0, 1); break }return this._space === 1 && this._dir.applyQuaternion(this.system.worldQuaternion), this.applyRotation(this._dir), this._dir.normalize(), this.spherizeDirection(this._dir, this.sphericalDirectionAmount), this.randomizeDirection(this._dir, this.randomDirectionAmount), Db && (Wo.DrawSphere(i, .01, 8925952, .5, !0), Wo.DrawDirection(i, this._dir, 8925952, .5, !0)), this._dir } randomizePosition(i, e) { if (e <= 0) return; const t = Rm._tempVec; t.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1), t.x *= e * this.scale.x, t.y *= e * this.scale.y, t.z *= e * this.scale.z, i.add(t) } randomizeDirection(i, e) { if (e === 0) return; const t = Rm._randomQuat, s = Rm._tempVec; s.set(Math.random() - .5, Math.random() - .5, Math.random() - .5).normalize(), t.setFromAxisAngle(s, e * Math.random() * Math.PI), i.applyQuaternion(t) } spherizeDirection(i, e) { if (e === 0) return; const t = Math.random() * Math.PI * 2, s = Math.acos(1 - Math.random() * 2), r = Math.sin(s) * Math.cos(t), n = Math.sin(s) * Math.sin(t), o = Math.cos(s), a = new S(r, n, o); i.lerp(a, e) } randomSpherePoint(i, e, t, s, r) { const n = Math.random(), o = Math.random(), a = 2 * Math.PI * n * (s / 360), l = Math.acos(2 * o - 1), c = Ke.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), t) * e, h = i.x + this.scale.x * (-c * Math.sin(l) * Math.cos(a)), d = i.y + this.scale.y * (c * Math.sin(l) * Math.sin(a)), p = i.z + this.scale.z * (c * Math.cos(l)); r.x = h, r.y = d, r.z = p } randomCirclePoint(i, e, t, s, r) { const n = Math.random(), o = 2 * Math.PI * n * (s / 360), a = Ke.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), t) * e, l = i.x + this.scale.x * a * Math.cos(o), c = i.y + this.scale.y * a * Math.sin(o), h = i.z; r.x = l, r.y = c, r.z = h } randomConePoint(i, e, t, s, r, n, o) { let a = 0, l = 0; switch (n) { case 0: a = Math.random(), l = Math.random(); break; case 2: this._loopTime > 1 && (this._loopDirection = -1), this._loopTime < 0 && (this._loopDirection = 1); case 1: a = .5, l = Math.random(), this._loopTime += this.system.deltaTime * this._loopDirection; break }let c = 2 * Math.PI * a * (r / 360); switch (n) { case 2: case 1: c += Math.PI + .5, c += this._loopTime * Math.PI * 2, c %= Ke.toRadians(r); break }const h = Math.acos(2 * l - 1), d = Ke.lerp(1, 1 - Math.pow(1 - Math.random(), Math.PI), s) * t, p = i.x + -d * Math.sin(h) * Math.cos(c), f = i.y + d * Math.sin(h) * Math.sin(c), g = i.z; o.x = p * this.scale.x, o.y = f * this.scale.y, o.z = g * this.scale.z } }, u(Fb, "_randomQuat", new we), u(Fb, "_tempVec", new S), Fb); let Ji = Rm; q([x()], Ji.prototype, "shapeType", 2), q([x()], Ji.prototype, "enabled", 2), q([x()], Ji.prototype, "alignToDirection", 2), q([x()], Ji.prototype, "angle", 2), q([x()], Ji.prototype, "arc", 2), q([x()], Ji.prototype, "arcSpread", 2), q([x()], Ji.prototype, "arcSpeedMultiplier", 2), q([x()], Ji.prototype, "arcMode", 2), q([x(S)], Ji.prototype, "boxThickness", 2), q([x(S)], Ji.prototype, "position", 2), q([x(S)], Ji.prototype, "rotation", 2), q([x(S)], Ji.prototype, "scale", 2), q([x()], Ji.prototype, "radius", 2), q([x()], Ji.prototype, "radiusThickness", 2), q([x()], Ji.prototype, "sphericalDirectionAmount", 2), q([x()], Ji.prototype, "randomDirectionAmount", 2), q([x()], Ji.prototype, "randomPositionAmount", 2); class hi { constructor() { u(this, "damping"), u(this, "enabled"), u(this, "frequency"), u(this, "octaveCount"), u(this, "octaveMultiplier"), u(this, "octaveScale"), u(this, "positionAmount"), u(this, "quality"), u(this, "remap"), u(this, "remapEnabled"), u(this, "remapMultiplier"), u(this, "remapX"), u(this, "remapXMultiplier"), u(this, "remapY"), u(this, "remapYMultiplier"), u(this, "remapZ"), u(this, "remapZMultiplier"), u(this, "scrollSpeedMultiplier"), u(this, "separateAxes"), u(this, "strengthMultiplier"), u(this, "strengthX"), u(this, "strengthXMultiplier"), u(this, "strengthY"), u(this, "strengthYMultiplier"), u(this, "strengthZ"), u(this, "strengthZMultiplier"), u(this, "_noise"), u(this, "_time", 0), u(this, "_temp", new S) } update(e) { this._time += e.time.deltaTime * this.scrollSpeedMultiplier } apply(e, t, s, r, n, o) { if (!this.enabled) return; this._noise || (this._noise = mte(() => 0)); const a = this._temp.set(t.x, t.y, t.z).multiplyScalar(this.frequency), l = this._noise(a.x, a.y, a.z, this._time), c = this._noise(a.x, a.y, a.z, this._time + 1e3 * this.frequency), h = this._noise(a.x, a.y, a.z, this._time + 2e3 * this.frequency); this._temp.set(l, c, h).normalize(); const d = n / o; let p = this.positionAmount.evaluate(d); this.separateAxes ? (this._temp.x *= p * this.strengthXMultiplier, this._temp.y *= p * this.strengthYMultiplier, this._temp.z *= p * this.strengthZMultiplier) : (this.strengthX && (p *= this.strengthX.evaluate(d) * 1.5), this._temp.multiplyScalar(p)), s.x += this._temp.x, s.y += this._temp.y, s.z += this._temp.z } } q([x()], hi.prototype, "damping", 2), q([x()], hi.prototype, "enabled", 2), q([x()], hi.prototype, "frequency", 2), q([x()], hi.prototype, "octaveCount", 2), q([x()], hi.prototype, "octaveMultiplier", 2), q([x()], hi.prototype, "octaveScale", 2), q([x(it)], hi.prototype, "positionAmount", 2), q([x()], hi.prototype, "quality", 2), q([x(it)], hi.prototype, "remap", 2), q([x()], hi.prototype, "remapEnabled", 2), q([x()], hi.prototype, "remapMultiplier", 2), q([x(it)], hi.prototype, "remapX", 2), q([x()], hi.prototype, "remapXMultiplier", 2), q([x(it)], hi.prototype, "remapY", 2), q([x()], hi.prototype, "remapYMultiplier", 2), q([x(it)], hi.prototype, "remapZ", 2), q([x()], hi.prototype, "remapZMultiplier", 2), q([x()], hi.prototype, "scrollSpeedMultiplier", 2), q([x()], hi.prototype, "separateAxes", 2), q([x()], hi.prototype, "strengthMultiplier", 2), q([x(it)], hi.prototype, "strengthX", 2), q([x()], hi.prototype, "strengthXMultiplier", 2), q([x(it)], hi.prototype, "strengthY", 2), q([x()], hi.prototype, "strengthYMultiplier", 2), q([x(it)], hi.prototype, "strengthZ", 2), q([x()], hi.prototype, "strengthZMultiplier", 2); class Mi { constructor() { u(this, "enabled"), u(this, "attachRibbonToTransform", !1), u(this, "colorOverLifetime"), u(this, "colorOverTrail"), u(this, "dieWithParticles", !0), u(this, "inheritParticleColor", !0), u(this, "lifetime"), u(this, "lifetimeMultiplier"), u(this, "minVertexDistance", .2), u(this, "mode", 0), u(this, "ratio", 1), u(this, "ribbonCount", 1), u(this, "shadowBias", 0), u(this, "sizeAffectsLifetime", !1), u(this, "sizeAffectsWidth", !1), u(this, "splitSubEmitterRibbons", !1), u(this, "textureMode", 0), u(this, "widthOverTrail"), u(this, "widthOverTrailMultiplier"), u(this, "worldSpace", !1) } getWidth(e, t, s) { let r = this.widthOverTrail.evaluate(s); return s === 0 && (r = e), e *= r, e } getColor(e, t, s) { const r = this.colorOverTrail.evaluate(s), n = this.colorOverLifetime.evaluate(t); e.x *= r.r * n.r, e.y *= r.g * n.g, e.z *= r.b * n.b, e.w *= r.alpha * n.alpha } } q([x()], Mi.prototype, "enabled", 2), q([x()], Mi.prototype, "attachRibbonToTransform", 2), q([x(Hr)], Mi.prototype, "colorOverLifetime", 2), q([x(Hr)], Mi.prototype, "colorOverTrail", 2), q([x()], Mi.prototype, "dieWithParticles", 2), q([x()], Mi.prototype, "inheritParticleColor", 2), q([x(it)], Mi.prototype, "lifetime", 2), q([x()], Mi.prototype, "lifetimeMultiplier", 2), q([x()], Mi.prototype, "minVertexDistance", 2), q([x()], Mi.prototype, "mode", 2), q([x()], Mi.prototype, "ratio", 2), q([x()], Mi.prototype, "ribbonCount", 2), q([x()], Mi.prototype, "shadowBias", 2), q([x()], Mi.prototype, "sizeAffectsLifetime", 2), q([x()], Mi.prototype, "sizeAffectsWidth", 2), q([x()], Mi.prototype, "splitSubEmitterRibbons", 2), q([x()], Mi.prototype, "textureMode", 2), q([x(it)], Mi.prototype, "widthOverTrail", 2), q([x()], Mi.prototype, "widthOverTrailMultiplier", 2), q([x()], Mi.prototype, "worldSpace", 2); class Di { constructor() { u(this, "enabled"), u(this, "space", 0), u(this, "orbitalX"), u(this, "orbitalY"), u(this, "orbitalZ"), u(this, "orbitalXMultiplier"), u(this, "orbitalYMultiplier"), u(this, "orbitalZMultiplier"), u(this, "orbitalOffsetX"), u(this, "orbitalOffsetY"), u(this, "orbitalOffsetZ"), u(this, "speedModifier"), u(this, "speedModifierMultiplier"), u(this, "x"), u(this, "xMultiplier"), u(this, "y"), u(this, "yMultiplier"), u(this, "z"), u(this, "zMultiplier"), u(this, "_system"), u(this, "_temp", new S), u(this, "_temp2", new S), u(this, "_temp3", new S), u(this, "_hasOrbital", !1), u(this, "_index", 0), u(this, "_orbitalMatrix", new He) } update(e) { this._system = e } init(e) { this._index == 0 && (e.debug = !0), this._index += 1, e.orbitx = this.orbitalX.evaluate(Math.random()), e.orbity = this.orbitalY.evaluate(Math.random()), e.orbitz = this.orbitalZ.evaluate(Math.random()), this._hasOrbital = e.orbitx != 0 || e.orbity != 0 || e.orbitz != 0 } apply(e, t, s, r, n, o, a) { var l; if (!this.enabled) return; const c = o / a, h = this.speedModifier.evaluate(c) * this.speedModifierMultiplier, d = this.x.evaluate(c), p = this.y.evaluate(c), f = this.z.evaluate(c); if (this._temp.set(-d, p, f), this._system, this._hasOrbital && ((l = this._system) == null ? void 0 : l.worldPos)) { const g = this._temp2.set(s.x, s.y, s.z), m = this.orbitalXMultiplier, v = this.orbitalYMultiplier, A = this.orbitalZMultiplier, b = h * Math.PI * 2 * 10, y = Math.cos(b * m), _ = Math.sin(b * m), w = Math.cos(b * v), E = Math.sin(b * v), P = Math.cos(b * A), C = Math.sin(b * A), R = g.x * (w * P) + g.y * (w * C) + g.z * -E, T = g.x * (_ * E * P - y * C) + g.y * (_ * E * C + y * P) + g.z * (_ * w), z = g.x * (y * E * P + _ * C) + g.y * (y * E * C - _ * P) + g.z * (y * w), H = this._temp3.set(g.x - R, g.y - T, g.z - z); H.normalize(), H.multiplyScalar(.2 / n * Math.max(this.orbitalXMultiplier, this.orbitalYMultiplier, this.orbitalZMultiplier)), r.x += H.x, r.y += H.y, r.z += H.z } r.x += this._temp.x, r.y += this._temp.y, r.z += this._temp.z, r.x *= h, r.y *= h, r.z *= h } } q([x()], Di.prototype, "enabled", 2), q([x()], Di.prototype, "space", 2), q([x(it)], Di.prototype, "orbitalX", 2), q([x(it)], Di.prototype, "orbitalY", 2), q([x(it)], Di.prototype, "orbitalZ", 2), q([x()], Di.prototype, "orbitalXMultiplier", 2), q([x()], Di.prototype, "orbitalYMultiplier", 2), q([x()], Di.prototype, "orbitalZMultiplier", 2), q([x()], Di.prototype, "orbitalOffsetX", 2), q([x()], Di.prototype, "orbitalOffsetY", 2), q([x()], Di.prototype, "orbitalOffsetZ", 2), q([x(it)], Di.prototype, "speedModifier", 2), q([x()], Di.prototype, "speedModifierMultiplier", 2), q([x(it)], Di.prototype, "x", 2), q([x()], Di.prototype, "xMultiplier", 2), q([x(it)], Di.prototype, "y", 2), q([x()], Di.prototype, "yMultiplier", 2), q([x(it)], Di.prototype, "z", 2), q([x()], Di.prototype, "zMultiplier", 2); class Vs { constructor() { u(this, "animation"), u(this, "enabled"), u(this, "cycleCount"), u(this, "frameOverTime"), u(this, "frameOverTimeMultiplier"), u(this, "numTilesX"), u(this, "numTilesY"), u(this, "startFrame"), u(this, "startFrameMultiplier"), u(this, "rowMode"), u(this, "rowIndex"), u(this, "spriteCount"), u(this, "timeMode") } sampleOnceAtStart() { if (this.timeMode === 0) switch (this.frameOverTime.mode) { case 0: case 3: case 2: case 1: return !0 }return !1 } getStartIndex() { return this.sampleOnceAtStart() ? Math.random() * (this.numTilesX * this.numTilesY) : 0 } evaluate(e) { if (!this.sampleOnceAtStart()) return this.getIndex(e) } getIndex(e) { const t = this.numTilesX * this.numTilesY; e = e * this.cycleCount; let s = this.frameOverTime.evaluate(e % 1); return s *= this.frameOverTimeMultiplier, s *= t, s = s % t, s = Math.floor(s), s } } q([x()], Vs.prototype, "animation", 2), q([x()], Vs.prototype, "enabled", 2), q([x()], Vs.prototype, "cycleCount", 2), q([x(it)], Vs.prototype, "frameOverTime", 2), q([x()], Vs.prototype, "frameOverTimeMultiplier", 2), q([x()], Vs.prototype, "numTilesX", 2), q([x()], Vs.prototype, "numTilesY", 2), q([x(it)], Vs.prototype, "startFrame", 2), q([x()], Vs.prototype, "startFrameMultiplier", 2), q([x()], Vs.prototype, "rowMode", 2), q([x()], Vs.prototype, "rowIndex", 2), q([x()], Vs.prototype, "spriteCount", 2), q([x()], Vs.prototype, "timeMode", 2); class Gn { constructor() { u(this, "enabled"), u(this, "separateAxes"), u(this, "x"), u(this, "xMultiplier"), u(this, "y"), u(this, "yMultiplier"), u(this, "z"), u(this, "zMultiplier") } evaluate(e, t) { return this.enabled ? this.separateAxes ? 0 : this.z.evaluate(e, t) * -1 : 0 } } q([x()], Gn.prototype, "enabled", 2), q([x()], Gn.prototype, "separateAxes", 2), q([x(it)], Gn.prototype, "x", 2), q([x()], Gn.prototype, "xMultiplier", 2), q([x(it)], Gn.prototype, "y", 2), q([x()], Gn.prototype, "yMultiplier", 2), q([x(it)], Gn.prototype, "z", 2), q([x()], Gn.prototype, "zMultiplier", 2); class un { constructor() { u(this, "enabled"), u(this, "range"), u(this, "separateAxes"), u(this, "x"), u(this, "xMultiplier"), u(this, "y"), u(this, "yMultiplier"), u(this, "z"), u(this, "zMultiplier") } evaluate(e, t) { if (!this.enabled) return 0; if (!this.separateAxes) { const s = Ke.lerp(this.range.x, this.range.y, t); return this.z.evaluate(s) * -1 } return 0 } } q([x()], un.prototype, "enabled", 2), q([x()], un.prototype, "range", 2), q([x()], un.prototype, "separateAxes", 2), q([x(it)], un.prototype, "x", 2), q([x()], un.prototype, "xMultiplier", 2), q([x(it)], un.prototype, "y", 2), q([x()], un.prototype, "yMultiplier", 2), q([x(it)], un.prototype, "z", 2), q([x()], un.prototype, "zMultiplier", 2); class ls { constructor() { u(this, "enabled"), u(this, "dampen"), u(this, "drag"), u(this, "dragMultiplier"), u(this, "limit"), u(this, "limitMultiplier"), u(this, "separateAxes"), u(this, "limitX"), u(this, "limitXMultiplier"), u(this, "limitY"), u(this, "limitYMultiplier"), u(this, "limitZ"), u(this, "limitZMultiplier"), u(this, "multiplyDragByParticleSize", !1), u(this, "multiplyDragByParticleVelocity", !1), u(this, "space"), u(this, "_temp", new S), u(this, "_temp2", new S) } apply(e, t, s, r, n, o, a) { if (this.enabled) { const l = this.limit.evaluate(n) * this.limitMultiplier; if (t.length() > l) { this._temp.copy(t).normalize().multiplyScalar(l); let c = this.dampen * .5; t.x = Ke.lerp(t.x, this._temp.x, c), t.y = Ke.lerp(t.y, this._temp.y, c), t.z = Ke.lerp(t.z, this._temp.z, c), s.x = Ke.lerp(s.x, this._temp.x, c), s.y = Ke.lerp(s.y, this._temp.y, c), s.z = Ke.lerp(s.z, this._temp.z, c) } } } } q([x()], ls.prototype, "enabled", 2), q([x()], ls.prototype, "dampen", 2), q([x(it)], ls.prototype, "drag", 2), q([x()], ls.prototype, "dragMultiplier", 2), q([x(it)], ls.prototype, "limit", 2), q([x()], ls.prototype, "limitMultiplier", 2), q([x()], ls.prototype, "separateAxes", 2), q([x(it)], ls.prototype, "limitX", 2), q([x()], ls.prototype, "limitXMultiplier", 2), q([x(it)], ls.prototype, "limitY", 2), q([x()], ls.prototype, "limitYMultiplier", 2), q([x(it)], ls.prototype, "limitZ", 2), q([x()], ls.prototype, "limitZMultiplier", 2), q([x()], ls.prototype, "multiplyDragByParticleSize", 2), q([x()], ls.prototype, "multiplyDragByParticleVelocity", 2), q([x()], ls.prototype, "space", 2); class jc { constructor() { u(this, "enabled"), u(this, "curve"), u(this, "curveMultiplier"), u(this, "mode"), u(this, "system"), u(this, "_lastWorldPosition"), u(this, "_velocity", new S), u(this, "_temp", new S) } update(e) { this.enabled && this.system.worldspace !== !1 && (this._lastWorldPosition ? (this._velocity.copy(this.system.worldPos).sub(this._lastWorldPosition).multiplyScalar(1 / this.system.deltaTime), this._lastWorldPosition.copy(this.system.worldPos)) : (this._velocity.set(0, 0, 0), this._lastWorldPosition = this.system.worldPos.clone())) } applyInitial(e) { if (this.enabled && this.system.worldspace !== !1 && this.mode === 0) { const t = this.curve.evaluate(Math.random(), Math.random()); this._temp.copy(this._velocity).multiplyScalar(t), e.add(this._temp) } } applyCurrent(e, t, s) { if (this.enabled && this.system.worldspace !== !1 && this.mode === 1) { const r = this.curve.evaluate(t, s); this._temp.copy(this._velocity).multiplyScalar(r), e.add(this._temp) } } } q([x()], jc.prototype, "enabled", 2), q([x(it)], jc.prototype, "curve", 2), q([x()], jc.prototype, "curveMultiplier", 2), q([x()], jc.prototype, "mode", 2); class Rr { constructor() { u(this, "enabled"), u(this, "range"), u(this, "separateAxes"), u(this, "size"), u(this, "sizeMultiplier"), u(this, "x"), u(this, "xMultiplier"), u(this, "y"), u(this, "yMultiplier"), u(this, "z"), u(this, "zMultiplier") } evaluate(e, t, s, r) { const n = e.length(), o = Ke.remap(n, this.range.x, this.range.y, 0, 1), a = this.size.evaluate(o, s); return r * a } } q([x()], Rr.prototype, "enabled", 2), q([x(W)], Rr.prototype, "range", 2), q([x()], Rr.prototype, "separateAxes", 2), q([x(it)], Rr.prototype, "size", 2), q([x()], Rr.prototype, "sizeMultiplier", 2), q([x(it)], Rr.prototype, "x", 2), q([x()], Rr.prototype, "xMultiplier", 2), q([x(it)], Rr.prototype, "y", 2), q([x()], Rr.prototype, "yMultiplier", 2), q([x(it)], Rr.prototype, "z", 2), q([x()], Rr.prototype, "zMultiplier", 2); class su { constructor() { u(this, "enabled"), u(this, "range"), u(this, "color") } evaluate(e, t, s) { const r = e.length(), n = Ke.remap(r, this.range.x, this.range.y, 0, 1), o = this.color.evaluate(n, t); s.x *= o.r, s.y *= o.g, s.z *= o.b, s.w *= o.alpha } } q([x()], su.prototype, "enabled", 2), q([x(W)], su.prototype, "range", 2), q([x(Hr)], su.prototype, "color", 2); function bte(i) { const e = i.domElement.querySelector("link[rel='ar']"); if (e) return e; const t = document.createElement("div"); t.classList.add("menu"), t.classList.add("quicklook-menu"), t.style.display = "none", t.style.visibility = "hidden"; const s = document.createElement("button"); s.id = "open-in-ar", s.innerText = "Open in QuickLook", t.appendChild(s); const r = document.createElement("a"); r.id = "needle-usdz-link", r.style.display = "none", r.rel = "ar", r.href = "", t.appendChild(r); const n = document.createElement("img"); return n.id = "button", r.appendChild(n), i.domElement.appendChild(t), r } function _te() { var i = new Date; const e = i.getMonth() + 1, t = i.getDate(), s = i.getHours(), r = i.getMinutes(), n = i.getSeconds(), o = (e < 10 ? "0" : "") + e, a = (t < 10 ? "0" : "") + t, l = (s < 10 ? "0" : "") + s, c = (r < 10 ? "0" : "") + r, h = (n < 10 ? "0" : "") + n; return i.getFullYear() + o + a + "-" + l + c + h } const Ub = oe("debugusdz"); function xte(i, e) { const t = [], s = $.getComponentsInChildren(i, Fr); let r = !1; Ub && console.log(s); for (const n of s) { if (!n || !n.runtimeAnimatorController) continue; Ub && console.log(n); const o = []; for (const a of n.runtimeAnimatorController.enumerateActions()) { Ub && console.log(a); const l = a.getClip(); if (!r && l.tracks.length > 0) { r = !0; const c = l.tracks[0], h = c.name.substring(0, c.name.lastIndexOf(".")), d = new rn(h + ".position", [0, .01], [0, 0, 0, 0, 0, 0]), p = new rn(h + ".quaternion", [0, .01], [0, 0, 0, 1, 0, 0, 0, 1]); o.push(new En("rest", .01, [d, p])) } o.includes(l) || o.push(l) } t.push({ root: n.gameObject, clips: o }) } Ub && console.log(t); for (const n of t) for (const o of n.clips) e.registerAnimation(n.root, o) } var wte = Object.defineProperty, Cte = Object.getOwnPropertyDescriptor, Hn = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Cte(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && wte(e, t, r), r }; const oa = oe("debugusdz"); class Qc { constructor() { u(this, "callToAction"), u(this, "checkoutTitle"), u(this, "checkoutSubtitle"), u(this, "callToActionURL") } } Hn([x()], Qc.prototype, "callToAction", 2), Hn([x()], Qc.prototype, "checkoutTitle", 2), Hn([x()], Qc.prototype, "checkoutSubtitle", 2), Hn([x()], Qc.prototype, "callToActionURL", 2); class Vn extends Ee { constructor() { super(...arguments), u(this, "objectToExport"), u(this, "autoExportAnimations", !1), u(this, "exportFileName"), u(this, "customUsdzFile"), u(this, "customBranding"), u(this, "anchoringType", "plane"), u(this, "planeAnchoringAlignment", "horizontal"), u(this, "interactive", !0), u(this, "extensions", []), u(this, "link"), u(this, "webxr"), u(this, "webARSessionRoot"), u(this, "lastCallback"), u(this, "_quicklookButton"), u(this, "_quicklookButtonContainer", null) } start() { var e, t, s, r; oa && (console.log(this), console.log("Debug USDZ, press 't' to export"), window.addEventListener("keydown", n => { switch (n.key) { case "t": this.exportAsync(); break } }), Su() && setTimeout(() => { this.exportAsync() }, 2e3)), (e = document.getElementById("open-in-ar")) == null || e.addEventListener("click", n => { n.preventDefault(), this.exportAsync() }), this.objectToExport || (this.objectToExport = this.gameObject), !((s = (t = this.objectToExport) == null ? void 0 : t.children) != null && s.length) && !((r = this.objectToExport) != null && r.isMesh) && (this.objectToExport = this.context.scene), this.interactive && (this.extensions.push(new Cb), this.extensions.push(new xb)) } onEnable() { const e = of(), t = Sa(); (oa || e && t) && (this.addQuicklookButton(), this.webARSessionRoot = $.findObjectOfType(Cc) ?? void 0, this.lastCallback = this.quicklookCallback.bind(this), this.link = bte(this.context), this.link.addEventListener("message", this.lastCallback)), oa && Ls("USDZ Exporter enabled: " + this.name) } onDisable() { var e; (e = this.link) == null || e.removeEventListener("message", this.lastCallback); const t = of(), s = Sa(); (oa || t && s) && this.removeQuicklookButton(), oa && Ls("USDZ Exporter disabled: " + this.name) } async exportAsync() { var e; let t = this.exportFileName ?? ((e = this.objectToExport) == null ? void 0 : e.name) ?? this.name; if (lc() || (t += "-MadeWithNeedle"), t += "-" + _te(), this.customUsdzFile) { const f = this.buildQuicklookOverlay(); oa && console.log(f); const g = f.callToAction ? encodeURIComponent(f.callToAction) : "", m = f.checkoutTitle ? encodeURIComponent(f.checkoutTitle) : "", v = f.checkoutSubtitle ? encodeURIComponent(f.checkoutSubtitle) : ""; this.link.href = this.customUsdzFile + `#callToAction=${g}&checkoutTitle=${m}&checkoutSubtitle=${v}&callToActionURL=${f.callToActionURL}`, console.log(this.link.href), this.lastCallback || (this.lastCallback = this.quicklookCallback.bind(this), this.link.addEventListener("message", this.lastCallback)), this.link.download = t + ".usdz", this.link.click(); return } if (!this.objectToExport) return; if (this.webARSessionRoot) { const f = this.webARSessionRoot.gameObject, g = 1 / this.webARSessionRoot.arScale; f.matrix.makeScale(g, g, g), this.webARSessionRoot.invertForward && f.matrix.multiply(new He().makeRotationY(Math.PI)) } const s = new zX, r = [...this.extensions], n = new Uy; r.push(n), this.autoExportAnimations && xte(this.objectToExport, n); const o = { self: this, exporter: s, extensions: r, object: this.objectToExport }; this.dispatchEvent(new CustomEvent("before-export", { detail: o })), s.debug = oa, this.anchoringType !== "plane" && this.anchoringType !== "none" && this.anchoringType !== "image" && this.anchoringType !== "face" && (this.anchoringType = "plane"), this.planeAnchoringAlignment !== "horizontal" && this.planeAnchoringAlignment !== "vertical" && this.planeAnchoringAlignment !== "any" && (this.planeAnchoringAlignment = "horizontal"); const a = await s.parse(this.objectToExport, { ar: { anchoring: { type: this.anchoringType }, planeAnchoring: { alignment: this.planeAnchoringAlignment } }, extensions: r, quickLookCompatible: !0 }), l = new Blob([a], { type: "application/octet-stream" }); this.dispatchEvent(new CustomEvent("after-export", { detail: o })); const c = this.buildQuicklookOverlay(); oa && console.log(c); const h = c.callToAction ? encodeURIComponent(c.callToAction) : "", d = c.checkoutTitle ? encodeURIComponent(c.checkoutTitle) : "", p = c.checkoutSubtitle ? encodeURIComponent(c.checkoutSubtitle) : ""; this.link.href = URL.createObjectURL(l) + `#callToAction=${h}&checkoutTitle=${d}&checkoutSubtitle=${p}&callToActionURL=${c.callToActionURL}`, this.lastCallback || (this.lastCallback = this.quicklookCallback.bind(this), this.link.addEventListener("message", this.lastCallback)), this.link.download = t + ".usdz", this.link.click() } quicklookCallback(e) { if (e?.data == "_apple_ar_quicklook_button_tapped") { oa && ao("Quicklook closed via call to action button"); var t = new CustomEvent("quicklook-button-tapped", { detail: this }); if (this.dispatchEvent(t), !t.defaultPrevented) { const s = new URLSearchParams(this.link.href); if (s) { const r = s.get("callToActionURL"); oa && Ls("Quicklook url: " + r), r && (lc() ? globalThis.open(r, "_blank") : console.warn("Quicklook closed: custom redirects require a Needle Engine Pro license: https://needle.tools/pricing", r)) } } } } buildQuicklookOverlay() { var e, t, s; const r = {}; return this.customBranding && Object.assign(r, this.customBranding), lc() || (console.log("Custom Quicklook banner text requires pro license: https://needle.tools/pricing"), r.callToAction = "Close", r.checkoutTitle = "\u{1F335} Made with Needle", r.checkoutSubtitle = "_"), (e = r.callToAction) != null && e.length || (r.callToAction = "Close"), (t = r.checkoutTitle) != null && t.length || (r.checkoutTitle = "\u{1F335} Made with Needle"), (s = r.checkoutSubtitle) != null && s.length || (r.checkoutSubtitle = "_"), this.dispatchEvent(new CustomEvent("quicklook-overlay", { detail: r })), r } async createQuicklookButton() { var e, t; if (!this.webxr) if (await nf(1), this.webxr = $.findObjectOfType(wt) ?? void 0, this.webxr) if (this.webxr.VRButton && ((e = this.webxr.VRButton.parentElement) == null || e.removeChild(this.webxr.VRButton)), this.webxr.ARButton && this._quicklookButton !== this.webxr.ARButton) { this._quicklookButton = this.webxr.ARButton; const s = (t = this.webxr.ARButton.parentElement) == null ? void 0 : t.querySelector("a"); s && (s.href = ""), this.webxr.ARButton.innerText = "Open in Quicklook", this.webxr.ARButton.disabled = !1, this.webxr.ARButton.addEventListener("click", r => { r.preventDefault(), this.exportAsync() }), this.webxr.ARButton.classList.add("quicklook-ar-button"), this._quicklookButtonContainer = this.webxr.ARButton.parentElement, this.dispatchEvent(new CustomEvent("created-button", { detail: this.webxr.ARButton })) } else { this.webxr.createARButton = !1, this.webxr.createVRButton = !1; let s = window.document.querySelector(".webxr-buttons"); s || (s = document.createElement("div"), s.classList.add("webxr-buttons")); const r = document.createElement("button"); r.innerText = "Open in Quicklook", r.addEventListener("click", () => { this.exportAsync() }), r.classList.add("webxr-ar-button"), r.classList.add("webxr-button"), r.classList.add("quicklook-ar-button"), s.appendChild(r), this._quicklookButtonContainer = s, this.dispatchEvent(new CustomEvent("created-button", { detail: r })) } else console.warn("Could not find WebXR component: will not create Quicklook button", _t.Current) } async addQuicklookButton() { await this.createQuicklookButton(), this._quicklookButton && this._quicklookButtonContainer && this._quicklookButtonContainer.appendChild(this._quicklookButton) } removeQuicklookButton() { var e; (e = this._quicklookButton) == null || e.remove() } } Hn([x(Me)], Vn.prototype, "objectToExport", 2), Hn([x()], Vn.prototype, "autoExportAnimations", 2), Hn([x()], Vn.prototype, "exportFileName", 2), Hn([x(URL)], Vn.prototype, "customUsdzFile", 2), Hn([x(Qc)], Vn.prototype, "customBranding", 2), Hn([x()], Vn.prototype, "anchoringType", 2), Hn([x()], Vn.prototype, "planeAnchoringAlignment", 2), Hn([x()], Vn.prototype, "interactive", 2); const HF = oe("debugdeletable"); class Nb extends qo { } class eM extends Ee { constructor() { super(...arguments), u(this, "deleteBoxes", []) } awake() { this.deleteBoxes = $.findObjectsOfType(Nb, this.context) } update() { for (const e of this.deleteBoxes) { const t = this.gameObject; if (e.isInBox(t) === !0) { const s = $.getComponentInParent(this.gameObject, Jd); s ? HF && console.warn("Can not delete object with usage marker", this.guid, s) : (HF && console.log("DESTROY", this.gameObject), Q0(this.gameObject, this.context.connection)) } } } } var Ste = Object.defineProperty, Ete = Object.getOwnPropertyDescriptor, ru = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Ete(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Ste(e, t, r), r }; class Eo extends Ir { constructor() { super(...arguments), u(this, "mode"), u(this, "focusDistance"), u(this, "focalLength"), u(this, "aperture"), u(this, "gaussianMaxRadius"), u(this, "resolutionScale"), u(this, "bokehScale") } get typeName() { return "DepthOfField" } init() { this.focalLength.valueProcessor = t => { const s = t / 300, r = 2; return Ke.lerp(r, .01, s) }; const e = 20; this.aperture.valueProcessor = t => { const s = 1 - t / 32; return Ke.lerp(1, e, s) } } onCreateEffect() { if (this.mode === 0) return; const e = 1 / window.devicePixelRatio; if (this.resolutionScale === void 0) { let s = 1; Su() && (s = .6), this.resolutionScale = new Dt(s * e) } const t = new W2(this.context.mainCamera, { worldFocusRange: .2, focalLength: 1, bokehScale: 20, resolutionScale: this.resolutionScale.value }); return this.focusDistance.onValueChanged = s => { t.circleOfConfusionMaterial.worldFocusDistance = s }, this.focalLength.onValueChanged = s => t.circleOfConfusionMaterial.worldFocusRange = s, this.aperture.onValueChanged = s => t.bokehScale = s, this.resolutionScale && (this.resolutionScale.onValueChanged = s => t.resolution.scale = s), [t] } unapply() { } } ru([x()], Eo.prototype, "mode", 2), ru([x(Dt)], Eo.prototype, "focusDistance", 2), ru([x(Dt)], Eo.prototype, "focalLength", 2), ru([x(Dt)], Eo.prototype, "aperture", 2), ru([x(Dt)], Eo.prototype, "gaussianMaxRadius", 2), ru([x(Dt)], Eo.prototype, "resolutionScale", 2), ru([x(Dt)], Eo.prototype, "bokehScale", 2), ta("DepthOfField", Eo); var Mte = Object.defineProperty, Ite = Object.getOwnPropertyDescriptor, Tte = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Ite(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Mte(e, t, r), r }; class zb extends Ee { constructor() { super(...arguments), u(this, "visibleOn") } onEnable() { this.apply() } apply() { this.test() || $.setActive(this.gameObject, !1) } test() { return this.visibleOn < 0 ? !0 : Rte() ? (this.visibleOn & 2) !== 0 : (this.visibleOn & 1) !== 0 } } Tte([x()], zb.prototype, "visibleOn", 2); let jb; function Rte() { if (jb === !0 || jb === !1) return jb; let i = !1; return function (e) { (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))) && (i = !0) }(navigator.userAgent || navigator.vendor || window.opera), jb = i, i } class tM { get extensionName() { return "DocumentExtension" } onAfterBuildDocument(e) { } } var VF = (i => (i.SelectStart = "selectstart", i.SelectEnd = "selectend", i))(VF || {}); const Gc = class extends Yd { constructor() { super(), u(this, "transformSelf", !0), u(this, "orbit", null), u(this, "selectStartEventListener", []), u(this, "selectEndEventListener", []), u(this, "_dragHelper", null), u(this, "_draggingRigidbodies", []), u(this, "_waitingForDragStart", null), u(this, "_isDragging", !1), u(this, "_marker", null), u(this, "_dragDelta"), u(this, "_didDrag", !1), u(this, "_activePointerId"), this.selectStartEventListener = [], this.selectEndEventListener = [], this._dragDelta = new W } static get HasAnySelected() { return this._active > 0 } addDragEventListener(i, e) { switch (i) { case "selectstart": this.selectStartEventListener.push(e); break; case "selectend": this.selectEndEventListener.push(e); break } } start() { this.orbit = $.findObjectOfType(Pc, this.context) } allowEdit(i = null) { return this.context.connection.allowEditing } onPointerEnter(i) { if (!this.allowEdit(this.gameObject) || wt.IsInWebXR) return; const e = $.getComponentInParent(i.object, Gc); !e || e !== this || (Gc.lastHovered = i.object, this.context.domElement.style.cursor = "pointer") } onPointerExit(i) { this.allowEdit(this.gameObject) && (wt.IsInWebXR || Gc.lastHovered === i.object && (this.context.domElement.style.cursor = "auto")) } onPointerDown(i) { this.allowEdit(this.gameObject) && (wt.IsInWebXR || (Gc._active += 1, this._dragDelta.set(0, 0), this._didDrag = !1, this._waitingForDragStart = i, i.StopPropagation(), this.orbit && (this.orbit.enabled = !1))) } onPointerUp(i) { this._waitingForDragStart = null, this.allowEdit(this.gameObject) && (Gc._active > 0 && (Gc._active -= 1), !wt.IsInWebXR && (this.onDragEnd(i), i.StopPropagation(), this.orbit && (this.orbit.enabled = !0))) } update() { var i; if (!wt.IsInWebXR) { if (this._waitingForDragStart) { if (!this._didDrag) { const t = this.context.input.getPointerPositionDelta(0); if (t && this._dragDelta.add(t), this._dragDelta.length() > 2) this._didDrag = !0; else return } const e = this._waitingForDragStart; this._waitingForDragStart = null, this.onDragStart(e) } this._dragHelper && this._dragHelper.hasSelected && this.onUpdateDrag(), (((i = this._dragHelper) == null ? void 0 : i.hasSelected) === !1 || this._activePointerId !== void 0 && this.context.input.getPointerPressed(this._activePointerId) === !1) && this.onDragEnd(null) } } onDragStart(i) { if (!this._dragHelper) if (this.context.mainCamera) this._dragHelper = new qF(this.context.mainCamera); else return; if (!i || !i.object) return; const e = $.getComponentInParent(i.object, Gc); if (!e || e !== this) return; let t = i.object; this.transformSelf && (t = this.gameObject); const s = { selected: t, attached: t }; for (const a of this.selectStartEventListener) a(this, s); if (this._activePointerId = i.pointerId, !s.attached) return; s.attached, t = s.attached, this._isDragging = !0, this._dragHelper.setSelected(t, this.context), this.orbit && (this.orbit.enabled = !1); const r = $.getComponentInChildren(t, Ic); r && (r.fastMode = !0, r?.requestOwnership()), this._marker = $.addNewComponent(t, Jd), this._draggingRigidbodies.length = 0; const n = $.getComponentsInChildren(t, ki); n && this._draggingRigidbodies.push(...n); const o = Dv(); $.invokeOnChildren(this._dragHelper.selected, o("onDragStart")) } onUpdateDrag() { if (this._dragHelper) { this._dragHelper.onUpdate(this.context); for (const i of this._draggingRigidbodies) i.wakeUp(), i.resetVelocities() } } onDragEnd(i) { if (!this || !this._isDragging || (this._isDragging = !1, !this._dragHelper)) return; for (const s of this._draggingRigidbodies) s.setVelocity(s.smoothedVelocity); this._draggingRigidbodies.length = 0; const e = this._dragHelper.selected; if (this._dragHelper.setSelected(null, this.context), this.orbit && (this.orbit.enabled = !0), i != null && i.object) { const s = $.getComponentInChildren(i.object, Ic); s && (s.fastMode = !1) } this._marker && this._marker.destroy(); for (const s of this.selectEndEventListener) s(this); const t = Dv(); $.invokeOnChildren(e, t("onDragEnd")) } }; let Sp = Gc; u(Sp, "_active", 0), u(Sp, "lastHovered"); const WF = class { constructor(i) { u(this, "_selected", null), u(this, "_context", null), u(this, "_camera"), u(this, "_cameraPlane", new xn), u(this, "_hasGroundPlane", !1), u(this, "_groundPlane", new xn), u(this, "_groundOffset", new S), u(this, "_groundOffsetFactor", 0), u(this, "_groundDistance", 0), u(this, "_groundPlanePoint", new S), u(this, "_raycaster", new hd), u(this, "_cameraPlaneOffset", new S), u(this, "_intersection", new S), u(this, "_worldPosition", new S), u(this, "_inverseMatrix", new He), u(this, "_rbs", []), u(this, "_groundLine"), u(this, "_groundMarker"), u(this, "_groundOffsetVector", new S(0, 1, 0)), u(this, "_requireUpdateGroundPlane", !0), u(this, "_didDragOnGroundPlaneLastFrame", !1), this._camera = i; const e = new Vi(WF.geometry), t = e.material; t.color = new xe(.4, .4, .4), e.layers.set(2), e.name = "line", e.scale.y = 1, this._groundLine = e; const s = new Zn(.5, 22, 22), r = new di({ color: t.color }), n = new ye(s, r); n.visible = !1, n.layers.set(2), this._groundMarker = n } get hasSelected() { return this._selected !== null && this._selected !== void 0 } get selected() { return this._selected } setSelected(i, e) { if (this._selected && e) for (const t of this._rbs) t.wakeUp(), t.setVelocity(0, 0, 0); if (this._selected && Er.Remove(e, this._selected), this._selected = i, this._context = e, this._rbs.length = 0, i ? (e.scene.add(this._groundLine), e.scene.add(this._groundMarker)) : (this._groundLine.removeFromParent(), this._groundMarker.removeFromParent()), this._selected) { if (!e) { console.error("DragHelper: no context"); return } Er.Add(e, this._selected, null), this._groundOffsetFactor = 0, this._hasGroundPlane = !0, this._groundOffset.set(0, 0, 0), this._requireUpdateGroundPlane = !0, this.onUpdateScreenSpacePlane() } } onUpdate(i) { var e, t, s, r, n; if (!this._context) return; const o = "Space", a = "KeyD", l = ((e = this._context) == null ? void 0 : e.input.isKeyPressed(o)) || ((t = this._context) == null ? void 0 : t.input.isKeyPressed(a)), c = this._context.input.getTouchesPressedCount() >= 2 || l; if (c) { const d = this._context.input.getPointerPositionDelta(0); d && (this._groundOffsetVector.set(0, 1, 0), (s = this._selected) == null || s.rotateOnWorldAxis(this._groundOffsetVector, d.x * this._context.time.deltaTime)) } const h = this._context.input.getPointerPositionRC(0); if (h && (this._raycaster.setFromCamera(h, this._camera), this._selected)) { this._groundOffsetVector.set(0, 1, 0); const d = xt(this._camera).clone().sub(xt(this._selected)).normalize(), p = Math.abs(d.dot(this._groundOffsetVector)), f = ((r = this._context) == null ? void 0 : r.input.isKeyPressed(o)) || ((n = this._context) == null ? void 0 : n.input.isKeyPressed(a)), g = !c && p > .2 && !f && this._context.input.getPointerPressedCount() <= 1, m = this._didDragOnGroundPlaneLastFrame !== g; if (this._didDragOnGroundPlaneLastFrame = g, this._hasGroundPlane || (this._requireUpdateGroundPlane = !0), (this._requireUpdateGroundPlane || !g || m) && this.onUpdateGroundPlane(), this._requireUpdateGroundPlane = !1, this._hasGroundPlane) if (this._raycaster.ray.intersectPlane(this._groundPlane, this._intersection)) { const v = this._intersection.y; if (this._groundPlanePoint.copy(this._intersection).sub(this._groundOffset), this._groundPlanePoint.y = v, g) { this._groundOffsetVector.set(0, 1, 0); const A = this._intersection.sub(this._groundOffset).add(this._groundOffsetVector.multiplyScalar(this._groundOffsetFactor)); this.onUpdateWorldPosition(A, this._groundPlanePoint, !1), this.onDidUpdate(); return } } else this._groundPlanePoint.set(0, 99999, 0); m && this.onUpdateScreenSpacePlane(), this._requireUpdateGroundPlane = !0, this._raycaster.ray.intersectPlane(this._cameraPlane, this._intersection) && (this.onUpdateWorldPosition(this._intersection.sub(this._cameraPlaneOffset), this._groundPlanePoint, !0), this.onDidUpdate()) } } onUpdateWorldPosition(i, e, t) { if (this._selected) { if (t) { const s = xt(this._selected); s.y = i.y, i = s } if (ts(this._selected, i), ts(this._groundLine, i), this._hasGroundPlane ? this._groundLine.scale.y = this._groundDistance : this._groundLine.scale.y = 1e3, this._groundMarker.visible = e !== null, e) { const s = xt(this._camera).distanceTo(e) * .01; this._groundMarker.scale.set(s, s, s), ts(this._groundMarker, e) } } } onUpdateScreenSpacePlane() { if (!this._selected || !this._context) return; const i = this._context.input.getPointerPositionRC(0); i && (this._raycaster.setFromCamera(i, this._camera), this._cameraPlane.setFromNormalAndCoplanarPoint(this._camera.getWorldDirection(this._cameraPlane.normal), this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld)), this._raycaster.ray.intersectPlane(this._cameraPlane, this._intersection) && this._selected.parent && (this._inverseMatrix.copy(this._selected.parent.matrixWorld).invert(), this._cameraPlaneOffset.copy(this._intersection).sub(this._worldPosition.setFromMatrixPosition(this._selected.matrixWorld)))) } onUpdateGroundPlane() { if (!this._selected || !this._context) return; const i = xt(this._selected), e = new Oa(new S(0, .1, 0).add(i), new S(0, -1, 0)), t = new co; t.ignore = [this._selected]; const s = this._context.physics.raycastFromRay(e, t); for (let r = 0; r < s.length; r++) { const n = s[r]; if (!n.face || this.contains(this._selected, n.object)) continue; const o = new S(0, 1, 0); this._groundPlane.setFromNormalAndCoplanarPoint(o, n.point); break } this._hasGroundPlane = !0, this._groundPlane.setFromNormalAndCoplanarPoint(e.direction.multiplyScalar(-1), e.origin), this._raycaster.ray.intersectPlane(this._groundPlane, this._intersection), this._groundDistance = this._intersection.distanceTo(i), this._groundOffset.copy(this._intersection).sub(i) } onDidUpdate() { Xr.markDirty(this._selected); for (const i of this._rbs) i.wakeUp(), i.resetForcesAndTorques(), i.setAngularVelocity(0, 0, 0) } contains(i, e) { if (i === e) return !0; if (i.children) { for (const t of i.children) if (this.contains(t, e)) return !0 } return !1 } }; let qF = WF; u(qF, "geometry", new yt().setFromPoints([new S(0, 0, 0), new S(0, -1, 0)])); function iM(i, e, t) { console.warn("Adding components on object has been temporarily disabled") } var XF = (i => (i.File_Spawned = "file-spawned", i))(XF || {}); class YF { constructor(e, t, s, r, n, o, a, l) { u(this, "guid"), u(this, "file_name"), u(this, "file_hash"), u(this, "file_size"), u(this, "position"), u(this, "seed"), u(this, "sender"), u(this, "serverUrl"), u(this, "parentGuid"), u(this, "boundsSize"), this.seed = t, this.guid = s, this.file_name = r, this.file_hash = n, this.file_size = o, this.position = a, this.sender = e, this.serverUrl = l } } async function sM(i, e, t) { const s = i.name; return s.endsWith(".gltf") || s.endsWith(".glb") ? new Promise((r, n) => { const o = new FileReader; o.readAsArrayBuffer(i), o.onloadend = async a => { const l = o.result, c = G0(), h = new Br(c), d = await fo().parseSync(e, l, i.name, h); if (d && d.scene) { const p = d.scene; if (!p.guid) { const f = new Br(c); p.guid = f.generateUUID() } t && Pte(e.connection, i, c, p, t), iM(), r(d) } } }) : (console.warn("Unsupported file type: " + s), console.log(i), null) } async function JF(i, e) { return new Promise(async (t, s) => { const r = G0(), n = new Br(r), o = i.toString(), a = await fo().loadSync(e, o, o, n); a && a.scene ? (a.scene, iM(), t(a)) : console.warn("Unsupported file type: " + i.toString()) }) } Zi.registerCallback(Jr.ContextCreated, i => { KF(i.context) }); function KF(i) { i.connection.beginListen("file-spawned", async e => { if (e.sender !== i.connection.connectionId) { console.log("received file event", e), Bte(e, i); let t = null; try { t = await hC(e.file_name, e.file_hash, e.file_size, e.serverUrl) } finally { kte(e) } if (t) { const s = new Br(e.seed), r = await fo().parseSync(i, t, null, s); if (r && r.scene) { const n = r.scene; if (iM(), e.parentGuid) { const o = ug(e.parentGuid, i.scene); "add" in o && o.add(n) } n.parent || i.scene.add(n), e.position !== null && n.position.copy(e.position) } } else console.error("download didnt return file") } }) } async function Pte(i, e, t, s, r) { if (!i.connectionId) { console.error("Can not upload file - no connection id"); return } if (!s.guid) { console.error("Can not upload file - no guid", s, s.guid); return } const n = await hD(e, r); if (!n) return; if (!n.filename) { console.error("Can not send upload event - no filename", e.name); return } if (!n.hash) { console.error("Can not send upload event - no hash", e.name); return } const o = new YF(i.connectionId, t, s.guid, n.filename, n.hash, e.size, s.position, n.url ?? r); s.parent && (o.parentGuid = s.parent.guid), i.send("file-spawned", o) } const rM = {}; function Bte(i, e) { const t = new pi, s = new ye(t, new di({ color: 65280 })), r = new l0(s, 5592405); if (rM[i.guid] = r, e.scene.add(r), i.parentGuid) { const n = ug(i.parentGuid, e.scene); n && n.add(r) } i.position && r.position.copy(i.position) } function kte(i, e) { const t = i.guid, s = rM[t]; s && (delete rM[t], s.removeFromParent()) } var Dte = Object.defineProperty, Ote = Object.getOwnPropertyDescriptor, nM = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Ote(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Dte(e, t, r), r }; const Lte = oe("debugnet"), oM = class extends Ee { constructor() { super(...arguments), u(this, "url", null), u(this, "urlParameterName", null), u(this, "localhost", null) } awake() { Lte && console.log(this), this.context.connection.registerProvider(this) } getWebsocketUrl() { let i = this.url ? oM.GetUrl(this.url, this.localhost) : null; if (this.urlParameterName) { const t = oe(this.urlParameterName); t && typeof t == "string" && (i = t) } if (!i) return null; const e = new RegExp("(((https?)|(?<socket_prefix>wss?))://)?(www.)?(?<url>.+)", "gm").exec(i); return e != null && e.groups ? e?.groups.socket_prefix ? i : "wss://" + e?.groups.url : null } static GetUrl(i, e) { let t = i; const s = oM.IsLocalNetwork() && e; return s && (t = e), i != null && i.startsWith("/") && (t = (s ? t : window.location.origin) + i), t } static IsLocalNetwork(i = window.location.hostname) { return dr(i) } }; let nu = oM; nM([x()], nu.prototype, "url", 2), nM([x()], nu.prototype, "urlParameterName", 2), nM([x()], nu.prototype, "localhost", 2); var Fte = Object.defineProperty, Ute = Object.getOwnPropertyDescriptor, ZF = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Ute(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Fte(e, t, r), r }; class Pm extends Ee { constructor() { super(...arguments), u(this, "filesBackendUrl"), u(this, "localhost"), u(this, "_dragOver"), u(this, "_drop") } onEnable() { this.filesBackendUrl = this.filesBackendUrl ? nu.GetUrl(this.filesBackendUrl, this.localhost) : void 0, this._dragOver = this.onDrag.bind(this), this._drop = this.onDrop.bind(this), this.context.domElement.addEventListener("dragover", this._dragOver), this.context.domElement.addEventListener("drop", this._drop) } onDisable() { this.context.domElement.removeEventListener("dragover", this._dragOver), this.context.domElement.removeEventListener("drop", this._drop) } onDrag(e) { e.preventDefault() } async addFiles(e) { for (const t of e) { if (!t) continue; console.log("Register file " + t.name + " to", this.filesBackendUrl, t); const s = await sM(t, this.context, this.filesBackendUrl); this.dispatchEvent(new CustomEvent("file-dropped", { detail: t })), s && this.addObject(void 0, s) } } async onDrop(e) { if (console.log(e), !e.dataTransfer) return; e.preventDefault(); const t = e.dataTransfer.items; if (t) for (const s in t) { const r = t[s]; if (r.kind === "file") { const n = r.getAsFile(); if (!n) continue; console.log("Register file " + n.name + " to", this.filesBackendUrl, n); const o = await sM(n, this.context, this.filesBackendUrl); this.dispatchEvent(new CustomEvent("file-dropped", { detail: n })), o && this.addObject(e, o) } else r.kind === "string" && r.type == "text/plain" && r.getAsString(async n => { console.log("dropped url", n); try { const o = new URL(n); if (!o) return; const a = await JF(o, this.context); a && this.addObject(e, a) } catch { console.log("dropped string is not a valid URL!", n) } }) } } async addObject(e, t) { console.log("Dropped", t); const s = t.scene; if (e !== void 0) { const r = new co; r.setMask(16777215), r.screenPointFromOffset(e.offsetX, e.offsetY); const n = this.context.physics.raycast(r); if (n && n.length > 0) for (const o of n) { s.position.copy(o.point); break } } this.gameObject.add(s), this.dispatchEvent(new CustomEvent("object-added", { detail: t })) } } ZF([x()], Pm.prototype, "filesBackendUrl", 2), ZF([x()], Pm.prototype, "localhost", 2); var Nte = Object.defineProperty, zte = Object.getOwnPropertyDescriptor, Qb = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? zte(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Nte(e, t, r), r }; class ou extends Yd { constructor() { super(...arguments), u(this, "parent", null), u(this, "object", null), u(this, "limitCount", 10), u(this, "limitInterval", 60), u(this, "_currentCount", 0), u(this, "_startPosition", null), u(this, "_startQuaternion", null) } awake() { var e, t; if (this.object) { if (this.object === this.gameObject) { console.error("Can not duplicate self"); return } this.object.visible = !1, this._startPosition = ((e = this.object.position) == null ? void 0 : e.clone()) ?? new S(0, 0, 0), this._startQuaternion = ((t = this.object.quaternion) == null ? void 0 : t.clone()) ?? new we(0, 0, 0, 1) } const s = $.getComponentInParent(this.gameObject, Sp); s ? s.addDragEventListener(VF.SelectStart, (r, n) => { if (this._currentCount >= this.limitCount) { n.attached = null; return } const o = this.handleDuplication(n.selected); o && (console.assert(o !== n.selected, "Duplicated object is original"), n.attached = o) }) : console.warn("Could no find drag controls in parent", this.name), os.addEventListener(pl.SelectStart, (r, n) => { if (this._currentCount >= this.limitCount) { n.grab = null; return } const o = this.handleDuplication(n.selected); o && (n.grab = o) }), this.cloneLimitIntervalFn() } cloneLimitIntervalFn() { this.destroyed || (this._currentCount > 0 && (this._currentCount -= 1), setTimeout(() => { this.cloneLimitIntervalFn() }, this.limitInterval / this.limitCount * 1e3)) } handleDuplication(e) { var t; if (this._currentCount >= this.limitCount || !this.object) return null; if (e === this.gameObject || this.handleMultiObject(e)) { if (this.object === this.gameObject) return null; this.object.visible = !0, this._startPosition && this.object.position.copy(this._startPosition), this._startQuaternion && this.object.quaternion.copy(this._startQuaternion); const s = new No; this.parent || (this.parent = this.gameObject.parent), this.parent && (s.parent = this.parent.guid ?? ((t = this.parent.userData) == null ? void 0 : t.guid), s.keepWorldPosition = !0), s.position = this.worldPosition, s.rotation = this.worldQuaternion, s.context = this.context, this._currentCount += 1; const r = $.instantiateSynced(this.object, s); return console.assert(r !== this.object, "Duplicated object is original"), this.object.visible = !1, this._startPosition && this.object.position.clone().copy(this._startPosition), this._startQuaternion && this.object.quaternion.clone().copy(this._startQuaternion), r } return null } handleMultiObject(e) { return this.gameObject.type === "Group" || this.gameObject.type === "Object3D" ? this.isInChildren(this.gameObject, e) : !1 } isInChildren(e, t) { if (!e) return !1; if (e === t) return !0; if (e.children) { for (let s of e.children) if (this.isInChildren(s, t)) return !0 } return !1 } } Qb([x(Me)], ou.prototype, "parent", 2), Qb([x(Me)], ou.prototype, "object", 2), Qb([x()], ou.prototype, "limitCount", 2), Qb([x()], ou.prototype, "limitInterval", 2); var Ep = (i => (i[i.PointerEnter = 0] = "PointerEnter", i[i.PointerExit = 1] = "PointerExit", i[i.PointerDown = 2] = "PointerDown", i[i.PointerUp = 3] = "PointerUp", i[i.PointerClick = 4] = "PointerClick", i[i.Drag = 5] = "Drag", i[i.Drop = 6] = "Drop", i[i.Scroll = 7] = "Scroll", i[i.UpdateSelected = 8] = "UpdateSelected", i[i.Select = 9] = "Select", i[i.Deselect = 10] = "Deselect", i[i.Move = 11] = "Move", i[i.InitializePotentialDrag = 12] = "InitializePotentialDrag", i[i.BeginDrag = 13] = "BeginDrag", i[i.EndDrag = 14] = "EndDrag", i[i.Submit = 15] = "Submit", i[i.Cancel = 16] = "Cancel", i))(Ep || {}), jte = Object.defineProperty, Qte = Object.getOwnPropertyDescriptor, aM = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Qte(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && jte(e, t, r), r }; class lM { constructor() { u(this, "eventID"), u(this, "callback") } } aM([x()], lM.prototype, "eventID", 2), aM([x(Nr)], lM.prototype, "callback", 2); class Gb extends Ee { constructor() { super(...arguments), u(this, "triggers") } invoke(e) { if (this.triggers) for (const t of this.triggers) t.eventID === e && t.callback.invoke() } onPointerClick(e) { this.invoke(Ep.PointerClick) } onPointerEnter(e) { this.invoke(Ep.PointerEnter) } onPointerExit(e) { this.invoke(Ep.PointerExit) } onPointerDown(e) { this.invoke(Ep.PointerDown) } onPointerUp(e) { this.invoke(Ep.PointerUp) } } aM([x(lM)], Gb.prototype, "triggers", 2); var Gte = Object.defineProperty, Hte = Object.getOwnPropertyDescriptor, cM = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Hte(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Gte(e, t, r), r }; class hM extends Ee { constructor() { super(...arguments), u(this, "connectedBody"), u(this, "_rigidBody", null) } get rigidBody() { return this._rigidBody } onEnable() { this._rigidBody || (this._rigidBody = this.gameObject.getComponent(ki)), this.rigidBody && this.connectedBody && this.startCoroutine(this.create()) } *create() { yield, this.rigidBody && this.connectedBody && this.createJoint(this.rigidBody, this.connectedBody) } } cM([x(ki)], hM.prototype, "connectedBody", 2); class uM extends hM { createJoint(e, t) { var s; (s = this.context.physics.engine) == null || s.addFixedJoint(e, t) } } class Bm extends hM { constructor() { super(...arguments), u(this, "anchor"), u(this, "axis") } createJoint(e, t) { var s; this.axis && this.anchor && ((s = this.context.physics.engine) == null || s.addHingeJoint(e, t, this.anchor, this.axis)) } } cM([x(S)], Bm.prototype, "anchor", 2), cM([x(S)], Bm.prototype, "axis", 2); const Vte = { type: "change" }; let Wte = class extends ms { constructor(i, e) { super(), this.object = i, this.domElement = e, this.movementSpeed = 1, this.rollSpeed = .005, this.dragToLook = !1, this.autoForward = !1; const t = this, s = 1e-6, r = new we, n = new S; this.tmpQuaternion = new we, this.status = 0, this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 }, this.moveVector = new S(0, 0, 0), this.rotationVector = new S(0, 0, 0), this.keydown = function (d) { if (!d.altKey) { switch (d.code) { case "ShiftLeft": case "ShiftRight": this.movementSpeedMultiplier = .1; break; case "KeyW": this.moveState.forward = 1; break; case "KeyS": this.moveState.back = 1; break; case "KeyA": this.moveState.left = 1; break; case "KeyD": this.moveState.right = 1; break; case "KeyR": this.moveState.up = 1; break; case "KeyF": this.moveState.down = 1; break; case "ArrowUp": this.moveState.pitchUp = 1; break; case "ArrowDown": this.moveState.pitchDown = 1; break; case "ArrowLeft": this.moveState.yawLeft = 1; break; case "ArrowRight": this.moveState.yawRight = 1; break; case "KeyQ": this.moveState.rollLeft = 1; break; case "KeyE": this.moveState.rollRight = 1; break }this.updateMovementVector(), this.updateRotationVector() } }, this.keyup = function (d) { switch (d.code) { case "ShiftLeft": case "ShiftRight": this.movementSpeedMultiplier = 1; break; case "KeyW": this.moveState.forward = 0; break; case "KeyS": this.moveState.back = 0; break; case "KeyA": this.moveState.left = 0; break; case "KeyD": this.moveState.right = 0; break; case "KeyR": this.moveState.up = 0; break; case "KeyF": this.moveState.down = 0; break; case "ArrowUp": this.moveState.pitchUp = 0; break; case "ArrowDown": this.moveState.pitchDown = 0; break; case "ArrowLeft": this.moveState.yawLeft = 0; break; case "ArrowRight": this.moveState.yawRight = 0; break; case "KeyQ": this.moveState.rollLeft = 0; break; case "KeyE": this.moveState.rollRight = 0; break }this.updateMovementVector(), this.updateRotationVector() }, this.pointerdown = function (d) { if (this.dragToLook) this.status++; else { switch (d.button) { case 0: this.moveState.forward = 1; break; case 2: this.moveState.back = 1; break }this.updateMovementVector() } }, this.pointermove = function (d) { if (!this.dragToLook || this.status > 0) { const p = this.getContainerDimensions(), f = p.size[0] / 2, g = p.size[1] / 2; this.moveState.yawLeft = -(d.pageX - p.offset[0] - f) / f, this.moveState.pitchDown = (d.pageY - p.offset[1] - g) / g, this.updateRotationVector() } }, this.pointerup = function (d) { if (this.dragToLook) this.status--, this.moveState.yawLeft = this.moveState.pitchDown = 0; else { switch (d.button) { case 0: this.moveState.forward = 0; break; case 2: this.moveState.back = 0; break }this.updateMovementVector() } this.updateRotationVector() }, this.update = function (d) { const p = d * t.movementSpeed, f = d * t.rollSpeed; t.object.translateX(t.moveVector.x * p), t.object.translateY(t.moveVector.y * p), t.object.translateZ(t.moveVector.z * p), t.tmpQuaternion.set(t.rotationVector.x * f, t.rotationVector.y * f, t.rotationVector.z * f, 1).normalize(), t.object.quaternion.multiply(t.tmpQuaternion), (n.distanceToSquared(t.object.position) > s || 8 * (1 - r.dot(t.object.quaternion)) > s) && (t.dispatchEvent(Vte), r.copy(t.object.quaternion), n.copy(t.object.position)) }, this.updateMovementVector = function () { const d = this.moveState.forward || this.autoForward && !this.moveState.back ? 1 : 0; this.moveVector.x = -this.moveState.left + this.moveState.right, this.moveVector.y = -this.moveState.down + this.moveState.up, this.moveVector.z = -d + this.moveState.back }, this.updateRotationVector = function () { this.rotationVector.x = -this.moveState.pitchDown + this.moveState.pitchUp, this.rotationVector.y = -this.moveState.yawRight + this.moveState.yawLeft, this.rotationVector.z = -this.moveState.rollRight + this.moveState.rollLeft }, this.getContainerDimensions = function () { return this.domElement != document ? { size: [this.domElement.offsetWidth, this.domElement.offsetHeight], offset: [this.domElement.offsetLeft, this.domElement.offsetTop] } : { size: [window.innerWidth, window.innerHeight], offset: [0, 0] } }, this.dispose = function () { this.domElement.removeEventListener("contextmenu", $F), this.domElement.removeEventListener("pointerdown", a), this.domElement.removeEventListener("pointermove", o), this.domElement.removeEventListener("pointerup", l), window.removeEventListener("keydown", c), window.removeEventListener("keyup", h) }; const o = this.pointermove.bind(this), a = this.pointerdown.bind(this), l = this.pointerup.bind(this), c = this.keydown.bind(this), h = this.keyup.bind(this); this.domElement.addEventListener("contextmenu", $F), this.domElement.addEventListener("pointerdown", a), this.domElement.addEventListener("pointermove", o), this.domElement.addEventListener("pointerup", l), window.addEventListener("keydown", c), window.addEventListener("keyup", h), this.updateMovementVector(), this.updateRotationVector() } }; function $F(i) { i.preventDefault() } class dM extends Ee { constructor() { super(...arguments), u(this, "_controls", null) } onEnable() { var e; const t = (e = $.getComponent(this.gameObject, Si)) == null ? void 0 : e.cam; this._controls = new Wte(t, this.context.renderer.domElement), this._controls.rollSpeed = .5, this._controls.movementSpeed = 3, this._controls.dragToLook = !0 } onDisable() { var e; (e = this._controls) == null || e.dispose(), this._controls = null } update() { this._controls && this._controls.update(this.context.time.deltaTime) } } var qte = Object.defineProperty, Xte = Object.getOwnPropertyDescriptor, pM = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Xte(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && qte(e, t, r), r }; class Mp extends Ee { constructor() { super(...arguments), u(this, "_fog") } get fog() { return this._fog || (this._fog = new vw(0, 0, 50)), this._fog } get mode() { return 1 } set near(e) { this.fog.near = e } get near() { return this.fog.near } set far(e) { this.fog.far = e } get far() { return this.fog.far } set color(e) { this.fog.color.copy(e) } get color() { return this.fog.color } onEnable() { this.scene.fog = this.fog } onDisable() { this.scene.fog === this._fog && (this.scene.fog = null) } } pM([x()], Mp.prototype, "near", 1), pM([x()], Mp.prototype, "far", 1), pM([x(xe)], Mp.prototype, "color", 1); let fM, gM, Ip, Hb; function mM(i, e, t) {
  gM || (gM = new ks(2, 2, 1, 1)), Ip || (Ip = new Vt({
    uniforms: { blitTexture: new Ce(i) }, vertexShader: `
            varying vec2 vUv;
            void main(){
                vUv = uv;
                gl_Position = vec4(position.xy * 1.0,0.,.999999);
            }`, fragmentShader: `
            uniform sampler2D blitTexture; 
            varying vec2 vUv;

            // took from threejs 05fc79cd52b79e8c3e8dec1e7dca72c5c39983a4
            vec4 conv_LinearTosRGB( in vec4 value ) {
                return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
            }

            void main(){ 
                gl_FragColor = vec4(vUv.xy, 0, 1);
                
                #ifdef IS_SRGB
                gl_FragColor = conv_LinearTosRGB( texture2D( blitTexture, vUv) );
                #else
                gl_FragColor = texture2D( blitTexture, vUv);
                #endif
            }`})), Ip.uniforms.blitTexture.value = i, Ip.defines.IS_SRGB = i.encoding == Xe, Ip.needsUpdate = !0, Hb || (Hb = new ye(gM, Ip), Hb.frustrumCulled = !1); const s = new Xt, r = new Cn; r.add(Hb), t || (fM || (fM = new $u({ antialias: !1 })), t = fM), t.setSize(Math.min(i.image.width, e), Math.min(i.image.height, e)), t.clear(), t.render(r, s); const n = new Nt(t.domElement); return n.userData.mimeType = "image/png", n
} class vM { constructor() { this.pluginCallbacks = [], this.register(function (e) { return new sie(e) }), this.register(function (e) { return new rie(e) }), this.register(function (e) { return new aie(e) }), this.register(function (e) { return new lie(e) }), this.register(function (e) { return new nie(e) }), this.register(function (e) { return new oie(e) }) } register(e) { return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this } unregister(e) { return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, s, r) { const n = new iie, o = []; for (let a = 0, l = this.pluginCallbacks.length; a < l; a++)o.push(this.pluginCallbacks[a](n)); n.setPlugins(o), n.write(e, t, r).catch(s) } parseAsync(e, t) { const s = this; return new Promise(function (r, n) { s.parse(e, r, n, t) }) } } const ti = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, BYTE: 5120, UNSIGNED_BYTE: 5121, SHORT: 5122, UNSIGNED_SHORT: 5123, FLOAT: 5126, UNSIGNED_INT: 5125, ARRAY_BUFFER: 34962, ELEMENT_ARRAY_BUFFER: 34963, NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987, CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, REPEAT: 10497 }, dn = {}; dn[Zt] = ti.NEAREST, dn[Pu] = ti.NEAREST_MIPMAP_NEAREST, dn[Bu] = ti.NEAREST_MIPMAP_LINEAR, dn[Qt] = ti.LINEAR, dn[df] = ti.LINEAR_MIPMAP_NEAREST, dn[eo] = ti.LINEAR_MIPMAP_LINEAR, dn[Ss] = ti.CLAMP_TO_EDGE, dn[yn] = ti.REPEAT, dn[Ta] = ti.MIRRORED_REPEAT; const eU = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" }, tU = 12, Yte = 1179937895, Jte = 2, iU = 8, Kte = 1313821514, Zte = 5130562; function km(i, e) { return i.length === e.length && i.every(function (t, s) { return t === e[s] }) } function $te(i) { return new TextEncoder().encode(i).buffer } function eie(i) { return km(i.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) } function tie(i, e, t) { const s = { min: new Array(i.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(i.itemSize).fill(Number.NEGATIVE_INFINITY) }; for (let r = e; r < e + t; r++)for (let n = 0; n < i.itemSize; n++) { let o; i.itemSize > 4 ? o = i.array[r * i.itemSize + n] : n === 0 ? o = i.getX(r) : n === 1 ? o = i.getY(r) : n === 2 ? o = i.getZ(r) : n === 3 && (o = i.getW(r)), s.min[n] = Math.min(s.min[n], o), s.max[n] = Math.max(s.max[n], o) } return s } function sU(i) { return Math.ceil(i / 4) * 4 } function AM(i, e = 0) { const t = sU(i.byteLength); if (t !== i.byteLength) { const s = new Uint8Array(t); if (s.set(new Uint8Array(i)), e !== 0) for (let r = i.byteLength; r < t; r++)s[r] = e; return s.buffer } return i } function rU() { return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas") } function nU(i, e) { if (i.toBlob !== void 0) return new Promise(s => i.toBlob(s, e)); let t; return e === "image/jpeg" ? t = .92 : e === "image/webp" && (t = .8), i.convertToBlob({ type: e, quality: t }) } class iie { constructor() { this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map, this.skins = [], this.extensionsUsed = {}, this.uids = new Map, this.uid = 0, this.json = { asset: { version: "2.0", generator: "THREE.GLTFExporter" } }, this.cache = { meshes: new Map, attributes: new Map, attributesNormalized: new Map, materials: new Map, textures: new Map, images: new Map } } setPlugins(e) { this.plugins = e } async write(e, t, s) { this.options = Object.assign({}, { binary: !1, trs: !1, onlyVisible: !0, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: !1 }, s), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending); const r = this, n = r.buffers, o = r.json; s = r.options; const a = r.extensionsUsed, l = new Blob(n, { type: "application/octet-stream" }), c = Object.keys(a); if (c.length > 0 && (o.extensionsUsed = c), o.buffers && o.buffers.length > 0 && (o.buffers[0].byteLength = l.size), s.binary === !0) { const h = new FileReader; h.readAsArrayBuffer(l), h.onloadend = function () { const d = AM(h.result), p = new DataView(new ArrayBuffer(iU)); p.setUint32(0, d.byteLength, !0), p.setUint32(4, Zte, !0); const f = AM($te(JSON.stringify(o)), 32), g = new DataView(new ArrayBuffer(iU)); g.setUint32(0, f.byteLength, !0), g.setUint32(4, Kte, !0); const m = new ArrayBuffer(tU), v = new DataView(m); v.setUint32(0, Yte, !0), v.setUint32(4, Jte, !0); const A = tU + g.byteLength + f.byteLength + p.byteLength + d.byteLength; v.setUint32(8, A, !0); const b = new Blob([m, g, f, p, d], { type: "application/octet-stream" }), y = new FileReader; y.readAsArrayBuffer(b), y.onloadend = function () { t(y.result) } } } else if (o.buffers && o.buffers.length > 0) { const h = new FileReader; h.readAsDataURL(l), h.onloadend = function () { const d = h.result; o.buffers[0].uri = d, t(o) } } else t(o) } serializeUserData(e, t) { if (Object.keys(e.userData).length === 0) return; const s = this.options, r = this.extensionsUsed; try { const n = JSON.parse(JSON.stringify(e.userData)); if (s.includeCustomExtensions && n.gltfExtensions) { t.extensions === void 0 && (t.extensions = {}); for (const o in n.gltfExtensions) t.extensions[o] = n.gltfExtensions[o], r[o] = !0; delete n.gltfExtensions } Object.keys(n).length > 0 && (t.extras = n) } catch (n) { console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + n.message) } } getUID(e, t = !1) { if (this.uids.has(e) === !1) { const s = new Map; s.set(!0, this.uid++), s.set(!1, this.uid++), this.uids.set(e, s) } return this.uids.get(e).get(t) } isNormalizedNormalAttribute(e) { if (this.cache.attributesNormalized.has(e)) return !1; const t = new S; for (let s = 0, r = e.count; s < r; s++)if (Math.abs(t.fromBufferAttribute(e, s).length() - 1) > 5e-4) return !1; return !0 } createNormalizedNormalAttribute(e) { const t = this.cache; if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e); const s = e.clone(), r = new S; for (let n = 0, o = s.count; n < o; n++)r.fromBufferAttribute(s, n), r.x === 0 && r.y === 0 && r.z === 0 ? r.setX(1) : r.normalize(), s.setXYZ(n, r.x, r.y, r.z); return t.attributesNormalized.set(e, s), s } applyTextureTransform(e, t) { let s = !1; const r = {}; (t.offset.x !== 0 || t.offset.y !== 0) && (r.offset = t.offset.toArray(), s = !0), t.rotation !== 0 && (r.rotation = t.rotation, s = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (r.scale = t.repeat.toArray(), s = !0), s && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, this.extensionsUsed.KHR_texture_transform = !0) } buildMetalRoughTexture(e, t) { if (e === t) return e; function s(p) { return p.encoding === Xe ? function (f) { return f < .04045 ? f * .0773993808 : Math.pow(f * .9478672986 + .0521327014, 2.4) } : function (f) { return f } } console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), typeof Na < "u" && (e instanceof Na && (e = mM(e)), t instanceof Na && (t = mM(t))); const r = e?.image, n = t?.image, o = Math.max(r?.width || 0, n?.width || 0), a = Math.max(r?.height || 0, n?.height || 0), l = rU(); l.width = o, l.height = a; const c = l.getContext("2d"); c.fillStyle = "#00ffff", c.fillRect(0, 0, o, a); const h = c.getImageData(0, 0, o, a); if (r) { c.drawImage(r, 0, 0, o, a); const p = s(e), f = c.getImageData(0, 0, o, a).data; for (let g = 2; g < f.length; g += 4)h.data[g] = p(f[g] / 256) * 256 } if (n) { c.drawImage(n, 0, 0, o, a); const p = s(t), f = c.getImageData(0, 0, o, a).data; for (let g = 1; g < f.length; g += 4)h.data[g] = p(f[g] / 256) * 256 } c.putImageData(h, 0, 0); const d = (e || t).clone(); return d.source = new Nl(l), d.encoding = Qi, d } processBuffer(e) { const t = this.json, s = this.buffers; return t.buffers || (t.buffers = [{ byteLength: 0 }]), s.push(e), 0 } processBufferView(e, t, s, r, n) { const o = this.json; o.bufferViews || (o.bufferViews = []); let a; t === ti.UNSIGNED_BYTE || t === ti.BYTE ? a = 1 : t === ti.UNSIGNED_SHORT ? a = 2 : a = 4; const l = sU(r * e.itemSize * a), c = new DataView(new ArrayBuffer(l)); let h = 0; for (let p = s; p < s + r; p++)for (let f = 0; f < e.itemSize; f++) { let g; e.itemSize > 4 ? g = e.array[p * e.itemSize + f] : f === 0 ? g = e.getX(p) : f === 1 ? g = e.getY(p) : f === 2 ? g = e.getZ(p) : f === 3 && (g = e.getW(p)), t === ti.FLOAT ? c.setFloat32(h, g, !0) : t === ti.UNSIGNED_INT ? c.setUint32(h, g, !0) : t === ti.UNSIGNED_SHORT ? c.setUint16(h, g, !0) : t === ti.UNSIGNED_BYTE ? c.setUint8(h, g) : t === ti.BYTE ? c.setInt8(h, g) : t === ti.SHORT && c.setInt16(h, g), h += a } const d = { buffer: this.processBuffer(c.buffer), byteOffset: this.byteOffset, byteLength: l }; return n !== void 0 && (d.target = n), n === ti.ARRAY_BUFFER && (d.byteStride = e.itemSize * a), this.byteOffset += l, o.bufferViews.push(d), { id: o.bufferViews.length - 1, byteLength: 0 } } processBufferViewImage(e) { const t = this, s = t.json; return s.bufferViews || (s.bufferViews = []), new Promise(function (r) { const n = new FileReader; n.readAsArrayBuffer(e), n.onloadend = function () { const o = AM(n.result), a = { buffer: t.processBuffer(o), byteOffset: t.byteOffset, byteLength: o.byteLength }; t.byteOffset += o.byteLength, r(s.bufferViews.push(a) - 1) } }) } processAccessor(e, t, s, r) { const n = this.json, o = { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 16: "MAT4" }; let a; if (e.array.constructor === Float32Array) a = ti.FLOAT; else if (e.array.constructor === Uint32Array) a = ti.UNSIGNED_INT; else if (e.array.constructor === Uint16Array) a = ti.UNSIGNED_SHORT; else if (e.array.constructor === Uint8Array) a = ti.UNSIGNED_BYTE; else if (e.array.constructor === Int8Array) a = ti.BYTE; else if (e.array.constructor === Int16Array) a = ti.SHORT; else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor); if (s === void 0 && (s = 0), r === void 0 && (r = e.count), r === 0) return null; const l = tie(e, s, r); let c; t !== void 0 && (c = e === t.index ? ti.ELEMENT_ARRAY_BUFFER : ti.ARRAY_BUFFER); const h = this.processBufferView(e, a, s, r, c), d = { bufferView: h.id, byteOffset: h.byteOffset, componentType: a, count: r, max: l.max, min: l.min, type: o[e.itemSize] }; return e.normalized === !0 && (d.normalized = !0), n.accessors || (n.accessors = []), n.accessors.push(d) - 1 } processImage(e, t, s, r = "image/png") { const n = this, o = n.cache, a = n.json, l = n.options, c = n.pending; o.images.has(e) || o.images.set(e, {}); const h = o.images.get(e), d = r + ":flipY/" + s.toString(); if (h[d] !== void 0) return h[d]; a.images || (a.images = []); const p = { mimeType: r }, f = rU(); f.width = Math.min(e.width, l.maxTextureSize), f.height = Math.min(e.height, l.maxTextureSize); const g = f.getContext("2d"); if (s === !0 && (g.translate(0, f.height), g.scale(1, -1)), e.data !== void 0) { if (t !== _i && console.error("GLTFExporter: Only RGBAFormat is supported."), e.width > l.maxTextureSize || e.height > l.maxTextureSize) g.drawImage(e, 0, 0, f.width, f.height); else { t !== _i && console.error("GLTFExporter: Only RGBAFormat is supported.", e), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e); const A = new Uint8ClampedArray(e.height * e.width * 4); for (let b = 0; b < A.length; b += 4)A[b + 0] = e.data[b + 0], A[b + 1] = e.data[b + 1], A[b + 2] = e.data[b + 2], A[b + 3] = e.data[b + 3]; g.putImageData(new ImageData(A, e.width, e.height), 0, 0) } const v = new Uint8ClampedArray(e.height * e.width * 4); for (let A = 0; A < v.length; A += 4)v[A + 0] = e.data[A + 0], v[A + 1] = e.data[A + 1], v[A + 2] = e.data[A + 2], v[A + 3] = e.data[A + 3]; g.putImageData(new ImageData(v, e.width, e.height), 0, 0) } else g.drawImage(e, 0, 0, f.width, f.height); l.binary === !0 ? c.push(nU(f, r).then(v => n.processBufferViewImage(v)).then(v => { p.bufferView = v })) : f.toDataURL !== void 0 ? p.uri = f.toDataURL(r) : c.push(nU(f, r).then(v => new FileReader().readAsDataURL(v)).then(v => { p.uri = v })); const m = a.images.push(p) - 1; return h[d] = m, m } processSampler(e) { const t = this.json; t.samplers || (t.samplers = []); const s = { magFilter: dn[e.magFilter], minFilter: dn[e.minFilter], wrapS: dn[e.wrapS], wrapT: dn[e.wrapT] }; return t.samplers.push(s) - 1 } processTexture(e) { const t = this.options, s = this.cache, r = this.json; if (s.textures.has(e)) return s.textures.get(e); r.textures || (r.textures = []); let n = e; typeof Na < "u" && e instanceof Na && (n = mM(e, t.maxTextureSize), s.images.delete(n.image)); let o = n.userData.mimeType; o === "image/webp" && (o = "image/png"); const a = { sampler: this.processSampler(e), source: this.processImage(n.image, n.format, n.flipY, o) }; e.name && (a.name = e.name), this._invokeAll(function (c) { c.writeTexture && c.writeTexture(n, a) }); const l = r.textures.push(a) - 1; return s.textures.set(e, l), l } processMaterial(e) { var t, s, r, n, o, a; const l = this.cache, c = this.json; if (l.materials.has(e)) return l.materials.get(e); if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null; c.materials || (c.materials = []); const h = { pbrMetallicRoughness: {} }; e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results."); const d = e.color.toArray().concat([e.opacity]); km(d, [1, 1, 1, 1]) || (h.pbrMetallicRoughness.baseColorFactor = d), e.isMeshStandardMaterial ? (h.pbrMetallicRoughness.metallicFactor = e.metalness, h.pbrMetallicRoughness.roughnessFactor = e.roughness) : (h.pbrMetallicRoughness.metallicFactor = .5, h.pbrMetallicRoughness.roughnessFactor = .5); const p = (t = e.metalnessMap) != null && t.image ? e.metalnessMap : void 0, f = (s = e.roughnessMap) != null && s.image ? e.roughnessMap : void 0; if (p || f) { const m = this.buildMetalRoughTexture(p, f), v = { index: this.processTexture(m) }; this.applyTextureTransform(v, m), h.pbrMetallicRoughness.metallicRoughnessTexture = v } if ((r = e.map) != null && r.image) { const m = { index: this.processTexture(e.map) }; this.applyTextureTransform(m, e.map), h.pbrMetallicRoughness.baseColorTexture = m } if (e.emissive) { const m = e.emissive.clone().multiplyScalar(e.emissiveIntensity), v = Math.max(m.r, m.g, m.b); if (v > 1 && (m.multiplyScalar(1 / v), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), v > 0 && (h.emissiveFactor = m.toArray()), (n = e.emissiveMap) != null && n.image) { const A = { index: this.processTexture(e.emissiveMap) }; this.applyTextureTransform(A, e.emissiveMap), h.emissiveTexture = A } } if ((o = e.normalMap) != null && o.image) { const m = { index: this.processTexture(e.normalMap) }; e.normalScale && e.normalScale.x !== 1 && (m.scale = e.normalScale.x), this.applyTextureTransform(m, e.normalMap), h.normalTexture = m } if ((a = e.aoMap) != null && a.image) { const m = { index: this.processTexture(e.aoMap), texCoord: 1 }; e.aoMapIntensity !== 1 && (m.strength = e.aoMapIntensity), this.applyTextureTransform(m, e.aoMap), h.occlusionTexture = m } e.transparent ? h.alphaMode = "BLEND" : e.alphaTest > 0 && (h.alphaMode = "MASK", h.alphaCutoff = e.alphaTest), e.side === yi && (h.doubleSided = !0), e.name !== "" && (h.name = e.name), this.serializeUserData(e, h), this._invokeAll(function (m) { m.writeMaterial && m.writeMaterial(e, h) }); const g = c.materials.push(h) - 1; return l.materials.set(e, g), g } processMesh(e) { const t = this.cache, s = this.json, r = [e.geometry.uuid]; if (Array.isArray(e.material)) for (let y = 0, _ = e.material.length; y < _; y++)r.push(e.material[y].uuid); else r.push(e.material.uuid); const n = r.join(":"); if (t.meshes.has(n)) return t.meshes.get(n); const o = e.geometry; let a; e.isLineSegments ? a = ti.LINES : e.isLineLoop ? a = ti.LINE_LOOP : e.isLine ? a = ti.LINE_STRIP : e.isPoints ? a = ti.POINTS : a = e.material.wireframe ? ti.LINES : ti.TRIANGLES; const l = {}, c = {}, h = [], d = [], p = { uv: "TEXCOORD_0", uv2: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, f = o.getAttribute("normal"); f !== void 0 && !this.isNormalizedNormalAttribute(f) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), o.setAttribute("normal", this.createNormalizedNormalAttribute(f))); let g = null; for (let y in o.attributes) { if (y.slice(0, 5) === "morph") continue; const _ = o.attributes[y]; if (y = p[y] || y.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(y) || (y = "_" + y), t.attributes.has(this.getUID(_))) { c[y] = t.attributes.get(this.getUID(_)); continue } g = null; const w = _.array; y === "JOINTS_0" && !(w instanceof Uint16Array) && !(w instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), g = new nt(new Uint16Array(w), _.itemSize, _.normalized)); const E = this.processAccessor(g || _, o); E !== null && (c[y] = E, t.attributes.set(this.getUID(_), E)) } if (f !== void 0 && o.setAttribute("normal", f), Object.keys(c).length === 0) return null; if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) { const y = [], _ = [], w = {}; if (e.morphTargetDictionary !== void 0) for (const E in e.morphTargetDictionary) w[e.morphTargetDictionary[E]] = E; for (let E = 0; E < e.morphTargetInfluences.length; ++E) { const P = {}; let C = !1; for (const R in o.morphAttributes) { if (R !== "position" && R !== "normal") { C || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), C = !0); continue } const T = o.morphAttributes[R][E], z = R.toUpperCase(), H = o.attributes[R]; if (t.attributes.has(this.getUID(T, !0))) { P[z] = t.attributes.get(this.getUID(T, !0)); continue } const N = T.clone(); if (!o.morphTargetsRelative) for (let F = 0, X = T.count; F < X; F++)N.setXYZ(F, T.getX(F) - H.getX(F), T.getY(F) - H.getY(F), T.getZ(F) - H.getZ(F)); P[z] = this.processAccessor(N, o), t.attributes.set(this.getUID(H, !0), P[z]) } d.push(P), y.push(e.morphTargetInfluences[E]), e.morphTargetDictionary !== void 0 && _.push(w[E]) } l.weights = y, _.length > 0 && (l.extras = {}, l.extras.targetNames = _) } const m = Array.isArray(e.material); if (m && o.groups.length === 0) return null; const v = m ? e.material : [e.material], A = m ? o.groups : [{ materialIndex: 0, start: void 0, count: void 0 }]; for (let y = 0, _ = A.length; y < _; y++) { const w = { mode: a, attributes: c }; if (this.serializeUserData(o, w), d.length > 0 && (w.targets = d), o.index !== null) { let P = this.getUID(o.index); (A[y].start !== void 0 || A[y].count !== void 0) && (P += ":" + A[y].start + ":" + A[y].count), t.attributes.has(P) ? w.indices = t.attributes.get(P) : (w.indices = this.processAccessor(o.index, o, A[y].start, A[y].count), t.attributes.set(P, w.indices)), w.indices === null && delete w.indices } const E = this.processMaterial(v[A[y].materialIndex]); E !== null && (w.material = E), h.push(w) } l.primitives = h, s.meshes || (s.meshes = []), this._invokeAll(function (y) { y.writeMesh && y.writeMesh(e, l) }); const b = s.meshes.push(l) - 1; return t.meshes.set(n, b), b } processCamera(e) { const t = this.json; t.cameras || (t.cameras = []); const s = e.isOrthographicCamera, r = { type: s ? "orthographic" : "perspective" }; return s ? r.orthographic = { xmag: e.right * 2, ymag: e.top * 2, zfar: e.far <= 0 ? .001 : e.far, znear: e.near < 0 ? 0 : e.near } : r.perspective = { aspectRatio: e.aspect, yfov: kr.degToRad(e.fov), zfar: e.far <= 0 ? .001 : e.far, znear: e.near < 0 ? 0 : e.near }, e.name !== "" && (r.name = e.type), t.cameras.push(r) - 1 } processAnimation(e, t) { const s = this.json, r = this.nodeMap; s.animations || (s.animations = []), e = vM.Utils.mergeMorphTargetTracks(e.clone(), t); const n = e.tracks, o = [], a = []; for (let l = 0; l < n.length; ++l) { const c = n[l], h = zt.parseTrackName(c.name); let d = zt.findNode(t, h.nodeName); const p = eU[h.propertyName]; if (h.objectName === "bones" && (d.isSkinnedMesh === !0 ? d = d.skeleton.getBoneByName(h.objectIndex) : d = void 0), !d || !p) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name), null; const f = 1; let g = c.values.length / c.times.length; p === eU.morphTargetInfluences && (g /= d.morphTargetInfluences.length); let m; c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (m = "CUBICSPLINE", g /= 3) : c.getInterpolation() === ah ? m = "STEP" : m = "LINEAR", a.push({ input: this.processAccessor(new nt(c.times, f)), output: this.processAccessor(new nt(c.values, g)), interpolation: m }), o.push({ sampler: a.length - 1, target: { node: r.get(d), path: p } }) } return s.animations.push({ name: e.name || "clip_" + s.animations.length, samplers: a, channels: o }), s.animations.length - 1 } processSkin(e) { const t = this.json, s = this.nodeMap, r = t.nodes[s.get(e)], n = e.skeleton; if (n === void 0) return null; const o = e.skeleton.bones[0]; if (o === void 0) return null; const a = [], l = new Float32Array(n.bones.length * 16), c = new He; for (let h = 0; h < n.bones.length; ++h)a.push(s.get(n.bones[h])), c.copy(n.boneInverses[h]), c.multiply(e.bindMatrix).toArray(l, h * 16); return t.skins === void 0 && (t.skins = []), t.skins.push({ inverseBindMatrices: this.processAccessor(new nt(l, 16)), joints: a, skeleton: s.get(o) }), r.skin = t.skins.length - 1 } processNode(e) { const t = this.json, s = this.options, r = this.nodeMap; t.nodes || (t.nodes = []); const n = {}; if (s.trs) { const a = e.quaternion.toArray(), l = e.position.toArray(), c = e.scale.toArray(); km(a, [0, 0, 0, 1]) || (n.rotation = a), km(l, [0, 0, 0]) || (n.translation = l), km(c, [1, 1, 1]) || (n.scale = c) } else e.matrixAutoUpdate && e.updateMatrix(), eie(e.matrix) === !1 && (n.matrix = e.matrix.elements); if (e.name !== "" && (n.name = String(e.name)), this.serializeUserData(e, n), e.isMesh || e.isLine || e.isPoints) { const a = this.processMesh(e); a !== null && (n.mesh = a) } else e.isCamera && (n.camera = this.processCamera(e)); if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) { const a = []; for (let l = 0, c = e.children.length; l < c; l++) { const h = e.children[l]; if (h.visible || s.onlyVisible === !1) { const d = this.processNode(h); d !== null && a.push(d) } } a.length > 0 && (n.children = a) } this._invokeAll(function (a) { a.writeNode && a.writeNode(e, n) }); const o = t.nodes.push(n) - 1; return r.set(e, o), o } processScene(e) { const t = this.json, s = this.options; t.scenes || (t.scenes = [], t.scene = 0); const r = {}; e.name !== "" && (r.name = e.name), t.scenes.push(r); const n = []; for (let o = 0, a = e.children.length; o < a; o++) { const l = e.children[o]; if (l.visible || s.onlyVisible === !1) { const c = this.processNode(l); c !== null && n.push(c) } } n.length > 0 && (r.nodes = n), this.serializeUserData(e, r) } processObjects(e) { const t = new Cn; t.name = "AuxScene"; for (let s = 0; s < e.length; s++)t.children.push(e[s]); this.processScene(t) } processInput(e) { const t = this.options; e = e instanceof Array ? e : [e], this._invokeAll(function (r) { r.beforeParse && r.beforeParse(e) }); const s = []; for (let r = 0; r < e.length; r++)e[r] instanceof Cn ? this.processScene(e[r]) : s.push(e[r]); s.length > 0 && this.processObjects(s); for (let r = 0; r < this.skins.length; ++r)this.processSkin(this.skins[r]); for (let r = 0; r < t.animations.length; ++r)this.processAnimation(t.animations[r], e[0]); this._invokeAll(function (r) { r.afterParse && r.afterParse(e) }) } _invokeAll(e) { for (let t = 0, s = this.plugins.length; t < s; t++)e(this.plugins[t]) } } class sie { constructor(e) { this.writer = e, this.name = "KHR_lights_punctual" } writeNode(e, t) { if (!e.isLight) return; if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) { console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e); return } const s = this.writer, r = s.json, n = s.extensionsUsed, o = {}; e.name && (o.name = e.name), o.color = e.color.toArray(), o.intensity = e.intensity, e.isDirectionalLight ? o.type = "directional" : e.isPointLight ? (o.type = "point", e.distance > 0 && (o.range = e.distance)) : e.isSpotLight && (o.type = "spot", e.distance > 0 && (o.range = e.distance), o.spot = {}, o.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, o.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), n[this.name] || (r.extensions = r.extensions || {}, r.extensions[this.name] = { lights: [] }, n[this.name] = !0); const a = r.extensions[this.name].lights; a.push(o), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: a.length - 1 } } } class rie { constructor(e) { this.writer = e, this.name = "KHR_materials_unlit" } writeMaterial(e, t) { if (!e.isMeshBasicMaterial) return; const s = this.writer.extensionsUsed; t.extensions = t.extensions || {}, t.extensions[this.name] = {}, s[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9 } } class nie { constructor(e) { this.writer = e, this.name = "KHR_materials_clearcoat" } writeMaterial(e, t) { if (!e.isMeshPhysicalMaterial) return; const s = this.writer, r = s.extensionsUsed, n = {}; if (n.clearcoatFactor = e.clearcoat, e.clearcoatMap) { const o = { index: s.processTexture(e.clearcoatMap) }; s.applyTextureTransform(o, e.clearcoatMap), n.clearcoatTexture = o } if (n.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) { const o = { index: s.processTexture(e.clearcoatRoughnessMap) }; s.applyTextureTransform(o, e.clearcoatRoughnessMap), n.clearcoatRoughnessTexture = o } if (e.clearcoatNormalMap) { const o = { index: s.processTexture(e.clearcoatNormalMap) }; s.applyTextureTransform(o, e.clearcoatNormalMap), n.clearcoatNormalTexture = o } t.extensions = t.extensions || {}, t.extensions[this.name] = n, r[this.name] = !0 } } class oie { constructor(e) { this.writer = e, this.name = "KHR_materials_iridescence" } writeMaterial(e, t) { if (!e.isMeshPhysicalMaterial) return; const s = this.writer, r = s.extensionsUsed, n = {}; if (n.iridescenceFactor = e.iridescence, e.iridescenceMap) { const o = { index: s.processTexture(e.iridescenceMap) }; s.applyTextureTransform(o, e.iridescenceMap), n.iridescenceTexture = o } if (n.iridescenceIor = e.iridescenceIOR, n.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], n.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) { const o = { index: s.processTexture(e.iridescenceThicknessMap) }; s.applyTextureTransform(o, e.iridescenceThicknessMap), n.iridescenceThicknessTexture = o } t.extensions = t.extensions || {}, t.extensions[this.name] = n, r[this.name] = !0 } } class aie { constructor(e) { this.writer = e, this.name = "KHR_materials_transmission" } writeMaterial(e, t) { if (!e.isMeshPhysicalMaterial || e.transmission === 0) return; const s = this.writer, r = s.extensionsUsed, n = {}; if (n.transmissionFactor = e.transmission, e.transmissionMap) { const o = { index: s.processTexture(e.transmissionMap) }; s.applyTextureTransform(o, e.transmissionMap), n.transmissionTexture = o } t.extensions = t.extensions || {}, t.extensions[this.name] = n, r[this.name] = !0 } } class lie { constructor(e) { this.writer = e, this.name = "KHR_materials_volume" } writeMaterial(e, t) { if (!e.isMeshPhysicalMaterial || e.transmission === 0) return; const s = this.writer, r = s.extensionsUsed, n = {}; if (n.thicknessFactor = e.thickness, e.thicknessMap) { const o = { index: s.processTexture(e.thicknessMap) }; s.applyTextureTransform(o, e.thicknessMap), n.thicknessTexture = o } n.attenuationDistance = e.attenuationDistance, n.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = n, r[this.name] = !0 } } vM.Utils = { insertKeyframe: function (i, e) { const t = i.getValueSize(), s = new i.TimeBufferType(i.times.length + 1), r = new i.ValueBufferType(i.values.length + t), n = i.createInterpolant(new i.ValueBufferType(t)); let o; if (i.times.length === 0) { s[0] = e; for (let a = 0; a < t; a++)r[a] = 0; o = 0 } else if (e < i.times[0]) { if (Math.abs(i.times[0] - e) < .001) return 0; s[0] = e, s.set(i.times, 1), r.set(n.evaluate(e), 0), r.set(i.values, t), o = 0 } else if (e > i.times[i.times.length - 1]) { if (Math.abs(i.times[i.times.length - 1] - e) < .001) return i.times.length - 1; s[s.length - 1] = e, s.set(i.times, 0), r.set(i.values, 0), r.set(n.evaluate(e), i.values.length), o = s.length - 1 } else for (let a = 0; a < i.times.length; a++) { if (Math.abs(i.times[a] - e) < .001) return a; if (i.times[a] < e && i.times[a + 1] > e) { s.set(i.times.slice(0, a + 1), 0), s[a + 1] = e, s.set(i.times.slice(a + 1), a + 2), r.set(i.values.slice(0, (a + 1) * t), 0), r.set(n.evaluate(e), (a + 1) * t), r.set(i.values.slice((a + 1) * t), (a + 2) * t), o = a + 1; break } } return i.times = s, i.values = r, o }, mergeMorphTargetTracks: function (i, e) { const t = [], s = {}, r = i.tracks; for (let n = 0; n < r.length; ++n) { let o = r[n]; const a = zt.parseTrackName(o.name), l = zt.findNode(e, a.nodeName); if (a.propertyName !== "morphTargetInfluences" || a.propertyIndex === void 0) { t.push(o); continue } if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) { if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation."); console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o = o.clone(), o.setInterpolation(Pa) } const c = l.morphTargetInfluences.length, h = l.morphTargetDictionary[a.propertyIndex]; if (h === void 0) throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex); let d; if (s[l.uuid] === void 0) { d = o.clone(); const f = new d.ValueBufferType(c * d.times.length); for (let g = 0; g < d.times.length; g++)f[g * c + h] = d.values[g]; d.name = (a.nodeName || "") + ".morphTargetInfluences", d.values = f, s[l.uuid] = d, t.push(d); continue } const p = o.createInterpolant(new o.ValueBufferType(1)); d = s[l.uuid]; for (let f = 0; f < d.times.length; f++)d.values[f * c + h] = p.evaluate(d.times[f]); for (let f = 0; f < o.times.length; f++) { const g = this.insertKeyframe(d, o.times[f]); d.values[g * c + h] = o.values[f] } } return i.tracks = t, i } }; class cie { constructor(e) { this.writer = e, this.name = "EXT_mesh_gpu_instancing" } writeNode(e, t) { if (e.constructor.name !== "InstancedMesh") return; const s = this.writer, r = s.extensionsUsed, n = {}; t.extensions = t.extensions || {}, t.extensions[this.name] = n; let o = new He; const a = new Array, l = new Array, c = new Array; for (let f = 0; f < e.count; f++) { e.getMatrixAt(f, o); let g = new S, m = new we, v = new S; o.decompose(g, m, v), a.push(g.x, g.y, g.z), l.push(m.x, m.y, m.z, m.w), c.push(v.x, v.y, v.z) } const h = new Float32Array(a), d = new Float32Array(l), p = new Float32Array(c); n.attributes = { TRANSLATION: s.processAccessor(new nt(h, 3)), ROTATION: s.processAccessor(new nt(d, 4)), SCALE: s.processAccessor(new nt(p, 3)) }, r[this.name] = !0 } } class yM extends qo { constructor() { super(...arguments), u(this, "sceneRoot") } start() { this.startCoroutine(this.updateGltfBox()) } *updateGltfBox() { for (; ;)for (let e = 0; e < 10; e++)yield } } class Rl extends Ee { constructor() { super(...arguments), u(this, "binary", !0), u(this, "objects", []), u(this, "exporter"), u(this, "ext") } async exportNow(e) { console.log("DO EXPORT", this.objects); const t = { binary: this.binary, pivot: Rl.calculateCenter(this.objects) }, s = await this.export(this.objects, t); this.binary ? e.endsWith(".glb") || (e += ".glb") : e.endsWith(".gltf") || (e += ".gltf"), this.binary ? Rl.saveArrayBuffer(s, e) : Rl.saveJson(s, e) } async export(e, t) { if (e === null || e.length <= 0) { console.log("no objects set to export"); return } this.exporter || (this.exporter = new vM, this.exporter.register(a => new cie(a)), this.ext = new aO, this.ext.registerExport(this.exporter)), Rl.filterTopmostParent(e); const s = { trs: !1, onlyVisible: !0, truncateDrawRange: !1, binary: t?.binary ?? !0, maxTextureSize: 1 / 0, embedImages: !0, includeCustomExtensions: !0, animations: Rl.collectAnimations(e) }, r = new Me; t != null && t.pivot && r.position.sub(t.pivot), console.log("EXPORT", e), e.forEach(a => { a && (r.children.push(a), a.matrixAutoUpdate = !1, a.matrix.copy(a.matrixWorld), $.getComponentsInChildren(a, Ui).forEach(l => { $.isActiveInHierarchy(l.gameObject) && l.setInstancingEnabled(!1) })) }); const n = new aB(r); return this.ext.context = n, new Promise((a, l) => { var c; try { (c = this.exporter) == null || c.parse(r, h => { o(), a(h) }, h => { o(), l(h) }, s) } catch (h) { console.error(h), l(h) } finally { console.log("FINALLY") } }); function o() { e.forEach(a => { a && (a.matrixAutoUpdate = !0, $.getComponentsInChildren(a, Ui).forEach(l => { $.isActiveInHierarchy(l.gameObject) && l.setInstancingEnabled(!1) })) }) } } static saveArrayBuffer(e, t) { this.save(new Blob([e], { type: "application/octet-stream" }), t) } static saveJson(e, t) { this.save("data: text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(e)), t) } static save(e, t) { const s = document.createElement("a"); s.style.display = "none", document.body.appendChild(s), typeof e == "string" ? s.href = e : s.href = URL.createObjectURL(e), s.download = t, s.click(), s.remove() } static collectAnimations(e, t) { t = t || []; for (const s of e) s && s.traverseVisible(r => { r.animations && r.animations.length > 0 && t.push(...r.animations) }); return t } static calculateCenter(e, t) { const s = t || new S; return s.set(0, 0, 0), e.forEach(r => { s.add(xt(r)) }), console.log(s), s.divideScalar(e.length), s } static filterTopmostParent(e) { if (!(e.length <= 0)) for (let t = 0; t < e.length; t++) { let s = e[t]; if (!s) { e.splice(t, 1), t--; continue } for (; s.parent;) { if (e.includes(s.parent)) { e.splice(t, 1), t--; break } s = s.parent } } } } var hie = Object.defineProperty, uie = Object.getOwnPropertyDescriptor, bM = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? uie(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && hie(e, t, r), r }; class Tp extends Ee { constructor() { super(...arguments), u(this, "isGizmo", !1), u(this, "color0"), u(this, "color1"), u(this, "gridHelper"), u(this, "size"), u(this, "divisions"), u(this, "offset") } onEnable() { if (this.isGizmo && !Vf) return; const e = this.size, t = this.divisions; this.gridHelper || (this.gridHelper = new XP(e, t, this.color0 ?? new xe(.4, .4, .4), this.color1 ?? new xe(.6, .6, .6)), this.offset !== void 0 && (this.gridHelper.position.y += this.offset)), this.gridHelper && this.gameObject.add(this.gridHelper) } onDisable() { this.gridHelper && (this.gameObject.remove(this.gridHelper), this.gridHelper = null) } } bM([x()], Tp.prototype, "isGizmo", 2), bM([x(xe)], Tp.prototype, "color0", 2), bM([x(xe)], Tp.prototype, "color1", 2); let die = class extends ye {
  constructor(i, e) {
    var t; const s = i.isCubeTexture, r = ((s ? (t = i.image[0]) == null ? void 0 : t.width : i.image.width) ?? 1024) / 4, n = Math.floor(Math.log2(r)), o = Math.pow(2, n), a = 3 * Math.max(o, 16 * 7), l = 4 * o, c = [s ? "#define ENVMAP_TYPE_CUBE" : "", `#define CUBEUV_TEXEL_WIDTH ${1 / a}`, `#define CUBEUV_TEXEL_HEIGHT ${1 / l}`, `#define CUBEUV_MAX_MIP ${n}.0`], h = `
        varying vec3 vWorldPosition;

        void main() 
        {

            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

        }
        `, d = c.join(`
`) + `
        #define ENVMAP_TYPE_CUBE_UV

        varying vec3 vWorldPosition;

        uniform float radius;
        uniform float height;
        uniform float angle;

        #ifdef ENVMAP_TYPE_CUBE

            uniform samplerCube map;

        #else

            uniform sampler2D map;

        #endif

        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {

            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;

        }

        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {

            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;

        }

        vec3 project() 
        {

            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;

            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;

            } else {

                p = vec3( 0.0, 1.0, 0.0 );

            }

            return p;

        }

        #include <common>
        #include <cube_uv_reflection_fragment>

        void main() 
        {

            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE

                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;

            #else

                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;

            #endif

            gl_FragColor = vec4( outcolor, 1.0 );

            #include <tonemapping_fragment>
            #include <encodings_fragment>

        }
        `, p = { map: { value: i }, height: { value: e?.height || 15 }, radius: { value: e?.radius || 100 } }, f = new Jp(1, 16), g = new Vt({ uniforms: p, fragmentShader: d, vertexShader: h, side: yi }); super(f, g)
  } set radius(i) { this.material.uniforms.radius.value = i } get radius() { return this.material.uniforms.radius.value } set height(i) { this.material.uniforms.height.value = i } get height() { return this.material.uniforms.height.value }
}; var pie = Object.defineProperty, fie = Object.getOwnPropertyDescriptor, Vb = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? fie(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && pie(e, t, r), r }; class au extends Ee { constructor() { super(...arguments), u(this, "applyOnAwake", !1), u(this, "_scale", 20), u(this, "_radius", 100), u(this, "_height", 100), u(this, "_lastEnvironment"), u(this, "env"), u(this, "_watcher") } set scale(e) { var t; this._scale = e, (t = this.env) == null || t.scale.setScalar(e) } get scale() { return this._scale } set radius(e) { this._radius = e, this.env && (this.env.radius = e) } get radius() { return this._radius } set height(e) { this._height = e, this.env && (this.env.height = e) } get height() { return this._height } awake() { this.applyOnAwake && this.updateAndCreate() } onEnable() { this.context.time.frameCount > 0 && this.applyOnAwake && this.updateAndCreate(), this._watcher || (this._watcher = new qp(this.context.scene, "environment"), this._watcher.subscribeWrite(e => { this.updateProjection() })) } onDisable() { var e, t; (e = this._watcher) == null || e.revoke(), (t = this.env) == null || t.removeFromParent() } updateAndCreate() { var e; this.updateProjection(), (e = this._watcher) == null || e.apply() } updateProjection() { var e; if (!this.context.scene.environment) { (e = this.env) == null || e.removeFromParent(); return } (!this.env || this.context.scene.environment !== this._lastEnvironment) && (console.log("Create/Update Ground Projection", this.context.scene.environment.name), this.env = new die(this.context.scene.environment)), this._lastEnvironment = this.context.scene.environment, this.env.parent || this.gameObject.add(this.env), this.env.scale.setScalar(this._scale), this.env.radius = this._radius, this.env.height = this._height, this.env.isObject3D === !0 && this.env.layers.set(2) } } Vb([x()], au.prototype, "applyOnAwake", 2), Vb([x()], au.prototype, "scale", 1), Vb([x()], au.prototype, "radius", 1), Vb([x()], au.prototype, "height", 1); var gie = Object.defineProperty, mie = Object.getOwnPropertyDescriptor, _l = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? mie(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && gie(e, t, r), r }; const _M = oe("debugtext"); class Vr extends Dc { constructor() { super(...arguments), u(this, "alignment", 0), u(this, "verticalOverflow", 0), u(this, "horizontalOverflow", 0), u(this, "lineSpacing", 1), u(this, "supportRichText", !1), u(this, "font"), u(this, "fontStyle", 0), u(this, "_text", ""), u(this, "_fontSize", 12), u(this, "_textMeshUi", null), u(this, "_didHandleTextRenderOnTop", !1) } get text() { return this._text } set text(e) { e !== this._text && (this._text = e, this.feedText(this.text, this.supportRichText), this.markDirty()) } set_text(e) { this.text = e } get fontSize() { return this._fontSize } set fontSize(e) { var t; this._fontSize = e, (t = this.uiObject) == null || t.set({ fontSize: e }) } onColorChanged() { var e; (e = this.uiObject) == null || e.set({ color: this.color, fontOpacity: this.color.alpha }) } onParentRectTransformChanged() { super.onParentRectTransformChanged(), this.uiObject && this.updateOverflow() } onBeforeRender() { this.uiObject && this.Root.screenspace && this.updateOverflow() } updateOverflow() { var e; const t = (e = this.uiObject) == null ? void 0 : e._overflow; t && (t._needsUpdate = !0, this.markDirty()) } onCreate(e) { _M && console.log(this), this.horizontalOverflow == 1 && (e.whiteSpace = "pre"), this.verticalOverflow == 0 && (this.context.renderer.localClippingEnabled = !0, e.overflow = "hidden"), this.horizontalOverflow == 1 && this.verticalOverflow == 0, e.lineHeight = this.lineSpacing, delete e.backgroundOpacity, delete e.backgroundColor, _M && (e.backgroundColor = 16750848, e.backgroundOpacity = .5); const t = this.rectTransform; e = { ...e, ...this.getTextOpts() }, this.getAlignment(e), _M && (e.backgroundColor = Math.random() * 16777215, e.backgroundOpacity = .1), this.uiObject = t.createNewText(e), this.feedText(this.text, this.supportRichText) } onAfterAddedToScene() { super.onAfterAddedToScene(), this.handleTextRenderOnTop() } getTextOpts() { let e = this.fontSize; const t = { color: this.color, fontOpacity: this.color.alpha, fontSize: e, fontKerning: "normal" }; return this.setFont(t, this.fontStyle), t } onEnable() { super.onEnable(), this._didHandleTextRenderOnTop = !1, this.uiObject && this.uiObject.addAfterUpdate(() => { this.setShadowComponentOwner(this.uiObject), this.markDirty() }), setTimeout(() => this.markDirty(), 10) } getAlignment(e) { switch (e.flexDirection = "column", this.alignment) { case 0: case 3: case 6: e.textAlign = "left"; break; case 1: case 4: case 7: e.textAlign = "center"; break; case 2: case 5: case 8: e.textAlign = "right"; break }switch (this.alignment) { default: case 0: case 1: case 2: e.alignItems = "start"; break; case 3: case 4: case 5: e.alignItems = "center"; break; case 6: case 7: case 8: e.alignItems = "end"; break }return e } feedText(e, t) { var s, r, n; if (!this.uiObject) return null; if (this._textMeshUi || (this._textMeshUi = []), !t || e.length === 0) this.uiObject.textContent = e; else { let o = this.getNextTag(e); if (o) o.startIndex > 0 && this.uiObject.add(new hb({ textContent: e.substring(0, o.startIndex), color: "inherit" })); else return this.uiObject.textContent = e; const a = []; for (; o;) { const l = this.getNextTag(e, o.endIndex), c = { fontFamily: (s = this.uiObject) == null ? void 0 : s.get("fontFamily"), color: "inherit", textContent: "" }; l ? (c.textContent = this.getText(e, o, l), this.handleTag(o, c, a), (r = this.uiObject) == null || r.add(new hb(c))) : (c.textContent = e.substring(o.endIndex), this.handleTag(o, c, a), (n = this.uiObject) == null || n.add(new hb(c))), o = l } } return null } handleTextRenderOnTop() { this._didHandleTextRenderOnTop || (this._didHandleTextRenderOnTop = !0, this.startCoroutine(this.renderOnTopCoroutine())) } *renderOnTopCoroutine() { if (!this.canvas) return; const e = [], t = this.canvas, s = { renderOnTop: t.renderOnTop, depthWrite: t.depthWrite, doubleSided: t.doubleSided }; for (; ;) { let r = !1; if (this._textMeshUi) for (let n = 0; n < this._textMeshUi.length; n++) { if (e[n] === !0) continue; r = !0; const o = this._textMeshUi[n]; o.textContent && (Sb(o, s), e[n] = !0) } if (!r) break; yield } } handleTag(e, t, s) { if (e.isEndTag) { if (s.length > 0) { const r = s.pop(); if (r) for (const n in r.previousValues) { const o = r.previousValues[n]; t[n] = o } } } else if (e.type.includes("color")) { const r = new xM(e, { color: t.color }); if (s.push(r), e.type.length > 6) { const n = parseInt("0x" + e.type.substring(7)); t.color = n } else t.color = new xe(1, 1, 1) } else if (e.type == "b") { this.setFont(t, 1); const r = new xM(e, { fontWeight: 700 }); s.push(r) } else if (e.type == "i") { this.setFont(t, 2); const r = new xM(e, { fontStyle: "italic" }); s.push(r) } } getText(e, t, s) { return e.substring(t.endIndex, s.startIndex) } getNextTag(e, t = 0) { const s = e.indexOf("<", t), r = e.indexOf(">", s); if (s >= 0 && r >= 0) { const n = e.substring(s + 1, r); return { type: n, startIndex: s, endIndex: r + 1, isEndTag: n.startsWith("/") } } return null } setFont(e, t) { if (!this.font) return; let s = this.font, r = bE.getFontFamily(s); r || (r = bE.addFontFamily(s)), e.fontFamily = r; const n = s.toLowerCase(); switch (t) { default: case 0: e.fontWeight = 400, e.fontStyle = "normal"; break; case 1: e.fontWeight = 700, e.fontStyle = "normal", n.includes("-bold") || (s += "-bold"); break; case 2: e.fontWeight = 400, e.fontStyle = "italic", n.includes("-italic") || (s += "-italic"); break; case 3: e.fontStyle = "italic", e.fontWeight = 400, n.includes("-bold") || (s += "-bold"), n.includes("-italic") || (s += "-italic") }let o = r.getVariant(e.fontWeight, e.fontStyle); if (!o) { let a = s; a != null && a.endsWith("-msdf.json") || (a += "-msdf.json"); let l = s; l != null && l.endsWith(".png") || (l += ".png"), o = r.addVariant(e.fontWeight, e.fontStyle, a, l), o?.addEventListener("ready", () => { this.markDirty() }) } } } _l([x()], Vr.prototype, "alignment", 2), _l([x()], Vr.prototype, "verticalOverflow", 2), _l([x()], Vr.prototype, "horizontalOverflow", 2), _l([x()], Vr.prototype, "lineSpacing", 2), _l([x()], Vr.prototype, "supportRichText", 2), _l([x(URL)], Vr.prototype, "font", 2), _l([x()], Vr.prototype, "fontStyle", 2), _l([x()], Vr.prototype, "text", 1), _l([x()], Vr.prototype, "fontSize", 1); class xM { constructor(e, t) { u(this, "tag"), u(this, "previousValues"), this.tag = e, this.previousValues = t } } var vie = Object.defineProperty, Aie = Object.getOwnPropertyDescriptor, Wb = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Aie(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && vie(e, t, r), r }; const lu = oe("debuginputfield"); var Dm; const Et = (Dm = class extends Ee { constructor() { super(...arguments), u(this, "textComponent"), u(this, "placeholder"), u(this, "onValueChanged"), u(this, "onEndEdit"), u(this, "inputEventFn"), u(this, "_iosEventFn") } get text() { var i; return ((i = this.textComponent) == null ? void 0 : i.text) ?? "" } get isFocused() { return Et.active === this } start() { lu && console.log(this.name, this) } onEnable() { var i; Et.htmlField || (Et.htmlField = document.createElement("input"), Et.htmlField.style.caretColor = "transparent", Et.htmlField.classList.add("ar"), document.body.appendChild(Et.htmlField)), this.inputEventFn || (this.inputEventFn = this.onInput.bind(this)), Et.htmlField.addEventListener("keyup", this.inputEventFn), this.placeholder && (i = this.textComponent) != null && i.text.length && $.setActive(this.placeholder.gameObject, !1), of() && (this._iosEventFn = this.processInputOniOS.bind(this), window.addEventListener("touchend", this._iosEventFn)) } onDisable() { var i; (i = Et.htmlField) == null || i.removeEventListener("keyup", this.inputEventFn), this.onDeselected(), this._iosEventFn && window.removeEventListener("touchend", this._iosEventFn) } onPointerClick(i) { lu && console.log("CLICK", i, Et.active), Et.activeTime = this.context.time.time, Et.active !== this && this.startCoroutine(this.activeLoop(), on.LateUpdate), this.selectInputField() } *activeLoop() { for (this.onSelected(); Et.active === this && !(this.context.input.getPointerUp(0) && this.context.time.time - Et.activeTime > .2);)this.setTextFromInputField(), yield; this.onDeselected() } onSelected() { var i, e, t, s; if (Et.active !== this && (lu && console.log("Select", this.name, this, Et.htmlField, this.context.isInXR, this.context.arOverlayElement, (i = this.textComponent) == null ? void 0 : i.text, (e = Et.htmlField) == null ? void 0 : e.value), (t = Et.active) == null || t.onDeselected(), Et.active = this, this.placeholder && $.setActive(this.placeholder.gameObject, !1), Et.htmlField)) { if (Et.htmlField.value = ((s = this.textComponent) == null ? void 0 : s.text) || "", lu && console.log("set input field value", Et.htmlField.value), this.context.isInXR) { const r = this.context.arOverlayElement; r && (Et.htmlField.style.width = "0px", Et.htmlField.style.height = "0px", r.append(Et.htmlField)) } this.selectInputField() } } onDeselected() { var i; Et.active === this && (Et.active = null, lu && console.log("Deselect", this.name, this), Et.htmlField && (Et.htmlField.blur(), document.body.append(Et.htmlField), Et.htmlField.style.width = "", Et.htmlField.style.height = ""), this.placeholder && (!this.textComponent || this.textComponent.text.length <= 0) && $.setActive(this.placeholder.gameObject, !0), Et.htmlField && ((i = this.onEndEdit) == null || i.invoke(Et.htmlField.value))) } update() { var i; Et.active === this && ((i = this.textComponent) == null || i.markDirty()) } onInput(i) { var e, t; if (Et.active === this) { if (lu && console.log(i.code, i, (e = Et.htmlField) == null ? void 0 : e.value, (t = this.textComponent) == null ? void 0 : t.text), i.code === "Escape" || i.code === "Enter") { this.onDeselected(); return } Et.htmlField && (this.textComponent && (this.setTextFromInputField(), this.placeholder && $.setActive(this.placeholder.gameObject, this.textComponent.text.length <= 0)), this.selectInputField()) } } setTextFromInputField() { var i; if (this.textComponent && Et.htmlField) { if (this.textComponent.text !== Et.htmlField.value) { lu && console.log("VALUE CHANGED"); const e = this.textComponent.text, t = Et.htmlField.value; (i = this.onValueChanged) == null || i.invoke(t, e) } this.textComponent.text = Et.htmlField.value } } selectInputField() { Et.htmlField && (Et.htmlField.setSelectionRange(Et.htmlField.value.length, Et.htmlField.value.length), Et.htmlField.focus()) } processInputOniOS() { const i = this.context.physics.raycast(); if (!i.length) return; const e = i[0].object, t = UE(e); (t?.gameObject === this.gameObject || t?.gameObject.parent === this.gameObject) && this.selectInputField() } }, u(Dm, "active", null), u(Dm, "activeTime", -1), u(Dm, "htmlField", null), Dm); let cu = Et; Wb([x(Vr)], cu.prototype, "textComponent", 2), Wb([x(Vr)], cu.prototype, "placeholder", 2), Wb([x(Nr)], cu.prototype, "onValueChanged", 2), Wb([x(Nr)], cu.prototype, "onEndEdit", 2); var yie = Object.defineProperty, bie = Object.getOwnPropertyDescriptor, aa = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? bie(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && yie(e, t, r), r }; function wM(i) { return i * Math.PI / 180 } const oU = 300, Rp = oe("debuglights"); class Wr extends Ee { constructor() { super(...arguments), u(this, "type", 0), u(this, "range", 1), u(this, "spotAngle", 1), u(this, "innerSpotAngle", 1), u(this, "_color", new xe(16777215)), u(this, "_shadowNearPlane", .1), u(this, "_shadowBias", 0), u(this, "_shadowNormalBias", 0), u(this, "_overrideShadowBiasSettings", !1), u(this, "_shadows", 1), u(this, "lightmapBakeType", 4), u(this, "_intensity", -1), u(this, "_shadowDistance"), u(this, "shadowWidth"), u(this, "shadowHeight"), u(this, "_shadowResolution"), u(this, "light"), u(this, "_webXRStartedListener"), u(this, "_webXREndedListener"), u(this, "_webARRoot") } set color(e) { this._color = e, this.light !== void 0 && (this.light.color = e) } get color() { return this.light ? this.light.color : this._color } set shadowNearPlane(e) { var t, s; if (e !== this._shadowNearPlane && (this._shadowNearPlane = e, ((s = (t = this.light) == null ? void 0 : t.shadow) == null ? void 0 : s.camera) !== void 0)) { const r = this.light.shadow.camera; r.near = e } } get shadowNearPlane() { return this._shadowNearPlane } set shadowBias(e) { var t, s; e !== this._shadowBias && (this._shadowBias = e, ((s = (t = this.light) == null ? void 0 : t.shadow) == null ? void 0 : s.bias) !== void 0 && (this.light.shadow.bias = e, this.light.shadow.needsUpdate = !0)) } get shadowBias() { return this._shadowBias } set shadowNormalBias(e) { var t, s; e !== this._shadowNormalBias && (this._shadowNormalBias = e, ((s = (t = this.light) == null ? void 0 : t.shadow) == null ? void 0 : s.normalBias) !== void 0 && (this.light.shadow.normalBias = e, this.light.shadow.needsUpdate = !0)) } get shadowNormalBias() { return this._shadowNormalBias } set shadows(e) { this._shadows = e, this.light && (this.light.castShadow = e !== 0, this.updateShadowSoftHard()) } get shadows() { return this._shadows } set intensity(e) { var t; if (this._intensity = e, this.light) { let s = 1; if (this.context.isInXR && this._webARRoot) { const r = (t = this._webARRoot) == null ? void 0 : t.arScale; typeof r == "number" && r > 0 && (s /= r) } this.light.intensity = e * s } } get intensity() { return this._intensity } get shadowDistance() { const e = this.light; return e ? e.shadow.camera.far : -1 } set shadowDistance(e) { this._shadowDistance = e; const t = this.light; if (t) { const s = t.shadow.camera; s.far = e, s.updateProjectionMatrix() } } get shadowResolution() { const e = this.light; return e ? e.shadow.mapSize.x : -1 } set shadowResolution(e) { if (e === this._shadowResolution) return; this._shadowResolution = e; const t = this.light; t && (t.shadow.mapSize.set(e, e), t.shadow.needsUpdate = !0) } get isBaked() { return this.lightmapBakeType === 2 } get selfIsLight() { if (this.gameObject.isLight === !0) return !0; switch (this.gameObject.type) { case "SpotLight": case "PointLight": case "DirectionalLight": return !0 }return !1 } getWorldPosition(e) { return this.light ? this.type === 1 ? this.light.getWorldPosition(e).multiplyScalar(1) : this.light.getWorldPosition(e) : e } awake() { this.color = new xe(this.color ?? 16777215), Rp && console.log(this.name, this) } onEnable() { Rp && console.log("ENABLE LIGHT", this.name), this.createLight(), !this.isBaked && (this.light && (this.light.visible = !0, this.light.intensity = this._intensity, this.selfIsLight || this.light.parent !== this.gameObject && this.gameObject.add(this.light)), this.type === 1 && this.startCoroutine(this.updateMainLightRoutine(), on.LateUpdate), this._webXRStartedListener = wt.addEventListener(bi.XRStarted, this.onWebXRStarted.bind(this)), this._webXREndedListener = wt.addEventListener(bi.XRStopped, this.onWebXREnded.bind(this))) } onDisable() { Rp && console.log("DISABLE LIGHT", this.name), this.light && (this.selfIsLight ? this.light.intensity = 0 : this.light.visible = !1), wt.removeEventListener(bi.XRStarted, this._webXRStartedListener), wt.removeEventListener(bi.XRStopped, this._webXREndedListener) } onWebXRStarted() { this._webARRoot = $.getComponentInParent(this.gameObject, Cc) ?? void 0 } onWebXREnded() { } createLight() { const e = this.selfIsLight; if (e && !this.light) switch (this.light = this.gameObject, this.light.name = this.name, this._intensity = this.light.intensity, this.type) { case 1: this.setDirectionalLight(this.light); break } else if (!this.light) switch (this.type) { case 1: const t = new KA(this.color, this.intensity * Math.PI); if (t.position.set(0, 0, -oU * .5).applyQuaternion(this.gameObject.quaternion), this.gameObject.add(t.target), dd(t.target, 0, 0, 0), this.light = t, this.gameObject.position.set(0, 0, 0), this.gameObject.rotation.set(0, 0, 0), Rp) { const o = new KP(this.light, .2, this.color); this.context.scene.add(o) } break; case 0: const s = new YA(this.color, this.intensity * Math.PI, this.range, wM(this.spotAngle / 2), 1 - wM(this.innerSpotAngle / 2) / wM(this.spotAngle / 2), 2); s.position.set(0, 0, 0), s.rotation.set(0, 0, 0), this.light = s; const r = s.target; s.add(r), r.position.set(0, 0, this.range), r.rotation.set(0, 0, 0); break; case 2: const n = new JA(this.color, this.intensity * Math.PI, this.range); this.light = n; break }if (this.light) { this._intensity >= 0 ? this.light.intensity = this._intensity : this._intensity = this.light.intensity, this.shadows !== 0 ? this.light.castShadow = !0 : this.light.castShadow = !1, this._shadowResolution !== void 0 && this._shadowResolution > 4 ? (this.light.shadow.mapSize.width = this._shadowResolution, this.light.shadow.mapSize.height = this._shadowResolution) : (this.light.shadow.mapSize.width = 2048, this.light.shadow.mapSize.height = 2048), Rp && console.log("Override shadow bias?", this._overrideShadowBiasSettings, this.shadowBias, this.shadowNormalBias), this.light.shadow.bias = this.shadowBias, this.light.shadow.normalBias = this.shadowNormalBias, this.updateShadowSoftHard(); const t = this.light.shadow.camera; if (t.near = this.shadowNearPlane, this._shadowDistance !== void 0 && typeof this._shadowDistance == "number" ? t.far = this._shadowDistance : t.far = oU * Math.abs(this.gameObject.scale.z), this.gameObject.scale.set(1, 1, 1), this.shadowWidth !== void 0) t.left = -this.shadowWidth / 2, t.right = this.shadowWidth / 2; else { const s = this.gameObject.scale.x; t.left *= s, t.right *= s } if (this.shadowHeight !== void 0) t.top = this.shadowHeight / 2, t.bottom = -this.shadowHeight / 2; else { const s = this.gameObject.scale.y; t.top *= s, t.bottom *= s } this.light.shadow.needsUpdate = !0, Rp && this.context.scene.add(new ZP(t)), this.isBaked ? this.light.removeFromParent() : e || this.gameObject.add(this.light) } } *updateMainLightRoutine() { for (; ;) { this.type === 1 && ((!this.context.mainLight || this.intensity > this.context.mainLight.intensity) && (this.context.mainLight = this), yield); break } } updateShadowSoftHard() { this.light && (this.shadows === 2 || (this.light.shadow.radius = 1, this.light.shadow.blurSamples = 1)) } setDirectionalLight(e) { e.add(e.target), e.target.position.set(0, 0, -1) } } u(Wr, "allowChangingRendererShadowMapType", !0), aa([x()], Wr.prototype, "type", 2), aa([x(xe)], Wr.prototype, "color", 1), aa([x()], Wr.prototype, "shadowNearPlane", 1), aa([x()], Wr.prototype, "shadowBias", 1), aa([x()], Wr.prototype, "shadowNormalBias", 1), aa([x()], Wr.prototype, "shadows", 1), aa([x()], Wr.prototype, "lightmapBakeType", 2), aa([x()], Wr.prototype, "intensity", 1), aa([x()], Wr.prototype, "shadowDistance", 1), aa([x()], Wr.prototype, "shadowResolution", 1), new S(0, 0, 0); var _ie = Object.defineProperty, xie = Object.getOwnPropertyDescriptor, Om = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? xie(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && _ie(e, t, r), r }; const Pp = oe("debugLODs"), wie = oe("noLODs"); class hu { constructor() { u(this, "screenRelativeTransitionHeight"), u(this, "distance"), u(this, "renderers") } } Om([x()], hu.prototype, "screenRelativeTransitionHeight", 2), Om([x()], hu.prototype, "distance", 2), Om([x()], hu.prototype, "renderers", 2); class Cie { constructor(e, t) { u(this, "model"), u(this, "renderers"), this.model = t, this.renderers = []; for (const s of t.renderers) { const r = this.findRenderer(s, e.gameObject); r && r.gameObject ? this.renderers.push(r) : Pp && console.warn("Renderer not found: " + s, e.gameObject) } } findRenderer(e, t) { const s = $.foreachComponent(t, r => { var n; return r.guid === e || ((n = Object.getPrototypeOf(r)) == null ? void 0 : n.guid) === e ? r : null }); if (s) return s; for (const r of t.children) { const n = this.findRenderer(e, r); if (n) return n } return null } } class Lm extends Ee { constructor() { super(...arguments), u(this, "fadeMode", 0), u(this, "localReferencePoint"), u(this, "lodCount", 0), u(this, "size", 0), u(this, "animateCrossFading", !1), u(this, "lodModels"), u(this, "_lods", []), u(this, "_settings", []), u(this, "_lodsHandler"), u(this, "_distanceFactor", 1) } start() { if (!wie && !this._lodsHandler && this.gameObject && (Pp && console.log(this), this.lodModels && Array.isArray(this.lodModels))) { let e = 0, t = []; for (const r of this.lodModels) { e = Math.max(r.distance, e); const n = new Cie(this, r); this._lods.push(n); for (const o of n.renderers) t.includes(o) || t.push(o) } this._lodsHandler = new Array; for (let r = 0; r < t.length; r++) { const n = new bw; this._lodsHandler.push(n), this.gameObject.add(n) } const s = new Me; s.name = "Cull " + this.name, Pp && console.log(t); for (let r = 0; r < t.length; r++) { const n = t[r], o = this._lodsHandler[r], a = n.gameObject; let l = 0, c = 0; Pp && console.log(r, a.name); for (const d of this._lods) { let p = null; d.renderers.includes(n) ? p = a : p = s, Pp && console.log("add", d.model.distance, p.name); const f = d.model.distance; if (c = f - l, l = Math.max(f, l), p.type === "Group") { console.warn("LODGroup: Group is not supported as LOD object", a.name, p); continue } this.onAddLodLevel(o, p, f) } const h = l + c; Pp && console.log("cull", h), this.onAddLodLevel(o, s, h) } } } update() { if (!this.gameObject || !this._lodsHandler) return; const e = this.context.mainCamera; if (e) for (const t of this._lodsHandler) t.update(e) } onAddLodLevel(e, t, s) { if (t === this.gameObject) { console.warn("LODGroup component must be on parent object and not mesh directly at the moment", t.name, t); return } e.addLevel(t, s * this._distanceFactor); const r = { lod: e, levelIndex: e.levels.length - 1, distance: s }; this._settings.push(r) } distanceFactor(e) { if (e !== this._distanceFactor) { this._distanceFactor = e; for (const t of this._settings) { const s = t.lod.levels[t.levelIndex]; s.distance = t.distance * e } } } } Om([x(S)], Lm.prototype, "localReferencePoint", 2), Om([x(hu)], Lm.prototype, "lodModels", 2); const Sie = oe("logstats"); class CM extends Ee { onEnable() { console.log(this), Sie && this.startCoroutine(this.run(), on.OnAfterRender) } *run() { for (; this.enabled;) { const e = this.context.renderer.info; console.log(e.memory, e.render, e.programs), yield } } } var Eie = Object.defineProperty, Mie = Object.getOwnPropertyDescriptor, qb = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Mie(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Eie(e, t, r), r }, SM; const aU = (SM = class extends Ee { constructor() { super(...arguments), u(this, "target"), u(this, "invertForward", !1), u(this, "keepUpDirection", !0), u(this, "copyTargetRotation", !1) } onBeforeRender() { let i = this.target; if (i || (i = this.context.mainCamera), !i) return; const e = xt(i), t = xt(this.gameObject); this.keepUpDirection && (e.y = t.y), this.copyTargetRotation ? Dr(this.gameObject, _s(i)) : this.gameObject.lookAt(e), this.invertForward && this.gameObject.quaternion.multiply(aU.flipYQuat) } createBehaviours(i, e, t) { if (e.uuid === this.gameObject.uuid) { let s = e; if (this.keepUpDirection) { const n = nl.createEmptyParent(e); s = n, n.matrix.multiply(new He().makeRotationZ(Math.PI / 2)), e.matrix.multiply(new He().makeRotationZ(-Math.PI / 2)) } const r = new Cr("lookat " + this.name, zr.sceneStartTrigger(), ni.lookAtCameraAction(s, void 0, this.invertForward ? Vd.back : Vd.forward, this.keepUpDirection ? Vd.up : Vd.zero)); i.addBehavior(r) } } }, u(SM, "flipYQuat", new we().setFromAxisAngle(new S(0, 1, 0), Math.PI)), SM); let uu = aU; qb([x(Me)], uu.prototype, "target", 2), qb([x()], uu.prototype, "invertForward", 2), qb([x()], uu.prototype, "keepUpDirection", 2), qb([x()], uu.prototype, "copyTargetRotation", 2); var Iie = Object.defineProperty, Tie = Object.getOwnPropertyDescriptor, Rie = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Tie(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Iie(e, t, r), r }; const EM = oe("debugnestedgltf"); class Xb extends Ee { constructor() { super(...arguments), u(this, "filePath"), u(this, "_isLoadingOrDoneLoading", !1) } listenToProgress(e) { var t; (t = this.filePath) == null || t.beginListenDownload(e) } preload() { var e; (e = this.filePath) == null || e.preload() } async start() { var e, t, s, r; if (this._isLoadingOrDoneLoading) return; EM && console.log(this, this.guid); const n = this.gameObject.parent; if (n) { this._isLoadingOrDoneLoading = !0; const o = new No; o.idProvider = new Br(this.hash(this.guid)), o.parent = n, this.gameObject.updateMatrix(); const a = this.gameObject.matrix; EM && console.log("Load nested:", ((e = this.filePath) == null ? void 0 : e.uri) ?? this.filePath, this.gameObject.position); const l = await ((s = (t = this.filePath) == null ? void 0 : t.instantiate) == null ? void 0 : s.call(this.filePath, o)); l && (l.matrixAutoUpdate = !1, l.matrix.identity(), l.applyMatrix4(a), l.matrixAutoUpdate = !0, l.layers.disableAll(), l.layers.set(this.layer)), this.destroy(), EM && console.log("Nested loading done:", ((r = this.filePath) == null ? void 0 : r.uri) ?? this.filePath, l) } } hash(e) { let t = 0; for (let s = 0; s < e.length; s++)t = e.charCodeAt(s) + ((t << 5) - t); return t } } Rie([x(or)], Xb.prototype, "filePath", 2); var Pie = Object.defineProperty, Bie = Object.getOwnPropertyDescriptor, Yb = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Bie(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Pie(e, t, r), r }; class du extends Ee { constructor() { super(...arguments), u(this, "referenceSpace"), u(this, "from"), u(this, "affectPosition", !1), u(this, "affectRotation", !1), u(this, "alignLookDirection", !1), u(this, "levelLookDirection", !1), u(this, "levelPosition", !1), u(this, "positionOffset", new S(0, 0, 0)), u(this, "rotationOffset", new S(0, 0, 0)), u(this, "offset", new S(0, 0, 0)) } update() { if (!this.from) return; var e = xt(this.from), t = _s(this.from); this.offset.copy(this.positionOffset); const s = this.offset.length(); if (this.referenceSpace && this.offset.transformDirection(this.referenceSpace.matrixWorld).multiplyScalar(s), e.add(this.offset), this.levelPosition && this.referenceSpace) { const a = new xn(this.gameObject.up, 0), l = xt(this.referenceSpace); a.setFromNormalAndCoplanarPoint(this.gameObject.up, l); const c = new S(0, 0, 0); a.projectPoint(e, c), e.copy(c) } this.affectPosition && ts(this.gameObject, e); const r = new ps(this.rotationOffset.x, this.rotationOffset.y, this.rotationOffset.z), n = new we().setFromEuler(r); this.affectRotation && Dr(this.gameObject, t.multiply(n)); let o = new S; this.from.getWorldDirection(o).multiplyScalar(50), this.levelLookDirection && (o.y = 0), this.alignLookDirection && this.gameObject.lookAt(o) } } Yb([x($)], du.prototype, "referenceSpace", 2), Yb([x($)], du.prototype, "from", 2), Yb([x(S)], du.prototype, "positionOffset", 2), Yb([x(S)], du.prototype, "rotationOffset", 2); var kie = Object.defineProperty, Die = Object.getOwnPropertyDescriptor, MM = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Die(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && kie(e, t, r), r }; class Bp extends Ee { constructor() { super(...arguments), u(this, "clickable", !0), u(this, "url"), u(this, "mode", 0), u(this, "_safariNewTabWorkaround", () => { var e, t; if (!this.clickable || !((e = this.url) != null && e.length) || this.mode === 1) return; const s = this.gameObject.getComponentInParent(lp); if (s) { const n = s.performRaycast(); if (!n) return; for (const o of n) if (o.object === this.gameObject || ((t = UE(o.object)) == null ? void 0 : t.gameObject) === this.gameObject) { this._validateUrl(); var r = document.createElement("a"); r.setAttribute("target", "_blank"), r.setAttribute("href", this.url), r.click(); break } } }) } async open() { if (!this.url) { console.error("URL is not set", this); return } switch (this._validateUrl(), Mn() && Ls("Open URL: " + this.url), this.mode) { case 0: Sa() ? globalThis.open(this.url, "_blank") : globalThis.open(this.url, "_blank"); break; case 1: Sa() ? globalThis.open(this.url, "_top") : globalThis.open(this.url, "_self"); break; case 2: Sa() ? globalThis.open(this.url, "_top") : globalThis.open(this.url, "_new"); break } } start() { this.gameObject.getComponentInParent(Yh) || this.gameObject.addNewComponent(Yh) } onEnable() { Sa() && window.addEventListener("touchend", this._safariNewTabWorkaround) } onDisable() { Sa() && window.removeEventListener("touchend", this._safariNewTabWorkaround) } onPointerEnter(e) { !e.used && this.clickable && this.context.input.setCursorPointer() } onPointerExit() { this.clickable && this.context.input.setCursorNormal() } onPointerClick(e) { var t; this.clickable && !e.used && (t = this.url) != null && t.length && this.open() } _validateUrl() { this.url && this.url.startsWith("www.") && (Mn() && console.warn("URL is not valid, adding https:// to the start of the URL", this.url), this.url = "https://" + this.url) } } MM([x()], Bp.prototype, "clickable", 2), MM([x()], Bp.prototype, "url", 2), MM([x()], Bp.prototype, "mode", 2); function Gt(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } function lU(i, e) { for (var t = 0; t < e.length; t++) { var s = e[t]; s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(i, s.key, s) } } function Ht(i, e, t) { return e && lU(i.prototype, e), t && lU(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } function ne(i, e, t) { return e in i ? Object.defineProperty(i, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = t, i } function kp(i, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); i.prototype = Object.create(e && e.prototype, { constructor: { value: i, writable: !0, configurable: !0 } }), Object.defineProperty(i, "prototype", { writable: !1 }), e && IM(i, e) } function Jb(i) { return Jb = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, Jb(i) } function IM(i, e) { return IM = Object.setPrototypeOf || function (t, s) { return t.__proto__ = s, t }, IM(i, e) } function Oie() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } function Jt(i) { if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return i } function Lie(i, e) { if (e && (typeof e == "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return Jt(i) } function Dp(i) { var e = Oie(); return function () { var t = Jb(i), s; if (e) { var r = Jb(this).constructor; s = Reflect.construct(t, arguments, r) } else s = t.apply(this, arguments); return Lie(this, s) } } function cU(i, e) { return Fie(i) || Uie(i, e) || hU(i, e) || Nie() } function Fie(i) { if (Array.isArray(i)) return i } function Uie(i, e) { var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"]; if (t != null) { var s = [], r = !0, n = !1, o, a; try { for (t = t.call(i); !(r = (o = t.next()).done) && (s.push(o.value), !(e && s.length === e)); r = !0); } catch (l) { n = !0, a = l } finally { try { !r && t.return != null && t.return() } finally { if (n) throw a } } return s } } function hU(i, e) { if (i) { if (typeof i == "string") return uU(i, e); var t = Object.prototype.toString.call(i).slice(8, -1); if (t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set") return Array.from(i); if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return uU(i, e) } } function uU(i, e) { (e == null || e > i.length) && (e = i.length); for (var t = 0, s = new Array(e); t < e; t++)s[t] = i[t]; return s } function Nie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function dU(i, e) {
  var t = typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"]; if (!t) {
    if (Array.isArray(i) || (t = hU(i)) || e && i && typeof i.length == "number") { t && (i = t); var s = 0, r = function () { }; return { s: r, n: function () { return s >= i.length ? { done: !0 } : { done: !1, value: i[s++] } }, e: function (l) { throw l }, f: r } } throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } var n = !0, o = !1, a; return { s: function () { t = t.call(i) }, n: function () { var l = t.next(); return n = l.done, l }, e: function (l) { o = !0, a = l }, f: function () { try { !n && t.return != null && t.return() } finally { if (o) throw a } } }
} var zie = function (i) { kp(t, i); var e = Dp(t); function t(s) { var r; return Gt(this, t), r = e.call(this), ne(Jt(r), "type", "ParticleEmitter"), ne(Jt(r), "system", void 0), r.system = s, r } return Ht(t, [{ key: "clone", value: function () { var s = this.system.clone(); return s.emitter.copy(this, !0), s.emitter } }, { key: "dispose", value: function () { } }, { key: "extractFromCache", value: function (s) { var r = []; for (var n in s) { var o = s[n]; delete o.metadata, r.push(o) } return r } }, { key: "toJSON", value: function (s) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = s === void 0 || typeof s == "string", o = {}; n && (s = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, o.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var a = {}; if (a.uuid = this.uuid, a.type = this.type, this.name !== "" && (a.name = this.name), this.castShadow === !0 && (a.castShadow = !0), this.receiveShadow === !0 && (a.receiveShadow = !0), this.visible === !1 && (a.visible = !1), this.frustumCulled === !1 && (a.frustumCulled = !1), this.renderOrder !== 0 && (a.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (a.matrixAutoUpdate = !1), this.system !== null && (a.ps = this.system.toJSON(s, r)), this.children.length > 0) { a.children = []; for (var l = 0; l < this.children.length; l++)this.children[l].type !== "ParticleSystemPreview" && a.children.push(this.children[l].toJSON(s).object) } if (n) { var c = this.extractFromCache(s.geometries), h = this.extractFromCache(s.materials), d = this.extractFromCache(s.textures), p = this.extractFromCache(s.images); c.length > 0 && (o.geometries = c), h.length > 0 && (o.materials = h), d.length > 0 && (o.textures = d), p.length > 0 && (o.images = p) } return o.object = a, o } }]), t }(Me), Fm = function () { function i() { Gt(this, i), ne(this, "parentMatrix", void 0), ne(this, "startSpeed", 0), ne(this, "startColor", new st), ne(this, "startSize", 1), ne(this, "position", new S), ne(this, "velocity", new S), ne(this, "age", 0), ne(this, "life", 1), ne(this, "size", 1), ne(this, "angularVelocity", void 0), ne(this, "rotation", 0), ne(this, "color", new st), ne(this, "uvTile", 0) } return Ht(i, [{ key: "died", get: function () { return this.age >= this.life } }]), i }(), jie = Ht(function i(e, t, s) { Gt(this, i), this.position = e, this.size = t, this.color = s }), Kb = function () { function i() { Gt(this, i), ne(this, "parentMatrix", void 0), ne(this, "startSpeed", 0), ne(this, "startColor", new st), ne(this, "startSize", 1), ne(this, "position", new S), ne(this, "localPosition", void 0), ne(this, "velocity", new S), ne(this, "age", 0), ne(this, "life", 1), ne(this, "size", 1), ne(this, "length", 100), ne(this, "color", new st), ne(this, "previous", []), ne(this, "uvTile", 0) } return Ht(i, [{ key: "recordCurrentState", value: function () { for (this.previous.push(new jie(this.position.clone(), this.size, this.color.clone())); this.previous.length > this.length;)this.previous.shift() } }, { key: "died", get: function () { return this.age >= this.life } }, { key: "reset", value: function () { this.previous.length = 0 } }]), i }(), Pr = function () { function i(e) { Gt(this, i), this.value = e, ne(this, "type", void 0), this.type = "value" } return Ht(i, [{ key: "genValue", value: function () { return this.value } }, { key: "toJSON", value: function () { return { type: "ConstantValue", value: this.value } } }, { key: "clone", value: function () { return new i(this.value) } }], [{ key: "fromJSON", value: function (e) { return new i(e.value) } }]), i }(), Qie = function () { function i(e, t) { Gt(this, i), this.a = e, this.b = t, ne(this, "type", void 0), this.type = "value" } return Ht(i, [{ key: "genValue", value: function () { return kr.lerp(this.a, this.b, Math.random()) } }, { key: "toJSON", value: function () { return { type: "IntervalValue", a: this.a, b: this.b } } }, { key: "clone", value: function () { return new i(this.a, this.b) } }], [{ key: "fromJSON", value: function (e) { return new i(e.a, e.b) } }]), i }(), Gie = function () { function i() { Gt(this, i), ne(this, "functions", void 0), this.functions = new Array } return Ht(i, [{ key: "findFunction", value: function (e) { for (var t = 0, s = 0, r = this.functions.length - 1; s + 1 < r;)if (t = Math.floor((s + r) / 2), e < this.getStartX(t)) r = t - 1; else if (e > this.getEndX(t)) s = t + 1; else return t; for (var n = s; n <= r; n++)if (e >= this.functions[n][1] && e <= this.getEndX(n)) return n; return -1 } }, { key: "getStartX", value: function (e) { return this.functions[e][1] } }, { key: "setStartX", value: function (e, t) { e > 0 && (this.functions[e][1] = t) } }, { key: "getEndX", value: function (e) { return e + 1 < this.functions.length ? this.functions[e + 1][1] : 1 } }, { key: "setEndX", value: function (e, t) { e + 1 < this.functions.length && (this.functions[e + 1][1] = t) } }, { key: "insertFunction", value: function (e, t) { var s = this.findFunction(e); this.functions.splice(s + 1, 0, [t, e]) } }, { key: "removeFunction", value: function (e) { return this.functions.splice(e, 1)[0][0] } }, { key: "getFunction", value: function (e) { return this.functions[e][0] } }, { key: "setFunction", value: function (e, t) { this.functions[e][0] = t } }, { key: "numOfFunctions", get: function () { return this.functions.length } }]), i }(), pU = function () { function i(e, t, s, r) { Gt(this, i), ne(this, "p", void 0), this.p = [e, t, s, r] } return Ht(i, [{ key: "genValue", value: function (e) { var t = e * e, s = e * e * e, r = 1 - e, n = r * r, o = n * r; return this.p[0] * o + this.p[1] * n * e * 3 + this.p[2] * r * t * 3 + this.p[3] * s } }, { key: "derivativeCoefficients", value: function (e) { for (var t = [], s = e, r = s.length - 1; r > 0; r--) { for (var n = [], o = 0; o < r; o++) { var a = r * (s[o + 1] - s[o]); n.push(a) } t.push(n), s = n } return t } }, { key: "getSlope", value: function (e) { var t = this.derivativeCoefficients(this.p)[0], s = 1 - e, r = s * s, n = s * e * 2, o = e * e; return r * t[0] + n * t[1] + o * t[2] } }, { key: "controlCurve", value: function (e, t) { this.p[1] = e / 3 + this.p[0], this.p[2] = this.p[3] - t / 3 } }, { key: "hull", value: function (e) { var t = this.p, s = [], r, n = [], o = 0, a = 0, l = 0; for (n[o++] = t[0], n[o++] = t[1], n[o++] = t[2], n[o++] = t[3]; t.length > 1;) { for (s = [], a = 0, l = t.length - 1; a < l; a++)r = e * t[a] + (1 - e) * t[a + 1], n[o++] = r, s.push(r); t = s } return n } }, { key: "split", value: function (e) { var t = this.hull(e), s = { left: new i(t[0], t[4], t[7], t[9]), right: new i(t[9], t[8], t[6], t[3]), span: t }; return s } }, { key: "clone", value: function () { return new i(this.p[0], this.p[1], this.p[2], this.p[3]) } }, { key: "toJSON", value: function () { return { p0: this.p[0], p1: this.p[1], p2: this.p[2], p3: this.p[3] } } }], [{ key: "fromJSON", value: function (e) { return new i(e.p0, e.p1, e.p2, e.p3) } }]), i }(), Hie = function (i) { kp(t, i); var e = Dp(t); function t() { var s, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [[new pU(0, .3333333333333333, .6666666666666666, 1), 0]]; return Gt(this, t), s = e.call(this), ne(Jt(s), "type", void 0), s.type = "function", s.functions = r, s } return Ht(t, [{ key: "genValue", value: function () { var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, r = this.findFunction(s); return r === -1 ? (console.error(s), 0) : this.functions[r][0].genValue((s - this.getStartX(r)) / (this.getEndX(r) - this.getStartX(r))) } }, { key: "toSVG", value: function (s, r) { if (r < 1) return ""; for (var n = ["M", 0, this.functions[0][0].p[0]].join(" "), o = 1 / r; o <= 1; o += 1 / r)n = [n, "L", o * s, this.genValue(o)].join(" "); return n } }, { key: "toJSON", value: function () { return { type: "PiecewiseBezier", functions: this.functions.map(function (s) { var r = cU(s, 2), n = r[0], o = r[1]; return { function: n.toJSON(), start: o } }) } } }, { key: "clone", value: function () { return new t(this.functions.map(function (s) { var r = cU(s, 2), n = r[0], o = r[1]; return [n.clone(), o] })) } }], [{ key: "fromJSON", value: function (s) { return new t(s.functions.map(function (r) { return [pU.fromJSON(r.function), r.start] })) } }]), t }(Gie), fU = function () { function i() { Gt(this, i), ne(this, "type", void 0), this.type = "rotation" } return Ht(i, [{ key: "genValue", value: function (e, t) { var s, r, n, o, a, l, c; do s = Math.random() * 2 - 1, r = Math.random() * 2 - 1, n = s * s + r * r; while (n > 1); do o = Math.random() * 2 - 1, a = Math.random() * 2 - 1, l = o * o + a * a; while (l > 1); return c = Math.sqrt((1 - n) / l), e.set(s, r, c * o, c * a), e } }, { key: "toJSON", value: function () { return { type: "RandomQuat" } } }, { key: "clone", value: function () { return new i } }], [{ key: "fromJSON", value: function (e) { return new i } }]), i }(), gU = function () { function i(e, t) { Gt(this, i), this.axis = e, this.angle = t, ne(this, "type", void 0), this.type = "rotation" } return Ht(i, [{ key: "genValue", value: function (e, t) { return e.setFromAxisAngle(this.axis, this.angle.genValue(t)) } }, { key: "toJSON", value: function () { return { type: "AxisAngle", axis: { x: this.axis.x, y: this.axis.y, z: this.axis.z }, angle: this.angle.toJSON() } } }, { key: "clone", value: function () { return new i(this.axis.clone(), this.angle.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(e.axis, Ws(e.angle)) } }]), i }(); function mU(i) { switch (i.type) { case "AxisAngle": return gU.fromJSON(i); case "RandomQuat": return fU.fromJSON(i); default: return new fU } } function Ws(i) { switch (i.type) { case "ConstantValue": return Pr.fromJSON(i); case "IntervalValue": return Qie.fromJSON(i); case "PiecewiseBezier": return Hie.fromJSON(i); default: return new Pr(0) } } function Vie(i) { switch (i.type) { case "ConstantValue": case "IntervalValue": case "PiecewiseBezier": return Ws(i); case "AxisAngle": case "RandomQuat": return mU(i); default: return new Pr(0) } } var Um = function (i) { return { r: i.x, g: i.y, b: i.z, a: i.w } }, Nm = function (i) { return new st(i.r, i.g, i.b, i.a) }, Wie = function () { function i(e, t) { Gt(this, i), this.a = e, this.b = t, ne(this, "type", void 0), this.type = "value" } return Ht(i, [{ key: "genColor", value: function (e) { var t = Math.random(); return e.copy(this.a).lerp(this.b, t) } }, { key: "toJSON", value: function () { return { type: "RandomColor", a: Um(this.a), b: Um(this.b) } } }, { key: "clone", value: function () { return new i(this.a.clone(), this.b.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(Nm(e.a), Nm(e.b)) } }]), i }(), qie = function () { function i(e, t) { Gt(this, i), this.a = e, this.b = t, ne(this, "type", void 0), this.type = "function" } return Ht(i, [{ key: "genColor", value: function (e, t) { return e.copy(this.a).lerp(this.b, t) } }, { key: "toJSON", value: function () { return { type: "ColorRange", a: Um(this.a), b: Um(this.b) } } }, { key: "clone", value: function () { return new i(this.a.clone(), this.b.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(Nm(e.a), Nm(e.b)) } }]), i }(), Zb = function () { function i(e) { Gt(this, i), this.color = e, ne(this, "type", void 0), this.type = "value" } return Ht(i, [{ key: "genColor", value: function (e) { return e.copy(this.color) } }, { key: "toJSON", value: function () { return { type: "ConstantColor", color: Um(this.color) } } }, { key: "clone", value: function () { return new i(this.color.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(Nm(e.color)) } }]), i }(); function vU(i) { switch (i.type) { case "ConstantColor": return Zb.fromJSON(i); case "ColorRange": return qie.fromJSON(i); case "RandomColor": return Wie.fromJSON(i); default: return new Zb(new st(1, 1, 1, 1)) } } var AU = function () { function i(e) { Gt(this, i), this.color = e, ne(this, "type", "ColorOverLife") } return Ht(i, [{ key: "initialize", value: function (e) { } }, { key: "update", value: function (e, t) { this.color.genColor(e.color, e.age / e.life), e.color.x *= e.startColor.x, e.color.y *= e.startColor.y, e.color.z *= e.startColor.z, e.color.w *= e.startColor.w } }, { key: "frameUpdate", value: function (e) { } }, { key: "toJSON", value: function () { return { type: this.type, color: this.color.toJSON() } } }, { key: "clone", value: function () { return new i(this.color.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(vU(e.color)) } }]), i }(), yU = function () { function i(e, t) { Gt(this, i), this.angularVelocity = e, this.dynamic = t, ne(this, "type", "RotationOverLife"), ne(this, "tempQuat", new we) } return Ht(i, [{ key: "initialize", value: function (e) { !this.dynamic && e instanceof Fm && (e.angularVelocity = this.angularVelocity.genValue()) } }, { key: "update", value: function (e, t) { this.dynamic ? e.rotation += t * this.angularVelocity.genValue(e.age / e.life) : e instanceof Fm && (e.rotation += t * e.angularVelocity) } }, { key: "toJSON", value: function () { return { type: this.type, angularVelocity: this.angularVelocity.toJSON(), dynamic: this.dynamic } } }, { key: "frameUpdate", value: function (e) { } }, { key: "clone", value: function () { return new i(this.angularVelocity.clone(), this.dynamic) } }], [{ key: "fromJSON", value: function (e) { return new i(Ws(e.angularVelocity), e.dynamic) } }]), i }(), bU = function () { function i(e) { Gt(this, i), this.size = e, ne(this, "type", "SizeOverLife") } return Ht(i, [{ key: "initialize", value: function (e) { } }, { key: "update", value: function (e) { e.size = e.startSize * this.size.genValue(e.age / e.life) } }, { key: "toJSON", value: function () { return { type: this.type, size: this.size.toJSON() } } }, { key: "frameUpdate", value: function (e) { } }, { key: "clone", value: function () { return new i(this.size.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(Ws(e.size)) } }]), i }(), _U = function () { function i(e) { Gt(this, i), this.speed = e, ne(this, "type", "SpeedOverLife") } return Ht(i, [{ key: "initialize", value: function (e) { } }, { key: "update", value: function (e) { e.velocity.normalize().multiplyScalar(e.startSpeed * this.speed.genValue(e.age / e.life)) } }, { key: "toJSON", value: function () { return { type: this.type, speed: this.speed.toJSON() } } }, { key: "frameUpdate", value: function (e) { } }, { key: "clone", value: function () { return new i(this.speed.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(Ws(e.speed)) } }]), i }(), xU = function () { function i(e) { Gt(this, i), this.frame = e, ne(this, "type", "FrameOverLife") } return Ht(i, [{ key: "initialize", value: function (e) { } }, { key: "update", value: function (e, t) { e.uvTile = Math.floor(this.frame.genValue(e.age / e.life)) } }, { key: "frameUpdate", value: function (e) { } }, { key: "toJSON", value: function () { return { type: this.type, frame: this.frame.toJSON() } } }, { key: "clone", value: function () { return new i(this.frame.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(Ws(e.frame)) } }]), i }(); new S(0, 0, 1); var wU = function () { function i(e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new S(0, 1, 0); Gt(this, i), this.orbitSpeed = e, this.axis = t, ne(this, "type", "OrbitOverLife"), ne(this, "rotation", void 0), ne(this, "line", void 0), ne(this, "temp", new S), this.rotation = new we, this.line = new GP } return Ht(i, [{ key: "initialize", value: function (e) { } }, { key: "update", value: function (e, t) { this.line.set(new S(0, 0, 0), this.axis), this.line.closestPointToPoint(e.position, !1, this.temp), this.rotation.setFromAxisAngle(this.axis, this.orbitSpeed.genValue(e.age / e.life) * t), e.position.sub(this.temp), e.position.applyQuaternion(this.rotation), e.position.add(this.temp) } }, { key: "frameUpdate", value: function (e) { } }, { key: "toJSON", value: function () { return { type: this.type, orbitSpeed: this.orbitSpeed.toJSON(), axis: [this.axis.x, this.axis.y, this.axis.z] } } }, { key: "clone", value: function () { return new i(this.orbitSpeed.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(Ws(e.orbitSpeed), e.axis ? new S(e.axis[0], e.axis[1], e.axis[2]) : void 0) } }]), i }(), CU = function () { function i(e, t) { Gt(this, i), this.direction = e, this.force = t, ne(this, "type", "ApplyForce") } return Ht(i, [{ key: "initialize", value: function (e) { e.force = this.force.genValue() } }, { key: "update", value: function (e, t) { e.velocity.addScaledVector(this.direction, e.force * t) } }, { key: "frameUpdate", value: function (e) { } }, { key: "toJSON", value: function () { return { type: this.type, direction: [this.direction.x, this.direction.y, this.direction.z], force: this.force.toJSON() } } }, { key: "clone", value: function () { return new i(this.direction.clone(), this.force.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(new S(e.direction[0], e.direction[1], e.direction[2]), Ws(e.force)) } }]), i }(), SU = function () { function i(e, t) { Gt(this, i), this.center = e, this.magnitude = t, ne(this, "type", "GravityForce"), ne(this, "temp", new S) } return Ht(i, [{ key: "initialize", value: function (e) { } }, { key: "update", value: function (e, t) { this.temp.copy(this.center).sub(e.position).normalize(), e.velocity.addScaledVector(this.temp, this.magnitude / e.position.distanceToSquared(this.center) * t) } }, { key: "frameUpdate", value: function (e) { } }, { key: "toJSON", value: function () { return { type: this.type, center: [this.center.x, this.center.y, this.center.z], magnitude: this.magnitude } } }, { key: "clone", value: function () { return new i(this.center.clone(), this.magnitude) } }], [{ key: "fromJSON", value: function (e) { return new i(new S(e.center[0], e.center[1], e.center[2]), e.magnitude) } }]), i }(), EU = function () { function i(e) { Gt(this, i), this.width = e, ne(this, "type", "WidthOverLength") } return Ht(i, [{ key: "initialize", value: function (e) { } }, { key: "update", value: function (e) { if (e instanceof Kb) for (var t = 0; t < e.previous.length; t++)e.previous[t].size = this.width.genValue((e.previous.length - t) / e.length) } }, { key: "frameUpdate", value: function (e) { } }, { key: "toJSON", value: function () { return { type: this.type, width: this.width.toJSON() } } }, { key: "clone", value: function () { return new i(this.width.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(Ws(e.width)) } }]), i }(); new S(0, 0, 1); var MU = function () { function i(e) { Gt(this, i), this.angle = e, ne(this, "type", "ChangeEmitDirection"), ne(this, "_temp", new S), ne(this, "_q", new we) } return Ht(i, [{ key: "initialize", value: function (e) { var t = e.velocity.length(); t != 0 && (e.velocity.normalize(), e.velocity.x === 0 && e.velocity.y === 0 ? this._temp.set(0, e.velocity.z, 0) : this._temp.set(-e.velocity.y, e.velocity.x, 0), this._q.setFromAxisAngle(this._temp.normalize(), this.angle.genValue()), this._temp.copy(e.velocity), e.velocity.applyQuaternion(this._q), this._q.setFromAxisAngle(this._temp, Math.random() * Math.PI * 2), e.velocity.applyQuaternion(this._q), e.velocity.setLength(t)) } }, { key: "update", value: function (e, t) { } }, { key: "frameUpdate", value: function (e) { } }, { key: "toJSON", value: function () { return { type: this.type, angle: this.angle.toJSON() } } }, { key: "clone", value: function () { return new i(this.angle) } }], [{ key: "fromJSON", value: function (e) { return new i(Ws(e.angle)) } }]), i }(), Xie = new S(1, 1, 1), IU = new S(0, 0, 1), TU = function () { function i(e, t, s) { Gt(this, i), this.particleSystem = e, this.useVelocityAsBasis = t, this.subParticleSystem = s, ne(this, "type", "EmitSubParticleSystem"), ne(this, "q_", new we), ne(this, "v_", new S), ne(this, "v2_", new S), this.subParticleSystem && (this.subParticleSystem.system.onlyUsedByOther = !0) } return Ht(i, [{ key: "initialize", value: function (e) { e.emissionState = { burstIndex: 0, burstWaveIndex: 0, time: 0, waitEmiting: 0, matrix: new He } } }, { key: "update", value: function (e, t) { if (!(!this.subParticleSystem || !e.emissionState)) { var s = e.emissionState.matrix, r; if (e.rotation === void 0 || this.useVelocityAsBasis) if (e.velocity.x === 0 && e.velocity.y === 0 && (e.velocity.z === 1 || e.velocity.z === 0)) s.set(1, 0, 0, e.position.x, 0, 1, 0, e.position.y, 0, 0, 1, e.position.z, 0, 0, 0, 1); else { this.v_.copy(IU).cross(e.velocity), this.v2_.copy(e.velocity).cross(this.v_); var n = this.v_.length(), o = this.v2_.length(); s.set(this.v_.x / n, this.v2_.x / o, e.velocity.x, e.position.x, this.v_.y / n, this.v2_.y / o, e.velocity.y, e.position.y, this.v_.z / n, this.v2_.z / o, e.velocity.z, e.position.z, 0, 0, 0, 1) } else e.rotation instanceof we ? r = e.rotation : (this.q_.setFromAxisAngle(IU, e.rotation), r = this.q_), s.compose(e.position, r, Xie); this.particleSystem.worldSpace || s.multiplyMatrices(this.particleSystem.emitter.matrixWorld, s), this.subParticleSystem.system.emit(t, e.emissionState, s) } } }, { key: "frameUpdate", value: function (e) { } }, { key: "toJSON", value: function () { return { type: this.type, subParticleSystem: this.subParticleSystem ? this.subParticleSystem.uuid : "", useVelocityAsBasis: this.useVelocityAsBasis } } }, { key: "clone", value: function () { return new i(this.particleSystem, this.useVelocityAsBasis, this.subParticleSystem) } }], [{ key: "fromJSON", value: function (e, t) { return new i(t, e.useVelocityAsBasis, void 0) } }]), i }(), Yie = .5 * (Math.sqrt(3) - 1), zm = (3 - Math.sqrt(3)) / 6, Jie = 1 / 3, la = 1 / 6, Kie = (Math.sqrt(5) - 1) / 4, qs = (5 - Math.sqrt(5)) / 20, Ps = new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]), cs = new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]), Zie = function () { function i() { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Math.random; Gt(this, i), ne(this, "p", void 0), ne(this, "perm", void 0), ne(this, "permMod12", void 0); var t = typeof e == "function" ? e : ese(e); this.p = $ie(t), this.perm = new Uint8Array(512), this.permMod12 = new Uint8Array(512); for (var s = 0; s < 512; s++)this.perm[s] = this.p[s & 255], this.permMod12[s] = this.perm[s] % 12 } return Ht(i, [{ key: "noise2D", value: function (e, t) { var s = this.permMod12, r = this.perm, n = 0, o = 0, a = 0, l = (e + t) * Yie, c = Math.floor(e + l), h = Math.floor(t + l), d = (c + h) * zm, p = c - d, f = h - d, g = e - p, m = t - f, v, A; g > m ? (v = 1, A = 0) : (v = 0, A = 1); var b = g - v + zm, y = m - A + zm, _ = g - 1 + 2 * zm, w = m - 1 + 2 * zm, E = c & 255, P = h & 255, C = .5 - g * g - m * m; if (C >= 0) { var R = s[E + r[P]] * 3; C *= C, n = C * C * (Ps[R] * g + Ps[R + 1] * m) } var T = .5 - b * b - y * y; if (T >= 0) { var z = s[E + v + r[P + A]] * 3; T *= T, o = T * T * (Ps[z] * b + Ps[z + 1] * y) } var H = .5 - _ * _ - w * w; if (H >= 0) { var N = s[E + 1 + r[P + 1]] * 3; H *= H, a = H * H * (Ps[N] * _ + Ps[N + 1] * w) } return 70 * (n + o + a) } }, { key: "noise3D", value: function (e, t, s) { var r = this.permMod12, n = this.perm, o, a, l, c, h = (e + t + s) * Jie, d = Math.floor(e + h), p = Math.floor(t + h), f = Math.floor(s + h), g = (d + p + f) * la, m = d - g, v = p - g, A = f - g, b = e - m, y = t - v, _ = s - A, w, E, P, C, R, T; b >= y ? y >= _ ? (w = 1, E = 0, P = 0, C = 1, R = 1, T = 0) : b >= _ ? (w = 1, E = 0, P = 0, C = 1, R = 0, T = 1) : (w = 0, E = 0, P = 1, C = 1, R = 0, T = 1) : y < _ ? (w = 0, E = 0, P = 1, C = 0, R = 1, T = 1) : b < _ ? (w = 0, E = 1, P = 0, C = 0, R = 1, T = 1) : (w = 0, E = 1, P = 0, C = 1, R = 1, T = 0); var z = b - w + la, H = y - E + la, N = _ - P + la, F = b - C + 2 * la, X = y - R + 2 * la, te = _ - T + 2 * la, re = b - 1 + 3 * la, Z = y - 1 + 3 * la, fe = _ - 1 + 3 * la, ae = d & 255, De = p & 255, Se = f & 255, ie = .6 - b * b - y * y - _ * _; if (ie < 0) o = 0; else { var ce = r[ae + n[De + n[Se]]] * 3; ie *= ie, o = ie * ie * (Ps[ce] * b + Ps[ce + 1] * y + Ps[ce + 2] * _) } var Te = .6 - z * z - H * H - N * N; if (Te < 0) a = 0; else { var K = r[ae + w + n[De + E + n[Se + P]]] * 3; Te *= Te, a = Te * Te * (Ps[K] * z + Ps[K + 1] * H + Ps[K + 2] * N) } var je = .6 - F * F - X * X - te * te; if (je < 0) l = 0; else { var Ue = r[ae + C + n[De + R + n[Se + T]]] * 3; je *= je, l = je * je * (Ps[Ue] * F + Ps[Ue + 1] * X + Ps[Ue + 2] * te) } var Pe = .6 - re * re - Z * Z - fe * fe; if (Pe < 0) c = 0; else { var ve = r[ae + 1 + n[De + 1 + n[Se + 1]]] * 3; Pe *= Pe, c = Pe * Pe * (Ps[ve] * re + Ps[ve + 1] * Z + Ps[ve + 2] * fe) } return 32 * (o + a + l + c) } }, { key: "noise4D", value: function (e, t, s, r) { var n = this.perm, o, a, l, c, h, d = (e + t + s + r) * Kie, p = Math.floor(e + d), f = Math.floor(t + d), g = Math.floor(s + d), m = Math.floor(r + d), v = (p + f + g + m) * qs, A = p - v, b = f - v, y = g - v, _ = m - v, w = e - A, E = t - b, P = s - y, C = r - _, R = 0, T = 0, z = 0, H = 0; w > E ? R++ : T++, w > P ? R++ : z++, w > C ? R++ : H++, E > P ? T++ : z++, E > C ? T++ : H++, P > C ? z++ : H++; var N = R >= 3 ? 1 : 0, F = T >= 3 ? 1 : 0, X = z >= 3 ? 1 : 0, te = H >= 3 ? 1 : 0, re = R >= 2 ? 1 : 0, Z = T >= 2 ? 1 : 0, fe = z >= 2 ? 1 : 0, ae = H >= 2 ? 1 : 0, De = R >= 1 ? 1 : 0, Se = T >= 1 ? 1 : 0, ie = z >= 1 ? 1 : 0, ce = H >= 1 ? 1 : 0, Te = w - N + qs, K = E - F + qs, je = P - X + qs, Ue = C - te + qs, Pe = w - re + 2 * qs, ve = E - Z + 2 * qs, de = P - fe + 2 * qs, Ae = C - ae + 2 * qs, pe = w - De + 3 * qs, Fe = E - Se + 3 * qs, Re = P - ie + 3 * qs, ht = C - ce + 3 * qs, me = w - 1 + 4 * qs, ut = E - 1 + 4 * qs, dt = P - 1 + 4 * qs, Pt = C - 1 + 4 * qs, ii = p & 255, U = f & 255, D = g & 255, le = m & 255, Ie = .6 - w * w - E * E - P * P - C * C; if (Ie < 0) o = 0; else { var Be = n[ii + n[U + n[D + n[le]]]] % 32 * 4; Ie *= Ie, o = Ie * Ie * (cs[Be] * w + cs[Be + 1] * E + cs[Be + 2] * P + cs[Be + 3] * C) } var Qe = .6 - Te * Te - K * K - je * je - Ue * Ue; if (Qe < 0) a = 0; else { var rt = n[ii + N + n[U + F + n[D + X + n[le + te]]]] % 32 * 4; Qe *= Qe, a = Qe * Qe * (cs[rt] * Te + cs[rt + 1] * K + cs[rt + 2] * je + cs[rt + 3] * Ue) } var j = .6 - Pe * Pe - ve * ve - de * de - Ae * Ae; if (j < 0) l = 0; else { var J = n[ii + re + n[U + Z + n[D + fe + n[le + ae]]]] % 32 * 4; j *= j, l = j * j * (cs[J] * Pe + cs[J + 1] * ve + cs[J + 2] * de + cs[J + 3] * Ae) } var Ve = .6 - pe * pe - Fe * Fe - Re * Re - ht * ht; if (Ve < 0) c = 0; else { var qe = n[ii + De + n[U + Se + n[D + ie + n[le + ce]]]] % 32 * 4; Ve *= Ve, c = Ve * Ve * (cs[qe] * pe + cs[qe + 1] * Fe + cs[qe + 2] * Re + cs[qe + 3] * ht) } var ze = .6 - me * me - ut * ut - dt * dt - Pt * Pt; if (ze < 0) h = 0; else { var ge = n[ii + 1 + n[U + 1 + n[D + 1 + n[le + 1]]]] % 32 * 4; ze *= ze, h = ze * ze * (cs[ge] * me + cs[ge + 1] * ut + cs[ge + 2] * dt + cs[ge + 3] * Pt) } return 27 * (o + a + l + c + h) } }]), i }(); function $ie(i) { for (var e = new Uint8Array(256), t = 0; t < 256; t++)e[t] = t; for (var s = 0; s < 255; s++) { var r = s + ~~(i() * (256 - s)), n = e[s]; e[s] = e[r], e[r] = n } return e } function ese(i) { var e = 0, t = 0, s = 0, r = 1, n = tse(); return e = n(" "), t = n(" "), s = n(" "), e -= n(i), e < 0 && (e += 1), t -= n(i), t < 0 && (t += 1), s -= n(i), s < 0 && (s += 1), function () { var o = 2091639 * e + r * 23283064365386963e-26; return e = t, t = s, s = o - (r = o | 0) } } function tse() { var i = 4022871197; return function (e) { e = e.toString(); for (var t = 0; t < e.length; t++) { i += e.charCodeAt(t); var s = .02519603282416938 * i; i = s >>> 0, s -= i, s *= i, i = s >>> 0, s -= i, i += s * 4294967296 } return (i >>> 0) * 23283064365386963e-26 } } var RU = function () { function i(e, t, s) { Gt(this, i), this.scale = e, this.power = t, this.fieldShift = s, ne(this, "type", "TurbulenceField"), ne(this, "generator", new Zie), ne(this, "offset", [new S, new S, new S]), ne(this, "temp", new S), this.offset[0].x = Math.random() / this.scale.x, this.offset[1].x = Math.random() / this.scale.x, this.offset[2].x = Math.random() / this.scale.x, this.offset[0].y = Math.random() / this.scale.y, this.offset[1].y = Math.random() / this.scale.y, this.offset[2].y = Math.random() / this.scale.y, this.offset[0].z = Math.random() / this.scale.z, this.offset[1].z = Math.random() / this.scale.z, this.offset[2].z = Math.random() / this.scale.z } return Ht(i, [{ key: "initialize", value: function (e) { } }, { key: "update", value: function (e, t) { var s = e.position.x / this.scale.x, r = e.position.y / this.scale.y, n = e.position.z / this.scale.z; this.temp.set(this.generator.noise3D(this.offset[0].x + s, this.offset[0].y + r, this.offset[0].z + n), this.generator.noise3D(this.offset[1].x + s, this.offset[1].y + r, this.offset[1].z + n), this.generator.noise3D(this.offset[2].x + s, this.offset[2].y + r, this.offset[2].z + n)).multiply(this.power), e.velocity.addScaledVector(this.temp, t) } }, { key: "toJSON", value: function () { return { type: this.type, scale: [this.scale.x, this.scale.y, this.scale.z], power: [this.power.x, this.power.y, this.power.z], fieldShift: [this.fieldShift.x, this.fieldShift.y, this.fieldShift.z] } } }, { key: "frameUpdate", value: function (e) { this.offset[0].x += e * this.fieldShift.x, this.offset[0].y += e * this.fieldShift.y, this.offset[0].z += e * this.fieldShift.z, this.offset[1].x += e * this.fieldShift.x, this.offset[1].y += e * this.fieldShift.y, this.offset[1].z += e * this.fieldShift.z, this.offset[2].x += e * this.fieldShift.x, this.offset[2].y += e * this.fieldShift.y, this.offset[2].z += e * this.fieldShift.z } }, { key: "clone", value: function () { return new i(this.scale.clone(), this.power.clone(), this.fieldShift.clone()) } }], [{ key: "fromJSON", value: function (e) { return new i(new S(e.scale[0], e.scale[1], e.scale[2]), new S(e.power[0], e.power[1], e.power[2]), new S(e.fieldShift[0], e.fieldShift[1], e.fieldShift[2])) } }]), i }(), PU = new we, BU = function () { function i(e, t) { Gt(this, i), this.angularVelocity = e, this.dynamic = t, ne(this, "type", "Rotation3DOverLife"), ne(this, "tempQuat", new we) } return Ht(i, [{ key: "initialize", value: function (e) { !this.dynamic && e instanceof Fm && (e.angularVelocity = new we, this.angularVelocity.genValue(e.angularVelocity)) } }, { key: "update", value: function (e, t) { this.dynamic ? (this.angularVelocity.genValue(this.tempQuat, e.age / e.life), this.tempQuat.slerpQuaternions(PU, this.tempQuat, t), e.rotation.multiply(this.tempQuat)) : e instanceof Fm && (this.tempQuat.slerpQuaternions(PU, e.angularVelocity, t), e.rotation.multiply(this.tempQuat)) } }, { key: "toJSON", value: function () { return { type: this.type, angularVelocity: this.angularVelocity.toJSON(), dynamic: this.dynamic } } }, { key: "frameUpdate", value: function (e) { } }, { key: "clone", value: function () { return new i(this.angularVelocity.clone(), this.dynamic) } }], [{ key: "fromJSON", value: function (e) { return new i(mU(e.angularVelocity), e.dynamic) } }]), i }(), ise = { ApplyForce: { type: "ApplyForce", constructor: CU, params: [["direction", "vec3"], ["force", "value"]], loadJSON: CU.fromJSON }, TurbulenceField: { type: "TurbulenceField", constructor: RU, params: [["scale", "vec3"], ["power", "vec3"], ["fieldShift", "vec3"]], loadJSON: RU.fromJSON }, GravityForce: { type: "GravityForce", constructor: SU, params: [["center", "vec3"], ["magnitude", "number"]], loadJSON: SU.fromJSON }, ColorOverLife: { type: "ColorOverLife", constructor: AU, params: [["color", "colorFunc"]], loadJSON: AU.fromJSON }, RotationOverLife: { type: "RotationOverLife", constructor: yU, params: [["angularVelocity", "valueFunc"], ["dynamic", "boolean"]], loadJSON: yU.fromJSON }, Rotation3DOverLife: { type: "Rotation3DOverLife", constructor: BU, params: [["angularVelocity", "rotationFunc"], ["dynamic", "boolean"]], loadJSON: BU.fromJSON }, SizeOverLife: { type: "SizeOverLife", constructor: bU, params: [["size", "valueFunc"]], loadJSON: bU.fromJSON }, SpeedOverLife: { type: "SpeedOverLife", constructor: _U, params: [["speed", "valueFunc"]], loadJSON: _U.fromJSON }, FrameOverLife: { type: "FrameOverLife", constructor: xU, params: [["frame", "valueFunc"]], loadJSON: xU.fromJSON }, OrbitOverLife: { type: "OrbitOverLife", constructor: wU, params: [["orbitSpeed", "valueFunc"], ["axis", "vec3"]], loadJSON: wU.fromJSON }, WidthOverLength: { type: "WidthOverLength", constructor: EU, params: [["width", "valueFunc"]], loadJSON: EU.fromJSON }, ChangeEmitDirection: { type: "ChangeEmitDirection", constructor: MU, params: [["angle", "value"]], loadJSON: MU.fromJSON }, EmitSubParticleSystem: { type: "EmitSubParticleSystem", constructor: TU, params: [["particleSystem", "self"], ["useVelocityAsBasis", "boolean"], ["subParticleSystem", "particleSystem"]], loadJSON: TU.fromJSON } }; function sse(i, e) { return ise[i.type].loadJSON(i, e) } var kU = function () { function i() { var e, t, s, r, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; Gt(this, i), ne(this, "type", "cone"), ne(this, "radius", void 0), ne(this, "arc", void 0), ne(this, "thickness", void 0), ne(this, "angle", void 0), this.radius = (e = n.radius) !== null && e !== void 0 ? e : 10, this.arc = (t = n.arc) !== null && t !== void 0 ? t : 2 * Math.PI, this.thickness = (s = n.thickness) !== null && s !== void 0 ? s : 1, this.angle = (r = n.angle) !== null && r !== void 0 ? r : Math.PI / 6 } return Ht(i, [{ key: "initialize", value: function (e) { var t = Math.random(), s = kr.lerp(1 - this.thickness, 1, Math.random()), r = t * this.arc, n = Math.sqrt(s), o = Math.sin(r), a = Math.cos(r); e.position.x = n * a, e.position.y = n * o, e.position.z = 0; var l = this.angle * n; e.velocity.set(0, 0, Math.cos(l)).addScaledVector(e.position, Math.sin(l)).multiplyScalar(e.startSpeed), e.position.multiplyScalar(this.radius) } }, { key: "toJSON", value: function () { return { type: "cone", radius: this.radius, arc: this.arc, thickness: this.thickness, angle: this.angle } } }, { key: "clone", value: function () { return new i({ radius: this.radius, arc: this.arc, thickness: this.thickness, angle: this.angle }) } }], [{ key: "fromJSON", value: function (e) { return new i(e) } }]), i }(), DU = function () { function i() { var e, t, s, r, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; Gt(this, i), ne(this, "type", "donut"), ne(this, "radius", void 0), ne(this, "arc", void 0), ne(this, "thickness", void 0), ne(this, "angle", void 0), this.radius = (e = n.radius) !== null && e !== void 0 ? e : 10, this.arc = (t = n.arc) !== null && t !== void 0 ? t : 2 * Math.PI, this.thickness = (s = n.thickness) !== null && s !== void 0 ? s : 1, this.angle = (r = n.angle) !== null && r !== void 0 ? r : Math.PI / 6 } return Ht(i, [{ key: "initialize", value: function (e) { var t = Math.random(), s = kr.lerp(this.thickness, 1, Math.random()), r = t * this.arc, n = Math.sqrt(s), o = Math.sin(r), a = Math.cos(r); e.position.x = n * a, e.position.y = n * o, e.position.z = 0; var l = this.angle * n; e.velocity.set(0, 0, Math.cos(l)).addScaledVector(e.position, Math.sin(l)).multiplyScalar(e.startSpeed), e.position.multiplyScalar(this.radius) } }, { key: "toJSON", value: function () { return { type: "donut", radius: this.radius, arc: this.arc, thickness: this.thickness, angle: this.angle } } }, { key: "clone", value: function () { return new i({ radius: this.radius, arc: this.arc, thickness: this.thickness, angle: this.angle }) } }], [{ key: "fromJSON", value: function (e) { return new i(e) } }]), i }(), OU = function () { function i() { Gt(this, i), ne(this, "type", "point") } return Ht(i, [{ key: "initialize", value: function (e) { var t = Math.random(), s = Math.random(), r = t * Math.PI * 2, n = Math.acos(2 * s - 1), o = Math.cbrt(Math.random()), a = Math.sin(r), l = Math.cos(r), c = Math.sin(n), h = Math.cos(n); e.velocity.x = o * c * l, e.velocity.y = o * c * a, e.velocity.z = o * h, e.velocity.multiplyScalar(e.startSpeed), e.position.setScalar(0) } }, { key: "toJSON", value: function () { return { type: "point" } } }, { key: "clone", value: function () { return new i } }], [{ key: "fromJSON", value: function (e) { return new i } }]), i }(), TM = function () { function i() { var e, t, s, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; Gt(this, i), ne(this, "type", "sphere"), ne(this, "radius", void 0), ne(this, "arc", void 0), ne(this, "thickness", void 0), this.radius = (e = r.radius) !== null && e !== void 0 ? e : 10, this.arc = (t = r.arc) !== null && t !== void 0 ? t : 2 * Math.PI, this.thickness = (s = r.thickness) !== null && s !== void 0 ? s : 1 } return Ht(i, [{ key: "initialize", value: function (e) { var t = Math.random(), s = Math.random(), r = kr.lerp(1 - this.thickness, 1, Math.random()), n = t * this.arc, o = Math.acos(2 * s - 1), a = Math.cbrt(r), l = Math.sin(n), c = Math.cos(n), h = Math.sin(o), d = Math.cos(o); e.position.x = a * h * c, e.position.y = a * h * l, e.position.z = a * d, e.velocity.setScalar(0).addScaledVector(e.position, e.startSpeed), e.position.multiplyScalar(this.radius) } }, { key: "toJSON", value: function () { return { type: "sphere", radius: this.radius, arc: this.arc, thickness: this.thickness } } }, { key: "clone", value: function () { return new i({ radius: this.radius, arc: this.arc, thickness: this.thickness }) } }], [{ key: "fromJSON", value: function (e) { return new i(e) } }]), i }(), LU = function () { function i(e) { Gt(this, i), ne(this, "type", "mesh_surface"), ne(this, "_triangleIndexToArea", []), ne(this, "_mesh", void 0), ne(this, "_tempA", new S), ne(this, "_tempB", new S), ne(this, "_tempC", new S), e && (this.mesh = e) } return Ht(i, [{ key: "mesh", get: function () { return this._mesh }, set: function (e) { this._mesh = e; var t = new vn; this._triangleIndexToArea.length = 0; var s = 0, r = e.geometry; if (r.getIndex()) { var n = r.getIndex().array, o = n.length / 3; this._triangleIndexToArea.push(0); for (var a = 0; a < o; a++)t.setFromAttributeAndIndices(r.getAttribute("position"), n[a * 3], n[a * 3 + 1], n[a * 3 + 2]), s += t.getArea(), this._triangleIndexToArea.push(s); e.userData.triangleIndexToArea = this._triangleIndexToArea } } }, { key: "initialize", value: function (e) { if (!this._mesh) { e.position.set(0, 0, 0), e.velocity.set(0, 0, 1).multiplyScalar(e.startSpeed); return } for (var t = this._triangleIndexToArea.length - 1, s = 0, r = t, n = Math.random() * this._triangleIndexToArea[t]; s + 1 < r;) { var o = Math.floor((s + r) / 2); n < this._triangleIndexToArea[o] ? r = o : s = o } var a = Math.random(), l = Math.random(); a + l > 1 && (a = 1 - a, l = 1 - l); var c = this._mesh.geometry, h = c.getIndex().array[s * 3], d = c.getIndex().array[s * 3 + 1], p = c.getIndex().array[s * 3 + 2], f = c.getAttribute("position"); this._tempA.fromBufferAttribute(f, h), this._tempB.fromBufferAttribute(f, d), this._tempC.fromBufferAttribute(f, p), this._tempB.sub(this._tempA), this._tempC.sub(this._tempA), this._tempA.addScaledVector(this._tempB, a).addScaledVector(this._tempC, l), e.position.copy(this._tempA), this._tempA.copy(this._tempB).cross(this._tempC).normalize(), e.velocity.copy(this._tempA).normalize().multiplyScalar(e.startSpeed) } }, { key: "toJSON", value: function () { return { type: "mesh_surface", mesh: this._mesh ? this._mesh.uuid : "" } } }, { key: "clone", value: function () { return new i(this._mesh) } }], [{ key: "fromJSON", value: function (e) { return new i } }]), i }(), rse = { cone: { type: "cone", params: [["radius", "number"], ["arc", "radian"], ["thickness", "number"], ["angle", "radian"]], constructor: kU, loadJSON: kU.fromJSON }, donut: { type: "donut", params: [["radius", "number"], ["arc", "radian"], ["thickness", "number"], ["angle", "radian"]], constructor: DU, loadJSON: DU.fromJSON }, point: { type: "point", params: [], constructor: OU, loadJSON: OU.fromJSON }, sphere: { type: "sphere", params: [["radius", "number"], ["arc", "radian"], ["thickness", "number"], ["angle", "radian"]], constructor: TM, loadJSON: TM.fromJSON }, mesh_surface: { type: "mesh_surface", params: [["mesh", "mesh"]], constructor: LU, loadJSON: LU.fromJSON } }; function nse(i) { return rse[i.type].loadJSON(i) } var At; (function (i) { i[i.BillBoard = 0] = "BillBoard", i[i.StretchedBillBoard = 1] = "StretchedBillBoard", i[i.LocalSpace = 2] = "LocalSpace", i[i.Trail = 3] = "Trail" })(At || (At = {})); var FU = function (i) { kp(t, i); var e = Dp(t); function t(s) { var r; return Gt(this, t), r = e.call(this), ne(Jt(r), "type", "ParticleSystemBatch"), ne(Jt(r), "systems", void 0), ne(Jt(r), "material", void 0), ne(Jt(r), "settings", void 0), ne(Jt(r), "maxParticles", void 0), r.maxParticles = 1e3, r.systems = new Set, r.settings = { blending: s.blending, instancingGeometry: s.instancingGeometry, renderMode: s.renderMode, renderOrder: s.renderOrder, texture: s.texture, uTileCount: s.uTileCount, vTileCount: s.vTileCount, transparent: s.transparent }, r.frustumCulled = !1, r.renderOrder = r.settings.renderOrder, r } return Ht(t, [{ key: "addSystem", value: function (s) { this.systems.add(s) } }, { key: "removeSystem", value: function (s) { this.systems.delete(s) } }]), t }(ye), ose = new S(0, 0, 1), UU = new we, ase = new ks(1, 1, 1, 1), lse = function () { function i(e, t) { var s, r, n, o, a, l, c, h, d, p, f, g, m, v, A, b, y, _, w, E, P, C; Gt(this, i), ne(this, "autoDestroy", void 0), ne(this, "looping", void 0), ne(this, "duration", void 0), ne(this, "startLife", void 0), ne(this, "startSpeed", void 0), ne(this, "startRotation", void 0), ne(this, "startSize", void 0), ne(this, "startColor", void 0), ne(this, "startTileIndex", void 0), ne(this, "rendererEmitterSettings", void 0), ne(this, "emissionOverTime", void 0), ne(this, "emissionOverDistance", void 0), ne(this, "emissionBursts", void 0), ne(this, "onlyUsedByOther", void 0), ne(this, "worldSpace", void 0), ne(this, "speedFactor", void 0), ne(this, "particleNum", void 0), ne(this, "paused", void 0), ne(this, "emissionState", void 0), ne(this, "emitEnded", void 0), ne(this, "markForDestroy", void 0), ne(this, "normalMatrix", new ds), ne(this, "behaviors", void 0), ne(this, "particles", void 0), ne(this, "emitterShape", void 0), ne(this, "emitter", void 0), ne(this, "rendererSettings", void 0), ne(this, "renderer", void 0), ne(this, "neededToUpdateRender", void 0), this.renderer = e, this.autoDestroy = t.autoDestroy === void 0 ? !1 : t.autoDestroy, this.duration = (s = t.duration) !== null && s !== void 0 ? s : 1, this.looping = t.looping === void 0 ? !0 : t.looping, this.startLife = (r = t.startLife) !== null && r !== void 0 ? r : new Pr(5), this.startSpeed = (n = t.startSpeed) !== null && n !== void 0 ? n : new Pr(0), this.startRotation = (o = t.startRotation) !== null && o !== void 0 ? o : new Pr(0), this.startSize = (a = t.startSize) !== null && a !== void 0 ? a : new Pr(1), this.startColor = (l = t.startColor) !== null && l !== void 0 ? l : new Zb(new st(1, 1, 1, 1)), this.emissionOverTime = (c = t.emissionOverTime) !== null && c !== void 0 ? c : new Pr(10), this.emissionOverDistance = (h = t.emissionOverDistance) !== null && h !== void 0 ? h : new Pr(0), this.emissionBursts = (d = t.emissionBursts) !== null && d !== void 0 ? d : [], this.onlyUsedByOther = (p = t.onlyUsedByOther) !== null && p !== void 0 ? p : !1, this.emitterShape = (f = t.shape) !== null && f !== void 0 ? f : new TM, this.behaviors = (g = t.behaviors) !== null && g !== void 0 ? g : new Array, this.worldSpace = (m = t.worldSpace) !== null && m !== void 0 ? m : !1, this.speedFactor = (v = t.speedFactor) !== null && v !== void 0 ? v : 0, this.rendererEmitterSettings = (A = t.rendererEmitterSettings) !== null && A !== void 0 ? A : {}, this.rendererSettings = { blending: (b = t.blending) !== null && b !== void 0 ? b : Ia, transparent: (y = t.transparent) !== null && y !== void 0 ? y : !0, instancingGeometry: (_ = t.instancingGeometry) !== null && _ !== void 0 ? _ : ase, renderMode: (w = t.renderMode) !== null && w !== void 0 ? w : At.BillBoard, renderOrder: (E = t.renderOrder) !== null && E !== void 0 ? E : 0, texture: t.texture, uTileCount: (P = t.uTileCount) !== null && P !== void 0 ? P : 1, vTileCount: (C = t.vTileCount) !== null && C !== void 0 ? C : 1 }, this.neededToUpdateRender = !0, this.particles = new Array, this.startTileIndex = t.startTileIndex || new Pr(0), this.emitter = new zie(this), this.paused = !1, this.particleNum = 0, this.emissionState = { burstIndex: 0, burstWaveIndex: 0, time: 0, waitEmiting: 0 }, this.emitEnded = !1, this.markForDestroy = !1, this.renderer.addSystem(this) } return Ht(i, [{ key: "texture", get: function () { return this.rendererSettings.texture }, set: function (e) { this.rendererSettings.texture = e, this.neededToUpdateRender = !0 } }, { key: "uTileCount", get: function () { return this.rendererSettings.uTileCount }, set: function (e) { this.rendererSettings.uTileCount = e, this.neededToUpdateRender = !0 } }, { key: "vTileCount", get: function () { return this.rendererSettings.vTileCount }, set: function (e) { this.rendererSettings.vTileCount = e, this.neededToUpdateRender = !0 } }, { key: "instancingGeometry", get: function () { return this.rendererSettings.instancingGeometry }, set: function (e) { this.restart(), this.particles.length = 0, this.rendererSettings.instancingGeometry = e, this.neededToUpdateRender = !0 } }, { key: "renderMode", get: function () { return this.rendererSettings.renderMode }, set: function (e) { if ((this.rendererSettings.renderMode != At.Trail && e === At.Trail || this.rendererSettings.renderMode == At.Trail && e !== At.Trail) && (this.restart(), this.particles.length = 0), this.rendererSettings.renderMode !== e) switch (e) { case At.Trail: this.rendererEmitterSettings = { startLength: new Pr(30), followLocalOrigin: !1 }; break; case At.LocalSpace: this.rendererEmitterSettings = { geometry: new ks(1, 1) }, this.startRotation = new gU(new S(0, 1, 0), new Pr(0)); break; case At.BillBoard: case At.StretchedBillBoard: this.rendererEmitterSettings = {}, this.rendererSettings.renderMode === At.LocalSpace && (this.startRotation = new Pr(0)); break }this.rendererSettings.renderMode = e, this.neededToUpdateRender = !0 } }, { key: "renderOrder", get: function () { return this.rendererSettings.renderOrder }, set: function (e) { this.rendererSettings.renderOrder = e, this.neededToUpdateRender = !0 } }, { key: "blending", get: function () { return this.rendererSettings.blending }, set: function (e) { this.rendererSettings.blending = e, this.neededToUpdateRender = !0 } }, { key: "pause", value: function () { this.paused = !0 } }, { key: "play", value: function () { this.paused = !1 } }, { key: "spawn", value: function (e, t, s) { UU.setFromRotationMatrix(s); for (var r = 0; r < e; r++) { for (this.particleNum++; this.particles.length < this.particleNum;)this.rendererSettings.renderMode === At.Trail ? this.particles.push(new Kb) : this.particles.push(new Fm); var n = this.particles[this.particleNum - 1]; if (this.startColor.genColor(n.startColor, t.time), n.color.copy(n.startColor), n.startSpeed = this.startSpeed.genValue(t.time / this.duration), n.life = this.startLife.genValue(t.time / this.duration), n.age = 0, n.startSize = this.startSize.genValue(t.time / this.duration), n.uvTile = Math.floor(this.startTileIndex.genValue()), n.size = n.startSize, this.rendererSettings.renderMode === At.LocalSpace || this.rendererSettings.renderMode === At.BillBoard || this.rendererSettings.renderMode === At.StretchedBillBoard) { var o = n; this.rendererSettings.renderMode === At.LocalSpace ? (o.rotation instanceof we || (o.rotation = new we), this.startRotation.type === "rotation" ? this.startRotation.genValue(o.rotation, t.time / this.duration) : o.rotation.setFromAxisAngle(ose, this.startRotation.genValue(t.time / this.duration))) : this.startRotation.type === "rotation" ? o.rotation = 0 : o.rotation = this.startRotation.genValue(t.time / this.duration) } else if (this.rendererSettings.renderMode === At.Trail) { var a = n; a.length = this.rendererEmitterSettings.startLength.genValue(t.time / this.duration), a.reset() } if (this.emitterShape.initialize(n), this.rendererSettings.renderMode === At.Trail && this.rendererEmitterSettings.followLocalOrigin) { var l = n; l.localPosition = new S().copy(l.position) } this.worldSpace ? (n.position.applyMatrix4(s), n.velocity.applyMatrix3(this.normalMatrix), n.rotation && n.rotation instanceof we && n.rotation.multiplyQuaternions(UU, n.rotation)) : this.onlyUsedByOther && (n.parentMatrix = s); for (var c = 0; c < this.behaviors.length; c++)this.behaviors[c].initialize(n) } } }, { key: "endEmit", value: function () { this.emitEnded = !0, this.autoDestroy && (this.markForDestroy = !0) } }, { key: "dispose", value: function () { this.renderer.deleteSystem(this), this.emitter.dispose(), this.emitter.parent && this.emitter.parent.remove(this.emitter) } }, { key: "restart", value: function () { this.paused = !1, this.particleNum = 0, this.emissionState.burstIndex = 0, this.emissionState.burstWaveIndex = 0, this.emissionState.time = 0, this.emissionState.waitEmiting = 0, this.emitEnded = !1, this.markForDestroy = !1 } }, { key: "update", value: function (e) { if (e > .1 && (e = .1), !this.paused) { if (this.emitEnded && this.particleNum === 0) { this.markForDestroy && this.emitter.parent && this.dispose(); return } this.neededToUpdateRender && (this.renderer.updateSystem(this), this.neededToUpdateRender = !1), this.onlyUsedByOther || this.emit(e, this.emissionState, this.emitter.matrixWorld); for (var t = 0; t < this.behaviors.length; t++) { for (var s = 0; s < this.particleNum; s++)this.behaviors[t].update(this.particles[s], e); this.behaviors[t].frameUpdate(e) } for (var r = 0; r < this.particleNum; r++)this.rendererEmitterSettings.followLocalOrigin && this.particles[r].localPosition ? (this.particles[r].position.copy(this.particles[r].localPosition), this.particles[r].parentMatrix ? this.particles[r].position.applyMatrix4(this.particles[r].parentMatrix) : this.particles[r].position.applyMatrix4(this.emitter.matrixWorld)) : this.particles[r].position.addScaledVector(this.particles[r].velocity, e), this.particles[r].age += e; if (this.rendererSettings.renderMode === At.Trail) for (var n = 0; n < this.particleNum; n++) { var o = this.particles[n]; o.recordCurrentState() } for (var a = 0; a < this.particleNum; a++) { var l = this.particles[a]; l.age >= l.life && (this.particles[a] = this.particles[this.particleNum - 1], this.particles[this.particleNum - 1] = l, this.particleNum--, a--) } } } }, { key: "emit", value: function (e, t, s) { if (t.time > this.duration && (this.looping ? (t.time -= this.duration, t.burstIndex = 0) : !this.emitEnded && !this.onlyUsedByOther && this.endEmit()), this.normalMatrix.getNormalMatrix(s), !this.emitEnded) { var r = Math.ceil(t.waitEmiting); this.spawn(r, t, s), t.waitEmiting -= r } for (; t.burstIndex < this.emissionBursts.length && this.emissionBursts[t.burstIndex].time <= t.time;) { if (Math.random() < this.emissionBursts[t.burstIndex].probability) { var n = this.emissionBursts[t.burstIndex].count; this.spawn(n, t, s) } t.burstIndex++ } this.emitEnded || (t.waitEmiting += e * this.emissionOverTime.genValue(t.time / this.duration)), t.time += e } }, { key: "toJSON", value: function (e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = e === void 0 || typeof e == "string"; if (s && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }), this.texture.toJSON(e), t.useUrlForImage && this.texture.source !== void 0) { var r = this.texture.source; e.images[r.uuid] = { uuid: r.uuid, url: this.texture.image.url } } var n; this.renderMode === At.Trail ? n = { startLength: this.rendererEmitterSettings.startLength.toJSON(), followLocalOrigin: this.rendererEmitterSettings.followLocalOrigin } : this.renderMode === At.LocalSpace ? n = {} : n = {}; var o = this.rendererSettings.instancingGeometry; return e.geometries && !e.geometries[o.uuid] && (e.geometries[o.uuid] = o.toJSON()), { autoDestroy: this.autoDestroy, looping: this.looping, duration: this.duration, shape: this.emitterShape.toJSON(), startLife: this.startLife.toJSON(), startSpeed: this.startSpeed.toJSON(), startRotation: this.startRotation.toJSON(), startSize: this.startSize.toJSON(), startColor: this.startColor.toJSON(), emissionOverTime: this.emissionOverTime.toJSON(), emissionOverDistance: this.emissionOverDistance.toJSON(), emissionBursts: this.emissionBursts, onlyUsedByOther: this.onlyUsedByOther, instancingGeometry: this.rendererSettings.instancingGeometry.uuid, renderOrder: this.renderOrder, renderMode: this.renderMode, rendererEmitterSettings: n, speedFactor: this.renderMode === At.StretchedBillBoard ? this.speedFactor : 0, texture: this.texture.uuid, startTileIndex: this.startTileIndex.toJSON(), uTileCount: this.uTileCount, vTileCount: this.vTileCount, blending: this.blending, behaviors: this.behaviors.map(function (a) { return a.toJSON() }), worldSpace: this.worldSpace } } }, { key: "addBehavior", value: function (e) { this.behaviors.push(e) } }, { key: "getRendererSettings", value: function () { return this.rendererSettings } }, { key: "clone", value: function () { var e = [], t = dU(this.emissionBursts), s; try { for (t.s(); !(s = t.n()).done;) { var r = s.value, n = {}; Object.assign(n, r), e.push(n) } } catch (d) { t.e(d) } finally { t.f() } var o = [], a = dU(this.behaviors), l; try { for (a.s(); !(l = a.n()).done;) { var c = l.value; o.push(c.clone()) } } catch (d) { a.e(d) } finally { a.f() } var h; return this.renderMode === At.Trail ? h = { startLength: this.rendererEmitterSettings.startLength.clone(), followLocalOrigin: this.rendererEmitterSettings.followLocalOrigin } : h = {}, new i(this.renderer, { autoDestroy: this.autoDestroy, looping: this.looping, duration: this.duration, shape: this.emitterShape.clone(), startLife: this.startLife.clone(), startSpeed: this.startSpeed.clone(), startRotation: this.startRotation.clone(), startSize: this.startSize.clone(), startColor: this.startColor.clone(), emissionOverTime: this.emissionOverTime.clone(), emissionOverDistance: this.emissionOverDistance.clone(), emissionBursts: e, onlyUsedByOther: this.onlyUsedByOther, instancingGeometry: this.rendererSettings.instancingGeometry, renderMode: this.renderMode, rendererEmitterSettings: h, speedFactor: this.speedFactor, texture: this.texture, startTileIndex: this.startTileIndex, uTileCount: this.uTileCount, vTileCount: this.vTileCount, blending: this.blending, behaviors: o, worldSpace: this.worldSpace }) } }], [{ key: "fromJSON", value: function (e, t, s, r) { var n = nse(e.shape), o; e.renderMode === At.Trail ? o = { startLength: Ws(e.rendererEmitterSettings.startLength), followLocalOrigin: e.rendererEmitterSettings.followLocalOrigin } : e.renderMode === At.LocalSpace ? o = {} : o = {}; var a = new i(r, { autoDestroy: e.autoDestroy, looping: e.looping, duration: e.duration, shape: n, startLife: Ws(e.startLife), startSpeed: Ws(e.startSpeed), startRotation: Vie(e.startRotation), startSize: Ws(e.startSize), startColor: vU(e.startColor), emissionOverTime: Ws(e.emissionOverTime), emissionOverDistance: Ws(e.emissionOverDistance), emissionBursts: e.emissionBursts, onlyUsedByOther: e.onlyUsedByOther, instancingGeometry: t.geometries[e.instancingGeometry], renderMode: e.renderMode, rendererEmitterSettings: o, renderOrder: e.renderOrder, speedFactor: e.speedFactor, texture: t.textures[e.texture], startTileIndex: typeof e.startTileIndex == "number" ? new Pr(e.startTileIndex) : Ws(e.startTileIndex), uTileCount: e.uTileCount, vTileCount: e.vTileCount, blending: e.blending, behaviors: [], worldSpace: e.worldSpace }); return a.behaviors = e.behaviors.map(function (l) { var c = sse(l, a); return c.type === "EmitSubParticleSystem" && (s[l.subParticleSystem] = c), c }), a } }]), i }(), NU = `

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec4 vColor;

void main() {

    #include <clipping_planes_fragment>
    
    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vColor;
    
    #include <logdepthbuf_fragment>
    
    #ifdef USE_MAP
    vec4 texelColor = texture2D( map, vUv);
    diffuseColor *= texelColor;
    #endif

    outgoingLight = diffuseColor.rgb;

    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    
    #include <tonemapping_fragment>

}
`, cse = `

#include <uv_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

attribute vec3 offset;
attribute float rotation;
attribute float size;
attribute vec4 color;
attribute float uvTile;

varying vec4 vColor;

#ifdef UV_TILE
uniform vec2 tileCount;
#endif

void main() {

    #ifdef UV_TILE
        vUv = vec2((mod(uvTile, tileCount.x) + uv.x) * (1.0 / tileCount.x), ((tileCount.y - floor(uvTile / tileCount.x) - 1.0) + uv.y) * (1.0 / tileCount.y));
    #else
        #include <uv_vertex>
    #endif
	
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
	
    vec2 alignedPosition = ( position.xy ) * size;
    
    vec2 rotatedPosition;
    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
    
    mvPosition.xy += rotatedPosition;

	vColor = color;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

}
`, hse = `

#include <uv_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

attribute vec3 offset;
attribute vec4 rotation;
attribute float size;
attribute vec4 color;
attribute float uvTile;

varying vec4 vColor;

#ifdef UV_TILE
uniform vec2 tileCount;
#endif

void main() {

    #ifdef UV_TILE
        vUv = vec2((mod(uvTile, tileCount.x) + uv.x) * (1.0 / tileCount.x), ((tileCount.y - floor(uvTile / tileCount.x) - 1.0) + uv.y) * (1.0 / tileCount.y));
    #else
        #include <uv_vertex>
    #endif
    
    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;
    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;
    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;
    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;
    float sx = size, sy = size, sz = size;
    
    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column
                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column
                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column
                      offset.x, offset.y, offset.z, 1.0);
    
    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));

	vColor = color;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

}
`, use = `

#include <uv_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

attribute vec3 offset;
attribute float rotation;
attribute float size;
attribute vec4 color;
attribute vec3 velocity;
attribute float uvTile;

varying vec4 vColor;

#ifdef UV_TILE
uniform vec2 tileCount;
#endif

uniform float speedFactor;

void main() {

    #ifdef UV_TILE
        vUv = vec2((mod(uvTile, tileCount.x) + uv.x) * (1.0 / tileCount.x), ((tileCount.y - floor(uvTile / tileCount.x) - 1.0) + uv.y) * (1.0 / tileCount.y));
    #else
        #include <uv_vertex>
    #endif
	
    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );
    vec3 viewVelocity = normalMatrix * velocity;

    vec3 scaledPos = vec3(position.xy * size, position.z);
    mvPosition.xyz += scaledPos + dot(scaledPos, viewVelocity) * viewVelocity / length(viewVelocity) * speedFactor;

	vColor = color;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

}
`; new S(0, 0, 1); var dse = function (i) { kp(t, i); var e = Dp(t); function t(s) { var r; return Gt(this, t), r = e.call(this, s), ne(Jt(r), "geometry", void 0), ne(Jt(r), "offsetBuffer", void 0), ne(Jt(r), "rotationBuffer", void 0), ne(Jt(r), "sizeBuffer", void 0), ne(Jt(r), "colorBuffer", void 0), ne(Jt(r), "uvTileBuffer", void 0), ne(Jt(r), "velocityBuffer", void 0), ne(Jt(r), "vector_", new S), ne(Jt(r), "quaternion_", new we), ne(Jt(r), "quaternion2_", new we), ne(Jt(r), "quaternion3_", new we), ne(Jt(r), "rotationMat_", new ds), ne(Jt(r), "rotationMat2_", new ds), r.maxParticles = 1e3, r.setupBuffers(), r.rebuildMaterial(), r } return Ht(t, [{ key: "buildExpandableBuffers", value: function () { this.offsetBuffer = new tn(new Float32Array(this.maxParticles * 3), 3), this.offsetBuffer.setUsage(Ks), this.geometry.setAttribute("offset", this.offsetBuffer), this.colorBuffer = new tn(new Float32Array(this.maxParticles * 4), 4), this.colorBuffer.setUsage(Ks), this.geometry.setAttribute("color", this.colorBuffer), this.settings.renderMode === At.LocalSpace ? (this.rotationBuffer = new tn(new Float32Array(this.maxParticles * 4), 4), this.rotationBuffer.setUsage(Ks), this.geometry.setAttribute("rotation", this.rotationBuffer)) : (this.settings.renderMode === At.BillBoard || this.settings.renderMode === At.StretchedBillBoard) && (this.rotationBuffer = new tn(new Float32Array(this.maxParticles), 1), this.rotationBuffer.setUsage(Ks), this.geometry.setAttribute("rotation", this.rotationBuffer)), this.sizeBuffer = new tn(new Float32Array(this.maxParticles), 1), this.sizeBuffer.setUsage(Ks), this.geometry.setAttribute("size", this.sizeBuffer), this.uvTileBuffer = new tn(new Float32Array(this.maxParticles), 1), this.uvTileBuffer.setUsage(Ks), this.geometry.setAttribute("uvTile", this.uvTileBuffer), this.settings.renderMode === At.StretchedBillBoard && (this.velocityBuffer = new tn(new Float32Array(this.maxParticles * 3), 3), this.velocityBuffer.setUsage(Ks), this.geometry.setAttribute("velocity", this.velocityBuffer)) } }, { key: "setupBuffers", value: function () { this.geometry && this.geometry.dispose(), this.geometry = new Kw, this.geometry.setIndex(this.settings.instancingGeometry.getIndex()), this.geometry.setAttribute("position", this.settings.instancingGeometry.getAttribute("position")), this.geometry.setAttribute("uv", this.settings.instancingGeometry.getAttribute("uv")), this.buildExpandableBuffers() } }, { key: "expandBuffers", value: function (s) { for (; s >= this.maxParticles;)this.maxParticles *= 2; this.setupBuffers() } }, { key: "rebuildMaterial", value: function () { var s = {}, r = {}; r.USE_MAP = "", r.USE_UV = "", s.map = new Ce(this.settings.texture), s.uvTransform = new Ce(new ds().copy(this.settings.texture.matrix)); var n = this.settings.uTileCount, o = this.settings.vTileCount; if (r.UV_TILE = "", s.tileCount = new Ce(new W(n, o)), this.settings.renderMode === At.BillBoard || this.settings.renderMode === At.LocalSpace) { var a, l; this.settings.renderMode === At.LocalSpace ? (a = hse, l = yi) : (a = cse, l = pr), this.material = new Vt({ uniforms: s, defines: r, vertexShader: a, fragmentShader: NU, transparent: this.settings.transparent, depthWrite: !this.settings.transparent, blending: this.settings.blending || rh, side: l }) } else if (this.settings.renderMode === At.StretchedBillBoard) s.speedFactor = new Ce(1), this.material = new Vt({ uniforms: s, defines: r, vertexShader: use, fragmentShader: NU, transparent: this.settings.transparent, depthWrite: !this.settings.transparent, blending: this.settings.blending || rh }); else throw new Error("render mode unavailable") } }, { key: "update", value: function () { var s = this, r = 0, n = 0; this.systems.forEach(function (o) { n += o.particleNum }), n > this.maxParticles && this.expandBuffers(n), this.systems.forEach(function (o) { var a = o.particles, l = o.particleNum; s.quaternion2_.setFromRotationMatrix(o.emitter.matrixWorld), s.rotationMat_.setFromMatrix4(o.emitter.matrixWorld); for (var c = 0; c < l; c++, r++) { var h = a[c]; if (s.settings.renderMode === At.LocalSpace) { var d = void 0; if (o.worldSpace) d = h.rotation; else { var p = void 0; h.parentMatrix ? p = s.quaternion3_.setFromRotationMatrix(h.parentMatrix) : p = s.quaternion2_, d = s.quaternion_, d.copy(h.rotation).multiply(p) } s.rotationBuffer.setXYZW(r, d.x, d.y, d.z, d.w) } else (s.settings.renderMode === At.StretchedBillBoard || s.settings.renderMode === At.BillBoard) && s.rotationBuffer.setX(r, h.rotation); var f = void 0; if (o.worldSpace ? f = h.position : (f = s.vector_, h.parentMatrix ? f.copy(h.position).applyMatrix4(h.parentMatrix) : f.copy(h.position).applyMatrix4(o.emitter.matrixWorld)), s.offsetBuffer.setXYZ(r, f.x, f.y, f.z), s.colorBuffer.setXYZW(r, h.color.x, h.color.y, h.color.z, h.color.w), s.sizeBuffer.setX(r, h.size), s.uvTileBuffer.setX(r, h.uvTile), s.settings.renderMode === At.StretchedBillBoard) { var g = o.speedFactor, m = void 0; o.worldSpace ? m = h.velocity : (m = s.vector_, h.parentMatrix ? (s.rotationMat2_.setFromMatrix4(h.parentMatrix), m.copy(h.velocity).applyMatrix3(s.rotationMat2_)) : m.copy(h.velocity).applyMatrix3(s.rotationMat_)), s.velocityBuffer.setXYZ(r, m.x * g, m.y * g, m.z * g) } } }), this.geometry.instanceCount = r, r > 0 && (this.offsetBuffer.updateRange.count = r * 3, this.offsetBuffer.needsUpdate = !0, this.sizeBuffer.updateRange.count = r, this.sizeBuffer.needsUpdate = !0, this.colorBuffer.updateRange.count = r * 4, this.colorBuffer.needsUpdate = !0, this.uvTileBuffer.updateRange.count = r, this.uvTileBuffer.needsUpdate = !0, this.settings.renderMode === At.StretchedBillBoard && (this.velocityBuffer.updateRange.count = r * 3, this.velocityBuffer.needsUpdate = !0), this.settings.renderMode === At.LocalSpace ? (this.rotationBuffer.updateRange.count = r * 4, this.rotationBuffer.needsUpdate = !0) : (this.settings.renderMode === At.StretchedBillBoard || this.settings.renderMode === At.BillBoard) && (this.rotationBuffer.updateRange.count = r, this.rotationBuffer.needsUpdate = !0)) } }, { key: "dispose", value: function () { this.geometry.dispose() } }]), t }(FU), pse = `

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

uniform sampler2D alphaMap;
uniform float useAlphaMap;
uniform float visibility;
uniform float alphaTest;
uniform vec2 repeat;

varying vec4 vColor;
    
void main() {
    #include <clipping_planes_fragment>
    #include <logdepthbuf_fragment>

    vec4 c = vColor;
    
    #ifdef USE_MAP
    c *= texture2D( map, vUv * repeat );
    #endif
    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUv * repeat ).a;
    if( c.a < alphaTest ) discard;
    gl_FragColor = c;

    #include <fog_fragment>
    #include <tonemapping_fragment>
}`, fse = `

#include <uv_pars_vertex>
#include <clipping_planes_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <fog_pars_vertex>

attribute vec3 previous;
attribute vec3 next;
attribute vec4 color;
attribute float side;
attribute float width;

uniform vec2 resolution;
uniform float lineWidth;
uniform float sizeAttenuation;

varying vec2 vUV;
varying vec4 vColor;
    
vec2 fix(vec4 i, float aspect) {
    vec2 res = i.xy / i.w;
    res.x *= aspect;
    return res;
}
    
void main() {

    #include <uv_vertex>
    
    float aspect = resolution.x / resolution.y;

    vColor = color;

    mat4 m = projectionMatrix * modelViewMatrix;
    vec4 finalPosition = m * vec4( position, 1.0 );
    vec4 prevPos = m * vec4( previous, 1.0 );
    vec4 nextPos = m * vec4( next, 1.0 );

    vec2 currentP = fix( finalPosition, aspect );
    vec2 prevP = fix( prevPos, aspect );
    vec2 nextP = fix( nextPos, aspect );

    float w = lineWidth * width;

    vec2 dir;
    if( nextP == currentP ) dir = normalize( currentP - prevP );
    else if( prevP == currentP ) dir = normalize( nextP - currentP );
    else {
        vec2 dir1 = normalize( currentP - prevP );
        vec2 dir2 = normalize( nextP - currentP );
        dir = normalize( dir1 + dir2 );

        vec2 perp = vec2( -dir1.y, dir1.x );
        vec2 miter = vec2( -dir.y, dir.x );
        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );

    }

    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;
    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );
    normal.xy *= .5 * w;
    normal *= projectionMatrix;
    if( sizeAttenuation == 0. ) {
        normal.xy *= finalPosition.w;
        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;
    }

    finalPosition.xy += normal.xy * side;

    gl_Position = finalPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    
	#include <fog_vertex>
}`; new S(0, 0, 1); var gse = function (i) { kp(t, i); var e = Dp(t); function t(s) { var r; return Gt(this, t), r = e.call(this, s), ne(Jt(r), "geometry", void 0), ne(Jt(r), "positionBuffer", void 0), ne(Jt(r), "previousBuffer", void 0), ne(Jt(r), "nextBuffer", void 0), ne(Jt(r), "uvBuffer", void 0), ne(Jt(r), "sideBuffer", void 0), ne(Jt(r), "widthBuffer", void 0), ne(Jt(r), "colorBuffer", void 0), ne(Jt(r), "indexBuffer", void 0), ne(Jt(r), "vector_", new S), r.maxParticles = 1e4, r.setupBuffers(), r.rebuildMaterial(), r } return Ht(t, [{ key: "setupBuffers", value: function () { this.geometry && this.geometry.dispose(), this.geometry = new yt, this.indexBuffer = new nt(new Uint32Array(this.maxParticles * 6), 1), this.indexBuffer.setUsage(Ks), this.geometry.setIndex(this.indexBuffer), this.positionBuffer = new nt(new Float32Array(this.maxParticles * 6), 3), this.positionBuffer.setUsage(Ks), this.geometry.setAttribute("position", this.positionBuffer), this.previousBuffer = new nt(new Float32Array(this.maxParticles * 6), 3), this.previousBuffer.setUsage(Ks), this.geometry.setAttribute("previous", this.previousBuffer), this.nextBuffer = new nt(new Float32Array(this.maxParticles * 6), 3), this.nextBuffer.setUsage(Ks), this.geometry.setAttribute("next", this.nextBuffer), this.widthBuffer = new nt(new Float32Array(this.maxParticles * 2), 1), this.widthBuffer.setUsage(Ks), this.geometry.setAttribute("width", this.widthBuffer), this.sideBuffer = new nt(new Float32Array(this.maxParticles * 2), 1), this.sideBuffer.setUsage(Ks), this.geometry.setAttribute("side", this.sideBuffer), this.uvBuffer = new nt(new Float32Array(this.maxParticles * 4), 2), this.uvBuffer.setUsage(Ks), this.geometry.setAttribute("uv", this.uvBuffer), this.colorBuffer = new nt(new Float32Array(this.maxParticles * 8), 4), this.colorBuffer.setUsage(Ks), this.geometry.setAttribute("color", this.colorBuffer) } }, { key: "expandBuffers", value: function (s) { for (; s >= this.maxParticles;)this.maxParticles *= 2; this.setupBuffers() } }, { key: "rebuildMaterial", value: function () { var s = { lineWidth: { value: 1 }, map: { value: null }, useMap: { value: 0 }, alphaMap: { value: null }, useAlphaMap: { value: 0 }, resolution: { value: new W(1, 1) }, sizeAttenuation: { value: 1 }, visibility: { value: 1 }, alphaTest: { value: 0 }, repeat: { value: new W(1, 1) } }, r = {}; if (r.USE_MAP = "", r.USE_UV = "", s.map = new Ce(this.settings.texture), s.uvTransform = new Ce(new ds().copy(this.settings.texture.matrix)), this.settings.renderMode === At.Trail) this.material = new Vt({ uniforms: s, defines: r, vertexShader: fse, fragmentShader: pse, transparent: this.settings.transparent, depthWrite: !this.settings.transparent, side: yi, blending: this.settings.blending || rh }); else throw new Error("render mode unavailable") } }, { key: "update", value: function () { var s = this, r = 0, n = 0, o = 0; this.systems.forEach(function (a) { for (var l = 0; l < a.particleNum; l++)o += a.particles[l].previous.length * 2 }), o > this.maxParticles && this.expandBuffers(o), this.systems.forEach(function (a) { for (var l = a.particles, c = a.particleNum, h = s.settings.uTileCount, d = s.settings.vTileCount, p = 1 / h, f = 1 / d, g = 0; g < c; g++)for (var m = l[g], v = m.uvTile % d, A = Math.floor(m.uvTile / d), b = 0; b < m.previous.length; b++, r += 2) { var y = m.previous[b]; s.positionBuffer.setXYZ(r, y.position.x, y.position.y, y.position.z), s.positionBuffer.setXYZ(r + 1, y.position.x, y.position.y, y.position.z), a.worldSpace ? (s.positionBuffer.setXYZ(r, y.position.x, y.position.y, y.position.z), s.positionBuffer.setXYZ(r + 1, y.position.x, y.position.y, y.position.z)) : (m.parentMatrix ? s.vector_.copy(y.position).applyMatrix4(m.parentMatrix) : s.vector_.copy(y.position).applyMatrix4(a.emitter.matrixWorld), s.positionBuffer.setXYZ(r, s.vector_.x, s.vector_.y, s.vector_.z), s.positionBuffer.setXYZ(r + 1, s.vector_.x, s.vector_.y, s.vector_.z)); var _ = void 0; b - 1 >= 0 ? _ = m.previous[b - 1] : _ = m.previous[0], a.worldSpace ? (s.previousBuffer.setXYZ(r, _.position.x, _.position.y, _.position.z), s.previousBuffer.setXYZ(r + 1, _.position.x, _.position.y, _.position.z)) : (m.parentMatrix ? s.vector_.copy(_.position).applyMatrix4(m.parentMatrix) : s.vector_.copy(_.position).applyMatrix4(a.emitter.matrixWorld), s.previousBuffer.setXYZ(r, s.vector_.x, s.vector_.y, s.vector_.z), s.previousBuffer.setXYZ(r + 1, s.vector_.x, s.vector_.y, s.vector_.z)); var w = void 0; b + 1 < m.previous.length ? w = m.previous[b + 1] : w = m.previous[m.previous.length - 1], a.worldSpace ? (s.nextBuffer.setXYZ(r, w.position.x, w.position.y, w.position.z), s.nextBuffer.setXYZ(r + 1, w.position.x, w.position.y, w.position.z)) : (m.parentMatrix ? s.vector_.copy(w.position).applyMatrix4(m.parentMatrix) : s.vector_.copy(w.position).applyMatrix4(a.emitter.matrixWorld), s.nextBuffer.setXYZ(r, s.vector_.x, s.vector_.y, s.vector_.z), s.nextBuffer.setXYZ(r + 1, s.vector_.x, s.vector_.y, s.vector_.z)), s.sideBuffer.setX(r, -1), s.sideBuffer.setX(r + 1, 1), s.widthBuffer.setX(r, y.size), s.widthBuffer.setX(r + 1, y.size), s.uvBuffer.setXY(r, (b / m.previous.length + v) * p, (d - A - 1) * f), s.uvBuffer.setXY(r + 1, (b / m.previous.length + v) * p, (d - A) * f), s.colorBuffer.setXYZW(r, y.color.x, y.color.y, y.color.z, y.color.w), s.colorBuffer.setXYZW(r + 1, y.color.x, y.color.y, y.color.z, y.color.w), b + 1 < m.previous.length && (s.indexBuffer.setX(n * 3, r), s.indexBuffer.setX(n * 3 + 1, r + 1), s.indexBuffer.setX(n * 3 + 2, r + 2), n++, s.indexBuffer.setX(n * 3, r + 2), s.indexBuffer.setX(n * 3 + 1, r + 1), s.indexBuffer.setX(n * 3 + 2, r + 3), n++) } }), this.positionBuffer.updateRange.count = r * 3, this.positionBuffer.needsUpdate = !0, this.previousBuffer.updateRange.count = r * 3, this.previousBuffer.needsUpdate = !0, this.nextBuffer.updateRange.count = r * 3, this.nextBuffer.needsUpdate = !0, this.sideBuffer.updateRange.count = r, this.sideBuffer.needsUpdate = !0, this.widthBuffer.updateRange.count = r, this.widthBuffer.needsUpdate = !0, this.uvBuffer.updateRange.count = r * 2, this.uvBuffer.needsUpdate = !0, this.colorBuffer.updateRange.count = r * 4, this.colorBuffer.needsUpdate = !0, this.indexBuffer.updateRange.count = n * 3, this.indexBuffer.needsUpdate = !0, this.geometry.setDrawRange(0, n * 3) } }, { key: "dispose", value: function () { this.geometry.dispose() } }]), t }(FU), mse = function (i) { kp(t, i); var e = Dp(t); function t() { var s; return Gt(this, t), s = e.call(this), ne(Jt(s), "batches", []), ne(Jt(s), "systemToBatchIndex", new Map), ne(Jt(s), "type", "BatchedParticleRenderer"), s } return Ht(t, [{ key: "addSystem", value: function (s) { for (var r = s.getRendererSettings(), n = 0; n < this.batches.length; n++)if (t.equals(this.batches[n].settings, r)) { this.batches[n].addSystem(s), this.systemToBatchIndex.set(s, n); return } var o; switch (r.renderMode) { case At.Trail: o = new gse(r); break; case At.LocalSpace: case At.BillBoard: case At.StretchedBillBoard: o = new dse(r); break }o.addSystem(s), this.batches.push(o), this.systemToBatchIndex.set(s, this.batches.length - 1), this.add(o) } }, { key: "deleteSystem", value: function (s) { var r = this.systemToBatchIndex.get(s); r != null && (this.batches[r].removeSystem(s), this.systemToBatchIndex.delete(s)) } }, { key: "updateSystem", value: function (s) { this.deleteSystem(s), this.addSystem(s) } }, { key: "update", value: function (s) { this.systemToBatchIndex.forEach(function (n, o) { o.update(s) }); for (var r = 0; r < this.batches.length; r++)this.batches[r].update() } }], [{ key: "equals", value: function (s, r) { return s.texture === r.texture && s.blending === r.blending && s.renderMode === r.renderMode && s.uTileCount === r.uTileCount && s.vTileCount === r.vTileCount && s.instancingGeometry === r.instancingGeometry && s.transparent === r.transparent && s.renderOrder === r.renderOrder } }]), t }(Me), vse = Object.defineProperty, Ase = Object.getOwnPropertyDescriptor, hs = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Ase(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && vse(e, t, r), r }; const jm = oe("debugparticles"), yse = oe("noprogressive"), bse = oe("debugprogressive"); var RM = (i => (i[i.Birth = 0] = "Birth", i[i.Collision = 1] = "Collision", i[i.Death = 2] = "Death", i[i.Trigger = 3] = "Trigger", i[i.Manual = 4] = "Manual", i))(RM || {}); class xl extends Ee { constructor() { super(...arguments), u(this, "renderMode"), u(this, "particleMaterial"), u(this, "trailMaterial"), u(this, "particleMesh"), u(this, "maxParticleSize"), u(this, "minParticleSize") } start() { if (this.maxParticleSize !== .5 && this.minParticleSize !== 0 && Mn()) { const e = `ParticleSystem "${this.name}" has non-default min/max particle size. This may not render correctly. Please set min size to 0 and the max size to 0.5 and use the "StartSize" setting instead`; console.warn(e) } } get transparent() { var e; return ((e = this.particleMaterial) == null ? void 0 : e.transparent) ?? !1 } getMaterial(e = !1) { const t = e === !0 && this.trailMaterial ? this.trailMaterial : this.particleMaterial; return t && !yse && t._didRequestTextureLOD === void 0 && (t._didRequestTextureLOD = 0, bse && console.log("Load material LOD", t.name), il.assignTextureLOD(this.context, this.sourceId, t)), t } getMesh(e) { let t = null; if (e === ra.HorizontalBillboard ? t = new pi(1, 1, 0) : e === ra.VerticalBillboard && (t = new pi(1, 0, 1)), !t && (this.particleMesh instanceof ye && (t = this.particleMesh.geometry), t === null)) { t = new ks(1, 1); const s = t.attributes.uv; for (let r = 0; r < s.count; r++)s.setX(r, 1 - s.getX(r)) } return new ye(t, this.getMaterial()) } } hs([x()], xl.prototype, "renderMode", 2), hs([x(Tt)], xl.prototype, "particleMaterial", 2), hs([x(Tt)], xl.prototype, "trailMaterial", 2), hs([x()], xl.prototype, "maxParticleSize", 2), hs([x()], xl.prototype, "minParticleSize", 2); class $b { constructor(e) { u(this, "_curve"), u(this, "type", "function"), this._curve = e } genValue(e) { return this._curve.evaluate(e, Math.random()) } toJSON() { throw new Error("Method not implemented.") } clone() { throw new Error("Method not implemented.") } } class PM { constructor(e) { u(this, "type", "value"), u(this, "system"), this.system = e } toJSON() { throw new Error("Method not implemented.") } clone() { throw new Error("Method not implemented.") } } class _se extends PM { genValue() { return this.system.textureSheetAnimation.getStartIndex() } } class xse extends PM { constructor() { super(...arguments), u(this, "_lastPosition", new S), u(this, "_lastDistance", 0) } update() { const e = xt(this.system.gameObject); this._lastDistance = this._lastPosition.distanceTo(e), this._lastPosition.copy(e) } genValue() { if (!this.system.isPlaying || !this.system.emission.enabled || this.system.currentParticles >= this.system.maxParticles) return 0; let e = this.system.emission.rateOverTime.evaluate(this.system.time / this.system.duration, Math.random()); if (this.system.deltaTime > 0) { const r = this.system.emission.rateOverDistance.evaluate(this.system.time / this.system.duration, Math.random()); let n = this._lastDistance / this.system.deltaTime * r; Number.isFinite(n) || (n = 0), e += n } const t = this.system.emission.getBurst(); t > 0 && (e += t / this.system.deltaTime); const s = this.system.maxParticles - this.system.currentParticles; return Ke.clamp(e, 0, s / this.system.deltaTime) } } class wse extends PM { genValue() { return this.system.isPlaying, 0 } } class Op { constructor(e) { u(this, "system"), this.system = e } get scaleFactorDiff() { return this.system.worldScale.x - this.system.scale } initialize(e) { } update(e, t) { } frameUpdate(e) { } toJSON() { throw new Error("Method not implemented.") } clone() { throw new Error("Method not implemented.") } } class Cse extends Op { constructor() { super(...arguments), u(this, "type", "NeedleTextureSheet") } update(e, t) { const s = this.system.textureSheetAnimation; if (s.enabled) { const r = e.age / e.life, n = s.evaluate(r); n !== void 0 && (e.uvTile = n) } } } const zU = Symbol("particleRotation"); class Sse extends Op { constructor() { super(...arguments), u(this, "type", "NeedleRotation") } initialize(e) { e[zU] = Math.random() } update(e, t) { if (e.rotation === void 0) return; const s = e.age / e.life; if (typeof e.rotation == "number" && (this.system.rotationOverLifetime.enabled ? e.rotation += this.system.rotationOverLifetime.evaluate(s, e[zU]) * t : this.system.renderer.renderMode === ra.Billboard && (e.rotation = Math.PI), this.system.rotationBySpeed.enabled)) { const r = e.velocity.length(); e.rotation += this.system.rotationBySpeed.evaluate(s, r) * t } } } const jU = Symbol("sizeLerpFactor"); class Ese extends Op { constructor() { super(...arguments), u(this, "type", "NeedleSize"), u(this, "_minSize", 0), u(this, "_maxSize", 1) } initialize(e) { e[jU] = Math.random(), this._minSize = this.system.renderer.minParticleSize, this._maxSize = this.system.renderer.maxParticleSize } update(e, t) { if (this.system.renderer.renderMode !== ra.Mesh) { const s = e.age / e.life; let r = 1; this.system.sizeOverLifetime.enabled && (r *= this.system.sizeOverLifetime.evaluate(s, void 0, e[jU]).x); const n = this.system.worldScale.x / this.system.cameraScale; e.size = e.startSize * r * n } } } const Lp = Symbol("particleLife"), BM = Symbol("trailLifetime"), QU = Symbol("trailStartLength"); class Mse extends Op { constructor() { super(...arguments), u(this, "type", "NeedleTrail") } initialize(e) { e instanceof Kb && (e[Lp] = e.life, this.system.trails.enabled && this.system.trails.dieWithParticles === !1 && (e[BM] = this.system.trails.lifetime.evaluate(Math.random(), Math.random()), e.life += e[BM]), e[QU] = e.length) } update(e) { var t; if ((t = this.system.trails) != null && t.enabled && e instanceof Kb) { const s = e, r = e.age / e[Lp], n = e.previous.values(), o = e.previous.length; for (let a = 0; a < o; a++) { const l = n.next().value, c = 1 - a / (o - 1); l.size = this.system.trails.getWidth(e.size, r, c), l.color.copy(e.color), this.system.trails.getColor(l.color, r, c) } if (e.age > e[Lp]) { e.velocity.set(0, 0, 0); const a = (e.age - e[Lp]) / e[BM]; s.length = Ke.lerp(e[QU], 0, a) } } } } const e_ = Symbol("startVelocity"), GU = Symbol("gravityModifier"), kM = Symbol("gravitySpeed"), t_ = Symbol("velocity lerp factor"), DM = new S; class Ise extends Op { constructor() { super(...arguments), u(this, "type", "NeedleVelocity"), u(this, "_gravityDirection", new S) } initialize(e) { var t, s; const r = this.system.main.simulationSpeed, n = 1 + this.scaleFactorDiff * r; e.startSpeed = this.system.main.startSpeed.evaluate(Math.random(), Math.random()) * n, e.velocity.copy(this.system.shape.getDirection(e.position)).multiplyScalar(e.startSpeed), (t = this.system.inheritVelocity) != null && t.enabled && this.system.inheritVelocity.applyInitial(e.velocity), e[e_] ? e[e_].copy(e.velocity) : e[e_] = e.velocity.clone(); const o = this.system.main.gravityModifier.evaluate(Math.random(), Math.random()) / (9.81 * 2); e[GU] = o * r, e[kM] = 1, e[t_] = Math.random(), (s = this.system.velocityOverLifetime) == null || s.init(e), this._gravityDirection.set(0, -1, 0), this.system.main.simulationSpace === Ob.Local && this._gravityDirection.applyQuaternion(this.system.worldQuaternionInverted) } update(e, t) { var s; const r = e[e_]; let n = e[GU]; n !== 0 && (DM.copy(this._gravityDirection).multiplyScalar(n * e[kM]), e[kM] += t, jm && Wo.DrawDirection(e.position, DM, 255, 0, !1, 10), r.add(DM)), e.velocity.copy(r); const o = e.age / e.life; (s = this.system.inheritVelocity) != null && s.enabled && this.system.inheritVelocity.applyCurrent(e.velocity, o, e[t_]); const a = this.system.noise; a.enabled && a.apply(0, e.position, e.velocity, t, e.age, e.life); const l = this.system.sizeBySpeed; l != null && l.enabled && (e.size = l.evaluate(e.velocity, o, e[t_], e.size)); const c = this.system.colorBySpeed; c != null && c.enabled && c.evaluate(e.velocity, e[t_], e.color); const h = this.system.velocityOverLifetime; h.enabled && h.apply(e, 0, e.position, e.velocity, t, e.age, e.life); const d = this.system.limitVelocityOverLifetime; d.enabled && d.apply(e.position, r, e.velocity, e.size, o, t, 1), this.system.worldspace && e.velocity.multiply(this.system.worldScale) } } const HU = Symbol("colorLerpFactor"); class Tse extends Op { constructor() { super(...arguments), u(this, "type", "NeedleColor") } initialize(e) { } _init(e) { const t = this.system.main.startColor.evaluate(Math.random()); e.startColor.set(t.r, t.g, t.b, t.alpha), e.color.copy(e.startColor), e[HU] = Math.random() } update(e, t) { if (e.age === 0 && this._init(e), this.system.colorOverLifetime.enabled) { const s = e.age / e.life, r = this.system.colorOverLifetime.color.evaluate(s, e[HU]); e.color.set(r.r, r.g, r.b, r.alpha).multiply(e.startColor) } else e.color.copy(e.startColor) } } class Rse { constructor(e) { u(this, "system"), u(this, "emission"), u(this, "autoDestroy"), u(this, "startLength"), u(this, "emissionBursts"), u(this, "onlyUsedByOther"), u(this, "behaviors", []), u(this, "rendererEmitterSettings", { startLength: new Pr(220), followLocalOrigin: !1 }), this.system = e, this.emission = new xse(this.system) } get anim() { return this.system.textureSheetAnimation } update() { this.emission.update() } get looping() { return this.system.main.loop } get duration() { return this.system.duration } get shape() { return this.system.shape } get startLife() { return new $b(this.system.main.startLifetime) } get startSpeed() { return new $b(this.system.main.startSpeed) } get startRotation() { return new $b(this.system.main.startRotation) } get startSize() { return new $b(this.system.main.startSize) } get startColor() { return new Zb(new st(1, 1, 1, 1)) } get emissionOverTime() { return this.emission } get emissionOverDistance() { return new wse(this.system) } get instancingGeometry() { return this.system.renderer.getMesh(this.system.renderer.renderMode).geometry } get renderMode() { if (this.system.trails.enabled === !0) return At.Trail; switch (this.system.renderer.renderMode) { case ra.Billboard: return At.BillBoard; case ra.Stretch: return At.StretchedBillBoard; case ra.HorizontalBillboard: return At.LocalSpace; case ra.VerticalBillboard: return At.LocalSpace; case ra.Mesh: return At.LocalSpace }return At.BillBoard } get speedFactor() { return this.system.main.simulationSpeed } get texture() { const e = this.system.renderer.getMaterial(this.system.trails.enabled); if (e && e.map) { const t = e.map; return t.premultiplyAlpha = !1, t.encoding = Qi, t } return iD(new mi(1, 1, 1, 1), 1) } get startTileIndex() { return new _se(this.system) } get uTileCount() { var e; return this.anim.enabled ? (e = this.anim) == null ? void 0 : e.numTilesX : void 0 } get vTileCount() { var e; return this.anim.enabled ? (e = this.anim) == null ? void 0 : e.numTilesY : void 0 } get renderOrder() { return 1 } get blending() { var e; return ((e = this.system.renderer.particleMaterial) == null ? void 0 : e.blending) ?? Ia } get transparent() { return this.system.renderer.transparent } get worldSpace() { return this.system.main.simulationSpace === Ob.World } } class Pse { constructor() { u(this, "burstIndex", 0), u(this, "burstWaveIndex", 0), u(this, "time", 0), u(this, "waitEmiting", 0) } } const i_ = class extends Ee { constructor() { super(...arguments), u(this, "_state"), u(this, "colorOverLifetime"), u(this, "main"), u(this, "emission"), u(this, "sizeOverLifetime"), u(this, "shape"), u(this, "noise"), u(this, "trails"), u(this, "velocityOverLifetime"), u(this, "limitVelocityOverLifetime"), u(this, "inheritVelocity"), u(this, "colorBySpeed"), u(this, "textureSheetAnimation"), u(this, "rotationOverLifetime"), u(this, "rotationBySpeed"), u(this, "sizeBySpeed"), u(this, "_cameraScale", 1), u(this, "__worldQuaternion", new we), u(this, "_worldQuaternionInverted", new we), u(this, "_worldScale", new S), u(this, "_worldPositionFrame", -1), u(this, "_worldPos", new S), u(this, "_renderer"), u(this, "_batchSystem"), u(this, "_particleSystem"), u(this, "_interface"), u(this, "_container"), u(this, "_time", 0), u(this, "_isPlaying", !0), u(this, "_isUsedAsSubsystem", !1), u(this, "_didPreWarm", !1), u(this, "_bursts"), u(this, "_subEmitterSystems"), u(this, "lastMaterialVersion", -1) } play(i = !1) { var e; i && $.foreachComponent(this.gameObject, t => { t instanceof i_ && t !== this && t.play(!1) }, !0), this._isPlaying = !0, this._particleSystem && (this._particleSystem.emissionState.time = 0, this._particleSystem.emitEnded = !1), (e = this.emission) == null || e.reset() } pause(i = !0) { i && $.foreachComponent(this.gameObject, e => { e instanceof i_ && e !== this && e.pause(!1) }, !0), this._isPlaying = !1 } stop(i = !0, e = !1) { i && $.foreachComponent(this.gameObject, t => { t instanceof i_ && t !== this && t.stop(!1, e) }, !0), this._isPlaying = !1, this._time = 0, e && this.reset() } reset() { var i; this._time = 0, this._particleSystem && (this._particleSystem.particleNum = 0, this._particleSystem.emissionState.time = 0, this._particleSystem.emitEnded = !1, (i = this.emission) == null || i.reset()) } emit(i) { if (this._particleSystem) { this.onUpdate(), i = Math.min(i, this.maxParticles - this.currentParticles), this._state || (this._state = new Pse), this._state.waitEmiting = i, this._state.time = 0; const e = this._particleSystem.emitEnded; this._particleSystem.emitEnded = !1, this._particleSystem.emit(this.deltaTime, this._state, this._particleSystem.emitter.matrixWorld), this._particleSystem.emitEnded = e } } get renderer() { return this._renderer } get isPlaying() { return this._isPlaying } get currentParticles() { var i; return ((i = this._particleSystem) == null ? void 0 : i.particleNum) ?? 0 } get maxParticles() { return this.main.maxParticles } get time() { return this._time } get duration() { return this.main.duration } get deltaTime() { return this.context.time.deltaTime * this.main.simulationSpeed } get scale() { return this.gameObject.scale.x } get cameraScale() { return this._cameraScale } get container() { return this._container } get worldspace() { return this.main.simulationSpace === Ob.World } get worldQuaternion() { return this.__worldQuaternion } get worldQuaternionInverted() { return this._worldQuaternionInverted } get worldScale() { return this._worldScale } get worldPos() { return this._worldPositionFrame !== this.context.time.frame && (this._worldPositionFrame = this.context.time.frame, xt(this.gameObject, this._worldPos)), this._worldPos } get matrixWorld() { return this._container.matrixWorld } get isSubsystem() { return this._isUsedAsSubsystem } set bursts(i) { for (let e = 0; e < i.length; e++) { const t = i[e]; if (!(t instanceof Im)) { const s = new Im; Rh(s, t), i[e] = s } } this._bursts = i } set subEmitterSystems(i) { for (let e = 0; e < i.length; e++) { const t = i[e]; if (!(t instanceof Qm)) { const s = new Qm; Rh(s, t), i[e] = s } } jm && i.length > 0 && console.log("SubEmitters: ", i, this), this._subEmitterSystems = i } onAfterDeserialize(i) { if (this._subEmitterSystems && Array.isArray(this._subEmitterSystems)) for (const e of this._subEmitterSystems) e._deserialize(this.context, this.gameObject) } awake() { this._renderer = this.gameObject.getComponent(xl), this._container = new Me, this._container.matrixAutoUpdate = !1, this.context.scene.add(this._container), this._batchSystem = new mse, this._batchSystem.name = this.gameObject.name, this._container.add(this._batchSystem), this._interface = new Rse(this), this._particleSystem = new lse(this._batchSystem, this._interface), this._particleSystem.addBehavior(new Ese(this)), this._particleSystem.addBehavior(new Tse(this)), this._particleSystem.addBehavior(new Cse(this)), this._particleSystem.addBehavior(new Sse(this)), this._particleSystem.addBehavior(new Ise(this)), this._particleSystem.addBehavior(new Mse(this)); const i = this._particleSystem.emitter; this.context.scene.add(i), jm && (console.log(this), this.gameObject.add(new ud(1))) } start() { this.addSubParticleSystems() } onDestroy() { var i, e, t, s; (i = this._container) == null || i.removeFromParent(), (e = this._batchSystem) == null || e.removeFromParent(), (t = this._particleSystem) == null || t.emitter.removeFromParent(), (s = this._particleSystem) == null || s.dispose() } onEnable() { this.inheritVelocity && (this.inheritVelocity.system = this), this._batchSystem && (this._batchSystem.visible = !0), this.play() } onDisable() { this._batchSystem && (this._batchSystem.visible = !1) } onBeforeRender() { var i; this._didPreWarm === !1 && ((i = this.main) == null ? void 0 : i.prewarm) === !0 && (this._didPreWarm = !0, this.preWarm()), this.onUpdate(), this.onSimulate(this.deltaTime) } preWarm() { var i; if (!((i = this.emission) != null && i.enabled) || this.emission.rateOverTime.getMax() <= 0) return; const e = 1 / 60, t = this.main.duration, s = this.main.startLifetime.getMax(), r = Math.min(t, s, 1e3), n = Math.ceil(r / e), o = Date.now(); jm && console.log(`Particles ${this.name} - Prewarm for ${n} frames (${r} sec). Duration: ${t}, Lifetime: ${s}`); for (let a = 0; a < n && !(this.currentParticles >= this.maxParticles); a++) { const l = Date.now() - o; if (l > 2e3) { console.warn(`Particles ${this.name} - Prewarm took too long. Aborting: ${l}`); break } this.onUpdate(), this.onSimulate(e) } } onSimulate(i) { if (this._batchSystem) { if (this.context.time.frameCount % 60 === 0) for (let e = 0; e < this._batchSystem.batches.length; e++) { const t = this._batchSystem.batches[e]; t.layers.disableAll(), t.layers.set(2) } this._batchSystem.update(i) } this._time += i, this._time > this.duration && (this._time = 0) } onUpdate() { var i, e; const t = this.renderer.getMaterial(this.trails.enabled); if (t && t.version != this.lastMaterialVersion && this._particleSystem && (this.lastMaterialVersion = t.version, this._particleSystem.texture = this._interface.texture), this._bursts && (this.emission.bursts = this._bursts, delete this._bursts), !this._isPlaying) return; const s = this.context.mainCamera; if (s) { const o = Fs(s); this._cameraScale = o.x } const r = !this.worldspace, n = this.gameObject; if (_s(n, this.__worldQuaternion), this._worldQuaternionInverted.copy(this.__worldQuaternion).invert(), Fs(this.gameObject, this._worldScale), r && this._container && (i = this.gameObject) != null && i.parent) { const o = Fs(this.gameObject.parent); o.x = 1 / o.x, o.y = 1 / o.y, o.z = 1 / o.z, this._container.matrix.makeScale(o.x, o.y, o.z), this._container.matrix.makeRotationFromQuaternion(this.__worldQuaternion), this._container.matrix.setPosition(this.worldPos), this._container.matrix.scale(this.gameObject.scale) } this.emission.system = this, this._interface.update(), this.shape.update(this, this.context, this.main.simulationSpace, this.gameObject), this.noise.update(this.context), (e = this.inheritVelocity) == null || e.update(this.context), this.velocityOverLifetime.update(this) } addSubParticleSystems() { var i; if (this._subEmitterSystems && this._particleSystem) for (const e of this._subEmitterSystems) { e.particleSystem && e.particleSystem.__internalAwake(); const t = (i = e.particleSystem) == null ? void 0 : i._particleSystem; if (t) { e.particleSystem._isUsedAsSubsystem = !0; const s = new s_(this, this._particleSystem, e.particleSystem, t); s.emitterType = e.type, s.emitterProbability = e.emitProbability, this._particleSystem.addBehavior(s) } } } }; let us = i_; hs([x(Tm)], us.prototype, "colorOverLifetime", 2), hs([x(Hs)], us.prototype, "main", 2), hs([x(na)], us.prototype, "emission", 2), hs([x(zc)], us.prototype, "sizeOverLifetime", 2), hs([x(Ji)], us.prototype, "shape", 2), hs([x(hi)], us.prototype, "noise", 2), hs([x(Mi)], us.prototype, "trails", 2), hs([x(Di)], us.prototype, "velocityOverLifetime", 2), hs([x(ls)], us.prototype, "limitVelocityOverLifetime", 2), hs([x(jc)], us.prototype, "inheritVelocity", 2), hs([x(su)], us.prototype, "colorBySpeed", 2), hs([x(Vs)], us.prototype, "textureSheetAnimation", 2), hs([x(Gn)], us.prototype, "rotationOverLifetime", 2), hs([x(un)], us.prototype, "rotationBySpeed", 2), hs([x(Rr)], us.prototype, "sizeBySpeed", 2); class Qm { constructor() { u(this, "particleSystem"), u(this, "emitProbability", 1), u(this, "properties"), u(this, "type") } _deserialize(e, t) { const s = this.particleSystem; if (s instanceof us) return; let r = ""; s && typeof s.guid == "string" && (r = s.guid, this.particleSystem = $.findByGuid(r, t)), jm && !(this.particleSystem instanceof us) && console.warn("Could not find particle system for sub emitter", r, t, this) } } new S(1, 1, 1), new S(0, 0, 1); class s_ { constructor(e, t, s, r) { u(this, "type", "NeedleParticleSubEmitter"), u(this, "emitterType"), u(this, "emitterProbability"), u(this, "q_", new we), u(this, "v_", new S), u(this, "v2_", new S), u(this, "_emitterMatrix", new He), u(this, "_circularBuffer"), this.system = e, this.particleSystem = t, this.subSystem = s, this.subParticleSystem = r, this.subParticleSystem && this.subParticleSystem && (this.subParticleSystem.onlyUsedByOther = !0); const n = 1e3; this._circularBuffer = new To(() => new He, n) } clone() { throw new Error("Method not implemented.") } initialize(e) { e.emissionState = { burstIndex: 0, burstWaveIndex: 0, time: 0, waitEmiting: 0 }, this._emitterMatrix.copy(this.subSystem.matrixWorld).invert().premultiply(this.system.matrixWorld), this.emitterType === RM.Birth && this.run(e) } update(e, t) { this.run(e) } frameUpdate(e) { } toJSON() { } run(e) { if (this.subSystem.currentParticles >= this.subSystem.main.maxParticles || !this.subParticleSystem || !e.emissionState || this.emitterProbability && Math.random() > this.emitterProbability) return; const t = this.system.deltaTime; if (this.emitterType === RM.Death) { let r = e.life; if (e[Lp] !== void 0 && (r = e[Lp]), !(e.age + t * 1.2 >= r)) return; const n = this.subSystem.main.maxParticles - this.subSystem.currentParticles; e.emissionState.waitEmiting = n } const s = new He; s.set(1, 0, 0, e.position.x, 0, 1, 0, e.position.y, 0, 0, 1, e.position.z, 0, 0, 0, 1), this.particleSystem.worldSpace || s.multiplyMatrices(this._emitterMatrix, s), this.subParticleSystem.emit(t, e.emissionState, s) } } var Bse = Object.defineProperty, kse = Object.getOwnPropertyDescriptor, Dse = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? kse(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Bse(e, t, r), r }; class Gm extends Ir { constructor() { super(...arguments), u(this, "granularity") } get typeName() { return "PixelationEffect" } onCreateEffect() { const e = new X2; return this.granularity.onValueChanged = t => { e.granularity = t }, e } } Dse([x(Dt)], Gm.prototype, "granularity", 2), ta("PixelationEffect", Gm); function* VU(i, e = null) { const t = e ? e.time : _t.Current.time, s = t.time; for (; t.time - s < i;)yield } function* Ose(i) { for (let e = 0; e < i; e++)yield } class wu extends Ee { constructor() { super(...arguments), u(this, "_didAssignPlayerColor", !1) } awake() { this.context.connection.beginListen(Li.JoinedRoom, this.tryAssignColor.bind(this)) } onEnable() { this._didAssignPlayerColor || this.startCoroutine(this.waitForConnection()) } *waitForConnection() { for (; !this.destroyed && this.enabled && (yield VU(.2), !this.tryAssignColor());); } tryAssignColor() { const e = $.getComponentInParent(this.gameObject, lr); return e && e.connectionId ? (this._didAssignPlayerColor = !0, this.assignUserColor(e.connectionId), !0) : !1 } assignUserColor(e) { const t = wu.hashCode(e), s = wu.colorFromHashCode(t); if (this.gameObject.type === "Mesh") { const r = this.gameObject; this.assignColor(s, e, r) } else if (this.gameObject.children) for (const r of this.gameObject.children) { const n = r; n.material && n.material.color && this.assignColor(s, e, n) } } assignColor(e, t, s) { let r = s.material; r && (r._playerMaterial !== t && (r = r.clone(), r._playerMaterial = t, s.material = r), r.color = e) } static hashCode(e) { var t = 0, s, r; if (e.length === 0) return t; for (s = 0; s < e.length; s++)r = e.charCodeAt(s), t = (t << 5) - t + r, t |= 0; return t } static colorFromHashCode(e) { const t = (e & 16711680) >> 16, s = (e & 65280) >> 8, r = e & 255; return new xe(t / 255, s / 255, r / 255) } } const r_ = oe("debugpost"), OM = Symbol("postprocessing-handler"); class n_ { constructor(e) { u(this, "_composer", null), u(this, "_lastVolumeComponents"), u(this, "_effects", []), u(this, "_isActive", !1), u(this, "context"), this.context = e } get isActive() { return this._isActive } apply(e) { this._isActive = !0, this.onApply(this.context, e) } unapply() { if (this._isActive = !1, this._lastVolumeComponents) { for (const t of this._lastVolumeComponents) t.unapply(); this._lastVolumeComponents.length = 0 } const e = this.context; e[OM] === this && delete e[OM], e.composer === this._composer && (e.composer = null) } dispose() { this.unapply(); for (const e of this._effects) e.dispose(); this._effects.length = 0 } onApply(e, t) { if (t) { e[OM] = this, r_ && console.log("refreshing volume profile", t), this._lastVolumeComponents = [...t], this._effects.length = 0; for (const s of t) if (s.context = e, s.apply) { if (s.active) { if (!e.mainCameraComponent) { console.error("No camera in scene found or available yet - can not create postprocessing effects"); return } const r = s.apply(); if (!r) continue; Array.isArray(r) ? this._effects.push(...r) : this._effects.push(r) } } else s.active && ao("Volume component is not a VolumeComponent: " + s.__type); this.applyEffects(e) } } applyEffects(e) { const t = this._effects; if (t.length <= 0) return; const s = e.mainCameraComponent, r = e.renderer, n = e.scene, o = s.cam; this._composer || (this._composer = new rC(r, { frameBufferType: gs, stencilBuffer: !0, multisampling: Su() ? 0 : 8 })), e.composer = this._composer; const a = e.composer; a.setMainCamera(o), a.setRenderer(r), a.setMainScene(n); for (const c of a.passes) c.dispose(); a.removeAllPasses(); const l = new iy(n, o); l.mainScene = n, a.addPass(l); try { this.orderEffects(); const c = []; for (const h of t) if (h instanceof po) c.push(h); else if (h instanceof nr) { const d = new Q2(o, ...c); d.mainScene = n, d.name = c.map(p => p.constructor.name).join(", "), d.enabled = !0, c.length = 0, a.addPass(h) } if (c.length > 0) { const h = new Q2(o, ...c); h.mainScene = n, h.enabled = !0, a.addPass(h) } } catch (c) { console.error("Error while applying postprocessing effects", c), a.removeAllPasses(), a.addPass(l) } r_ && console.log("PostProcessing Passes", t, "->", a.passes) } orderEffects() { r_ && console.log("Before ordering effects", [...this._effects]), this._effects.sort((e, t) => { const s = LM.indexOf(e.constructor), r = LM.indexOf(t.constructor); return s < 0 && r < 0 ? -1 : s < 0 ? 1 : r < 0 ? -1 : s - r }), r_ && console.log("After ordering effects", [...this._effects]) } } const LM = [G2, tC, $2, W2, nC, Y2, eD, q2, V2, H2, X2]; class WU extends Vw {
  constructor(e) { super(e), this.type = gs } parse(e) {
    const t = function (d, p) { switch (d) { case 1: console.error("THREE.RGBELoader Read Error: " + (p || "")); break; case 2: console.error("THREE.RGBELoader Write Error: " + (p || "")); break; case 3: console.error("THREE.RGBELoader Bad File Format: " + (p || "")); break; default: case 4: console.error("THREE.RGBELoader: Error: " + (p || "")) }return -1 }, s = `
`, r = function (d, p, f) { p = p || 1024; let g = d.pos, m = -1, v = 0, A = "", b = String.fromCharCode.apply(null, new Uint16Array(d.subarray(g, g + 128))); for (; 0 > (m = b.indexOf(s)) && v < p && g < d.byteLength;)A += b, v += b.length, g += 128, b += String.fromCharCode.apply(null, new Uint16Array(d.subarray(g, g + 128))); return -1 < m ? (f !== !1 && (d.pos += v + m + 1), A + b.slice(0, m)) : !1 }, n = function (d) {
        const p = /^#\?(\S+)/, f = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, g = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, m = /^\s*FORMAT=(\S+)\s*$/, v = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, A = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 }; let b, y; if (d.pos >= d.byteLength || !(b = r(d))) return t(1, "no header found"); if (!(y = b.match(p))) return t(3, "bad initial token"); for (A.valid |= 1, A.programtype = y[1], A.string += b + `
`; b = r(d), b !== !1;) {
          if (A.string += b + `
`, b.charAt(0) === "#") {
            A.comments += b + `
`; continue
          } if ((y = b.match(f)) && (A.gamma = parseFloat(y[1])), (y = b.match(g)) && (A.exposure = parseFloat(y[1])), (y = b.match(m)) && (A.valid |= 2, A.format = y[1]), (y = b.match(v)) && (A.valid |= 4, A.height = parseInt(y[1], 10), A.width = parseInt(y[2], 10)), A.valid & 2 && A.valid & 4) break
        } return A.valid & 2 ? A.valid & 4 ? A : t(3, "missing image size specifier") : t(3, "missing format specifier")
      }, o = function (d, p, f) { const g = p; if (g < 8 || g > 32767 || d[0] !== 2 || d[1] !== 2 || d[2] & 128) return new Uint8Array(d); if (g !== (d[2] << 8 | d[3])) return t(3, "wrong scanline width"); const m = new Uint8Array(4 * p * f); if (!m.length) return t(4, "unable to allocate buffer space"); let v = 0, A = 0; const b = 4 * g, y = new Uint8Array(4), _ = new Uint8Array(b); let w = f; for (; w > 0 && A < d.byteLength;) { if (A + 4 > d.byteLength) return t(1); if (y[0] = d[A++], y[1] = d[A++], y[2] = d[A++], y[3] = d[A++], y[0] != 2 || y[1] != 2 || (y[2] << 8 | y[3]) != g) return t(3, "bad rgbe scanline format"); let E = 0, P; for (; E < b && A < d.byteLength;) { P = d[A++]; const R = P > 128; if (R && (P -= 128), P === 0 || E + P > b) return t(3, "bad scanline data"); if (R) { const T = d[A++]; for (let z = 0; z < P; z++)_[E++] = T } else _.set(d.subarray(A, A + P), E), E += P, A += P } const C = g; for (let R = 0; R < C; R++) { let T = 0; m[v] = _[R + T], T += g, m[v + 1] = _[R + T], T += g, m[v + 2] = _[R + T], T += g, m[v + 3] = _[R + T], v += 4 } w-- } return m }, a = function (d, p, f, g) { const m = d[p + 3], v = Math.pow(2, m - 128) / 255; f[g + 0] = d[p + 0] * v, f[g + 1] = d[p + 1] * v, f[g + 2] = d[p + 2] * v, f[g + 3] = 1 }, l = function (d, p, f, g) { const m = d[p + 3], v = Math.pow(2, m - 128) / 255; f[g + 0] = Th.toHalfFloat(Math.min(d[p + 0] * v, 65504)), f[g + 1] = Th.toHalfFloat(Math.min(d[p + 1] * v, 65504)), f[g + 2] = Th.toHalfFloat(Math.min(d[p + 2] * v, 65504)), f[g + 3] = Th.toHalfFloat(1) }, c = new Uint8Array(e); c.pos = 0; const h = n(c); if (h !== -1) { const d = h.width, p = h.height, f = o(c.subarray(c.pos), d, p); if (f !== -1) { let g, m, v; switch (this.type) { case $i: v = f.length / 4; const A = new Float32Array(v * 4); for (let y = 0; y < v; y++)a(f, y * 4, A, y * 4); g = A, m = $i; break; case gs: v = f.length / 4; const b = new Uint16Array(v * 4); for (let y = 0; y < v; y++)l(f, y * 4, b, y * 4); g = b, m = gs; break; default: console.error("THREE.RGBELoader: unsupported type: ", this.type); break }return { width: d, height: p, data: g, header: h.string, gamma: h.gamma, exposure: h.exposure, type: m } } } return null
  } setDataType(e) { return this.type = e, this } load(e, t, s, r) { function n(o, a) { switch (o.type) { case $i: case gs: o.encoding = Qi, o.minFilter = Qt, o.magFilter = Qt, o.generateMipmaps = !1, o.flipY = !0; break }t && t(o, a) } return super.load(e, n, s, r) }
} const qU = oe("debugautosync"), FM = Symbol("syncerId"); class Lse { constructor() { u(this, "_syncers", {}) } getOrCreateSyncer(e) { if (!e.guid) return null; if (this._syncers[e.guid]) return this._syncers[e.guid]; const t = new Fse(e); return t[FM] = e.guid, this._syncers[t[FM]] = t, t } removeSyncer(e) { delete this._syncers[e[FM]] } } const UM = new Lse; class Fse { constructor(e) { u(this, "comp"), u(this, "hasChanges", !1), u(this, "changedProperties", {}), u(this, "data", {}), u(this, "_boundEvent"), u(this, "_handleReceivingMethod"), u(this, "_isReceiving", !1), u(this, "_isInit", !1), this.comp = e } get networkingKey() { return this.comp.constructor.name } init(e) { if (this._isInit) return; this._isInit = !0, this.comp = e, this._boundEvent = this.onHandleSending.bind(this), this.comp.context.post_render_callbacks.push(this._boundEvent), this._handleReceivingMethod = this.onHandleReceiving.bind(this), this.comp.context.connection.beginListen(this.networkingKey, this._handleReceivingMethod); const t = this.comp.context.connection.tryGetState(this.comp.guid); t && this.onHandleReceiving(t) } destroy() { this._isInit && (this._boundEvent && this.comp.context.post_render_callbacks.splice(this.comp.context.post_render_callbacks.indexOf(this._boundEvent), 1), this._handleReceivingMethod && this.comp.context.connection.stopListen(this.networkingKey, this._handleReceivingMethod), this.comp = null, this._isInit = !1) } notifyChanged(e, t) { this._isReceiving || (this.hasChanges = !0, this.changedProperties[e] = t) } onHandleSending() { if (!this.hasChanges) return; this.hasChanges = !1; const e = this.comp.context.connection; if (!e || !e.isConnected) { for (const t in this.changedProperties) delete this.changedProperties[t]; return } for (const t in this.data) delete this.data[t]; this.data.guid = this.comp.guid; for (const t in this.changedProperties) { const s = this.changedProperties[t]; delete this.changedProperties[t], this.data[t] = s } e.send(this.networkingKey, this.data) } onHandleReceiving(e) { if (!this._isInit || !this.comp) return; const t = e.guid; if (!(t && t !== this.comp.guid)) { qU && console.log("RECEIVED", this.comp.name, this.comp.guid, e); try { this._isReceiving = !0; for (const s in e) { if (s === "guid") continue; const r = e[s]; this.comp[s] = r } } catch (s) { console.error(s) } finally { this._isReceiving = !1 } } } } function Use(i, e) { let t = e !== i; if (!t && i && e) { if (Array.isArray(i) && Array.isArray(e)) t = !0; else if (typeof i == "object" && typeof e == "object") { for (const s of Object.keys(i)) if (i[s] !== e[s]) { t = !0; break } } } return t } const Hm = Symbol("AutoSyncHandler"); function Nse(i) { if (i[Hm]) return i[Hm]; const e = UM.getOrCreateSyncer(i); return e?.init(i), i[Hm] = e, e } function zse(i) { const e = i[Hm]; e && (UM.removeSyncer(e), e.destroy(), delete i[Hm]) } const NM = function (i) { return function (e, t) { let s = null, r; typeof i == "string" ? r = e[i] : typeof i == "function" && (r = i); const n = e, o = n.__internalAwake; qU && console.log(t); const a = Symbol(t); n.__internalAwake = function () { if (this[a] !== void 0) return; this[a] = this[t], o.call(this), s = UM.getOrCreateSyncer(this); const c = Object.getOwnPropertyDescriptor(this, t); c?.set === void 0 && Object.defineProperty(this, t, { set: function (h) { var d; const p = this[a]; this[a] = h, Use(h, p) && r?.call(this, h, p) !== !1 && ((d = Nse(this)) == null || d.notifyChanged(t, h)) }, get: function () { return this[a] }, configurable: !0, enumerable: !0 }), s?.init(this) }; const l = n.__internalDestroy; n.__internalDestroy = function () { zse(this), l.call(this) } } }; var jse = Object.defineProperty, Qse = Object.getOwnPropertyDescriptor, o_ = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Qse(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && jse(e, t, r), r }; const Vm = oe("debugskybox"); class pu extends Ee { constructor() { super(...arguments), u(this, "url"), u(this, "allowDrop", !0), u(this, "background", !0), u(this, "environment", !0), u(this, "_loader"), u(this, "_prevUrl"), u(this, "_prevLoadedEnvironment"), u(this, "_prevEnvironment", null), u(this, "_prevBackground", null), u(this, "dragOverEvent"), u(this, "dropEvent") } onEnable() { this.setSkybox(this.url), this.registerDropEvents() } onDisable() { var e; this.context.scene.environment === this._prevLoadedEnvironment && (this.context.scene.environment = this._prevEnvironment, Si.backgroundShouldBeTransparent(this.context) || (this.context.scene.background = this._prevBackground), this._prevLoadedEnvironment = void 0), this.unregisterDropEvents(), (e = this.context.mainCameraComponent) == null || e.applyClearFlags() } async setSkybox(e) { var t; if (!e) return; if (!(e != null && e.endsWith(".hdr")) && !e.endsWith(".exr") && !e.endsWith(".jpg") && !e.endsWith(".png") && !e.endsWith(".jpeg") && console.warn("Potentially invalid skybox url", this.url, "on", this.name), Vm && console.log("Remote skybox url?: " + e), this._prevUrl === e && this._prevLoadedEnvironment) { this.applySkybox(); return } else (t = this._prevLoadedEnvironment) == null || t.dispose(), this._prevLoadedEnvironment = void 0; this._prevUrl = e; const s = e.endsWith(".exr"), r = e.endsWith(".hdr"); s ? this._loader instanceof aS || (this._loader = new aS) : r ? this._loader instanceof WU || (this._loader = new WU) : this._loader instanceof Yl || (this._loader = new Yl), Vm && console.log("Loading skybox: " + e); const n = await this._loader.loadAsync(e); if (!n || !this.enabled) return; this.url = e; const o = e.lastIndexOf("/"); n.name = e.substring(o >= 0 ? o + 1 : 0), this._loader instanceof Yl && (n.encoding = Xe), this._prevLoadedEnvironment = n, this.applySkybox() } applySkybox() { var e; const t = this._prevLoadedEnvironment; t && (t.mapping = Tu, t.needsUpdate = !0, this.context.scene.background !== t && (this._prevBackground = this.context.scene.background), this.context.scene.environment !== t && (this._prevEnvironment = this.context.scene.environment), Vm && console.log("Set remote skybox", this.url), this.environment && (this.context.scene.environment = t), this.background && !Si.backgroundShouldBeTransparent(this.context) && (this.context.scene.background = t), ((e = this.context.mainCameraComponent) == null ? void 0 : e.backgroundBlurriness) !== void 0 && (this.context.scene.backgroundBlurriness = this.context.mainCameraComponent.backgroundBlurriness)) } registerDropEvents() { this.dragOverEvent || (this.dragOverEvent = e => { if (this.allowDrop && e.dataTransfer) for (const t of e.dataTransfer.types) t === "text/uri-list" && e.preventDefault() }, this.dropEvent = e => { var t, s, r, n; if (this.allowDrop && (e.preventDefault(), !!e.dataTransfer)) { for (const o of e.dataTransfer.types) if (o === "text/uri-list") { const a = e.dataTransfer.getData(o); Vm && console.log(o, a); let l = (s = (t = new RegExp(/polyhaven.com\/asset_img\/.+?\/(?<name>.+)\.png/).exec(a)) == null ? void 0 : t.groups) == null ? void 0 : s.name; if (l || (l = (n = (r = new RegExp(/polyhaven\.com\/a\/(?<name>.+)/).exec(a)) == null ? void 0 : r.groups) == null ? void 0 : n.name), Vm && console.log(l), l) { const c = "https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/1k/" + l + "_1k.exr"; this.setSkybox(c) } else console.warn("Could not resolve skybox name from dropped url", a) } } }, this.context.domElement.addEventListener("dragover", this.dragOverEvent), this.context.domElement.addEventListener("drop", this.dropEvent)) } unregisterDropEvents() { this.dragOverEvent && (this.context.domElement.removeEventListener("dragover", this.dragOverEvent), this.context.domElement.removeEventListener("drop", this.dropEvent)) } } o_([NM("setSkybox"), x(URL)], pu.prototype, "url", 2), o_([x()], pu.prototype, "allowDrop", 2), o_([x()], pu.prototype, "background", 2), o_([x()], pu.prototype, "environment", 2); var Gse = Object.defineProperty, Hse = Object.getOwnPropertyDescriptor, ca = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Hse(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Gse(e, t, r), r }; const Hc = oe("debugsceneswitcher"), Wm = "scene"; Zi.registerCallback(Jr.ContextRegistered, async i => { Promise.resolve().then(() => Dne).then(e => { const t = e.NeedleEngineHTMLElement; Hc && console.log("SceneSwitcher: registering scene attribute", t.observedAttributes), t.observedAttributes.includes(Wm) || t.observedAttributes.push(Wm) }) }); const Vc = Promise.resolve(!1); class pn extends Ee { constructor() { super(...arguments), u(this, "scenes"), u(this, "queryParameterName", "scene"), u(this, "clamp", !0), u(this, "useHistory", !0), u(this, "useKeyboard", !0), u(this, "useSwipe", !0), u(this, "useSceneLighting", !0), u(this, "preloadNext", 1), u(this, "preloadPrevious", 1), u(this, "preloadConcurrent", 2), u(this, "_currentIndex", -1), u(this, "_currentScene"), u(this, "_engineElementOverserver"), u(this, "_preloadScheduler"), u(this, "onPopState", async e => { if (!this.useHistory) return; let t = this.useHistory; try { this.useHistory = !1; let s = !1; if (this.queryParameterName && (s = await this.tryLoadFromQueryParam()), !s) { const r = e.state; if (r !== null && r.startsWith(this.guid)) { const n = r.substr(this.guid.length + 2); console.log(n), await this.trySelectSceneFromValue(n) } } } finally { this.useHistory = t } }), u(this, "normalizedSwipeThresholdX", .1), u(this, "_didSwipe", !1), u(this, "onPointerMove", e => { if (!this._didSwipe && e.button === 0 && e.pointerType === "touch" && this.context.input.getPointerPressedCount() === 1) { const t = this.context.input.getPointerPositionDelta(e.button); if (t) { const s = t.x / this.context.domWidth; s >= this.normalizedSwipeThresholdX ? (this._didSwipe = !0, this.selectPrev()) : s <= -this.normalizedSwipeThresholdX && (this._didSwipe = !0, this.selectNext()) } } }), u(this, "onPointerUp", e => { e.button === 0 && (this._didSwipe = !1) }), u(this, "onKeyDown", e => { if (!this.useKeyboard || !this.scenes) return; const t = e.key.toLowerCase(); if (!t) return; const s = parseInt(t) - 1; if (s >= 0) { this.trySelectSceneFromValue(s); return } switch (t) { case "arrowright": case "d": this.selectNext(); break; case "arrowleft": case "a": this.selectPrev(); break } }) } get currentIndex() { return this._currentIndex } async start() { if (this._currentIndex === -1 && !await this.tryLoadFromQueryParam()) { const e = this.context.domElement.getAttribute(Wm); try { (e === null || !await this.trySelectSceneFromValue(e)) && this._currentIndex === -1 && this.select(0) } finally { } } } onEnable() { globalThis.addEventListener("popstate", this.onPopState), this.context.input.addEventListener(Lo.KeyDown, this.onKeyDown), this.context.input.addEventListener(Lo.PointerMove, this.onPointerMove), this.context.input.addEventListener(Lo.PointerUp, this.onPointerUp), this._engineElementOverserver || (this._engineElementOverserver = new MutationObserver(e => { for (const t of e) if (t.type === "attributes" && t.attributeName === Wm) { const s = this.context.domElement.getAttribute(Wm); s !== null && this.trySelectSceneFromValue(s) } })), this._engineElementOverserver.observe(this.context.domElement, { attributes: !0 }), this._preloadScheduler || (this._preloadScheduler = new Vse(this)), this._preloadScheduler.maxLoadAhead = this.preloadNext, this._preloadScheduler.maxLoadBehind = this.preloadPrevious, this._preloadScheduler.maxConcurrent = this.preloadConcurrent, this._preloadScheduler.begin() } onDisable() { var e; globalThis.removeEventListener("popstate", this.onPopState), this.context.input.removeEventListener(Lo.KeyDown, this.onKeyDown), this.context.input.removeEventListener(Lo.PointerMove, this.onPointerMove), this.context.input.removeEventListener(Lo.PointerUp, this.onPointerUp), (e = this._preloadScheduler) == null || e.stop() } selectNext() { return this.select(this._currentIndex + 1) } selectPrev() { return this.select(this._currentIndex - 1) } select(e) { var t, s; if (Hc && console.log("select", e), typeof e == "object" && console.warn('Switching to "' + e + '" might not work. Please either use an index or a AssetReference (not a scene reference)'), typeof e == "string") { const n = (t = this.scenes) == null ? void 0 : t.find(o => o.uri === e); if (!n) { const o = or.getOrCreate(this.sourceId ?? "", e, this.context); return this.switchScene(o) } if (n) e = this.scenes.indexOf(n); else return Vc } if (!((s = this.scenes) != null && s.length)) return Vc; if (e < 0) { if (this.clamp) return Vc; e = this.scenes.length - 1 } else if (e >= this.scenes.length) { if (this.clamp) return Vc; e = 0 } const r = this.scenes[e]; return this.switchScene(r) } async switchScene(e) { var t, s; if (e === this._currentScene) return !0; this._currentScene && this._currentScene.unload(); const r = this._currentIndex = ((t = this.scenes) == null ? void 0 : t.indexOf(e)) ?? -1; this._currentScene = e; try { const n = new CustomEvent("loadscene-start", { detail: { scene: e, switcher: this, index: r } }); this.dispatchEvent(n), await e.loadAssetAsync(); const o = new CustomEvent("loadscene-finished", { detail: { scene: e, switcher: this, index: r } }); if (this.dispatchEvent(o), o.defaultPrevented) return Hc && console.warn("Adding loaded scene prevented:", e, o), !1; if (!e.asset) return Hc && console.warn("Failed loading scene:", e), !1; if (this._currentIndex === r) { if ($.add(e.asset, this.gameObject), this.useSceneLighting && this.context.sceneLighting.enable(e), this.useHistory && r >= 0) if ((s = this.queryParameterName) != null && s.length) BI(this.queryParameterName, r.toString(), this.useHistory); else { const a = history.state, l = this.guid + "::" + r; a !== l && history.pushState(l, "unused", location.href) } return !0 } } catch (n) { console.error(n) } return !1 } preload(e) { if (e >= 0 && e < this.scenes.length) { const t = this.scenes[e]; if (t instanceof or) return t.preload() } return Vc } tryLoadFromQueryParam() { var e; if (!((e = this.queryParameterName) != null && e.length)) return Vc; const t = oe(this.queryParameterName); return typeof t == "boolean" ? Vc : this.trySelectSceneFromValue(t) } trySelectSceneFromValue(e) { if (typeof e == "string") { const t = parseInt(e); if (t >= 0 && t < this.scenes.length) return this.select(t); for (let s = 0; s < this.scenes.length; s++)if (this.scenes[s].uri.toLowerCase().includes(e)) return this.select(s) } else if (typeof e == "number" && e >= 0 && e < this.scenes.length) return this.select(e); return dr() && console.warn('Can not find scene: "' + e + '"', this), Vc } } ca([x(or)], pn.prototype, "scenes", 2), ca([x()], pn.prototype, "queryParameterName", 2), ca([x()], pn.prototype, "clamp", 2), ca([x()], pn.prototype, "useHistory", 2), ca([x()], pn.prototype, "useKeyboard", 2), ca([x()], pn.prototype, "useSwipe", 2), ca([x()], pn.prototype, "useSceneLighting", 2), ca([x()], pn.prototype, "preloadNext", 2), ca([x()], pn.prototype, "preloadPrevious", 2), ca([x()], pn.prototype, "preloadConcurrent", 2); class Vse { constructor(e, t = 1, s = 1, r = 2) { u(this, "maxLoadAhead"), u(this, "maxLoadBehind"), u(this, "maxConcurrent"), u(this, "_isRunning", !1), u(this, "_rooms"), u(this, "_roomTasks", []), u(this, "_maxConcurrentLoads", 1), this._rooms = e, this.maxLoadAhead = t, this.maxLoadBehind = s, this.maxConcurrent = r } begin() { if (this._isRunning) return; Hc && console.log("Preload begin"), this._isRunning = !0; let e = -1, t, s; const r = this._rooms.scenes; let n = setInterval(() => { if (this.allLoaded() && (Hc && console.log("All scenes loaded"), this.stop()), !this._isRunning) { clearInterval(n); return } if (this.canLoadNewScene() === !1) return; e !== this._rooms.currentIndex && (e = this._rooms.currentIndex, s = 0, t = 0); const o = s % 2 === 0; o && (t += 1), s += 1; const a = o ? this.maxLoadAhead : this.maxLoadBehind; if (t > a) return; let l = o ? e + t : e - t; if (l < 0 || l < 0 || l >= r.length) return; const c = r[l]; new Wse(l, c, this._roomTasks) }, 200) } stop() { this._isRunning = !1 } canLoadNewScene() { return this._roomTasks.length < this._maxConcurrentLoads } allLoaded() { for (const e of this._rooms.scenes) if (e.isLoaded() === !1) return !1; return !0 } } class Wse { constructor(e, t, s) { u(this, "index"), u(this, "asset"), u(this, "tasks"), this.index = e, this.asset = t, this.tasks = s, s.push(this), this.awaitLoading() } async awaitLoading() { this.asset.isLoaded() || (Hc && console.log("Preload start: " + this.asset.uri, this.index), await this.asset.preload(), Hc && console.log("Preload finished: " + this.asset.uri, this.index)); const e = this.tasks.indexOf(this); e >= 0 && this.tasks.splice(e, 1) } } function qse() { return new Promise((i, e) => { let t = () => { t != null && (document.removeEventListener("pointerdown", t), document.removeEventListener("click", t), document.removeEventListener("dragstart", t), document.removeEventListener("touchstart", t), i()) }; document.addEventListener("pointerdown", t), document.addEventListener("click", t), document.addEventListener("dragstart", t), document.addEventListener("touchstart", t) }) } async function Xse(i) { await qse(), i() } var XU = (i => (i[i.Quad = 0] = "Quad", i))(XU || {}); class Yse { static createPrimitive(e, t) { let s; switch (e) { case 0: const r = new ks(1, 1, 1, 1), n = t?.material ?? new di({ color: 16777215 }); s = new ye(r, n) }return t != null && t.name && (s.name = t.name), s } } var Jse = Object.defineProperty, Kse = Object.getOwnPropertyDescriptor, Wn = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Kse(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Jse(e, t, r), r }; const ha = oe("debugvideo"); var YU = (i => (i[i.CameraFarPlane = 0] = "CameraFarPlane", i[i.CameraNearPlane = 1] = "CameraNearPlane", i[i.RenderTexture = 2] = "RenderTexture", i[i.MaterialOverride = 3] = "MaterialOverride", i))(YU || {}); class Xs extends Ee { constructor() { super(), u(this, "renderer", null), u(this, "playOnAwake", !0), u(this, "aspectMode", 0), u(this, "clip", null), u(this, "renderMode"), u(this, "targetMaterialProperty"), u(this, "targetMaterialRenderer"), u(this, "targetTexture"), u(this, "time", 0), u(this, "_playbackSpeed", 1), u(this, "_isLooping", !1), u(this, "_muted", !1), u(this, "_audioOutputMode", 2), u(this, "playInBackground", !0), u(this, "_crossOrigin", "anonymous"), u(this, "source"), u(this, "url", null), u(this, "_videoElement", null), u(this, "_videoTexture", null), u(this, "_videoMaterial", null), u(this, "_isPlaying", !1), u(this, "wasPlaying", !1), u(this, "visibilityChanged", e => { switch (document.visibilityState) { case "hidden": this.playInBackground || (this.wasPlaying = this._isPlaying, this.pause()); break; case "visible": this.wasPlaying && !this._isPlaying && this.play(); break } }), u(this, "_receivedInput", !1), u(this, "_overlay", null), u(this, "_targetObjects"), u(this, "_updateAspectRoutineId", -1), Xse(() => { this._receivedInput = !0, this.updateVideoElementSettings() }), this._targetObjects = [], oe("videoscreenspace") && window.addEventListener("keydown", e => { e.key === "f" && (this.screenspace = !this.screenspace) }) } get playbackSpeed() { var e; return ((e = this._videoElement) == null ? void 0 : e.playbackRate) ?? this._playbackSpeed } set playbackSpeed(e) { this._playbackSpeed = e, this._videoElement && (this._videoElement.playbackRate = e) } get isLooping() { var e; return ((e = this._videoElement) == null ? void 0 : e.loop) ?? this._isLooping } set isLooping(e) { this._isLooping = e, this._videoElement && (this._videoElement.loop = e) } get currentTime() { var e; return ((e = this._videoElement) == null ? void 0 : e.currentTime) ?? this.time } set currentTime(e) { this._videoElement ? this._videoElement.currentTime = e : this.time = e } get isPlaying() { const e = this._videoElement; return !!(e && (e.currentTime > 0 && !e.paused && !e.ended && e.readyState > e.HAVE_CURRENT_DATA || e.srcObject && e.srcObject.active)) } get crossOrigin() { var e; return ((e = this._videoElement) == null ? void 0 : e.crossOrigin) ?? this._crossOrigin } set crossOrigin(e) { this._crossOrigin = e, this._videoElement && (e !== null ? this._videoElement.setAttribute("crossorigin", e) : this._videoElement.removeAttribute("crossorigin")) } get videoMaterial() { return this._videoMaterial } get videoTexture() { return this._videoTexture } get videoElement() { return this._videoElement } get muted() { var e; return ((e = this._videoElement) == null ? void 0 : e.muted) ?? this._muted } set muted(e) { this._muted = e, this._videoElement && (this._videoElement.muted = e) } set audioOutputMode(e) { e !== this._audioOutputMode && (e === 1 && Mn() && console.warn("VideoAudioOutputMode.AudioSource is not yet implemented"), this._audioOutputMode = e, this.updateVideoElementSettings()) } get audioOutputMode() { return this._audioOutputMode } setVideo(e) { this.clip = e, this.source = 0, this._videoElement ? (this._videoElement.srcObject = e, this._isPlaying && this.play(), this.updateAspect()) : this.create(!0) } setClipURL(e) { this.url !== e && (this.url = e, this.source = 1, ha && console.log("set url", e), this._videoElement ? (this._videoElement.src = e, this._isPlaying && (this.stop(), this.play())) : this.create(!0)) } onEnable() { var e, t; window.addEventListener("visibilitychange", this.visibilityChanged), this.playOnAwake === !0 && this.create(!0), this.screenspace ? (e = this._overlay) == null || e.start() : (t = this._overlay) == null || t.stop() } onDisable() { window.removeEventListener("visibilitychange", this.visibilityChanged), this.pause() } onDestroy() { var e; this._videoElement && ((e = this._videoElement.parentElement) == null || e.removeChild(this._videoElement), this._videoElement = null), this._videoTexture && (this._videoTexture.dispose(), this._videoTexture = null) } play() { var e, t; this._videoElement || this.create(!1), this._videoElement && (this._isPlaying && !((e = this._videoElement) != null && e.ended) && !((t = this._videoElement) != null && t.paused) || (this._isPlaying = !0, this._receivedInput || (this._videoElement.muted = !0), this.updateVideoElementSettings(), this._videoElement.currentTime = this.time, this._videoElement.play().catch(s => { var r; console.log(s), ha && console.error("Error playing video", s, "CODE=" + s.code, (r = this.videoElement) == null ? void 0 : r.src, this), setTimeout(() => { this._isPlaying && !this.destroyed && this.activeAndEnabled && this.play() }, 1e3) }), ha && console.log("play", this._videoElement, this.time))) } stop() { this._isPlaying = !1, this.time = 0, this._videoElement && (this._videoElement.currentTime = 0, this._videoElement.pause(), ha && console.log("STOP", this)) } pause() { var e, t; this.time = ((e = this._videoElement) == null ? void 0 : e.currentTime) ?? 0, this._isPlaying = !1, (t = this._videoElement) == null || t.pause(), ha && console.log("PAUSE", this, this.currentTime) } create(e) { var t; let s; switch (this.source) { case 0: s = this.clip; break; case 1: s = this.url; break }s && (this._videoElement || (ha && console.warn("Create VideoElement", this), this._videoElement = this.createVideoElement(), (t = this.context.domElement) == null || t.prepend(this._videoElement), this.updateVideoElementStyles()), typeof s == "string" ? (ha && console.log("Set Video src", s), this._videoElement.src = s) : (ha && console.log("Set Video srcObject", s), this._videoElement.srcObject = s), this._videoTexture || (this._videoTexture = new JR(this._videoElement)), this._videoTexture.flipY = !1, this._videoTexture.encoding = Xe, this.handleBeginPlaying(e), ha && console.log(this, e)) } updateAspect() { this.aspectMode !== 0 && this.startCoroutine(this.updateAspectImpl()) } get screenspace() { var e; return ((e = this._overlay) == null ? void 0 : e.enabled) ?? !1 } set screenspace(e) { var t; if (e) { if (!this._videoTexture) return; this._overlay || (this._overlay = new Zse(this.context)), this._overlay.add(this._videoTexture) } else (t = this._overlay) == null || t.remove(this._videoTexture); this._overlay && (this._overlay.enabled = e) } createVideoElement() { const e = document.createElement("video"); return this._crossOrigin && e.setAttribute("crossorigin", this._crossOrigin), ha && console.log("created video element", e), e } handleBeginPlaying(e) { var t, s; if (!this.enabled || !this._videoElement) return; this._targetObjects.length = 0; let r = this.gameObject; switch (this.renderMode) { case 3: r = (t = this.targetMaterialRenderer) == null ? void 0 : t.gameObject, r || (r = (s = $.getComponent(this.gameObject, Ui)) == null ? void 0 : s.gameObject); break; case 2: console.error("VideoPlayer renderTexture not implemented yet. Please use material override instead"); return }if (!r) { console.error("Missing target for video material renderer", this.name, YU[this.renderMode], this); return } const n = r.material; if (n) if (this._targetObjects.push(r), n !== this._videoMaterial && (this._videoMaterial = n.clone(), r.material = this._videoMaterial), !this.targetMaterialProperty) this._videoMaterial.map = this._videoTexture; else switch (this.targetMaterialProperty) { default: this._videoMaterial.map = this._videoTexture; break } else { console.warn("Can not play video, no material found, this might be a multimaterial case which is not supported yet"); return } this.updateVideoElementSettings(), this.updateVideoElementStyles(), e && this.play() } updateVideoElementSettings() { if (!this._videoElement) return; this._videoElement.loop = this._isLooping, this._videoElement.currentTime = this.currentTime, this._videoElement.playbackRate = this._playbackSpeed, this._videoElement.playsInline = !0; let e = !this._receivedInput || this.audioOutputMode === 0; !e && this._muted && (e = !0), this._videoElement.muted = e, this.playOnAwake && (this._videoElement.autoplay = !0) } updateVideoElementStyles() { this._videoElement && (this._videoElement.style.userSelect = "none", this._videoElement.style.visibility = "hidden", this._videoElement.style.display = "none", this.updateAspect()) } *updateAspectImpl() { const e = ++this._updateAspectRoutineId, t = void 0, s = this.clip; for (; e === this._updateAspectRoutineId && this.aspectMode !== 0 && this.clip && s === this.clip && this._isPlaying;) { if (!s || typeof s == "string") return; let r; for (const n of s.getVideoTracks()) { const o = n.getSettings(); if (o && o.width && o.height) { r = o.width / o.height; break } else r = this.context.renderer.domElement.clientWidth / this.context.renderer.domElement.clientHeight } if (r === void 0) { for (let n = 0; n < 10; n++)yield; if (!this.isPlaying) break; continue } if (t === r) { yield; continue } for (const n of this._targetObjects) { let o = 1; if (n.parent) { const a = Fs(n.parent); o = a.x / a.y } switch (this.aspectMode) { case 1: n.scale.y = 1 / r * n.scale.x * o; break; case 2: n.scale.x = r * n.scale.y * o; break } } for (let n = 0; n < 3; n++)yield } } } Wn([x(Me)], Xs.prototype, "renderer", 2), Wn([x()], Xs.prototype, "playOnAwake", 2), Wn([x()], Xs.prototype, "aspectMode", 2), Wn([x(URL)], Xs.prototype, "clip", 2), Wn([x()], Xs.prototype, "renderMode", 2), Wn([x()], Xs.prototype, "targetMaterialProperty", 2), Wn([x(Ui)], Xs.prototype, "targetMaterialRenderer", 2), Wn([x(Nt)], Xs.prototype, "targetTexture", 2), Wn([x()], Xs.prototype, "time", 2), Wn([x()], Xs.prototype, "playbackSpeed", 1), Wn([x()], Xs.prototype, "isLooping", 1), Wn([x()], Xs.prototype, "audioOutputMode", 1); class Zse { constructor(e) { u(this, "context"), u(this, "_videos", []), u(this, "_screenspaceModeQuad"), u(this, "_isInScreenspaceMode", !1), u(this, "_input"), this.context = e, this._input = new $se(this) } get enabled() { return this._isInScreenspaceMode } set enabled(e) { e ? this.start() : this.stop() } add(e) { this._videos.indexOf(e) === -1 && this._videos.push(e) } remove(e) { if (!e) return; const t = this._videos.indexOf(e); t >= 0 && this._videos.splice(t, 1) } start() { var e; if (this._isInScreenspaceMode || this._videos.length < 0) return; const t = this._videos[this._videos.length - 1]; if (!t) return; if (this._isInScreenspaceMode = !0, !this._screenspaceModeQuad) { if (this._screenspaceModeQuad = Yse.createPrimitive(XU.Quad, { material: new ere(t) }), !this._screenspaceModeQuad) return; this._screenspaceModeQuad.geometry.scale(2, 2, 2) } const s = this._screenspaceModeQuad; this.context.scene.add(s), this.updateScreenspaceMaterialUniforms(); const r = s.material; r?.reset(), (e = this._input) == null || e.enable(r) } stop() { var e; this._isInScreenspaceMode = !1, this._screenspaceModeQuad && ((e = this._input) == null || e.disable(), this._screenspaceModeQuad.removeFromParent()) } updateScreenspaceMaterialUniforms() { var e; const t = (e = this._screenspaceModeQuad) == null ? void 0 : e.material; t && (t.screenAspect = this.context.domElement.clientWidth / this.context.domElement.clientHeight) } } class $se { constructor(e) { u(this, "_onResizeScreenFn"), u(this, "_onKeyUpFn"), u(this, "_onMouseWheelFn"), u(this, "context"), u(this, "overlay"), u(this, "_material"), u(this, "_isPinching", !1), u(this, "_lastPinch", 0), this.overlay = e, this.context = e.context } enable(e) { this._material = e, window.addEventListener("resize", this._onResizeScreenFn = () => { this.overlay.updateScreenspaceMaterialUniforms() }), window.addEventListener("keyup", this._onKeyUpFn = r => { r.key === "Escape" && this.overlay.stop() }), window.addEventListener("wheel", this._onMouseWheelFn = r => { this.overlay.enabled && (e.zoom += r.deltaY * 5e-4, r.preventDefault()) }, { passive: !1 }); const t = new W; window.addEventListener("mousemove", r => { if (this.overlay.enabled && this.context.input.getPointerPressed(0)) { const n = new W(r.movementX, r.movementY); n.x /= this.context.domElement.clientWidth, n.y /= this.context.domElement.clientHeight, t.set(n.x, n.y), t.multiplyScalar(e.zoom / -this.context.time.deltaTime * .01), e.offset = e.offset.add(t) } }), window.addEventListener("pointermove", r => { this.overlay.enabled && this.context.input.getPointerPressed(0) && this.context.input.getTouchesPressedCount() === 1 && (t.set(r.movementX, r.movementY), t.multiplyScalar(e.zoom * -this.context.time.deltaTime * .05), e.offset = e.offset.add(t)) }); let s = 0; window.addEventListener("touchstart", r => { if (r.touches.length < 2) { this.context.time.time - s < .3 && this.overlay.stop(), s = this.context.time.time; return } this._isPinching = !0, this._lastPinch = 0 }), window.addEventListener("touchmove", r => { if (!this._isPinching || !this._material) return; const n = r.touches[0], o = r.touches[1], a = n.clientX - o.clientX, l = n.clientY - o.clientY, c = Math.sqrt(a * a + l * l); if (this._lastPinch !== 0) { const h = c - this._lastPinch; this._material.zoom -= h * .004 } this._lastPinch = c }), window.addEventListener("touchend", () => { this._isPinching = !1 }) } disable() { this._onResizeScreenFn && (window.removeEventListener("resize", this._onResizeScreenFn), this._onResizeScreenFn = void 0), this._onKeyUpFn && (window.removeEventListener("keyup", this._onKeyUpFn), this._onKeyUpFn = void 0), this._onMouseWheelFn && (window.removeEventListener("wheel", this._onMouseWheelFn), this._onMouseWheelFn = void 0) } } class ere extends Vt {
  constructor(e) {
    super(), u(this, "_offset", new W), this.uniforms = { map: { value: e }, screenAspect: { value: 1 }, offsetScale: { value: new st(0, 0, 1, 1) } }, this.vertexShader = `
        uniform sampler2D map;
        uniform float screenAspect;
        uniform vec4 offsetScale;
        varying vec2 vUv;

        void main() {

            gl_Position = vec4( position , 1.0 );
            vUv = uv;
            vUv.y = 1. - vUv.y;

            // fit into screen
            ivec2 res = textureSize(map, 0);
            float videoAspect = float(res.x) / float(res.y);
            float aspect = videoAspect / screenAspect;
            if(aspect >= 1.0) 
            {
                vUv.y = vUv.y * aspect;
                float offset = (1. - aspect) * .5;
                vUv.y = vUv.y + offset;
            }
            else
            {
                vUv.x = vUv.x / aspect;
                float offset = (1. - 1. / aspect) * .5;
                vUv.x = vUv.x + offset;
            }

            vUv.x -= .5;
            vUv.y -= .5;

            vUv.x *= offsetScale.z;
            vUv.y *= offsetScale.z;
            vUv.x += offsetScale.x;
            vUv.y += offsetScale.y;

            vUv.x += .5;
            vUv.y += .5;
        }

        `, this.fragmentShader = `
        uniform sampler2D map;
        varying vec2 vUv;
        void main() {
            if(vUv.x < 0. || vUv.x > 1. || vUv.y < 0. || vUv.y > 1.)
                gl_FragColor = vec4(0., 0., 0., 1.);
            else
                gl_FragColor = texture2D(map, vUv);
        }
        `} set screenAspect(e) { this.uniforms.screenAspect.value = e, this.needsUpdate = !0 } set offset(e) { const t = this.uniforms.offsetScale.value; t.x = e.x, t.y = e.y, this.uniforms.offsetScale.value = t, this.needsUpdate = !0 } get offset() { const e = this.uniforms.offsetScale.value; return this._offset.set(e.x, e.y), this._offset } set zoom(e) { const t = this.uniforms.offsetScale.value; e < .001 && (e = .001), t.z = e, this.needsUpdate = !0 } get zoom() { return this.uniforms.offsetScale.value.z } reset() { this.offset = this.offset.set(0, 0), this.zoom = 1, this.needsUpdate = !0 }
} var tre = Object.defineProperty, ire = Object.getOwnPropertyDescriptor, JU = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? ire(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && tre(e, t, r), r }; const Bs = oe("debugscreensharing"); function a_(i) { if (i) for (const e of i.getTracks()) e.stop() } class qm extends Ee { constructor() { super(...arguments), u(this, "videoPlayer"), u(this, "device", 0), u(this, "_net"), u(this, "_requestOpen", !1), u(this, "_currentStream", null), u(this, "_currentMode", 0) } onPointerEnter() { this.context.input.setCursorPointer() } onPointerExit() { this.context.input.setCursorNormal() } onPointerClick(e) { var t; if (!(e && e.pointerId !== 0) && this.context.connection.isInRoom !== !1) { if (this.isReceiving && (t = this.videoPlayer) != null && t.isPlaying) { this.videoPlayer && (this.videoPlayer.screenspace = !this.videoPlayer.screenspace); return } if (this.isSending) { this.close(); return } this.share() } } get currentScream() { return this._currentStream } get currentMode() { return this._currentMode } get isSending() { var e; return ((e = this._currentStream) == null ? void 0 : e.active) && this._currentMode === 1 } get isReceiving() { if (this._currentMode === 2) { if (!this._currentStream || this._currentStream.active === !1) return !1; const e = this._currentStream.getTracks(); for (const t of e) if (t.readyState === "live") return !0 } return !1 } awake() { Bs && console.log("Screensharing", this.name, this), ss.registerWaitForAllowAudio(() => { this.videoPlayer && this._currentStream && this._currentMode === 2 && (this.videoPlayer.playInBackground = !0, this.videoPlayer.setVideo(this._currentStream)) }) } onDisable() { this.close() } start() { if (this.videoPlayer || (this.videoPlayer = $.getComponent(this.gameObject, Xs) ?? void 0), !this.videoPlayer) { console.error("Screencapture did not find a VideoPlayer component"); return } const e = KU.getOrCreate(this.context, this.guid); this._net = new ore(this.context, e), this._net.enable(), this._net.addEventListener("receive-video", this.onReceiveVideo.bind(this)) } async share(e) { e != null && e.device && (this.device = e.device), this._requestOpen = !0; try { if (this.videoPlayer) { const t = e?.constraints ?? { echoCancellation: !0, autoGainControl: !1 }, s = { video: t, audio: t }, r = s.video; switch (r !== void 0 && typeof r != "boolean" && (r.width || (r.width = { max: 1920 }), r.height || (r.height = { max: 1920 }), r.aspectRatio || (r.aspectRatio = { ideal: 1.7777777778 }), r.frameRate || (r.frameRate = { ideal: 24 }), r.facingMode || (r.facingMode = { ideal: "user" })), this.device) { case 1: this.tryShareUserCamera(s, e); break; case 0: if (!navigator.mediaDevices.getDisplayMedia) { console.error("No getDisplayMedia support"); return } const n = await navigator.mediaDevices.getDisplayMedia(s); this._requestOpen ? this.setVideo(n, 1) : a_(n); break; case 2: const o = 0, a = this.context.renderer.domElement.captureStream(o); this.setVideo(a, 1); break } } } catch (t) { if (t.name === "NotAllowedError") { console.log("Selection cancelled"), this._requestOpen = !1; return } console.error("Error opening video", t) } } close() { var e; this._requestOpen = !1, this._currentStream && (Bs && console.warn("Close current stream / disposing resources, stream was active?", this._currentStream.active), (e = this._net) == null || e.stopSendingVideo(this._currentStream), a_(this._currentStream), this._currentMode = 0, this._currentStream = null) } setVideo(e, t) { var s; if (e === this._currentStream || (this.close(), !e || !this.videoPlayer)) return; this._currentStream = e, this._requestOpen = !0, this._currentMode = t, this.videoPlayer.setVideo(e); const r = t === 1; r && ((s = this._net) == null || s.startSendingVideo(e)), t === 1 && (this.videoPlayer.muted = !0); for (const n of e.getTracks()) n.addEventListener("ended", () => { Bs && console.log("Track ended", n), this.close() }), Bs && n.kind === "video" && console.log(r ? "Video \u2192" : "Video \u2190", n.getSettings()) } onReceiveVideo(e) { var t; ((t = e.stream) == null ? void 0 : t.active) === !0 && this.setVideo(e.stream, 2) } async tryShareUserCamera(e, t) { const s = (await navigator.mediaDevices.enumerateDevices()).filter(r => r.kind === "videoinput"); Bs && console.log("Request camera", s); for (const r of s) try { if (!this._requestOpen) break; if (r.kind !== "videoinput") continue; const n = r.deviceId; if (t?.deviceId !== void 0 && n !== t.deviceId) continue; e.video !== !1 && ((typeof e.video > "u" || typeof e.video == "boolean") && (e.video = {}), e.video.deviceId = n); const o = await navigator.mediaDevices.getUserMedia(e); this._requestOpen ? this.setVideo(o, 1) : a_(o), Bs && console.log("Selected camera", r); break } catch (n) { if (n.message === "Failed to allocate videosource" || n.message === "Could not start video source") { ao("Failed to start video: Try another camera (Code " + n.code + ")"), console.warn(n); continue } else console.error("Failed to get user media", n.message, n.code, n) } } } JU([x(Xs)], qm.prototype, "videoPlayer", 2), JU([x()], qm.prototype, "device", 2); class sre { constructor(e, t) { u(this, "type", "receive-video"), u(this, "stream"), u(this, "target"), this.stream = e, this.target = t } } class rre { constructor(e, t) { u(this, "guid"), u(this, "peerId"), u(this, "dontSave", !0), this.guid = e.id, this.peerId = t } } class nre extends ms { constructor(e, t, s) { super(), u(this, "userId"), u(this, "direction"), u(this, "call"), u(this, "_stream", null), u(this, "_isDisposed", !1), this.userId = e, this.call = t, this.direction = s, this._stream = null, t.on("stream", r => { if (Bs && console.log("Receive video", r.getAudioTracks(), r.getVideoTracks()), this._stream = r, s === "incoming") { const n = new sre(r, this); this.dispatchEvent(n) } }) } get stream() { return this._stream } close() { this._isDisposed || (this._isDisposed = !0, this.call.close(), a_(this._stream)) } get isOpen() { var e; return ((e = this.call.peerConnection) == null ? void 0 : e.connectionState) === "connected" } get isClosed() { return !this.isOpen } } const Xm = class extends ms { constructor(i, e) { super(), u(this, "id"), u(this, "context"), u(this, "_peer"), u(this, "_incomingCalls", []), u(this, "_outgoingCalls", []), u(this, "_enabled", !1), u(this, "_enabledPeer", !1), u(this, "onConnectRoomFn", this.onConnectRoom.bind(this)), u(this, "onPeerConnectFn", this.onPeerConnect.bind(this)), u(this, "onPeerReceiveCallFn", this.onPeerReceivingCall.bind(this)), this.context = i, this.id = e, this.setupPeer(), navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia } static getOrCreate(i, e) { if (Xm.instances.has(e)) return Xm.instances.get(e); const t = new Xm(i, e); return Xm.instances.set(e, t), t } getMyPeerId() { if (this.context.connection.connectionId) return this.getPeerIdFromUserId(this.context.connection.connectionId) } getPeerIdFromUserId(i) { return this.id + "-" + i } getUserIdFromPeerId(i) { return i.substring(this.id.length + 1) } makeCall(i, e) { var t; const s = { metadata: { userId: this.context.connection.connectionId } }, r = (t = this._peer) == null ? void 0 : t.call(i, e, s); if (r) return this.registerCall(r, "outgoing") } get peer() { return this._peer } enable() { this._enabled || (this._enabled = !0, this.context.connection.beginListen(Li.JoinedRoom, this.onConnectRoomFn), this.subscribePeerEvents()) } disable() { this._enabled && (this._enabled = !1, this.context.connection.stopListen(Li.JoinedRoom, this.onConnectRoomFn), this.unsubscribePeerEvents()) } onConnectRoom() { this.setupPeer() } setupPeer() { if (this.context.connection.connectionId && !this._enabledPeer) { if (this._enabledPeer = !0, !this._peer) { const i = this.getMyPeerId(); i ? this._peer = new U0(i) : console.error("Failed to setup peerjs because we dont have a connection id", this.context.connection.connectionId) } this._enabled && this.subscribePeerEvents() } } subscribePeerEvents() { this._peer && (this._peer.on("open", this.onPeerConnectFn), this._peer.on("call", this.onPeerReceiveCallFn)) } unsubscribePeerEvents() { this._peer && (this._peer.off("open", this.onPeerConnectFn), this._peer.off("call", this.onPeerReceiveCallFn)) } onPeerConnect(i) { Bs && console.log("Peer connected as", i), this.context.connection.send("peer-user-connected", new rre(this, i)) } onPeerReceivingCall(i) { i.answer(), this.registerCall(i, "incoming") } registerCall(i, e) { const t = i.metadata; (!t || !t.userId) && console.error("Missing call metadata", i); const s = t.userId; e === "incoming" && Bs ? console.log("Receive call from", i.metadata) : Bs && console.log("Make call to", i.metadata); const r = e === "incoming" ? this._incomingCalls : this._outgoingCalls, n = new nre(s, i, e); return r.push(n), i.on("error", o => { console.error("Call error", o) }), i.on("close", () => { Bs && console.log("Call ended", i.metadata), i.close(); const o = r.indexOf(n); o !== -1 && r.splice(o, 1) }), e === "incoming" && (n.addEventListener("receive-video", o => { this.dispatchEvent(o) }), i.on("stream", () => { let o = 0, a = setInterval(() => { const l = o === 0; !n.isOpen && l && (o += 1, clearInterval(a), n.close()) }, 2e3) })), n } }; let KU = Xm; u(KU, "instances", new Map); class ore extends ms { constructor(e, t) { super(), u(this, "context"), u(this, "peer"), u(this, "_sendingVideoStreams", new Map), u(this, "onJoinedRoom", s => { Bs && console.log(`${s.userId} joined room and I'm currently sending ${this._sendingVideoStreams.size} streams`), this._sendingVideoStreams.size > 0 && this.updateSendingCalls() }), u(this, "onReceiveVideo", s => { Bs && console.log("RECEIVE VIDEO", s), this.dispatchEvent({ type: "receive-video", target: this, stream: s.stream, userId: s.userId }) }), u(this, "onUserConnected", s => { if (this.peer.id === s.guid) { Bs && console.log("USER CONNECTED", s.guid, s); const r = this._sendingVideoStreams.keys().next().value; this.peer.makeCall(s.peerId, r) } }), this.context = e, this.peer = t } startSendingVideo(e) { this._sendingVideoStreams.has(e) || (this._sendingVideoStreams.set(e, []), this.updateSendingCalls()) } stopSendingVideo(e) { if (e) { const t = this._sendingVideoStreams.get(e); if (t) { Bs && console.log("Closing calls", t); for (const s of t) s.close() } this._sendingVideoStreams.delete(e), t && Bs && console.log("Currently sending", this._sendingVideoStreams) } } enable() { this.peer.enable(), this.peer.addEventListener("receive-video", this.onReceiveVideo), this.context.connection.beginListen("peer-user-connected", this.onUserConnected), this.context.connection.beginListen(Li.JoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(Li.UserJoinedRoom, this.onJoinedRoom), this.context.connection.beginListen(Li.UserLeftRoom, this.onUserLeft) } disable() { this.peer.disable(), this.peer.removeEventListener("receive-video", this.onReceiveVideo), this.context.connection.stopListen("peer-user-connected", this.onUserConnected), this.context.connection.stopListen(Li.JoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(Li.UserJoinedRoom, this.onJoinedRoom), this.context.connection.stopListen(Li.UserLeftRoom, this.onUserLeft) } onUserLeft(e) { this.stopCallsToUsersThatAreNotInTheRoomAnymore() } updateSendingCalls() { var e; let t = !1; for (const s of this._sendingVideoStreams.keys()) { const r = this._sendingVideoStreams.get(s) || []; for (const n of this.context.connection.usersInRoom()) { if (n === this.context.connection.connectionId) continue; const o = r.find(a => a.userId === n); if (!o || ((e = o.stream) == null ? void 0 : e.active) === !1) { Bs && console.log("Starting call to", n); const a = this.peer.makeCall(this.peer.getPeerIdFromUserId(n), s); a && (t = !0, r.push(a)) } } this._sendingVideoStreams.set(s, r) } this.stopCallsToUsersThatAreNotInTheRoomAnymore(), t && Bs && console.log("Currently sending", this._sendingVideoStreams) } stopCallsToUsersThatAreNotInTheRoomAnymore() { for (const e of this._sendingVideoStreams.keys()) { const t = this._sendingVideoStreams.get(e); if (t) for (let s = t.length - 1; s >= 0; s--) { const r = t[s]; this.context.connection.userIsInRoom(r.userId) || (r.close(), t.splice(s, 1)) } } } } var are = Object.defineProperty, lre = Object.getOwnPropertyDescriptor, Ym = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? lre(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && are(e, t, r), r }; class wl extends Ir { constructor() { super(...arguments), u(this, "intensity"), u(this, "falloff"), u(this, "samples"), u(this, "color"), u(this, "luminanceInfluence"), u(this, "_ssao") } get typeName() { return "ScreenSpaceAmbientOcclusion" } onBeforeRender() { if (this._ssao && this.context.mainCamera instanceof Xt) { const e = this.context.mainCamera.far - this.context.mainCamera.near; this._ssao.ssaoMaterial.worldDistanceFalloff = e * .01, this._ssao.ssaoMaterial.worldDistanceThreshold = this.context.mainCamera.far } } onCreateEffect() { const e = this.context.mainCamera, t = new G2(this.context.scene, e), s = new tC({ normalBuffer: t.texture, resolutionScale: .5 }), r = this._ssao = new $2(e, t.texture, { normalDepthBuffer: s.texture, worldDistanceThreshold: 1, worldDistanceFalloff: 1, worldProximityThreshold: .1, worldProximityFalloff: 2, intensity: 1, blendFunction: kt.MULTIPLY, luminanceInfluence: .5 }); this.intensity.onValueChanged = o => { r.intensity = o }, this.falloff.onValueChanged = o => { r.ssaoMaterial.radius = o * .1 }, this.samples.onValueChanged = o => { r.samples = o }, this.color.onValueChanged = o => { r.color || (r.color = new xe), r.color.copy(o) }, this.luminanceInfluence.onValueChanged = o => { r.luminanceInfluence = o }; const n = new Array; return n.push(t), n.push(s), n.push(r), n } } Ym([x(Dt)], wl.prototype, "intensity", 2), Ym([x(Dt)], wl.prototype, "falloff", 2), Ym([x(Dt)], wl.prototype, "samples", 2), Ym([x(Dt)], wl.prototype, "color", 2), Ym([x(Dt)], wl.prototype, "luminanceInfluence", 2), ta("ScreenSpaceAmbientOcclusion", wl); var cre = Object.defineProperty, hre = Object.getOwnPropertyDescriptor, ZU = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? hre(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && cre(e, t, r), r }; class Jm extends Ee {
  constructor() { super(...arguments), u(this, "mode", 0), u(this, "shadowColor", new mi(0, 0, 0, 1)) } awake() { switch (this.mode) { case 0: this.applyShadowMaterial(); break; case 1: this.applyLightBlendMaterial(); break; case 2: this.applyOccluderMaterial(); break } } applyLightBlendMaterial() {
    const e = $.getComponent(this.gameObject, Ui); if (e) {
      const t = e.sharedMaterial; t.blending = rh, this.applyMaterialOptions(t), t.onBeforeCompile = s => {
        s.fragmentShader = s.fragmentShader.replace("vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;", `vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
                // diffuse-only lighting with overdrive to somewhat compensate
                // for the loss of indirect lighting and to make it more visible.
                vec3 direct = reflectedLight.directDiffuse * 3.;
                float max = max(direct.r, max(direct.g, direct.b));
                
                // early out - we're simply returning direct lighting and some alpha based on it so it can 
                // be blended onto the scene.
                gl_FragColor = vec4(direct, max);
                return;
                `)
      }
    }
  } applyShadowMaterial() { var e; const t = $.getComponent(this.gameObject, Ui); if (t) if (((e = t.sharedMaterial) == null ? void 0 : e.type) !== "ShadowMaterial") { const s = new Uw; s.color = this.shadowColor, s.opacity = this.shadowColor.alpha, this.applyMaterialOptions(s), t.sharedMaterial = s } else { const s = t.sharedMaterial; s.color = this.shadowColor, s.opacity = this.shadowColor.alpha, this.applyMaterialOptions(s) } } applyOccluderMaterial() { const e = $.getComponent(this.gameObject, Ui); if (e) { const t = e.sharedMaterial; t.depthWrite = !0, t.stencilWrite = !0, t.colorWrite = !1, this.gameObject.renderOrder = -100 } } applyMaterialOptions(e) { e && (e.depthWrite = !1, e.stencilWrite = !1) }
} ZU([x()], Jm.prototype, "mode", 2), ZU([x(mi)], Jm.prototype, "shadowColor", 2); var ure = Object.defineProperty, dre = Object.getOwnPropertyDescriptor, l_ = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? dre(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && ure(e, t, r), r }, zM; const $U = (zM = class extends Ee { constructor() { super(...arguments), u(this, "target", null), u(this, "followFactor", .1), u(this, "rotateFactor", .1), u(this, "positionAxes", Kd.All), u(this, "flipForward", !1), u(this, "_firstUpdate", !0) } onBeforeRender() { this.updateNow(!1) } updateNow(i) { if (!(!this.target || this.target === this.gameObject)) { if (this.followFactor > 0) { const e = xt(this.target), t = this._firstUpdate || i ? 1 : Ke.clamp01(this.context.time.deltaTime * this.followFactor), s = this.worldPosition; this.positionAxes & Kd.X && (s.x = Ke.lerp(s.x, e.x, t)), this.positionAxes & Kd.Y && (s.y = Ke.lerp(s.y, e.y, t)), this.positionAxes & Kd.Z && (s.z = Ke.lerp(s.z, e.z, t)), this.worldPosition = s } if (this.rotateFactor > 0) { const e = _s(this.target); this.flipForward && e.premultiply($U._invertForward); const t = this._firstUpdate || i ? 1 : Ke.clamp01(this.context.time.deltaTime * this.rotateFactor); this.worldQuaternion = this.worldQuaternion.slerp(e, t) } this._firstUpdate = !1 } } }, u(zM, "_invertForward", new we().setFromAxisAngle(new S(0, 1, 0), Math.PI)), zM); let Wc = $U; l_([x(Me)], Wc.prototype, "target", 2), l_([x()], Wc.prototype, "followFactor", 2), l_([x()], Wc.prototype, "rotateFactor", 2), l_([x()], Wc.prototype, "positionAxes", 2); class pre extends ye { constructor(e) { const t = new fre(e), s = new ks(t.image.width * .001, t.image.height * .001), r = new di({ map: t, toneMapped: !1, transparent: !0 }); super(s, r); function n(o) { r.map.dispatchDOMEvent(o) } this.addEventListener("mousedown", n), this.addEventListener("mousemove", n), this.addEventListener("mouseup", n), this.addEventListener("click", n), this.dispose = function () { s.dispose(), r.dispose(), r.map.dispose(), jM.delete(e), this.removeEventListener("mousedown", n), this.removeEventListener("mousemove", n), this.removeEventListener("mouseup", n), this.removeEventListener("click", n) } } } class fre extends ZR { constructor(e) { super(eN(e)), this.dom = e, this.anisotropy = 16, this.encoding = Xe, this.minFilter = Qt, this.magFilter = Qt; const t = new MutationObserver(() => { this.scheduleUpdate || (this.scheduleUpdate = setTimeout(() => this.update(), 16)) }), s = { attributes: !0, childList: !0, subtree: !0, characterData: !0 }; t.observe(e, s), this.observer = t } dispatchDOMEvent(e) { e.data && gre(this.dom, e.type, e.data.x, e.data.y) } update() { this.image = eN(this.dom), this.needsUpdate = !0, this.scheduleUpdate = null } dispose() { this.observer && this.observer.disconnect(), this.scheduleUpdate = clearTimeout(this.scheduleUpdate), super.dispose() } } const jM = new WeakMap; function eN(i) { const e = document.createRange(), t = new xe; function s(p) { const f = []; let g = !1; function m() { if (g && (g = !1, p.restore()), f.length === 0) return; let v = -1 / 0, A = -1 / 0, b = 1 / 0, y = 1 / 0; for (let _ = 0; _ < f.length; _++) { const w = f[_]; v = Math.max(v, w.x), A = Math.max(A, w.y), b = Math.min(b, w.x + w.width), y = Math.min(y, w.y + w.height) } p.save(), p.beginPath(), p.rect(v, A, b - v, y - A), p.clip(), g = !0 } return { add: function (v) { f.push(v), m() }, remove: function () { f.pop(), m() } } } function r(p, f, g, m) { m !== "" && (p.textTransform === "uppercase" && (m = m.toUpperCase()), h.font = p.fontWeight + " " + p.fontSize + " " + p.fontFamily, h.textBaseline = "top", h.fillStyle = p.color, h.fillText(m, f, g + parseFloat(p.fontSize) * .1)) } function n(p, f, g, m, v) { g < 2 * v && (v = g / 2), m < 2 * v && (v = m / 2), h.beginPath(), h.moveTo(p + v, f), h.arcTo(p + g, f, p + g, f + m, v), h.arcTo(p + g, f + m, p, f + m, v), h.arcTo(p, f + m, p, f, v), h.arcTo(p, f, p + g, f, v), h.closePath() } function o(p, f, g, m, v, A) { const b = p[f + "Width"], y = p[f + "Style"], _ = p[f + "Color"]; b !== "0px" && y !== "none" && _ !== "transparent" && _ !== "rgba(0, 0, 0, 0)" && (h.strokeStyle = _, h.lineWidth = parseFloat(b), h.beginPath(), h.moveTo(g, m), h.lineTo(g + v, m + A), h.stroke()) } function a(p, f) { let g = 0, m = 0, v = 0, A = 0; if (p.nodeType === Node.TEXT_NODE) { e.selectNode(p); const y = e.getBoundingClientRect(); g = y.left - l.left - .5, m = y.top - l.top - .5, v = y.width, A = y.height, r(f, g, m, p.nodeValue.trim()) } else { if (p.nodeType === Node.COMMENT_NODE) return; if (p instanceof HTMLCanvasElement) { if (p.style.display === "none") return; h.save(); const y = window.devicePixelRatio; h.scale(1 / y, 1 / y), h.drawImage(p, 0, 0), h.restore() } else { if (p.style.display === "none") return; const y = p.getBoundingClientRect(); g = y.left - l.left - .5, m = y.top - l.top - .5, v = y.width, A = y.height, f = window.getComputedStyle(p), n(g, m, v, A, parseFloat(f.borderRadius)); const _ = f.backgroundColor; _ !== "transparent" && _ !== "rgba(0, 0, 0, 0)" && (h.fillStyle = _, h.fill()); const w = ["borderTop", "borderLeft", "borderBottom", "borderRight"]; let E = !0, P = null; for (const C of w) { if (P !== null && (E = f[C + "Width"] === f[P + "Width"] && f[C + "Color"] === f[P + "Color"] && f[C + "Style"] === f[P + "Style"]), E === !1) break; P = C } if (E === !0) { const C = parseFloat(f.borderTopWidth); f.borderTopWidth !== "0px" && f.borderTopStyle !== "none" && f.borderTopColor !== "transparent" && f.borderTopColor !== "rgba(0, 0, 0, 0)" && (h.strokeStyle = f.borderTopColor, h.lineWidth = C, h.stroke()) } else o(f, "borderTop", g, m, v, 0), o(f, "borderLeft", g, m, 0, A), o(f, "borderBottom", g, m + A, v, 0), o(f, "borderRight", g + v, m, 0, A); if (p instanceof HTMLInputElement) { let C = f.accentColor; (C === void 0 || C === "auto") && (C = f.color), t.set(C); const R = Math.sqrt(.299 * t.r ** 2 + .587 * t.g ** 2 + .114 * t.b ** 2) < .5 ? "white" : "#111111"; if (p.type === "radio" && (n(g, m, v, A, A), h.fillStyle = "white", h.strokeStyle = C, h.lineWidth = 1, h.fill(), h.stroke(), p.checked && (n(g + 2, m + 2, v - 4, A - 4, A), h.fillStyle = C, h.strokeStyle = R, h.lineWidth = 2, h.fill(), h.stroke())), p.type === "checkbox" && (n(g, m, v, A, 2), h.fillStyle = p.checked ? C : "white", h.strokeStyle = p.checked ? R : C, h.lineWidth = 1, h.stroke(), h.fill(), p.checked)) { const T = h.textAlign; h.textAlign = "center"; const z = { color: R, fontFamily: f.fontFamily, fontSize: A + "px", fontWeight: "bold" }; r(z, g + v / 2, m, "\u2714"), h.textAlign = T } if (p.type === "range") { const [T, z, H] = ["min", "max", "value"].map(F => parseFloat(p[F])), N = (H - T) / (z - T) * (v - A); n(g, m + A / 4, v, A / 2, A / 4), h.fillStyle = R, h.strokeStyle = C, h.lineWidth = 1, h.fill(), h.stroke(), n(g, m + A / 4, N + A / 2, A / 2, A / 4), h.fillStyle = C, h.fill(), n(g + N, m, A, A, A / 2), h.fillStyle = C, h.fill() } (p.type === "color" || p.type === "text" || p.type === "number") && (d.add({ x: g, y: m, width: v, height: A }), r(f, g + parseInt(f.paddingLeft), m + parseInt(f.paddingTop), p.value), d.remove()) } } } const b = f.overflow === "auto" || f.overflow === "hidden"; b && d.add({ x: g, y: m, width: v, height: A }); for (let y = 0; y < p.childNodes.length; y++)a(p.childNodes[y], f); b && d.remove() } const l = i.getBoundingClientRect(); let c = jM.get(i); c === void 0 && (c = document.createElement("canvas"), c.width = l.width, c.height = l.height, jM.set(i, c)); const h = c.getContext("2d"), d = new s(h); return a(i), c } function gre(i, e, t, s) { const r = { clientX: t * i.offsetWidth + i.offsetLeft, clientY: s * i.offsetHeight + i.offsetTop, view: i.ownerDocument.defaultView }; window.dispatchEvent(new MouseEvent(e, r)); const n = i.getBoundingClientRect(); t = t * n.width + n.left, s = s * n.height + n.top; function o(a) { if (a.nodeType !== Node.TEXT_NODE && a.nodeType !== Node.COMMENT_NODE) { const l = a.getBoundingClientRect(); if (t > l.left && t < l.right && s > l.top && s < l.bottom && (a.dispatchEvent(new MouseEvent(e, r)), a instanceof HTMLInputElement && a.type === "range" && (e === "mousedown" || e === "click"))) { const [c, h] = ["min", "max"].map(f => parseFloat(a[f])), d = l.width, p = (t - l.x) / d; a.value = c + (h - c) * p, a.dispatchEvent(new InputEvent("input", { bubbles: !0 })) } for (let c = 0; c < a.childNodes.length; c++)o(a.childNodes[c]) } } o(i) } const c_ = new W, Fp = { type: "", data: c_ }; class mre extends wn { constructor(e, t) { super(); const s = this, r = new hd, n = new He, o = e.domElement; function a(p) { p.stopPropagation(); const f = e.domElement.getBoundingClientRect(); c_.x = (p.clientX - f.left) / f.width * 2 - 1, c_.y = -(p.clientY - f.top) / f.height * 2 + 1, r.setFromCamera(c_, t); const g = r.intersectObjects(s.children, !1); if (g.length > 0) { const m = g[0], v = m.object, A = m.uv; Fp.type = p.type, Fp.data.set(A.x, 1 - A.y), v.dispatchEvent(Fp) } } o.addEventListener("pointerdown", a), o.addEventListener("pointerup", a), o.addEventListener("pointermove", a), o.addEventListener("mousedown", a), o.addEventListener("mouseup", a), o.addEventListener("mousemove", a), o.addEventListener("click", a); const l = { move: "mousemove", select: "click", selectstart: "mousedown", selectend: "mouseup" }; function c(p) { const f = p.target; n.identity().extractRotation(f.matrixWorld), r.ray.origin.setFromMatrixPosition(f.matrixWorld), r.ray.direction.set(0, 0, -1).applyMatrix4(n); const g = r.intersectObjects(s.children, !1); if (g.length > 0) { const m = g[0], v = m.object, A = m.uv; Fp.type = l[p.type], Fp.data.set(A.x, 1 - A.y), v.dispatchEvent(Fp) } } const h = e.xr.getController(0); h.addEventListener("move", c), h.addEventListener("select", c), h.addEventListener("selectstart", c), h.addEventListener("selectend", c); const d = e.xr.getController(1); d.addEventListener("move", c), d.addEventListener("select", c), d.addEventListener("selectstart", c), d.addEventListener("selectend", c) } } class QM extends Ee { constructor() { super(...arguments), u(this, "id", null), u(this, "keepAspect", !1) } start() { if (!this.id || !this.context.mainCamera) return; const e = document.getElementById(this.id); if (!e) { console.warn('Could not find element with id "' + this.id + '"'); return } e.style.display = "block", e.style.visibility = "hidden"; const t = new mre(this.context.renderer, this.context.mainCamera); this.gameObject.add(t); const s = new pre(e); t.add(s), s.visible = !1, console.log(s); const r = s.material; r.transparent = !0, setTimeout(() => { s.visible = !0; const n = y1(this.gameObject).clone(); m0(this.gameObject, 0, 0, 0), this.gameObject.updateMatrixWorld(); const o = new er; o.setFromObject(t), this.setWorldRotation(n.x, n.y, n.z); const a = o.max.x - o.min.x, l = o.max.y - o.min.y; if (this.keepAspect) { const h = a / l; a > l ? s.scale.set(1 / a, 1 / l / h, 1) : s.scale.set(1 / a * h, 1 / l, 1) } else s.scale.set(1 / a, 1 / l, 1); const c = this.gameObject.scale; s.scale.multiply(c) }, 1) } } var vre = Object.defineProperty, Are = Object.getOwnPropertyDescriptor, Km = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Are(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && vre(e, t, r), r }; const Zm = oe("debugspatialtrigger"), tN = new bn, iN = new bn; function yre(i, e) { return tN.mask = i, iN.mask = e, tN.test(iN) } class ua extends Ee { constructor() { super(...arguments), u(this, "triggerMask", 0), u(this, "onEnter"), u(this, "onStay"), u(this, "onExit"), u(this, "currentIntersected", []), u(this, "lastIntersected", []) } start() { Zm && console.log(this.name, this.triggerMask, this) } update() { this.currentIntersected.length = 0; for (const e of $m.triggers) yre(e.triggerMask, this.triggerMask) && e.test(this.gameObject) && this.currentIntersected.push(e); for (let e = this.lastIntersected.length - 1; e >= 0; e--) { const t = this.lastIntersected[e]; this.currentIntersected.indexOf(t) < 0 && (this.onExitTrigger(t), this.lastIntersected.splice(e, 1)) } for (const e of this.currentIntersected) this.lastIntersected.indexOf(e) < 0 && this.onEnterTrigger(e), this.onStayTrigger(e); this.lastIntersected.length = 0, this.lastIntersected.push(...this.currentIntersected) } onEnterTrigger(e) { var t; Zm && console.log("ENTER TRIGGER", this.name, e.name, this, e), e.raiseOnEnterEvent(this), (t = this.onEnter) == null || t.invoke(this, e) } onExitTrigger(e) { var t; Zm && console.log("EXIT TRIGGER", this.name, e.name, this, e), e.raiseOnExitEvent(this), (t = this.onExit) == null || t.invoke(this, e) } onStayTrigger(e) { var t; e.raiseOnStayEvent(this), (t = this.onStay) == null || t.invoke(this, e) } } Km([x()], ua.prototype, "triggerMask", 2), Km([x(Nr)], ua.prototype, "onEnter", 2), Km([x(Nr)], ua.prototype, "onStay", 2), Km([x(Nr)], ua.prototype, "onExit", 2); var GM; const h_ = (GM = class extends Ee { constructor() { super(...arguments), u(this, "triggerMask"), u(this, "boxHelper") } start() { Zm && console.log(this.name, this.triggerMask, this) } onEnable() { var i; h_.triggers.push(this), this.boxHelper || (this.boxHelper = $.addNewComponent(this.gameObject, qo), (i = this.boxHelper) == null || i.showHelper(null, Zm)) } onDisable() { h_.triggers.splice(h_.triggers.indexOf(this), 1) } test(i) { return this.boxHelper ? this.boxHelper.isInBox(i) ?? !1 : !1 } raiseOnEnterEvent(i) { $.foreachComponent(this.gameObject, e => { e !== i && e instanceof ua && e.onEnterTrigger(this) }, !1) } raiseOnStayEvent(i) { $.foreachComponent(this.gameObject, e => { e !== i && e instanceof ua && e.onStayTrigger(this) }, !1) } raiseOnExitEvent(i) { $.foreachComponent(this.gameObject, e => { e !== i && e instanceof ua && e.onExitTrigger(this) }, !1) } }, u(GM, "triggers", []), GM); let $m = h_; Km([x()], $m.prototype, "triggerMask", 2); var bre = Object.defineProperty, _re = Object.getOwnPropertyDescriptor, xre = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? _re(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && bre(e, t, r), r }; const fn = oe("debugspectator"); class u_ extends Ee { constructor() { super(...arguments), u(this, "cam", null), u(this, "useKeys", !0), u(this, "_mode", 0), u(this, "orbit", null), u(this, "_handler"), u(this, "eventSub_WebXRRequestStartEvent", null), u(this, "eventSub_WebXRStartEvent", null), u(this, "eventSub_WebXREndEvent", null), u(this, "_debug"), u(this, "_networking") } get mode() { return this._mode } set mode(e) { this._mode = e } get isSpectating() { var e; return ((e = this._handler) == null ? void 0 : e.currentTarget) !== void 0 } isSpectatingUser(e) { var t; return ((t = this.target) == null ? void 0 : t.userId) === e } isFollowedBy(e) { var t; return (t = this.followers) == null ? void 0 : t.includes(e) } get followers() { return this._networking.followers } stopSpectating() { if (this.context.isInXR) { this.followSelf(); return } this.target = void 0 } get localId() { return this.context.connection.connectionId ?? "local" } set target(e) { var t; if (this._handler) { const s = (t = this._handler.currentTarget) == null ? void 0 : t.userId, r = this.context.players.getPlayerView(this.localId); e === void 0 || this.context.isInXR === !1 && r?.currentObject === e.currentObject ? this._handler.currentTarget !== void 0 && (this._handler.disable(), $.setActive(this.gameObject, !1), this.orbit && (this.orbit.enabled = !0), this._networking.onSpectatedObjectChanged(e, s)) : this._handler.currentTarget !== e && (this._handler.set(e), $.setActive(this.gameObject, !0), this.orbit && (this.orbit.enabled = !1), this._networking.onSpectatedObjectChanged(e, s)) } } get target() { var e; return (e = this._handler) == null ? void 0 : e.currentTarget } requestAllFollowMe() { this._networking.onRequestFollowMe() } get isSpectatingSelf() { var e, t; return this.isSpectating && ((e = this.target) == null ? void 0 : e.currentObject) === ((t = this.context.players.getPlayerView(this.localId)) == null ? void 0 : t.currentObject) } awake() { if (this._debug = new Sre(this.context, this), this._networking = new Ire(this.context, this), this._networking.awake(), $.setActive(this.gameObject, !1), this.cam = $.getComponent(this.gameObject, Si), !this.cam) { console.error("Spectator camera needs camera component", this); return } !this._handler && this.cam && (this._handler = new wre(this.context, this.cam, this)), this.eventSub_WebXRRequestStartEvent = this.onXRSessionRequestStart.bind(this), this.eventSub_WebXRStartEvent = this.onXRSessionStart.bind(this), this.eventSub_WebXREndEvent = this.onXRSessionEnded.bind(this), wt.addEventListener(bi.RequestVRSession, this.eventSub_WebXRRequestStartEvent), wt.addEventListener(bi.XRStarted, this.eventSub_WebXRStartEvent), wt.addEventListener(bi.XRStopped, this.eventSub_WebXREndEvent), this.orbit = $.getComponent(this.context.mainCamera, Pc) } onDestroy() { var e; this.stopSpectating(), wt.removeEventListener(bi.RequestVRSession, this.eventSub_WebXRStartEvent), wt.removeEventListener(bi.XRStarted, this.eventSub_WebXRStartEvent), wt.removeEventListener(bi.XRStopped, this.eventSub_WebXREndEvent), (e = this._handler) == null || e.destroy(), this._networking.destroy() } isSupportedPlatform() { const e = window.navigator.userAgent, t = /Windows|MacOS/.test(e), s = /Windows NT/.test(e) && /Edg/.test(e) && !/Win64/.test(e); return t && !s } onXRSessionRequestStart(e) { this.isSupportedPlatform() && $.setActive(this.gameObject, !0) } onXRSessionStart(e) { this.isSupportedPlatform() && (fn && console.log(this.context.mainCamera), this.context.mainCamera && this.followSelf()) } onXRSessionEnded(e) { var t, s; this.context.removeCamera(this.cam), $.setActive(this.gameObject, !1), this.orbit && (this.orbit.enabled = !0), (t = this._handler) == null || t.set(void 0), (s = this._handler) == null || s.disable(), this.isSpectatingSelf && this.stopSpectating() } followSelf() { this.target = this.context.players.getPlayerView(this.context.connection.connectionId), this.target || (this.context.players.setPlayerView(this.localId, this.context.mainCamera, jo.Headset), this.target = this.context.players.getPlayerView(this.localId)), fn && console.log("Follow self", this.target) } onAfterRender() { var e, t, s; if (!this.cam) return; const r = this.context.renderer, n = r.xr.enabled; if (!r.xr.isPresenting && !((e = this._handler) != null && e.currentTarget)) return; (t = this._handler) == null || t.update(this._mode); const o = r.getRenderTarget(); let a = null; if (!o) { if (!r.state.bindFramebuffer || !r.state.bindXRFramebuffer) return; a = r._framebuffer, r.state.bindXRFramebuffer(null) } this.setAvatarFlagsBeforeRender(); const l = this.context.mainCameraComponent; if (l) { const d = l.backgroundColor; d && r.setClearColor(d, d.alpha), this.cam.backgroundColor = d, this.cam.clearFlags = l.clearFlags, this.cam.nearClipPlane = l.nearClipPlane, this.cam.farClipPlane = l.farClipPlane } else r.setClearColor(new xe(1, 1, 1)); r.setRenderTarget(null), r.xr.enabled = !1; const c = (s = this.cam) == null ? void 0 : s.cam; this.context.updateAspect(c); const h = r.xr.isPresenting; r.xr.isPresenting = !1, r.setSize(this.context.domWidth, this.context.domHeight), r.render(this.context.scene, c), r.xr.isPresenting = h, r.xr.enabled = n, o ? r.setRenderTarget(o) : r.state.bindXRFramebuffer(a), this.resetAvatarFlags() } setAvatarFlagsBeforeRender() { const e = this._mode === 0; for (const t of lr.instances) if (t.avatar && "isLocalAvatar" in t.avatar) { let s = rs.All; this.isSpectatingSelf && (s = e && t.avatar.isLocalAvatar ? rs.FirstPerson : rs.ThirdPerson); const r = t.avatar.flags; if (!r) continue; for (const n of r) n.UpdateVisible(s) } } resetAvatarFlags() { var e; for (const t of lr.instances) if (t.avatar && "flags" in t.avatar) { const s = t.avatar.flags; if (!s) continue; for (const r of s) (e = t.avatar) != null && e.isLocalAvatar ? r.UpdateVisible(rs.FirstPerson) : r.UpdateVisible(rs.ThirdPerson) } } } xre([x()], u_.prototype, "useKeys", 2); class wre { constructor(e, t, s) { u(this, "context"), u(this, "cam"), u(this, "spectator"), u(this, "follow"), u(this, "target"), u(this, "view"), u(this, "currentObject"), this.context = e, this.cam = t, this.spectator = s } get currentTarget() { return this.view } set(e) { const t = e?.currentObject; if (!t) { this.spectator.stopSpectating(); return } t !== this.currentObject && (this.currentObject = t, this.view = e, this.follow || (this.follow = $.addNewComponent(this.cam.gameObject, Wc)), this.target || (this.target = new Me), t.add(this.target), this.follow.enabled = !0, this.follow.target = this.target, fn && console.log("FOLLOW", t), this.context.isInXR ? this.context.removeCamera(this.cam) : this.context.setCurrentCamera(this.cam)) } disable() { fn && console.log("STOP FOLLOW", this.currentObject), this.view = void 0, this.currentObject = void 0, this.context.removeCamera(this.cam), this.follow && (this.follow.enabled = !1) } destroy() { var e; (e = this.target) == null || e.removeFromParent(), this.follow && $.destroy(this.follow) } update(e) { var t, s, r, n, o, a; if (((t = this.currentTarget) == null ? void 0 : t.isConnected) === !1 || ((s = this.currentTarget) == null ? void 0 : s.removed) === !0) { fn && console.log("Target disconnected or timeout", this.currentTarget), this.spectator.stopSpectating(); return } this.currentTarget && ((r = this.currentTarget) == null ? void 0 : r.currentObject) !== this.currentObject && (fn && console.log("Target changed", this.currentObject, "to", this.currentTarget.currentObject), this.set(this.currentTarget)); const l = this.context.mainCamera; l && (this.cam.cam.near !== l.near || this.cam.cam.far !== l.far) && (this.cam.cam.near = l.near, this.cam.cam.far = l.far, this.cam.cam.updateProjectionMatrix()); const c = (n = this.follow) == null ? void 0 : n.target; if (!(!c || !this.follow)) { switch (e) { case 0: ((o = this.view) == null ? void 0 : o.viewDevice) !== jo.Browser ? (this.follow.followFactor = 5, this.follow.rotateFactor = 5) : (this.follow.followFactor = 50, this.follow.rotateFactor = 50), c.position.set(0, 0, 0); break; case 1: this.follow.followFactor = 3, this.follow.rotateFactor = 2, c.position.set(0, .5, 1.5); break }this.follow.flipForward = !1, ((a = this.view) == null ? void 0 : a.viewDevice) !== jo.Browser ? c.quaternion.copy(Cre) : c.quaternion.identity() } } } const Cre = new we().setFromAxisAngle(new S(0, 1, 0), Math.PI); class Sre { constructor(e, t) { u(this, "context"), u(this, "spectator"), this.context = e, this.spectator = t, console.log("Click other avatars or cameras to follow them. Press ESC to exit spectator mode."), this.context.domElement.addEventListener("keydown", r => { !this.spectator.useKeys || r.key === "Escape" && this.spectator.stopSpectating() }); let s = 0; this.context.input.addEventListener(Lo.PointerDown, r => { s = this.context.time.time }), this.context.input.addEventListener(Lo.PointerUp, r => { const n = this.context.time.time - s; n > 1 ? this.spectator.stopSpectating() : this.context.input.getPointerClicked(0) && n < .3 && this.trySelectObject() }) } trySelectObject() { const e = new co; e.setMask(16777215); const t = this.context.physics.raycast(e); if (fn && console.log(...t), t != null && t.length) for (const s of t) { if (s.distance < .2) continue; const r = s.object, n = $.getComponentInParent(r, lr), o = n?.connectionId; if (o) { const a = this.context.players.getPlayerView(o); this.spectator.target = a, fn && console.log("spectate", o, n); break } } } } class Ere { constructor(e, t, s) { u(this, "guid"), u(this, "dontSave", !0), u(this, "targetUserId"), u(this, "stoppedFollowing"), this.guid = e, this.targetUserId = t, this.stoppedFollowing = s } } class Mre { constructor(e, t) { u(this, "guid"), u(this, "userId"), this.guid = e.guid, this.userId = t } } class Ire { constructor(e, t) { u(this, "followers", []), u(this, "context"), u(this, "spectator"), u(this, "_followerEventMethod"), u(this, "_requestFollowMethod"), u(this, "_joinedRoomMethod"), u(this, "_lastRequestFollowUser"), u(this, "_enforceFollowInterval"), this.context = e, this.spectator = t, this._followerEventMethod = this.onFollowerEvent.bind(this), this._requestFollowMethod = this.onRequestFollowEvent.bind(this), this._joinedRoomMethod = this.onUserJoinedRoom.bind(this) } awake() { this.context.connection.beginListen("spectator-follower-changed", this._followerEventMethod), this.context.connection.beginListen("spectator-request-follow", this._requestFollowMethod), this.context.connection.beginListen(Li.JoinedRoom, this._joinedRoomMethod), this.context.domElement.addEventListener("keydown", e => { this.spectator.useKeys && (e.key === "f" ? this.onRequestFollowMe() : e.key === "Escape" && this.onRequestFollowMe(!0)) }) } destroy() { this.context.connection.stopListen("spectator-follower-changed", this._followerEventMethod), this.context.connection.stopListen("spectator-request-follow", this._requestFollowMethod), this.context.connection.stopListen(Li.JoinedRoom, this._joinedRoomMethod) } onSpectatedObjectChanged(e, t) { if (fn && console.log(this.context.connection.connectionId, "onSpectatedObjectChanged", e, t), this.context.connection.connectionId) { const s = e?.userId === void 0, r = s ? t : e?.userId, n = new Ere(this.context.connection.connectionId, r, s); this.context.connection.send("spectator-follower-changed", n) } } onRequestFollowMe(e = !1) { if (fn && console.log("Request follow", this.context.connection.connectionId), this.context.connection.connectionId) { this.spectator.stopSpectating(); const t = e ? void 0 : this.context.connection.connectionId, s = new Mre(this.spectator, t); this.context.connection.send("spectator-request-follow", s) } } onUserJoinedRoom() { oe("followme") && this.onRequestFollowMe() } onFollowerEvent(e) { const t = e.targetUserId, s = e.guid; if (fn && console.log(e), t === this.context.connection.connectionId) if (e.stoppedFollowing) { const r = this.followers.indexOf(s); r !== -1 && (this.followers.splice(r, 1), this.removeDisconnectedFollowers(), console.log(s, "unfollows you", this.followers.length)) } else this.followers.includes(s) || (this.followers.push(s), this.removeDisconnectedFollowers(), console.log(s, "follows you", this.followers.length)) } removeDisconnectedFollowers() { for (let e = this.followers.length - 1; e >= 0; e--) { const t = this.followers[e]; this.context.connection.userIsInRoom(t) === !1 && this.followers.splice(e, 1) } } onRequestFollowEvent(e) { if (this._lastRequestFollowUser = e, e.userId === this.context.connection.connectionId) this.spectator.stopSpectating(); else if (e.userId === void 0) this.spectator.stopSpectating(); else { const t = this.context.players.getPlayerView(e.userId); if (t) this.spectator.target = t; else return fn && console.warn("Could not find view", e.userId), this.enforceFollow(), !1 } return !0 } enforceFollow() { this._enforceFollowInterval || (this._enforceFollowInterval = setInterval(() => { this._lastRequestFollowUser === void 0 || this._lastRequestFollowUser.userId && this.spectator.isFollowedBy(this._lastRequestFollowUser.userId) ? (clearInterval(this._enforceFollowInterval), this._enforceFollowInterval = void 0) : (fn && console.log("REQUEST FOLLOW AGAIN", this._lastRequestFollowUser.userId), this.onRequestFollowEvent(this._lastRequestFollowUser)) }, 1e3)) } } var Tre = Object.defineProperty, Rre = Object.getOwnPropertyDescriptor, qn = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Rre(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Tre(e, t, r), r }; const HM = oe("debugspriterenderer"), Pre = oe("wireframe"), VM = class { static getOrCreateGeometry(i) { if (i._geometry) return i._geometry; if (i.guid && VM.cache[i.guid]) return HM && console.log("Take cached geometry for sprite", i.guid), VM.cache[i.guid]; const e = new yt; i._geometry = e; const t = new Float32Array(i.triangles.length * 3), s = new Float32Array(i.triangles.length * 2); for (let r = 0; r < i.triangles.length; r += 1) { const n = i.triangles[r]; t[r * 3] = -i.vertices[n].x, t[r * 3 + 1] = i.vertices[n].y, t[r * 3 + 2] = 0; const o = i.uv[n]; s[r * 2] = o.x, s[r * 2 + 1] = 1 - o.y } return e.setAttribute("position", new nt(t, 3)), e.setAttribute("uv", new nt(s, 2)), i.guid && (this.cache[i.guid] = e), HM && console.log("Built sprite geometry", i, e), e } }; let WM = VM; u(WM, "cache", {}); class Cl { constructor() { u(this, "guid"), u(this, "texture"), u(this, "triangles"), u(this, "uv"), u(this, "vertices"), u(this, "_geometry") } } qn([x()], Cl.prototype, "guid", 2), qn([x(Nt)], Cl.prototype, "texture", 2), qn([Cd()], Cl.prototype, "triangles", 2), qn([Cd()], Cl.prototype, "uv", 2), qn([Cd()], Cl.prototype, "vertices", 2); const qM = Symbol("spriteOwner"); class ev { constructor() { u(this, "sprites") } } qn([x(Cl)], ev.prototype, "sprites", 2); class Up { constructor() { u(this, "spriteSheet"), u(this, "index", 0) } update() { if (!this.spriteSheet) return; const e = this.index; if (e < 0 || e >= this.spriteSheet.sprites.length) return; const t = this.spriteSheet.sprites[e]; let s = t?.texture; s && (s.encoding = Xe, s.minFilter == Zt && s.magFilter == Zt && (s.anisotropy = 1), s.needsUpdate = !0) } } qn([x(ev)], Up.prototype, "spriteSheet", 2), qn([x()], Up.prototype, "index", 2); class fu extends Ee { constructor() { super(...arguments), u(this, "drawMode", 0), u(this, "size", { x: 1, y: 1 }), u(this, "color"), u(this, "sharedMaterial"), u(this, "_spriteSheet"), u(this, "_currentSprite") } get sprite() { return this._spriteSheet } set sprite(e) { if (e !== this._spriteSheet) if (typeof e == "number") { const t = Math.floor(e); t === e && (this.spriteIndex = t); return } else this._spriteSheet = e, this.updateSprite() } set spriteIndex(e) { this._spriteSheet && (this._spriteSheet.index = e, this.updateSprite()) } get spriteIndex() { var e; return ((e = this._spriteSheet) == null ? void 0 : e.index) ?? 0 } get spriteFrames() { var e, t; return ((t = (e = this._spriteSheet) == null ? void 0 : e.spriteSheet) == null ? void 0 : t.sprites.length) ?? 0 } awake() { this._currentSprite = void 0, HM && console.log("Awake", this.name, this, this.sprite) } start() { this._currentSprite ? this.gameObject && this.gameObject.add(this._currentSprite) : this.updateSprite() } updateSprite() { var e, t, s; if (!this.__didAwake || !((t = (e = this.sprite) == null ? void 0 : e.spriteSheet) != null && t.sprites)) return; const r = this.sprite.spriteSheet.sprites[this.spriteIndex]; if (this._currentSprite) this._currentSprite.geometry = WM.getOrCreateGeometry(r), this._currentSprite.material.map = r.texture; else { const n = new di({ color: 16777215, side: yi }); if (!n) return; if (Pre && (n.wireframe = !0), this.color && (n.color || (n.color = new xe), n.color.copy(this.color), n.opacity = this.color.alpha), n.transparent = !0, r.texture && !n.wireframe) { let o = r.texture; o[qM] !== void 0 && o[qM] !== this && this.spriteFrames > 1 && (o = r.texture = o.clone()), o[qM] = this, n.map = o } this.sharedMaterial = n, this._currentSprite = new ye(WM.getOrCreateGeometry(r), n) } this._currentSprite.parent !== this.gameObject && (this.drawMode === 2 && this._currentSprite.scale.set(this.size.x, this.size.y, 1), this.gameObject && this.gameObject.add(this._currentSprite)), this._currentSprite && this._currentSprite.layers.set(this.layer), (s = this._spriteSheet) == null || s.update() } } qn([x()], fu.prototype, "drawMode", 2), qn([x(mi)], fu.prototype, "color", 2), qn([x(Tt)], fu.prototype, "sharedMaterial", 2), qn([x(Up)], fu.prototype, "sprite", 1); class xa { constructor() { u(this, "bb", null), u(this, "bb_pos", 0) } __init(e, t) { return this.bb_pos = e, this.bb = t, this } static getRootAsSyncedCameraModel(e, t) { return (t || new xa).__init(e.readInt32(e.position()) + e.position(), e) } static getSizePrefixedRootAsSyncedCameraModel(e, t) { return e.setPosition(e.position() + E0), (t || new xa).__init(e.readInt32(e.position()) + e.position(), e) } userId(e) { const t = this.bb.__offset(this.bb_pos, 4); return t ? this.bb.__string(this.bb_pos + t, e) : null } guid(e) { const t = this.bb.__offset(this.bb_pos, 6); return t ? this.bb.__string(this.bb_pos + t, e) : null } dontSave() { const e = this.bb.__offset(this.bb_pos, 8); return e ? !!this.bb.readInt8(this.bb_pos + e) : !1 } pos(e) { const t = this.bb.__offset(this.bb_pos, 10); return t ? (e || new an).__init(this.bb_pos + t, this.bb) : null } rot(e) { const t = this.bb.__offset(this.bb_pos, 12); return t ? (e || new an).__init(this.bb_pos + t, this.bb) : null } static startSyncedCameraModel(e) { e.startObject(5) } static addUserId(e, t) { e.addFieldOffset(0, t, 0) } static addGuid(e, t) { e.addFieldOffset(1, t, 0) } static addDontSave(e, t) { e.addFieldInt8(2, +t, 0) } static addPos(e, t) { e.addFieldStruct(3, t, 0) } static addRot(e, t) { e.addFieldStruct(4, t, 0) } static endSyncedCameraModel(e) { return e.endObject() } static finishSyncedCameraModelBuffer(e, t) { e.finish(t) } static finishSizePrefixedSyncedCameraModelBuffer(e, t) { e.finish(t, void 0, !0) } } var Bre = Object.defineProperty, kre = Object.getOwnPropertyDescriptor, Dre = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? kre(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Bre(e, t, r), r }; const d_ = "SCAM"; C1(d_, xa.getRootAsSyncedCameraModel); const gn = new Zp; class Ore { constructor(e, t) { u(this, "userId"), u(this, "guid"), this.guid = t, this.userId = e } send(e, t) { if (e) { gn.clear(); const s = gn.createString(this.guid), r = gn.createString(this.userId); xa.startSyncedCameraModel(gn), xa.addGuid(gn, s), xa.addUserId(gn, r); const n = xt(e), o = y1(e); xa.addPos(gn, an.createVec3(gn, n.x, n.y, n.z)), xa.addRot(gn, an.createVec3(gn, o.x, o.y, o.z)); const a = xa.endSyncedCameraModel(gn); gn.finish(a, d_), t.sendBinary(gn.asUint8Array()) } } } var XM; const YM = (XM = class extends Ee { constructor() { super(...arguments), u(this, "cameraPrefab", null), u(this, "_lastWorldPosition"), u(this, "_lastWorldQuaternion"), u(this, "_model", null), u(this, "_needsUpdate", !0), u(this, "_lastUpdateTime", 0), u(this, "remoteCams", {}), u(this, "userToCamMap", {}), u(this, "_camTimeoutInSeconds", 10), u(this, "_receiveCallback", null) } getCameraObject(i) { const e = this.userToCamMap[i]; return e ? this.remoteCams[e].obj : null } async awake() { this._lastWorldPosition = this.worldPosition.clone(), this._lastWorldQuaternion = this.worldQuaternion.clone(), this.cameraPrefab && ("uri" in this.cameraPrefab && (this.cameraPrefab = await this.cameraPrefab.instantiate(this.gameObject)), this.cameraPrefab && "isObject3D" in this.cameraPrefab && (this.cameraPrefab.visible = !1)) } onEnable() { this._receiveCallback = this.context.connection.beginListenBinary(d_, this.onReceivedRemoteCameraInfoBin.bind(this)) } onDisable() { this.context.connection.stopListenBinary(d_, this._receiveCallback) } update() { for (const s in this.remoteCams) { const r = this.remoteCams[s], n = this.context.time.realtimeSinceStartup - r.lastUpdate; if (!r || n > this._camTimeoutInSeconds) { console.log("Remote cam timeout", r, n), r != null && r.obj && $.destroy(r.obj), delete this.remoteCams[s], r && delete this.userToCamMap[r.userId], YM.instances.push(r), this.context.players.removePlayerView(r.userId, jo.Browser); continue } } if (wt.IsInWebXR) return; const i = this.context.mainCamera; if (i === null) { this.enabled = !1; return } if (!this.context.connection.isConnected || this.context.connection.connectionId === null) return; this._model === null && (this._model = new Ore(this.context.connection.connectionId, this.context.connection.connectionId + "_camera")); const e = xt(i), t = _s(i); (e.distanceTo(this._lastWorldPosition) > .001 || t.angleTo(this._lastWorldQuaternion) > .01) && (this._needsUpdate = !0), this._lastWorldPosition.copy(e), this._lastWorldQuaternion.copy(t), !((!this._needsUpdate || this.context.time.frameCount % 2 !== 0) && !(this.context.time.realtimeSinceStartup - this._lastUpdateTime > this._camTimeoutInSeconds * .5)) && (this._lastUpdateTime = this.context.time.realtimeSinceStartup, this._needsUpdate = !1, this._model.send(i, this.context.connection), this.context.isInXR || this.context.players.setPlayerView(this.context.connection.connectionId, i, jo.Browser)) } onReceivedRemoteCameraInfoBin(i) { const e = i.guid(); if (!e) return; const t = i.userId(); if (!t || !this.context.connection.userIsInRoom(t) || !this.cameraPrefab) return; let s = this.remoteCams[e]; if (!s) if ("isObject3D" in this.cameraPrefab) { const a = new No; a.context = this.context; const l = $.instantiate(this.cameraPrefab, a); s = this.remoteCams[e] = { obj: l, lastUpdate: this.context.time.realtimeSinceStartup, userId: t }, s.obj.visible = !0, this.gameObject.add(l), this.userToCamMap[t] = e, YM.instances.push(s); const c = $.getOrAddComponent(l, lr); c.connectionId = t, c.avatar = l } else return; const r = s.obj; this.context.players.setPlayerView(t, r, jo.Browser), s.lastUpdate = this.context.time.realtimeSinceStartup, Xr.markDirty(r); const n = i.pos(); n && dd(r, n.x(), n.y(), n.z()); const o = i.rot(); o && m0(r, o.x(), o.y(), o.z()) } }, u(XM, "instances", []), XM); let p_ = YM; Dre([x([Me, or])], p_.prototype, "cameraPrefab", 2); var Lre = Object.defineProperty, Fre = Object.getOwnPropertyDescriptor, tv = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Fre(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Lre(e, t, r), r }; const JM = "view", f_ = oe("debugsyncedroom"); class qc extends Ee { constructor() { super(...arguments), u(this, "roomName"), u(this, "urlParameterName", "room"), u(this, "joinRandomRoom", !0), u(this, "requireRoomParameter", !1), u(this, "autoRejoin", !0), u(this, "_roomPrefix"), u(this, "_lastPingTime", 0), u(this, "_lastRoomTime", -1) } get RoomPrefix() { return this._roomPrefix } awake() { f_ && console.log("Room", this.roomName, this.urlParameterName, this.joinRandomRoom, this.requireRoomParameter, this.autoRejoin), this._roomPrefix === void 0 && (this._roomPrefix = this.roomName, this.roomName = "") } onEnable() { const e = oe(JM); if (e && typeof e == "string" && e.length > 0) { console.log("Join as viewer"), this.context.connection.joinRoom(e, !0); return } this.tryJoinRoom() } onDisable() { this.roomName && this.roomName.length > 0 && this.context.connection.leaveRoom(this.roomName) } tryJoinRoom(e = 0) { e === void 0 && (e = 0); let t = !1; if (this.urlParameterName) { const s = oe(this.urlParameterName); if (s && typeof s == "string") { t = !0; const r = UI(s); this.roomName = r } else if (this.joinRandomRoom && (console.log("No room name found in url, generating random one"), this.setRandomRoomUrlParameter(), e < 1)) return this.tryJoinRoom(e + 1) } else this.joinRandomRoom && (this.roomName === null || this.roomName === void 0 || this.roomName.length <= 0) && (console.log("generate room name"), this.roomName = this.generateRoomName()); return this.requireRoomParameter && !t ? (f_ && console.log('No required room parameter "' + this.urlParameterName + '" in url - will not connect to networking backend.'), !1) : !this.roomName || this.roomName.length <= 0 ? (f_ && console.error('Missing room name on "' + this.name + '". Make sure this is correctly configured in Unity', this.context.connection.isDebugEnabled ? this : ""), !1) : (this.context.connection.isConnected || this.context.connection.connect(), f_ && console.log("Join " + this.roomName), this._roomPrefix && (this.roomName = this._roomPrefix + this.roomName), this.context.connection.joinRoom(this.roomName), !0) } update() { this.context.connection.isConnected && (this.context.time.time - this._lastPingTime > 3 && (this._lastPingTime = this.context.time.time, this.context.connection.sendPing()), this.context.connection.isInRoom && (this._lastRoomTime = this.context.time.time)), this._lastRoomTime > 0 && this.context.time.time - this._lastRoomTime > .3 && (this._lastRoomTime = -1, this.autoRejoin ? (console.log("Disconnected from networking backend - attempt reconnecting now"), this.tryJoinRoom()) : console.warn("You are not connected to a room anymore (possibly because the tab was inactive for too long and the server kicked you)")) } get currentRoomName() { return oe(JM) || oe(this.urlParameterName) } setRandomRoomUrlParameter() { const e = sf(), t = this.generateRoomName(); oe(this.urlParameterName) ? e.set(this.urlParameterName, t) : e.append(this.urlParameterName, t), q_(t, e) } generateRoomName() { return FI() + "_" + DI(100, 999) } getViewOnlyUrl() { if (this.context.connection.isConnected && this.context.connection.currentRoomViewId) { const e = window.location.search, t = new URLSearchParams(e); return t.has(this.urlParameterName) && t.delete(this.urlParameterName), t.set(JM, this.context.connection.currentRoomViewId), window.location.origin + window.location.pathname + "?" + t.toString() } return null } } tv([x()], qc.prototype, "roomName", 2), tv([x()], qc.prototype, "urlParameterName", 2), tv([x()], qc.prototype, "joinRandomRoom", 2), tv([x()], qc.prototype, "requireRoomParameter", 2), tv([x()], qc.prototype, "autoRejoin", 2); function Ure() { const i = oe("testwindowcount") || 0; i && i > 0 && Nre(i) } function Nre(i) { if (oe("testwindow")) return null; const e = new URL(window.location.href); rf(e.searchParams, Ny, 1), rf(e.searchParams, "testwindow", 1); const t = e.toString(), s = []; window.onbeforeunload = () => { for (const l of s) l.close() }; const r = .05, n = 128; let o = 0, a = 0; for (let l = 0; l < i; l++) { o * n + n * .01 >= window.innerWidth && (a += 1, o = 0); const c = o * (n * (1 + r)) + window.screenLeft, h = a * (n * (1 + r)) + window.screenTop + 90 + 60 * a; o += 1; const d = window.open(t, "test window " + l, `popup=yes width=${n} height=${n} top=${h} left=${c}`); if (!d) { console.warn("Failed to open window"); continue } s.push(d), d.onload = () => { d.onbeforeunload = () => { for (let p = 0; p < s.length; p++) { const f = s[p]; f !== d && f.close() } s.length = 0 } } } return s } class KM extends Ee { awake() { Ure() } } class ZM extends Ee { constructor() { super(...arguments), u(this, "transformsPerFrame", 10), u(this, "interval", 0), u(this, "useFlatbuffers", !0), u(this, "builder", null), u(this, "models", null) } awake() { if (this.useFlatbuffers) this.context.connection.beginListenBinary(Hg, e => { }); else { this.models = []; for (let e = 0; e < this.transformsPerFrame; e++)this.models.push(new sN(this.context.connection.connectionId + "_simulatedTransform_" + e, this)) } } update() { if (this.context.connection.isConnected) { if (this.useFlatbuffers) { if (!this.context.connection.connectionId || this.context.time.frameCount % this.interval !== 0) return; this.builder === null && (this.builder = new Zp(1024)); const e = this.builder; for (let t = 0; t < this.transformsPerFrame; t++) { e.clear(); const s = VL(this.context.connection.connectionId, this); this.context.connection.sendBinary(s) } } else if (this.models) for (let e = 0; e < this.models.length; e++) { const t = this.models[e]; t.dontSave = !0, t.update(this, null), this.context.connection.send("TestSimulateUserData-" + e, t) } } } } class sN { constructor(e, t) { u(this, "guid"), u(this, "fast", !1), u(this, "position"), u(this, "rotation"), u(this, "velocity"), u(this, "dontSave"), this.guid = e, this.position = { x: 0, y: 0, z: 0 }, this.rotation = { x: 0, y: 0, z: 0, w: 0 }, this.update(t, null) } isValid() { return this.fast !== void 0 || this.position !== void 0 || this.rotation !== void 0 || this.velocity !== void 0 } update(e, t) { const s = e.worldPosition; this.position.x = s.x, this.position.y = s.y, this.position.z = s.z; const r = e.worldQuaternion; if (this.rotation.x = r.x, this.rotation.y = r.y, this.rotation.z = r.z, this.rotation.w = r.w, this.fast = !1, t) { const n = t.getVelocity(); this.velocity === void 0 && (this.velocity = { x: 0, y: 0, z: 0 }), this.velocity.x = n.x, this.velocity.y = n.y, this.velocity.z = n.z } } } u(sN, "temp", new S); class Xc { constructor(e) { u(this, "id"), u(this, "content", ""), u(this, "font", []), u(this, "pointSize", 144), u(this, "width"), u(this, "height"), u(this, "depth"), u(this, "wrapMode"), u(this, "horizontalAlignment"), u(this, "verticalAlignment"), this.id = e } static getId() { return this.global_id++ } setDepth(e) { return this.depth = e, this } setPointSize(e) { return this.pointSize = e, this } setHorizontalAlignment(e) { return this.horizontalAlignment = e, this } setVerticalAlignment(e) { return this.verticalAlignment = e, this } writeTo(e, t) { var s; t.beginBlock(`def Preliminary_Text "${this.id}"`), this.content && t.appendLine(`string content = "${this.content}"`), (!this.font || this.font.length <= 0) && (this.font || (this.font = []), (s = this.font) == null || s.push("sans-serif")); const r = this.font.map(n => `"${n}"`).join(", "); t.appendLine(`string[] font = [ ${r} ]`), t.appendLine(`double pointSize = ${this.pointSize}`), typeof this.width == "number" && t.appendLine(`double width = ${this.width}`), typeof this.height == "number" && t.appendLine(`double height = ${this.height}`), typeof this.depth == "number" && t.appendLine(`double depth = ${this.depth}`), this.wrapMode && t.appendLine(`token wrapMode = "${this.wrapMode}"`), this.horizontalAlignment && t.appendLine(`token horizontalAlignment = "${this.horizontalAlignment}"`), this.verticalAlignment && t.appendLine(`token verticalAlignment = "${this.verticalAlignment}"`), t.closeBlock() } } u(Xc, "global_id", 0); class g_ { static singleLine(e, t, s) { const r = new Xc("text_" + Xc.getId()); return r.content = e, t && (r.pointSize = t), s && (r.depth = s), r } static multiLine(e, t, s, r, n, o) { const a = new Xc("text_" + Xc.getId()); return a.content = e, a.width = t, a.height = s, a.horizontalAlignment = r, a.verticalAlignment = n, o && (a.wrapMode = o), a } } class $M { onExportObject(e, t, s) { t.addEventListener("serialize", (r, n) => { const o = g_.multiLine("Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.", 1, 1, "justified", "top"); o.pointSize = 300, o.depth = .01, o.writeTo(void 0, r) }) } } var zre = Object.defineProperty, jre = Object.getOwnPropertyDescriptor, Np = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? jre(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && zre(e, t, r), r }; class da extends Ir { constructor() { super(...arguments), u(this, "offset"), u(this, "rotation"), u(this, "focusArea"), u(this, "feather"), u(this, "kernelSize"), u(this, "resolutionScale") } get typeName() { return "TiltShiftEffect" } init() { this.offset.defaultValue = 0, this.rotation.defaultValue = 0, this.focusArea.defaultValue = .4, this.feather.defaultValue = .3, this.kernelSize.defaultValue = Ya.MEDIUM, this.resolutionScale.defaultValue = 1 / window.devicePixelRatio } onCreateEffect() { console.log(this); const e = new eq({ kernelSize: Ya.VERY_LARGE }); return this.offset.onValueChanged = t => e.offset = t, this.rotation.onValueChanged = t => e.rotation = t, this.focusArea.onValueChanged = t => e.focusArea = t, this.feather.onValueChanged = t => e.feather = t, this.kernelSize.onValueChanged = t => e.blurPass.kernelSize = t, this.resolutionScale.onValueChanged = t => e.resolution.scale = t / window.devicePixelRatio, e } } Np([x(Dt)], da.prototype, "offset", 2), Np([x(Dt)], da.prototype, "rotation", 2), Np([x(Dt)], da.prototype, "focusArea", 2), Np([x(Dt)], da.prototype, "feather", 2), Np([x(Dt)], da.prototype, "kernelSize", 2), Np([x(Dt)], da.prototype, "resolutionScale", 2), ta("TiltShiftEffect", da); var Qre = Object.defineProperty, Gre = Object.getOwnPropertyDescriptor, Hre = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? Gre(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && Qre(e, t, r), r }; class iv extends Ir { constructor() { super(...arguments), u(this, "mode") } get typeName() { return "ToneMapping" } get isToneMapping() { return !0 } init() { this.mode.defaultValue = fr } apply() { this.mode.onValueChanged = this._apply.bind(this), this._apply(this.mode.value) } unapply() { this.context.renderer.toneMapping = fr } _apply(e) { switch (e) { case 0: this.context.renderer.toneMapping = uf; break; case 1: this.context.renderer.toneMapping = hx; break; case 2: this.context.renderer.toneMapping = ux; break } } } Hre([x(Dt)], iv.prototype, "mode", 2), ta("Tonemapping", iv); const gu = new hd, qr = new S, Yc = new S, Ii = new we, rN = { X: new S(1, 0, 0), Y: new S(0, 1, 0), Z: new S(0, 0, 1) }, eI = { type: "change" }, nN = { type: "mouseDown" }, oN = { type: "mouseUp", mode: null }, aN = { type: "objectChange" }; class Vre extends Me { constructor(e, t) { super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none"; const s = new Kre; this._gizmo = s, this.add(s); const r = new Zre; this._plane = r, this.add(r); const n = this; function o(b, y) { let _ = y; Object.defineProperty(n, b, { get: function () { return _ !== void 0 ? _ : y }, set: function (w) { _ !== w && (_ = w, r[b] = w, s[b] = w, n.dispatchEvent({ type: b + "-changed", value: w }), n.dispatchEvent(eI)) } }), n[b] = y, r[b] = y, s[b] = y } o("camera", e), o("object", void 0), o("enabled", !0), o("axis", null), o("mode", "translate"), o("translationSnap", null), o("rotationSnap", null), o("scaleSnap", null), o("space", "world"), o("size", 1), o("dragging", !1), o("showX", !0), o("showY", !0), o("showZ", !0); const a = new S, l = new S, c = new we, h = new we, d = new S, p = new we, f = new S, g = new S, m = new S, v = 0, A = new S; o("worldPosition", a), o("worldPositionStart", l), o("worldQuaternion", c), o("worldQuaternionStart", h), o("cameraPosition", d), o("cameraQuaternion", p), o("pointStart", f), o("pointEnd", g), o("rotationAxis", m), o("rotationAngle", v), o("eye", A), this._offset = new S, this._startNorm = new S, this._endNorm = new S, this._cameraScale = new S, this._parentPosition = new S, this._parentQuaternion = new we, this._parentQuaternionInv = new we, this._parentScale = new S, this._worldScaleStart = new S, this._worldQuaternionInv = new we, this._worldScale = new S, this._positionStart = new S, this._quaternionStart = new we, this._scaleStart = new S, this._getPointer = Wre.bind(this), this._onPointerDown = Xre.bind(this), this._onPointerHover = qre.bind(this), this._onPointerMove = Yre.bind(this), this._onPointerUp = Jre.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp) } updateMatrixWorld() { this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this) } pointerHover(e) { if (this.object === void 0 || this.dragging === !0) return; gu.setFromCamera(e, this.camera); const t = tI(this._gizmo.picker[this.mode], gu); t ? this.axis = t.object.name : this.axis = null } pointerDown(e) { if (!(this.object === void 0 || this.dragging === !0 || e.button !== 0) && this.axis !== null) { gu.setFromCamera(e, this.camera); const t = tI(this._plane, gu, !0); t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, nN.mode = this.mode, this.dispatchEvent(nN) } } pointerMove(e) { const t = this.axis, s = this.mode, r = this.object; let n = this.space; if (s === "scale" ? n = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (n = "world"), r === void 0 || t === null || this.dragging === !1 || e.button !== -1) return; gu.setFromCamera(e, this.camera); const o = tI(this._plane, gu, !0); if (o) { if (this.pointEnd.copy(o.point).sub(this.worldPositionStart), s === "translate") this._offset.copy(this.pointEnd).sub(this.pointStart), n === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), n === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), r.position.copy(this._offset).add(this._positionStart), this.translationSnap && (n === "local" && (r.position.applyQuaternion(Ii.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this._quaternionStart)), n === "world" && (r.parent && r.position.add(qr.setFromMatrixPosition(r.parent.matrixWorld)), t.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(qr.setFromMatrixPosition(r.parent.matrixWorld)))); else if (s === "scale") { if (t.search("XYZ") !== -1) { let a = this.pointEnd.length() / this.pointStart.length(); this.pointEnd.dot(this.pointStart) < 0 && (a *= -1), Yc.set(a, a, a) } else qr.copy(this.pointStart), Yc.copy(this.pointEnd), qr.applyQuaternion(this._worldQuaternionInv), Yc.applyQuaternion(this._worldQuaternionInv), Yc.divide(qr), t.search("X") === -1 && (Yc.x = 1), t.search("Y") === -1 && (Yc.y = 1), t.search("Z") === -1 && (Yc.z = 1); r.scale.copy(this._scaleStart).multiply(Yc), this.scaleSnap && (t.search("X") !== -1 && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap)) } else if (s === "rotate") { this._offset.copy(this.pointEnd).sub(this.pointStart); const a = 20 / this.worldPosition.distanceTo(qr.setFromMatrixPosition(this.camera.matrixWorld)); t === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(qr.copy(this.rotationAxis).cross(this.eye)) * a) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(rN[t]), qr.copy(rN[t]), n === "local" && qr.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(qr.cross(this.eye).normalize()) * a), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), n === "local" && t !== "E" && t !== "XYZE" ? (r.quaternion.copy(this._quaternionStart), r.quaternion.multiply(Ii.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r.quaternion.copy(Ii.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this._quaternionStart).normalize()) } this.dispatchEvent(eI), this.dispatchEvent(aN) } } pointerUp(e) { e.button === 0 && (this.dragging && this.axis !== null && (oN.mode = this.mode, this.dispatchEvent(oN)), this.dragging = !1, this.axis = null) } dispose() { this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function (e) { e.geometry && e.geometry.dispose(), e.material && e.material.dispose() }) } attach(e) { return this.object = e, this.visible = !0, this } detach() { return this.object = void 0, this.visible = !1, this.axis = null, this } reset() { this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(eI), this.dispatchEvent(aN), this.pointStart.copy(this.pointEnd)) } getRaycaster() { return gu } getMode() { return this.mode } setMode(e) { this.mode = e } setTranslationSnap(e) { this.translationSnap = e } setRotationSnap(e) { this.rotationSnap = e } setScaleSnap(e) { this.scaleSnap = e } setSize(e) { this.size = e } setSpace(e) { this.space = e } } function Wre(i) { if (this.domElement.ownerDocument.pointerLockElement) return { x: 0, y: 0, button: i.button }; { const e = this.domElement.getBoundingClientRect(); return { x: (i.clientX - e.left) / e.width * 2 - 1, y: -(i.clientY - e.top) / e.height * 2 + 1, button: i.button } } } function qre(i) { if (this.enabled) switch (i.pointerType) { case "mouse": case "pen": this.pointerHover(this._getPointer(i)); break } } function Xre(i) { this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(i.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(i)), this.pointerDown(this._getPointer(i))) } function Yre(i) { this.enabled && this.pointerMove(this._getPointer(i)) } function Jre(i) { this.enabled && (this.domElement.releasePointerCapture(i.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(i))) } function tI(i, e, t) { const s = e.intersectObject(i, !0); for (let r = 0; r < s.length; r++)if (s[r].object.visible || t) return s[r]; return !1 } const m_ = new ps, Ai = new S(0, 1, 0), lN = new S(0, 0, 0), cN = new He, v_ = new we, A_ = new we, pa = new S, hN = new He, sv = new S(1, 0, 0), mu = new S(0, 1, 0), rv = new S(0, 0, 1), y_ = new S, nv = new S, ov = new S; class Kre extends Me { constructor() { super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo"; const e = new di({ depthTest: !1, depthWrite: !1, fog: !1, toneMapped: !1, transparent: !0 }), t = new Hi({ depthTest: !1, depthWrite: !1, fog: !1, toneMapped: !1, transparent: !0 }), s = e.clone(); s.opacity = .15; const r = t.clone(); r.opacity = .5; const n = e.clone(); n.color.setHex(16711680); const o = e.clone(); o.color.setHex(65280); const a = e.clone(); a.color.setHex(255); const l = e.clone(); l.color.setHex(16711680), l.opacity = .5; const c = e.clone(); c.color.setHex(65280), c.opacity = .5; const h = e.clone(); h.color.setHex(255), h.opacity = .5; const d = e.clone(); d.opacity = .25; const p = e.clone(); p.color.setHex(16776960), p.opacity = .25, e.clone().color.setHex(16776960); const f = e.clone(); f.color.setHex(7895160); const g = new ji(0, .04, .1, 12); g.translate(0, .05, 0); const m = new pi(.08, .08, .08); m.translate(0, .04, 0); const v = new yt; v.setAttribute("position", new et([0, 0, 0, 1, 0, 0], 3)); const A = new ji(.0075, .0075, .5, 3); A.translate(0, .25, 0); function b(F, X) { const te = new ya(F, .0075, 3, 64, X * Math.PI * 2); return te.rotateY(Math.PI / 2), te.rotateX(Math.PI / 2), te } function y() { const F = new yt; return F.setAttribute("position", new et([0, 0, 0, 1, 1, 1], 3)), F } const _ = { X: [[new ye(g, n), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new ye(g, n), [-.5, 0, 0], [0, 0, Math.PI / 2]], [new ye(A, n), [0, 0, 0], [0, 0, -Math.PI / 2]]], Y: [[new ye(g, o), [0, .5, 0]], [new ye(g, o), [0, -.5, 0], [Math.PI, 0, 0]], [new ye(A, o)]], Z: [[new ye(g, a), [0, 0, .5], [Math.PI / 2, 0, 0]], [new ye(g, a), [0, 0, -.5], [-Math.PI / 2, 0, 0]], [new ye(A, a), null, [Math.PI / 2, 0, 0]]], XYZ: [[new ye(new Aa(.1, 0), d.clone()), [0, 0, 0]]], XY: [[new ye(new pi(.15, .15, .01), h.clone()), [.15, .15, 0]]], YZ: [[new ye(new pi(.15, .15, .01), l.clone()), [0, .15, .15], [0, Math.PI / 2, 0]]], XZ: [[new ye(new pi(.15, .15, .01), c.clone()), [.15, 0, .15], [-Math.PI / 2, 0, 0]]] }, w = { X: [[new ye(new ji(.2, 0, .6, 4), s), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new ye(new ji(.2, 0, .6, 4), s), [-.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new ye(new ji(.2, 0, .6, 4), s), [0, .3, 0]], [new ye(new ji(.2, 0, .6, 4), s), [0, -.3, 0], [0, 0, Math.PI]]], Z: [[new ye(new ji(.2, 0, .6, 4), s), [0, 0, .3], [Math.PI / 2, 0, 0]], [new ye(new ji(.2, 0, .6, 4), s), [0, 0, -.3], [-Math.PI / 2, 0, 0]]], XYZ: [[new ye(new Aa(.2, 0), s)]], XY: [[new ye(new pi(.2, .2, .01), s), [.15, .15, 0]]], YZ: [[new ye(new pi(.2, .2, .01), s), [0, .15, .15], [0, Math.PI / 2, 0]]], XZ: [[new ye(new pi(.2, .2, .01), s), [.15, 0, .15], [-Math.PI / 2, 0, 0]]] }, E = { START: [[new ye(new Aa(.01, 2), r), null, null, null, "helper"]], END: [[new ye(new Aa(.01, 2), r), null, null, null, "helper"]], DELTA: [[new Vi(y(), r), null, null, null, "helper"]], X: [[new Vi(v, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new Vi(v, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new Vi(v, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] }, P = { XYZE: [[new ye(b(.5, 1), f), null, [0, Math.PI / 2, 0]]], X: [[new ye(b(.5, .5), n)]], Y: [[new ye(b(.5, .5), o), null, [0, 0, -Math.PI / 2]]], Z: [[new ye(b(.5, .5), a), null, [0, Math.PI / 2, 0]]], E: [[new ye(b(.75, 1), p), null, [0, Math.PI / 2, 0]]] }, C = { AXIS: [[new Vi(v, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]] }, R = { XYZE: [[new ye(new Zn(.25, 10, 8), s)]], X: [[new ye(new ya(.5, .1, 4, 24), s), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]], Y: [[new ye(new ya(.5, .1, 4, 24), s), [0, 0, 0], [Math.PI / 2, 0, 0]]], Z: [[new ye(new ya(.5, .1, 4, 24), s), [0, 0, 0], [0, 0, -Math.PI / 2]]], E: [[new ye(new ya(.75, .1, 2, 24), s)]] }, T = { X: [[new ye(m, n), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new ye(A, n), [0, 0, 0], [0, 0, -Math.PI / 2]], [new ye(m, n), [-.5, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new ye(m, o), [0, .5, 0]], [new ye(A, o)], [new ye(m, o), [0, -.5, 0], [0, 0, Math.PI]]], Z: [[new ye(m, a), [0, 0, .5], [Math.PI / 2, 0, 0]], [new ye(A, a), [0, 0, 0], [Math.PI / 2, 0, 0]], [new ye(m, a), [0, 0, -.5], [-Math.PI / 2, 0, 0]]], XY: [[new ye(new pi(.15, .15, .01), h), [.15, .15, 0]]], YZ: [[new ye(new pi(.15, .15, .01), l), [0, .15, .15], [0, Math.PI / 2, 0]]], XZ: [[new ye(new pi(.15, .15, .01), c), [.15, 0, .15], [-Math.PI / 2, 0, 0]]], XYZ: [[new ye(new pi(.1, .1, .1), d.clone())]] }, z = { X: [[new ye(new ji(.2, 0, .6, 4), s), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new ye(new ji(.2, 0, .6, 4), s), [-.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new ye(new ji(.2, 0, .6, 4), s), [0, .3, 0]], [new ye(new ji(.2, 0, .6, 4), s), [0, -.3, 0], [0, 0, Math.PI]]], Z: [[new ye(new ji(.2, 0, .6, 4), s), [0, 0, .3], [Math.PI / 2, 0, 0]], [new ye(new ji(.2, 0, .6, 4), s), [0, 0, -.3], [-Math.PI / 2, 0, 0]]], XY: [[new ye(new pi(.2, .2, .01), s), [.15, .15, 0]]], YZ: [[new ye(new pi(.2, .2, .01), s), [0, .15, .15], [0, Math.PI / 2, 0]]], XZ: [[new ye(new pi(.2, .2, .01), s), [.15, 0, .15], [-Math.PI / 2, 0, 0]]], XYZ: [[new ye(new pi(.2, .2, .2), s), [0, 0, 0]]] }, H = { X: [[new Vi(v, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new Vi(v, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new Vi(v, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] }; function N(F) { const X = new Me; for (const te in F) for (let re = F[te].length; re--;) { const Z = F[te][re][0].clone(), fe = F[te][re][1], ae = F[te][re][2], De = F[te][re][3], Se = F[te][re][4]; Z.name = te, Z.tag = Se, fe && Z.position.set(fe[0], fe[1], fe[2]), ae && Z.rotation.set(ae[0], ae[1], ae[2]), De && Z.scale.set(De[0], De[1], De[2]), Z.updateMatrix(); const ie = Z.geometry.clone(); ie.applyMatrix4(Z.matrix), Z.geometry = ie, Z.renderOrder = 1 / 0, Z.position.set(0, 0, 0), Z.rotation.set(0, 0, 0), Z.scale.set(1, 1, 1), X.add(Z) } return X } this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = N(_)), this.add(this.gizmo.rotate = N(P)), this.add(this.gizmo.scale = N(T)), this.add(this.picker.translate = N(w)), this.add(this.picker.rotate = N(R)), this.add(this.picker.scale = N(z)), this.add(this.helper.translate = N(E)), this.add(this.helper.rotate = N(C)), this.add(this.helper.scale = N(H)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1 } updateMatrixWorld(e) { const t = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : A_; this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale"; let s = []; s = s.concat(this.picker[this.mode].children), s = s.concat(this.gizmo[this.mode].children), s = s.concat(this.helper[this.mode].children); for (let r = 0; r < s.length; r++) { const n = s[r]; n.visible = !0, n.rotation.set(0, 0, 0), n.position.copy(this.worldPosition); let o; if (this.camera.isOrthographicCamera ? o = (this.camera.top - this.camera.bottom) / this.camera.zoom : o = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), n.scale.set(1, 1, 1).multiplyScalar(o * this.size / 4), n.tag === "helper") { n.visible = !1, n.name === "AXIS" ? (n.position.copy(this.worldPositionStart), n.visible = !!this.axis, this.axis === "X" && (Ii.setFromEuler(m_.set(0, 0, 0)), n.quaternion.copy(t).multiply(Ii), Math.abs(Ai.copy(sv).applyQuaternion(t).dot(this.eye)) > .9 && (n.visible = !1)), this.axis === "Y" && (Ii.setFromEuler(m_.set(0, 0, Math.PI / 2)), n.quaternion.copy(t).multiply(Ii), Math.abs(Ai.copy(mu).applyQuaternion(t).dot(this.eye)) > .9 && (n.visible = !1)), this.axis === "Z" && (Ii.setFromEuler(m_.set(0, Math.PI / 2, 0)), n.quaternion.copy(t).multiply(Ii), Math.abs(Ai.copy(rv).applyQuaternion(t).dot(this.eye)) > .9 && (n.visible = !1)), this.axis === "XYZE" && (Ii.setFromEuler(m_.set(0, Math.PI / 2, 0)), Ai.copy(this.rotationAxis), n.quaternion.setFromRotationMatrix(cN.lookAt(lN, Ai, mu)), n.quaternion.multiply(Ii), n.visible = this.dragging), this.axis === "E" && (n.visible = !1)) : n.name === "START" ? (n.position.copy(this.worldPositionStart), n.visible = this.dragging) : n.name === "END" ? (n.position.copy(this.worldPosition), n.visible = this.dragging) : n.name === "DELTA" ? (n.position.copy(this.worldPositionStart), n.quaternion.copy(this.worldQuaternionStart), qr.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), qr.applyQuaternion(this.worldQuaternionStart.clone().invert()), n.scale.copy(qr), n.visible = this.dragging) : (n.quaternion.copy(t), this.dragging ? n.position.copy(this.worldPositionStart) : n.position.copy(this.worldPosition), this.axis && (n.visible = this.axis.search(n.name) !== -1)); continue } n.quaternion.copy(t), this.mode === "translate" || this.mode === "scale" ? (n.name === "X" && Math.abs(Ai.copy(sv).applyQuaternion(t).dot(this.eye)) > .99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), n.name === "Y" && Math.abs(Ai.copy(mu).applyQuaternion(t).dot(this.eye)) > .99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), n.name === "Z" && Math.abs(Ai.copy(rv).applyQuaternion(t).dot(this.eye)) > .99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), n.name === "XY" && Math.abs(Ai.copy(rv).applyQuaternion(t).dot(this.eye)) < .2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), n.name === "YZ" && Math.abs(Ai.copy(sv).applyQuaternion(t).dot(this.eye)) < .2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), n.name === "XZ" && Math.abs(Ai.copy(mu).applyQuaternion(t).dot(this.eye)) < .2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1)) : this.mode === "rotate" && (v_.copy(t), Ai.copy(this.eye).applyQuaternion(Ii.copy(t).invert()), n.name.search("E") !== -1 && n.quaternion.setFromRotationMatrix(cN.lookAt(this.eye, lN, mu)), n.name === "X" && (Ii.setFromAxisAngle(sv, Math.atan2(-Ai.y, Ai.z)), Ii.multiplyQuaternions(v_, Ii), n.quaternion.copy(Ii)), n.name === "Y" && (Ii.setFromAxisAngle(mu, Math.atan2(Ai.x, Ai.z)), Ii.multiplyQuaternions(v_, Ii), n.quaternion.copy(Ii)), n.name === "Z" && (Ii.setFromAxisAngle(rv, Math.atan2(Ai.y, Ai.x)), Ii.multiplyQuaternions(v_, Ii), n.quaternion.copy(Ii))), n.visible = n.visible && (n.name.indexOf("X") === -1 || this.showX), n.visible = n.visible && (n.name.indexOf("Y") === -1 || this.showY), n.visible = n.visible && (n.name.indexOf("Z") === -1 || this.showZ), n.visible = n.visible && (n.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), n.material._color = n.material._color || n.material.color.clone(), n.material._opacity = n.material._opacity || n.material.opacity, n.material.color.copy(n.material._color), n.material.opacity = n.material._opacity, this.enabled && this.axis && (n.name === this.axis || this.axis.split("").some(function (a) { return n.name === a })) && (n.material.color.setHex(16776960), n.material.opacity = 1) } super.updateMatrixWorld(e) } } class Zre extends ye { constructor() { super(new ks(1e5, 1e5, 2, 2), new di({ visible: !1, wireframe: !0, side: yi, transparent: !0, opacity: .1, toneMapped: !1 })), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane" } updateMatrixWorld(e) { let t = this.space; switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), y_.copy(sv).applyQuaternion(t === "local" ? this.worldQuaternion : A_), nv.copy(mu).applyQuaternion(t === "local" ? this.worldQuaternion : A_), ov.copy(rv).applyQuaternion(t === "local" ? this.worldQuaternion : A_), Ai.copy(nv), this.mode) { case "translate": case "scale": switch (this.axis) { case "X": Ai.copy(this.eye).cross(y_), pa.copy(y_).cross(Ai); break; case "Y": Ai.copy(this.eye).cross(nv), pa.copy(nv).cross(Ai); break; case "Z": Ai.copy(this.eye).cross(ov), pa.copy(ov).cross(Ai); break; case "XY": pa.copy(ov); break; case "YZ": pa.copy(y_); break; case "XZ": Ai.copy(ov), pa.copy(nv); break; case "XYZ": case "E": pa.set(0, 0, 0); break }break; case "rotate": default: pa.set(0, 0, 0) }pa.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (hN.lookAt(qr.set(0, 0, 0), pa, Ai), this.quaternion.setFromRotationMatrix(hN)), super.updateMatrixWorld(e) } } var $re = Object.defineProperty, ene = Object.getOwnPropertyDescriptor, b_ = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? ene(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && $re(e, t, r), r }; class vu extends Ee { constructor() { super(...arguments), u(this, "isGizmo", !1), u(this, "translationSnap", 1), u(this, "rotationSnapAngle", 15), u(this, "scaleSnap", .25), u(this, "control"), u(this, "orbit"), u(this, "changeEventListener"), u(this, "windowKeyDownListener"), u(this, "windowKeyUpListener") } onEnable() { var e; this.isGizmo && !Vf || this.context.mainCamera && (this.control || (this.control = new Vre(this.context.mainCamera, this.context.domElement), this.control.visible = !0, this.control.enabled = !0, this.control.getRaycaster().layers.set(2), this.control.size = 1, this.control.traverse(t => { const s = t; if (s.layers.set(2), s) { const r = s.material; r && (r.opacity = .3) } }), this.orbit = $.getComponentInParent(this.context.mainCamera, OL) ?? void 0), this.control && (this.context.scene.add(this.control), this.control.attach(this.gameObject), this.changeEventListener = this.onControlChangedEvent.bind(this), (e = this.control) == null || e.addEventListener("dragging-changed", this.changeEventListener), this.addWindowEvents())) } onDisable() { var e, t; (e = this.control) == null || e.removeFromParent(), this.changeEventListener && ((t = this.control) == null || t.removeEventListener("dragging-changed", this.changeEventListener)), this.removeWindowEvents() } enableSnapping() { this.control && (this.control.setTranslationSnap(this.translationSnap), this.control.setRotationSnap(kr.degToRad(this.rotationSnapAngle)), this.control.setScaleSnap(this.scaleSnap)) } disableSnapping() { this.control && (this.control.setTranslationSnap(null), this.control.setRotationSnap(null), this.control.setScaleSnap(null)) } onControlChangedEvent(e) { const t = this.orbit; if (t && (t.enabled = !e.value), e.value) { const s = $.getComponentInParent(this.gameObject, Ic); s && s.requestOwnership() } } addWindowEvents() { const e = this.control; e && (this.windowKeyDownListener || (this.windowKeyDownListener = t => { if (this.enabled) switch (t.keyCode) { case 81: e.setSpace(e.space === "local" ? "world" : "local"); break; case 16: this.enableSnapping(); break; case 87: e.setMode("translate"); break; case 69: e.setMode("rotate"); break; case 82: e.setMode("scale"); break; case 187: case 107: e.setSize(e.size + .1); break; case 189: case 109: e.setSize(Math.max(e.size - .1, .1)); break; case 88: e.showX = !e.showX; break; case 89: e.showY = !e.showY; break; case 90: e.showZ = !e.showZ; break; case 32: e.enabled = !e.enabled; break } }), this.windowKeyUpListener || (this.windowKeyUpListener = t => { if (this.enabled) switch (t.keyCode) { case 16: this.disableSnapping(); break } }), window.addEventListener("keydown", this.windowKeyDownListener), window.addEventListener("keyup", this.windowKeyUpListener)) } removeWindowEvents() { window.removeEventListener("keydown", this.windowKeyDownListener), window.removeEventListener("keyup", this.windowKeyUpListener) } } b_([x()], vu.prototype, "isGizmo", 2), b_([x()], vu.prototype, "translationSnap", 2), b_([x()], vu.prototype, "rotationSnapAngle", 2), b_([x()], vu.prototype, "scaleSnap", 2); var tne = Object.defineProperty, ine = Object.getOwnPropertyDescriptor, iI = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? ine(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && tne(e, t, r), r }; class Au extends Ir { constructor() { super(...arguments), u(this, "color"), u(this, "intensity"), u(this, "center") } get typeName() { return "Vignette" } init() { this.color.defaultValue = { r: 0, g: 0, b: 0, a: 1 }, this.intensity.defaultValue = 0, this.center.defaultValue = { x: .5, y: .5 } } onCreateEffect() { const e = new eD; return this.intensity.onValueChanged = t => { e.offset = t, this.updateDarkness(e) }, this.color.onValueChanged = t => { this.updateDarkness(e) }, e } updateDarkness(e) { const t = this.intensity.value; e.darkness = t } } iI([x(Dt)], Au.prototype, "color", 2), iI([x(Dt)], Au.prototype, "intensity", 2), iI([x(Dt)], Au.prototype, "center", 2), ta("Vignette", Au); var sne = Object.defineProperty, rne = Object.getOwnPropertyDescriptor, nne = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? rne(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && sne(e, t, r), r }; const sI = oe("debugpost"); class __ extends Ee { constructor() { super(...arguments), u(this, "sharedProfile"), u(this, "_postprocessing"), u(this, "_effects", []), u(this, "_lastApplyTime"), u(this, "_rapidApplyCount", 0), u(this, "_modificationQueue"), u(this, "_recreateId", -1) } awake() { var e; (e = this.sharedProfile) == null || e.init(), sI && (console.log(this), console.log("Press P to toggle post processing"), window.addEventListener("keydown", t => { t.key === "p" && (console.log("Toggle volume: " + this.name, !this.enabled), this.enabled = !this.enabled) })) } onDisable() { var e; (e = this._postprocessing) == null || e.unapply() } onBeforeRender() { if (!this.context.isInXR) { if (this.context.composer && !(this.context.composer instanceof rC)) return; this.context.mainCamera && (!this._postprocessing || !this._postprocessing.isActive) && this.apply(), this.context.composer && (this.context.composer.setRenderer(this.context.renderer), this.context.composer.setMainScene(this.context.scene), this.context.mainCamera && this.context.composer.setMainCamera(this.context.mainCamera)) } } onDestroy() { var e; (e = this._postprocessing) == null || e.dispose() } apply() { var e, t; sI && console.log("Apply PostProcessing", this, (e = this.context.mainCamera) == null ? void 0 : e.name), Mn() && (this._lastApplyTime !== void 0 && Date.now() - this._lastApplyTime < 100 && (this._rapidApplyCount++, this._rapidApplyCount === 5 && console.warn("Detected rapid post processing modifications - this might be a bug", this)), this._lastApplyTime = Date.now()), this.unapply(), this._effects.length = 0, (t = this.sharedProfile) != null && t.components && this._effects.push(...this.sharedProfile.components); const s = this.gameObject.getComponentsInChildren(Ir); if (sI && s != null && s.length && console.log("Additional", s), s) for (const r of s) r.active && this._effects.push(r); this._effects.length > 0 && (this._postprocessing || (this._postprocessing = new n_(this.context)), this._postprocessing.apply(this._effects), this._applyPostQueue()) } unapply() { var e; (e = this._postprocessing) == null || e.unapply() } _applyPostQueue() { if (this._modificationQueue) { for (const e of this._modificationQueue.values()) this.onEditorModification(e); this._modificationQueue.clear() } } onEditorModification(e) { var t, s; if (e.propertyName.startsWith("postprocessing.")) { if (!this._postprocessing) return this._modificationQueue || (this._modificationQueue = new Map), this._modificationQueue.set(e.propertyName, e), !0; if (!((t = this._effects) != null && t.length)) return; const r = e.propertyName.split("."); if (r.length === 3 || r.length === 4) { const n = r[1], o = r[2]; for (const a of this._effects) if (((s = a.typeName) == null ? void 0 : s.toLowerCase()) === n.toLowerCase()) { if (o === "active") { a.active = e.value, this.scheduleRecreate(); return } if (!x_.has(n)) { const l = new Array; x_.set(n, l); const c = Object.keys(a); for (const h of c) a[h] instanceof Dt && l.push(h) } if (x_.has(n)) { const l = o.toLowerCase(), c = x_.get(n); for (const h of c) if (h.toLowerCase() === l) { const d = a[h]; d instanceof Dt && (r.length === 4 && r[3] === "active" ? (d.overrideState = e.value, this.scheduleRecreate()) : d && d.value !== void 0 && (d.value = e.value)); return } } console.warn("Unknown modification", o); return } } return !0 } return !1 } scheduleRecreate() { const e = ++this._recreateId; setTimeout(() => { e === this._recreateId && (this.onDisable(), this.onEnable()) }, 200) } } nne([Cd(mm)], __.prototype, "sharedProfile", 2); const x_ = new Map; var one = Object.defineProperty, ane = Object.getOwnPropertyDescriptor, lne = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? ane(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && one(e, t, r), r }; class w_ extends Ee { constructor() { super(...arguments), u(this, "backgroundTint", new mi(1, 1, 1, 1)), u(this, "_preRender"), u(this, "backgroundPlane"), u(this, "threeTexture"), u(this, "forceTextureInitialization", function () { const e = new di, t = new ks, s = new Cn; s.add(new ye(t, e)); const r = new gh; return function (n, o) { e.map = o, n.render(s, r) } }()) } awake() { wt.OptionalFeatures_AR.push("camera-access") } get background() { return this.backgroundPlane } onEnable() { this._preRender = this.preRender.bind(this), this.context.pre_render_callbacks.push(this._preRender), this.backgroundPlane && (this.gameObject.add(this.backgroundPlane), this.backgroundPlane.visible = !1) } onDisable() { this.context.pre_render_callbacks = this.context.pre_render_callbacks.filter(e => e !== this._preRender), this.backgroundPlane && this.gameObject.remove(this.backgroundPlane) } preRender() { if (!this || !this.gameObject) return; const e = this.context.renderer.xr.getFrame(); e && (!this.threeTexture && this.context.renderer && (this.threeTexture = new Nt, this.forceTextureInitialization(this.context.renderer, this.threeTexture)), this.backgroundPlane === void 0 && (this.backgroundPlane = hne(this.backgroundTint), this.gameObject.add(this.backgroundPlane)), this.updateFromFrame(e)) } onBeforeRender(e) { this.updateFromFrame(e) } updateFromFrame(e) { if (!e) return; const t = e.getViewerPose(this.context.renderer.xr.getReferenceSpace()); if (t) { for (const s of t.views) if ("camera" in s && s.camera) { let r = this.context.renderer.xr.getBinding(); if (r || (r = new XRWebGLBinding(e.session, this.context.renderer.getContext())), r) { let n = null; if ("getCameraImage" in r) { n = r.getCameraImage(s.camera); const o = this.context.renderer.properties.get(this.threeTexture); o.__webglTexture = n, this.backgroundPlane && (this.backgroundPlane.setTexture(this.threeTexture), this.backgroundPlane.visible = !0) } } } } } } lne([x()], w_.prototype, "backgroundTint", 2); let cne = `
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );
    texColor.w = 1.0;

    // inline sRGB decode
    texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    gl_FragColor = texColor * <backgroundTint>;

    #include <tonemapping_fragment>
    #include <encodings_fragment>

}
`; function hne(i) { const e = "vec4(" + i.r.toFixed(3) + "," + i.g.toFixed(3) + "," + i.b.toFixed(3) + "," + i.a.toFixed(3) + ")"; console.log(e); const t = new ye(new ks(2, 2), new Vt({ name: "BackgroundMaterial", uniforms: ow.clone(en.background.uniforms), vertexShader: en.background.vertexShader, fragmentShader: cne.replace("<backgroundTint>", e), side: yi, depthTest: !1, depthWrite: !1, fog: !1 })); return t.geometry.deleteAttribute("normal"), Object.defineProperty(t.material, "map", { get: function () { return this.threeTexture } }), t.renderOrder = -1e4, t.layers.disableAll(), t.layers.enable(2), t.frustumCulled = !1, t.setTexture = function (s) { t.material.uniforms.t2D.value = s }, t } var une = Object.defineProperty, dne = Object.getOwnPropertyDescriptor, zp = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? dne(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && une(e, t, r), r }; const pne = oe("debugimagetracking"), C_ = class { constructor(i, e, t, s, r, n) { u(this, "measuredSize"), u(this, "state"), u(this, "_position"), u(this, "_rotation"), u(this, "_trackingComponent"), u(this, "_trackedImage"), u(this, "_bitmap"), u(this, "_pose"), this._trackingComponent = i, this._trackedImage = e, this._bitmap = t, this.measuredSize = s, this.state = r, this._pose = n } get url() { return this._trackedImage.image ?? "" } get widthInMeters() { return this._trackedImage.widthInMeters ?? void 0 } get bitmap() { return this._bitmap } get model() { return this._trackedImage } getPosition(i) { return this.ensureTransformData(), i.copy(this._position), i } getQuaternion(i) { return this.ensureTransformData(), i.copy(this._rotation), i } applyToObject(i, e = void 0) { this.ensureTransformData(); const t = i.position.distanceToSquared(this._position) > .05 || i.quaternion.angleTo(this._rotation) > .05; e === void 0 || e >= 1 || t ? (i.position.copy(this._position), i.quaternion.copy(this._rotation)) : (e = Math.max(0, Math.min(1, e)), i.position.lerp(this._position, e), i.quaternion.slerp(this._rotation, e)), i.quaternion.multiply(C_.y180) } ensureTransformData() { if (!this._position) { this._position = C_._positionBuffer.get(), this._rotation = C_._rotationBuffer.get(); const i = this._pose.transform; this._position.set(i.position.x, i.position.y, i.position.z), this._rotation.set(i.orientation.x, i.orientation.y, i.orientation.z, i.orientation.w) } } }; let yu = C_; u(yu, "y180", new we().setFromAxisAngle(new S(0, 1, 0), Math.PI)), u(yu, "_positionBuffer", new To(() => new S, 20)), u(yu, "_rotationBuffer", new To(() => new we, 20)); class Sl { constructor() { u(this, "image"), u(this, "widthInMeters"), u(this, "object"), u(this, "createObjectInstance", !1), u(this, "imageDoesNotMove", !1) } } zp([x(URL)], Sl.prototype, "image", 2), zp([x()], Sl.prototype, "widthInMeters", 2), zp([x(or)], Sl.prototype, "object", 2), zp([x()], Sl.prototype, "createObjectInstance", 2), zp([x()], Sl.prototype, "imageDoesNotMove", 2); class fne { constructor(e, t, s) { u(this, "filename"), u(this, "widthInMeters"), u(this, "imageData"), this.filename = e, this.imageData = t, this.widthInMeters = s } get extensionName() { return "image-tracking" } onAfterHierarchy(e, t) { t.beginBlock('def Preliminary_ReferenceImage "AnchoringReferenceImage"'), t.appendLine("uniform asset image = @tracker/" + this.filename + "@"), t.appendLine("uniform double physicalWidth = " + (this.widthInMeters * 100).toFixed(8)), t.closeBlock() } onAfterSerialize(e) { e.files["tracker/" + this.filename] = this.imageData } } var rI; const av = (rI = class extends Ee { constructor() { super(...arguments), u(this, "trackedImages"), u(this, "trackedImageIndexMap", new Map), u(this, "xr", null), u(this, "onModifyAROptions", i => { var e; const t = i.detail, s = t.optionalFeatures || []; s.includes("image-tracking") || s.push("image-tracking"), t.optionalFeatures = s, t.trackedImages = []; for (const r of this.trackedImages) if ((e = r.image) != null && e.length && r.widthInMeters > 0) { const n = av._imageElements.get(r.image); n && (this.trackedImageIndexMap.set(t.trackedImages.length, r), t.trackedImages.push({ image: n, widthInMeters: r.widthInMeters })) } }), u(this, "imageToObjectMap", new Map), u(this, "onImageTrackingUpdate", i => { const e = i.detail; for (const [t, s] of this.imageToObjectMap) { if (!s.object || !t) continue; let r = !1; for (const n of e) if (n.model === t) { r = !0; break } r || $.setActive(s.object, !1) } for (const t of e) { const s = t.model; if (!s.object) continue; let r = this.imageToObjectMap.get(s); if (r === void 0) r = { object: null, frames: 0 }, this.imageToObjectMap.set(s, r), s.object.loadAssetAsync().then(n => { s.createObjectInstance && (n = $.instantiate(n)), n && (r.object = n, this.xr && this.xr.Rig.add(n), t.applyToObject(n), n.activeSelf || $.setActive(n, !0)) }); else { if (r.frames++, s.imageDoesNotMove && r.frames > 10 || !r.object) continue; this.xr && this.xr.Rig.add(r.object), t.applyToObject(r.object), r.object.activeSelf || $.setActive(r.object, !0) } } }), u(this, "onXRStarted", i => { for (const e of this.imageToObjectMap.values()) e.frames = 0 }), u(this, "onXRUpdate", i => { const e = i.frame; if (e) { if (e.session && !("getImageTrackingResults" in e)) { ao('Image tracking is currently not supported on this device. On Chrome for Android, you can enable the <a href="chrome://flags/#webxr-incubations">chrome://flags/#webxr-incubations</a> flag.'); return } if (e.session && typeof e.getImageTrackingResults == "function") { const t = e.getImageTrackingResults(); if (t.length) { const s = this.context.renderer.xr.getReferenceSpace(); if (s) { const r = []; for (const n of t) { const o = n.index, a = this.trackedImageIndexMap.get(o); if (a) { const l = e.getPose(n.imageSpace, s), c = n.trackingState, h = new yu(this, a, n.image, n.measuredSize, c, l); r.push(h) } else pne && console.warn("No tracked image for index", o) } if (r.length > 0) try { this.dispatchEvent(new CustomEvent("image-tracking", { detail: r })) } catch (n) { console.error(n) } } } } } }) } awake() { for (const i of this.trackedImages) if (i.image && !av._imageElements.has(i.image)) { const e = i.image; av._imageElements.set(e, null); const t = document.createElement("img"); t.src = e, t.addEventListener("load", async () => { const s = await createImageBitmap(t); av._imageElements.set(e, s); const r = await xL(s); if (r) { const n = await (await new Promise(a => r.toBlob(a, "image/png", 1))).arrayBuffer(), o = $.findObjectOfType(Vn); o && (o.extensions.push(new fne("marker.png", new Uint8Array(n), this.trackedImages[0].widthInMeters)), o.anchoringType = "image") } }) } } onEnable() { this.xr = $.findObjectOfType(wt), wt.addEventListener(bi.ModifyAROptions, this.onModifyAROptions), wt.addEventListener(bi.XRStarted, this.onXRStarted), wt.addEventListener(bi.XRUpdate, this.onXRUpdate), this.addEventListener("image-tracking", this.onImageTrackingUpdate) } onDisable() { wt.removeEventListener(bi.ModifyAROptions, this.onModifyAROptions), wt.removeEventListener(bi.XRStarted, this.onXRStarted), wt.removeEventListener(bi.XRUpdate, this.onXRUpdate), this.removeEventListener("image-tracking", this.onImageTrackingUpdate) } }, u(rI, "_imageElements", new Map), rI); let S_ = av; zp([x(Sl)], S_.prototype, "trackedImages", 2); var gne = Object.defineProperty, mne = Object.getOwnPropertyDescriptor, vne = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? mne(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && gne(e, t, r), r }; const uN = oe("debugplanetracking"); class E_ extends Ee { constructor() { super(...arguments), u(this, "planeTemplate"), u(this, "onModifyAROptions", e => { const t = e.detail, s = t.optionalFeatures || []; s.includes("plane-detection") || s.push("plane-detection"), t.optionalFeatures = s }), u(this, "onXRUpdate", e => { this.processPlanes(e.rig, e.frame) }), u(this, "_planeId", 1), u(this, "_allPlanes", new Map) } get trackedPlanes() { return this._allPlanes.values() } onEnable() { wt.addEventListener(bi.XRUpdate, this.onXRUpdate), wt.addEventListener("modify-ar-options", this.onModifyAROptions) } onDisable() { wt.removeEventListener(bi.XRUpdate, this.onXRUpdate), wt.removeEventListener("modify-ar-options", this.onModifyAROptions) } processPlanes(e, t) { const s = this.context.renderer; if (!e || t.detectedPlanes === void 0) return; const r = s.xr.getReferenceSpace(); if (r) { for (const n of this._allPlanes.keys()) if (!t.detectedPlanes.has(n)) { const o = this._allPlanes.get(n); this._allPlanes.delete(n), uN && console.log("Plane no longer tracked, id=" + o.id), o.mesh && e?.remove(o.mesh); const a = new CustomEvent("plane-tracking", { detail: { type: "plane-removed", context: o } }); this.dispatchEvent(a) } for (const n of t.detectedPlanes) { const o = t.getPose(n.planeSpace, r); let a; if (this._allPlanes.has(n)) { const l = this._allPlanes.get(n); if (a = l.mesh, l.timestamp < n.lastChangedTime) { if (l.timestamp = n.lastChangedTime, l.mesh) { const h = this.createGeometry(n.polygon); if (l.mesh instanceof ye) l.mesh.geometry.dispose(), l.mesh.geometry = h; else if (l.mesh instanceof wn) for (const d of l.mesh.children) d instanceof ye && (d.geometry.dispose(), d.geometry = h); l.collider && (l.collider.sharedMesh = l.mesh, l.collider.convex = !0, l.collider.onDisable(), l.collider.onEnable()) } const c = new CustomEvent("plane-tracking", { detail: { type: "plane-updated", context: l } }); this.dispatchEvent(c) } } else if (this.planeTemplate || (this.planeTemplate = new ye), this.planeTemplate) { const l = $.instantiate(this.planeTemplate); a = l, l instanceof ye && (uo(l.geometry), l.geometry = this.createGeometry(n.polygon)); const c = l.getComponent(_m); c && (c.sharedMesh = l, c.convex = !0, c.onDisable(), c.onEnable()), l.matrixAutoUpdate = !1, l.matrixWorldNeedsUpdate = !0, e.add(l); const h = { id: this._planeId++, xrPlane: n, timestamp: n.lastChangedTime, mesh: l, collider: c }; this._allPlanes.set(n, h), uN && console.log("New plane detected, id=" + h.id); try { const d = new CustomEvent("plane-tracking", { detail: { type: "plane-added", context: h } }); this.dispatchEvent(d) } catch (d) { console.error(d) } } a && (o ? (a.visible = !0, a.matrix.fromArray(o.transform.matrix)) : a.visible = !1) } } } createGeometry(e) { const t = new yt, s = [], r = []; e.forEach(p => { s.push(p.x, p.y, p.z), r.push(p.x, p.z) }); const n = new S(s[0], s[1], s[2]), o = new S(s[3], s[4], s[5]), a = new S(s[6], s[7], s[8]), l = new S, c = new S; l.subVectors(o, n), c.subVectors(a, n), l.cross(c), l.normalize(); const h = []; for (let p = 0; p < s.length / 3; p++)h.push(l.x, l.y, l.z); const d = []; for (let p = 2; p < e.length; ++p)d.push(0, p - 1, p); return t.setAttribute("position", new nt(new Float32Array(s), 3)), t.setAttribute("uv", new nt(new Float32Array(r), 2)), t.setAttribute("normal", new nt(new Float32Array(h), 3)), t.setIndex(d), t } } vne([x(Me)], E_.prototype, "planeTemplate", 2); class M_ { constructor() { u(this, "guid"), u(this, "dontSave", !0), u(this, "userId"), u(this, "point", { x: 0, y: 0, z: 0 }), u(this, "source", { x: 0, y: 0, z: 0 }), u(this, "target") } update(e, t, s, r = void 0) { this.userId = e.connection.connectionId, this.point.x = t.x, this.point.y = t.y, this.point.z = t.z, this.source.x = s.x, this.source.y = s.y, this.source.z = s.z, this.target = r } } class nI extends Ee { constructor() { super(...arguments), u(this, "prefab", null), u(this, "_grabModels", []), u(this, "_grabModelsUpdateTime", []), u(this, "_addOrUpdateSub", null), u(this, "_endSub", null), u(this, "_freeSub", null), u(this, "_instances", {}), u(this, "temp", new S) } awake() { this.prefab && (this.prefab.visible = !1) } onEnable() { this._addOrUpdateSub = this.context.connection.beginListen("xr-grab-visual-start-or-update", this.onRemoteGrabStartOrUpdate.bind(this)), this._endSub = this.context.connection.beginListen("xr-grab-visual-end", this.onRemoteGrabEnd.bind(this)), this._freeSub = ea.AddEventListener(db.WillFree, this.onAttachedObjectFree.bind(this)) } onDisable() { this.context.connection.stopListen("xr-grab-visual-start-or-update", this._addOrUpdateSub), this.context.connection.stopListen("xr-grab-visual-end", this._endSub), ea.RemoveEventListener(db.WillFree, this._freeSub) } addOrUpdateGrab(e) { this.context.connection.send("xr-grab-visual-start-or-update", e, Lr.Queued) } endGrab(e) { this.context.connection.send("xr-grab-visual-end", e, Lr.Queued) } onRemoteGrabStartOrUpdate(e) { if (!this.prefab) return; const t = this._instances[e.guid]; if (!t) { const s = $.instantiate(this.prefab); if (s.visible = !0, this._instances[e.guid] = { instance: s, model: e }, e.userId) { const r = $.getComponentsInChildren(s, wu); if (r?.length > 0) for (const n of r) n.assignUserColor(e.userId) } return } t.model = e } onRemoteGrabEnd(e) { if (!e) return; const t = e.guid; this._instances[t] && ($.destroy(this._instances[t].instance), delete this._instances[t]) } onAttachedObjectFree(e) { if (this._grabModels.length <= 0) return; const t = this._grabModels[0]; this.updateModel(t, e), this.endGrab(t) } onBeforeRender() { if (this.updateRendering(), !!this.prefab && (this.prefab.visible = !1, this.context.time.frameCount % 10 === 0)) for (let e = 0; e < ea.Current.length; e++) { const t = ea.Current[e]; if (!t.controller || !t.selected) continue; this._grabModels.length <= e && (this._grabModels.push(new M_), this._grabModelsUpdateTime.push(0)), this._grabModelsUpdateTime[e] = this.context.time.time; const s = this._grabModels[e]; this.updateModel(s, t), this.addOrUpdateGrab(s) } } updateModel(e, t) { if (!t.controller || !t.selected) return; e.guid = t.grabUUID; const s = t.selected.guid; e.update(this.context, t.grabPoint, t.controller.worldPosition, s) } updateRendering() { const e = this.context.time.deltaTime / .5; for (const t in this._instances) { const { instance: s, model: r } = this._instances[t]; if (!s || !r) continue; const { point: n } = r, o = xt(s); this.temp.set(n.x, n.y, n.z), o.lerp(this.temp, e), ts(s, o) } } } class oI { } const Ane = Object.freeze(Object.defineProperty({ __proto__: null, ActionBuilder: ni, ActionCollection: ES, ActionModel: yo, AlignmentConstraint: Ug, Animation: mo, AnimationCurve: Gh, AnimationExtension: Uy, AnimationTrackHandler: bb, Animator: Fr, AnimatorController: xu, Antialiasing: vm, AttachedObject: ea, AudioExtension: xb, AudioListener: cp, AudioSource: ss, AudioTrackHandler: fm, AvatarBlink_Simple: Kh, AvatarEyeLook_Rotation: dp, AvatarLoader: Gy, AvatarMarker: lr, AvatarModel: Qy, Avatar_Brain_LookAt: Gg, Avatar_MouthShapes: Am, Avatar_MustacheShake: BE, Avatar_POI: Er, AxesHelper: pp, BaseUIComponent: ba, BasicIKConstraint: LE, BehaviorExtension: Cb, BehaviorModel: Cr, Behaviour: Ee, Bloom: Zh, BoxCollider: bm, BoxGizmo: qh, BoxHelperComponent: qo, Button: Al, CallInfo: jh, Camera: Si, Canvas: cr, CanvasGroup: Ap, CapsuleCollider: kc, ChangeMaterialOnClick: Cm, ChangeTransformOnClick: tu, CharacterController: iu, CharacterControllerInput: bl, ChromaticAberration: Mm, Collider: ia, ColorAdjustments: Uc, ColorBySpeedModule: su, ColorOverLifetimeModule: Tm, Component: ac, ControlTrackHandler: _b, CustomBranding: Qc, Deletable: eM, DeleteBox: Nb, DepthOfField: Eo, DeviceFlag: zb, DocumentExtension: tM, DragControls: Sp, DropListener: Pm, Duplicatable: ou, EmissionModule: na, EmphasizeOnClick: _p, EventList: Nr, EventListEvent: My, EventSystem: jn, EventTrigger: Gb, FieldWithDefault: vS, FixedJoint: uM, FlyControls: dM, Fog: Mp, GltfExport: Rl, GltfExportBox: yM, Gradient: Nc, Graphic: Dc, GraphicRaycaster: SE, GridHelper: Tp, GridLayoutGroup: qE, GroundProjectedEnv: au, GroupActionModel: bc, HideOnStart: KE, HingeJoint: Bm, HorizontalLayoutGroup: WE, Image: mp, InheritVelocityModule: jc, InputField: cu, Interactable: Yd, LODGroup: Lm, LODModel: hu, Light: Wr, LimitVelocityOverLifetimeModule: ls, LogStats: CM, LookAt: uu, LookAtConstraint: zg, MainModule: Hs, MaskableGraphic: wm, MeshCollider: _m, MeshRenderer: Ry, MinMaxCurve: it, MinMaxGradient: Hr, NestedGltf: Xb, Networking: nu, NoiseModule: hi, ObjectRaycaster: Yh, OffsetConstraint: du, OpenURL: Bp, OrbitControls: Pc, Outline: gp, Padding: Oc, ParticleBurst: Im, ParticleSubEmitter: s_, ParticleSystem: us, ParticleSystemRenderer: xl, PixelationEffect: Gm, PlayAnimationOnClick: Fc, PlayAudioOnClick: xp, PlayableDirector: um, PlayerColor: wu, PointerEventData: Xh, PostProcessingHandler: n_, PreliminaryAction: Cp, PreliminaryTrigger: Sm, RGBAColor: mi, RawImage: Rb, Raycaster: lp, Rect: QE, RectTransform: Tr, ReflectionProbe: Qd, RegisteredAnimationInfo: Ly, RemoteSkybox: pu, Renderer: Ui, RendererLightmap: Lg, Rigidbody: ki, RotationBySpeedModule: un, RotationOverLifetimeModule: Gn, SceneSwitcher: pn, ScreenCapture: qm, ScreenSpaceAmbientOcclusion: wl, SetActiveOnClick: bp, ShadowCatcher: Jm, ShapeModule: Ji, SignalAsset: cm, SignalReceiver: up, SignalReceiverEvent: hp, SignalTrackHandler: gm, Size: jE, SizeBySpeedModule: Rr, SizeOverLifetimeModule: zc, SkinnedMeshRenderer: AS, SmoothFollow: Wc, SpatialHtml: QM, SpatialTrigger: $m, SpatialTriggerReceiver: ua, SpectatorCamera: u_, SphereCollider: ym, Sprite: Cl, SpriteData: Up, SpriteRenderer: fu, SpriteSheet: ev, SubEmitterSystem: Qm, SyncedCamera: p_, SyncedRoom: qc, SyncedTransform: Ic, TapGestureTrigger: $E, TeleportTarget: ub, TestRunner: KM, TestSimulateUserData: ZM, Text: Vr, TextBuilder: g_, TextExtension: $M, TextureSheetAnimationModule: Vs, TiltShiftEffect: da, ToneMapping: iv, TrailModule: Mi, TransformData: Fy, TransformGizmo: vu, TriggerBuilder: zr, TriggerModel: Hd, UIRaycastUtils: sp, UIRootComponent: em, USDZExporter: Vn, USDZText: Xc, UsageMarker: Jd, VRUserState: fl, VariantAction: SS, VelocityOverLifetimeModule: Di, VerticalLayoutGroup: VE, VideoPlayer: Xs, Vignette: Au, VisibilityAction: Em, Voip: Il, Volume: __, VolumeParameter: Dt, VolumeProfile: mm, WebAR: nm, WebARCameraBackground: w_, WebARSessionRoot: Cc, WebXR: wt, WebXRAvatar: Ec, WebXRController: os, WebXRImageTracking: S_, WebXRImageTrackingModel: Sl, WebXRPlaneTracking: E_, WebXRSync: sm, WebXRTrackedImage: yu, XRFlag: Sr, XRGrabModel: M_, XRGrabRendering: nI, XRRig: pb, XRState: Xo, __Ignore: oI }, Symbol.toStringTag, { value: "Module" })); var yne = Object.defineProperty, bne = Object.getOwnPropertyDescriptor, dN = (i, e, t, s) => { for (var r = s > 1 ? void 0 : s ? bne(e, t) : e, n = i.length - 1, o; n >= 0; n--)(o = i[n]) && (r = (s ? o(e, t, r) : o(r)) || r); return s && r && yne(e, t, r), r }; const I_ = oe("debugplayersync"); class aI extends Ee { constructor() { super(...arguments), u(this, "asset"), u(this, "joinedRoomFunction") } awake() { this.watchTabVisible(), this.joinedRoomFunction = this.onUserJoined.bind(this) } onEnable() { this.context.connection.beginListen(Li.JoinedRoom, this.joinedRoomFunction) } onDisable() { this.context.connection.stopListen(Li.JoinedRoom, this.joinedRoomFunction) } async onUserJoined(e) { var t, s; I_ && console.log("PlayerSync.onUserJoined", e); const r = await ((t = this.asset) == null ? void 0 : t.instantiateSynced({ parent: this.gameObject }, !0)); if (r) { let n = $.getComponent(r, jp); n ? n.owner = this.context.connection.connectionId : (console.error("<strong>Failed finding PlayerState on " + ((s = this.asset) == null ? void 0 : s.uri) + "</strong>: please make sure the asset has a PlayerState component!"), $.destroySynced(r)) } else console.warn("PlayerSync: failed instantiating asset!") } watchTabVisible() { window.addEventListener("visibilitychange", e => { if (document.visibilityState === "visible") for (let t = jp.all.length - 1; t >= 0; t--) { const s = jp.all[t]; (!s.owner || !this.context.connection.userIsInRoom(s.owner)) && s.doDestroy() } }) } } dN([x(or)], aI.prototype, "asset", 2); var pN = (i => (i.OwnerChanged = "ownerChanged", i))(pN || {}), lv; const Ys = (lv = class extends Ee { constructor() { super(...arguments), u(this, "owner") } static get all() { return Ys._all } static get local() { return Ys._local } static isLocalPlayer(i) { if (i instanceof Me) { const e = $.getComponentInParent(i, Ys); return e?.isLocalPlayer ?? !1 } else if (i instanceof ac) { const e = $.getComponentInParent(i.gameObject, Ys); return e?.isLocalPlayer ?? !1 } return !1 } static addEventListener(i, e) { return this._callbacks[i] || (this._callbacks[i] = []), this._callbacks[i].push(e), e } static removeEventListener(i, e) { if (!this._callbacks[i]) return; const t = this._callbacks[i].indexOf(e); t >= 0 && this._callbacks[i].splice(t, 1) } static dispatchEvent(i, e) { if (this._callbacks[i]) for (const t of this._callbacks[i]) t(e) } get isLocalPlayer() { return this.owner === this.context.connection.connectionId } onOwnerChange(i, e) { I_ && console.log("PlayerSync.onOwnerChange", this, "newOwner", i, "oldOwner", e); const t = Ys._local.indexOf(this); t >= 0 && Ys._local.splice(t, 1); const s = { playerState: this, oldValue: e, newValue: i }; if (this.owner === this.context.connection.connectionId) { Ys._local.push(this); const n = new CustomEvent("local-owner-changed", { detail: s }); this.dispatchEvent(n), Ys.dispatchEvent("ownerChanged", n) } const r = new CustomEvent("owner-changed", { detail: s }); this.dispatchEvent(r), Ys.dispatchEvent("ownerChanged", r) } awake() { Ys.all.push(this), I_ && console.log("Registered new PlayerState", this, Ys.all.length - 1, Ys.all), this.context.connection.beginListen(Li.UserLeftRoom, i => { if (i.userId === this.owner) { this.doDestroy(); return } }) } start() { if (this.owner && !this.context.connection.userIsInRoom(this.owner)) { this.doDestroy(); return } } doDestroy() { I_ && console.log("PlayerSync.doDestroy \u2192 syncDestroy", this), Q0(this.gameObject, this.context.connection) } onDestroy() { if (Ys.all.splice(Ys.all.indexOf(this), 1), this.isLocalPlayer) { const i = Ys._local.indexOf(this); i >= 0 && Ys._local.splice(i, 1) } } }, u(lv, "_all", []), u(lv, "_local", []), u(lv, "_callbacks", {}), lv); let jp = Ys; dN([NM("onOwnerChange")], jp.prototype, "owner", 2); class _ne extends Ee { constructor() { super(...arguments), u(this, "toggleKey", "KeyP") } update() { this.context.input.isKeyDown(this.toggleKey) && this.context.domElement.classList.toggle("presentation-mode") } } Q.add("__Ignore", oI), Q.add("ActionBuilder", ni), Q.add("ActionCollection", ES), Q.add("ActionModel", yo), Q.add("AlignmentConstraint", Ug), Q.add("Animation", mo), Q.add("AnimationCurve", Gh), Q.add("AnimationExtension", Uy), Q.add("AnimationTrackHandler", bb), Q.add("Animator", Fr), Q.add("AnimatorController", xu), Q.add("Antialiasing", vm), Q.add("AttachedObject", ea), Q.add("AudioExtension", xb), Q.add("AudioListener", cp), Q.add("AudioSource", ss), Q.add("AudioTrackHandler", fm), Q.add("Avatar_Brain_LookAt", Gg), Q.add("Avatar_MouthShapes", Am), Q.add("Avatar_MustacheShake", BE), Q.add("Avatar_POI", Er), Q.add("AvatarBlink_Simple", Kh), Q.add("AvatarEyeLook_Rotation", dp), Q.add("AvatarLoader", Gy), Q.add("AvatarMarker", lr), Q.add("AvatarModel", Qy), Q.add("AxesHelper", pp), Q.add("BaseUIComponent", ba), Q.add("BasicIKConstraint", LE), Q.add("BehaviorExtension", Cb), Q.add("BehaviorModel", Cr), Q.add("Behaviour", Ee), Q.add("Bloom", Zh), Q.add("BoxCollider", bm), Q.add("BoxGizmo", qh), Q.add("BoxHelperComponent", qo), Q.add("Button", Al), Q.add("CallInfo", jh), Q.add("Camera", Si), Q.add("Canvas", cr), Q.add("CanvasGroup", Ap), Q.add("CapsuleCollider", kc), Q.add("ChangeMaterialOnClick", Cm), Q.add("ChangeTransformOnClick", tu), Q.add("CharacterController", iu), Q.add("CharacterControllerInput", bl), Q.add("ChromaticAberration", Mm), Q.add("Collider", ia), Q.add("ColorAdjustments", Uc), Q.add("ColorBySpeedModule", su), Q.add("ColorOverLifetimeModule", Tm), Q.add("Component", ac), Q.add("ControlTrackHandler", _b), Q.add("CustomBranding", Qc), Q.add("Deletable", eM), Q.add("DeleteBox", Nb), Q.add("DepthOfField", Eo), Q.add("DeviceFlag", zb), Q.add("DocumentExtension", tM), Q.add("DragControls", Sp), Q.add("DropListener", Pm), Q.add("Duplicatable", ou), Q.add("EmissionModule", na), Q.add("EmphasizeOnClick", _p), Q.add("EventList", Nr), Q.add("EventListEvent", My), Q.add("EventSystem", jn), Q.add("EventTrigger", Gb), Q.add("FieldWithDefault", vS), Q.add("FixedJoint", uM), Q.add("FlyControls", dM), Q.add("Fog", Mp), Q.add("GltfExport", Rl), Q.add("GltfExportBox", yM), Q.add("Gradient", Nc), Q.add("Graphic", Dc), Q.add("GraphicRaycaster", SE), Q.add("GridHelper", Tp), Q.add("GridLayoutGroup", qE), Q.add("GroundProjectedEnv", au), Q.add("GroupActionModel", bc), Q.add("HideOnStart", KE), Q.add("HingeJoint", Bm), Q.add("HorizontalLayoutGroup", WE), Q.add("Image", mp), Q.add("InheritVelocityModule", jc), Q.add("InputField", cu), Q.add("Interactable", Yd), Q.add("Light", Wr), Q.add("LimitVelocityOverLifetimeModule", ls), Q.add("LODGroup", Lm), Q.add("LODModel", hu), Q.add("LogStats", CM), Q.add("LookAt", uu), Q.add("LookAtConstraint", zg), Q.add("MainModule", Hs), Q.add("MaskableGraphic", wm), Q.add("MeshCollider", _m), Q.add("MeshRenderer", Ry), Q.add("MinMaxCurve", it), Q.add("MinMaxGradient", Hr), Q.add("NestedGltf", Xb), Q.add("Networking", nu), Q.add("NoiseModule", hi), Q.add("ObjectRaycaster", Yh), Q.add("OffsetConstraint", du), Q.add("OpenURL", Bp), Q.add("OrbitControls", Pc), Q.add("Outline", gp), Q.add("Padding", Oc), Q.add("ParticleBurst", Im), Q.add("ParticleSubEmitter", s_), Q.add("ParticleSystem", us), Q.add("ParticleSystemRenderer", xl), Q.add("PixelationEffect", Gm), Q.add("PlayableDirector", um), Q.add("PlayAnimationOnClick", Fc), Q.add("PlayAudioOnClick", xp), Q.add("PlayerColor", wu), Q.add("PlayerState", jp), Q.add("PlayerSync", aI), Q.add("PointerEventData", Xh), Q.add("PostProcessingHandler", n_), Q.add("PreliminaryAction", Cp), Q.add("PreliminaryTrigger", Sm), Q.add("PresentationMode", _ne), Q.add("RawImage", Rb), Q.add("Raycaster", lp), Q.add("Rect", QE), Q.add("RectTransform", Tr), Q.add("ReflectionProbe", Qd), Q.add("RegisteredAnimationInfo", Ly), Q.add("RemoteSkybox", pu), Q.add("Renderer", Ui), Q.add("RendererLightmap", Lg), Q.add("RGBAColor", mi), Q.add("Rigidbody", ki), Q.add("RotationBySpeedModule", un), Q.add("RotationOverLifetimeModule", Gn), Q.add("SceneSwitcher", pn), Q.add("ScreenCapture", qm), Q.add("ScreenSpaceAmbientOcclusion", wl), Q.add("SetActiveOnClick", bp), Q.add("ShadowCatcher", Jm), Q.add("ShapeModule", Ji), Q.add("SignalAsset", cm), Q.add("SignalReceiver", up), Q.add("SignalReceiverEvent", hp), Q.add("SignalTrackHandler", gm), Q.add("Size", jE), Q.add("SizeBySpeedModule", Rr), Q.add("SizeOverLifetimeModule", zc), Q.add("SkinnedMeshRenderer", AS), Q.add("SmoothFollow", Wc), Q.add("SpatialHtml", QM), Q.add("SpatialTrigger", $m), Q.add("SpatialTriggerReceiver", ua), Q.add("SpectatorCamera", u_), Q.add("SphereCollider", ym), Q.add("Sprite", Cl), Q.add("SpriteData", Up), Q.add("SpriteRenderer", fu), Q.add("SpriteSheet", ev), Q.add("SubEmitterSystem", Qm), Q.add("SyncedCamera", p_), Q.add("SyncedRoom", qc), Q.add("SyncedTransform", Ic), Q.add("TapGestureTrigger", $E), Q.add("TeleportTarget", ub), Q.add("TestRunner", KM), Q.add("TestSimulateUserData", ZM), Q.add("Text", Vr), Q.add("TextBuilder", g_), Q.add("TextExtension", $M), Q.add("TextureSheetAnimationModule", Vs), Q.add("TiltShiftEffect", da), Q.add("ToneMapping", iv), Q.add("TrailModule", Mi), Q.add("TransformData", Fy), Q.add("TransformGizmo", vu), Q.add("TriggerBuilder", zr), Q.add("TriggerModel", Hd), Q.add("UIRaycastUtils", sp), Q.add("UIRootComponent", em), Q.add("UsageMarker", Jd), Q.add("USDZExporter", Vn), Q.add("USDZText", Xc), Q.add("VariantAction", SS), Q.add("VelocityOverLifetimeModule", Di), Q.add("VerticalLayoutGroup", VE), Q.add("VideoPlayer", Xs), Q.add("Vignette", Au), Q.add("VisibilityAction", Em), Q.add("Voip", Il), Q.add("Volume", __), Q.add("VolumeParameter", Dt), Q.add("VolumeProfile", mm), Q.add("VRUserState", fl), Q.add("WebAR", nm), Q.add("WebARCameraBackground", w_), Q.add("WebARSessionRoot", Cc), Q.add("WebXR", wt), Q.add("WebXRAvatar", Ec), Q.add("WebXRController", os), Q.add("WebXRImageTracking", S_), Q.add("WebXRImageTrackingModel", Sl), Q.add("WebXRPlaneTracking", E_), Q.add("WebXRSync", sm), Q.add("WebXRTrackedImage", yu), Q.add("XRFlag", Sr), Q.add("XRGrabModel", M_), Q.add("XRGrabRendering", nI), Q.add("XRRig", pb), Q.add("XRState", Xo); const fN = ir, xne = oe("debugtypestore"); xne && console.log(Q); function wne(i, e) { const t = lB(i, e); return t !== void 0 ? t : null } const Cne = new l6, lI = Symbol("deserialize-queue"); async function Sne(i, e, t, s = null, r) { if (!t) return; let n = s; typeof n == "number" && (n = new Br(s)); const o = e.indexOf("?"); e = o === -1 ? e : e.substring(0, o); const a = new aB(t.scene); a.gltfId = e, a.context = i, a.gltf = t, a.nodeToObject = r?.nodeToObjectMap, a.implementationInformation = Cne; let l = i[lI]; if (l || (l = i[lI] = []), t.scenes) for (const c of t.scenes) await hI(a, c, l); if (t.children) for (const c of t.children) await hI(a, c, l); i.new_scripts_pre_setup_callbacks.push(() => { const c = i[lI]; if (c) { for (const h of c) Ene(h, a); c.length = 0 } if (n) { const h = {}; cI(t, n, h); for (const d of t.scenes) cI(d, n, h) } }) } function cI(i, e, t) { if (e === null || !i) return; const s = i.guid; if (i.guid = e.generateUUID(), s && s !== "invalid" && (t[s] = i.guid), i && i.userData && i.userData.components) for (const r of i.userData.components) { if (r === null) continue; const n = r.guid; r.guid = e.generateUUID(), n && n !== "invalid" && (t[n] = r.guid), r.resolveGuids && r.resolveGuids(t) } if (i.children) for (const r of i.children) cI(r, e, t) } const cv = []; async function hI(i, e, t, s) {
  if (!e) return; const r = e.userData; if (r) {
    const n = r.builtin_components; if (n && n.length > 0) for (const o of n) try { if (o === null) continue; const a = Q.get(o.name); if (a != null) { const l = new a; l.sourceId = i.gltfId, Rh(l, o, i.implementationInformation), "guid" in o && (l[af] = o.guid), tc(e, l, !1), t.push({ instance: l, compData: o, obj: e }) } else fN && console.debug("unknown component: " + o.name), cv.includes(o.name) || cv.push(o.name) } catch (a) { console.error(o.name + " - " + a.message, a) } if (cv.length > 0) {
      const o = cv.join(", "); console.warn("unknown components: " + o), cv.length = 0, dr() && Ls(`<strong>Unknown components in scene</strong>:

${o}

This could mean you forgot to add a npmdef to your ExportInfo
<a href="https://engine.needle.tools/docs/project_structure.html#creating-and-installing-a-npmdef" target="_blank">documentation</a>`, Ro.Warn)
    }
  } if (e.children) for (const n of e.children) await hI(i, n, t)
} function Ene(i, e) { const { instance: t, compData: s, obj: r } = i; e.object = r, e.target = t, p0(t, s, e), fN && console.debug("add " + s.name, s, t) } class uI { createBuiltinComponents(e, t, s, r, n) { return Sne(e, t, s, r, n) } writeBuiltinComponentData(e, t) { return wne(e, t) } parseSync(e, t, s, r) { return vN(e, t, s, r) } loadSync(e, t, s, r, n) { return AN(e, t, s, r, n) } } uC(uI); const Mne = oe("printGltf"); var gN = (i => (i[i.BeforeLoad = 0] = "BeforeLoad", i[i.AfterLoaded = 1] = "AfterLoaded", i[i.FinishedSetup = 10] = "FinishedSetup", i))(gN || {}); class bu { constructor(e, t, s, r) { u(this, "context"), u(this, "loader"), u(this, "path"), u(this, "gltf"), this.context = e, this.path = t, this.loader = s, this.gltf = r } } const Jc = {}; function Ine(i, e) { Jc[i] = Jc[i] || [], Jc[i].push(e) } function Tne(i, e) { if (Jc[i]) { const t = Jc[i].indexOf(e); t >= 0 && Jc[i].splice(t, 1) } } function Qp(i, e) { if (Jc[i]) for (const t of Jc[i]) t(e) } async function mN(i, e, t, s, r) { Mne && console.warn("glTF", e, t), await fo().createBuiltinComponents(i, e, t, s, r) } function dI(i, e) { const t = new Sd; return ZO(t, e, i), t } function vN(i, e, t, s) { typeof t != "string" && console.warn("Parse gltf binary without path, this might lead to errors in resolving extensions. Please provide the source path of the gltf/glb file", t, typeof t); const r = dI(t, i), n = gS(r); return new Promise((o, a) => { try { wg(r, i), Qp(0, new bu(i, t, r)), r.parse(e, t, async l => { Qp(1, new bu(i, t, r, l)), await mN(i, t, l, s, n), Qp(10, new bu(i, t, r, l)), D2(l.scene, i), o(l) }, l => { console.error("failed loading " + t, l), o(void 0) }) } catch (l) { console.error(l), a(l) } }) } function AN(i, e, t, s, r) { const n = dI(e, i), o = gS(n); return new Promise((a, l) => { try { wg(n, i), Qp(0, new bu(i, e, n)), n.load(e, async c => { Qp(1, new bu(i, e, n, c)), await mN(i, t, c, s, o), Qp(10, new bu(i, e, n, c)), D2(c.scene, i), a(c) }, c => { r?.call(n, c) }, c => { console.error("failed loading " + e, c), a(void 0) }) } catch (c) { console.error(c), l(c) } }) } function Rne(i, e, t, s = !1) { e && e.animations && e.animations.length > 0 && t.push(() => { yN(e, s) }) } function yN(i, e = !1) { if (!i || !i.animations || !i.scene || !e && !vd(i.scene, mo)) return; for (let s = 0; s < i.animations.length; s++) { const r = i.animations[s]; if (!(!r.tracks || r.tracks.length <= 0)) for (const n in r.tracks) { const o = r.tracks[n], a = o.__objectName ?? o.name.substring(0, o.name.indexOf(".")), l = i.scene.getObjectByName(a); if (!l) continue; let c = t(l); if (!c) if (e) c = tc(i.scene, new mo); else { console.warn("Failed finding animator for", o.name, a); continue } const h = c.animations = c.animations || []; r.name_animator = c.name, h.indexOf(r) < 0 && h.push(r) } } function t(s) { var r; if (!s) return; const n = (r = s.userData) == null ? void 0 : r.components; if (n && n.length > 0) for (let o = 0; o < n.length; o++) { const a = n[o]; if (a instanceof Fr || a instanceof mo) return s } return t(s.parent) } } function bN(i, e, t = !0) { if (e.userData && e.userData.name === i) return e; if (e.children && e.children.length > 0) for (let s = 0; s < e.children.length; s++) { const r = e.children[s], n = bN(i, r, t); if (n) return n } } function Pne(i, e = null) { const t = e ?? _t.Current.scripts; for (const s in t) { const r = t[s]; if (r && r.guid === i) return r } return null } uC(uI); const Xn = oe("debugwebcomponent"), _N = "needle-engine", xN = "vr", wN = "desktop", Bne = [Lh, xN, wN], hv = "ar-session-active", uv = "desktop-session-active"; class pI extends HTMLElement { constructor() { super(), u(this, "gameObject", $), u(this, "GameObject", $), u(this, "_context"), u(this, "_overlay_ar"), u(this, "_loadingProgress01", 0), u(this, "_loadingView"), u(this, "_previousSrc", null), u(this, "_isCurrentlySettingsSourceAttribute", !1), u(this, "onReady", () => { var e; return (e = this._loadingView) == null ? void 0 : e.onLoadingFinished() }), this._overlay_ar = new Iq, this._context = new _t({ domElement: this }), this.addEventListener("ready", this.onReady) } get loadingProgress01() { return this._loadingProgress01 } get loadingFinished() { return this.loadingProgress01 > .999 } get cameraControls() { const e = this.getAttribute("camera-controls"); return !(e === null || e === "False" || e === "false" || e === "0") } getContext() { return new Promise((e, t) => { if (this._context && this.loadingFinished) e(this._context); else { const s = () => { this.removeEventListener("loadfinished", s), this._context && this.loadingFinished && e(this._context) }; this.addEventListener("loadfinished", s) } }) } get context() { return this._context } get Context() { return this._context } async connectedCallback() { Xn && (console.log("<needle-engine> connected"), console.dir(this)), this.onSetupDesktop(); const e = this.getAttribute("src") ?? globalThis["needle:codegen_files"]; e && e.length > 0 && await this.onLoad(e, !0), this.onSetupDesktop() } disconnectedCallback() { var e; (e = this._context) == null || e.onDestroy() } static get observedAttributes() { return ["hash", "src", "camera-controls", "loadstart", "progress", "loadfinished", "dracoDecoderPath", "dracoDecoderType", "ktx2DecoderPath"] } attributeChangedCallback(e, t, s) { switch (e) { case "src": Xn && console.log("src changed to type:", typeof s, ', from "', t, '" to "', s), this.onLoad(s, !1); break; case "hash": this._context && (this._context.hash = s); break; case "loadstart": case "progress": case "loadfinished": typeof s == "string" && s.length > 0 && (Xn && console.log(e + " attribute changed", s), this.registerEventFromAttribute(e, s)); break; case "dracoDecoderPath": Xn && console.log("dracoDecoderPath", s), jD(s); break; case "dracoDecoderType": s === "wasm" || s === "js" ? (Xn && console.log("dracoDecoderType", s), QD(s)) : console.error("Invalid dracoDecoderType", s, "expected js or wasm"); break; case "ktx2DecoderPath": Xn && console.log("ktx2DecoderPath", s), GD(s); break } } async onLoad(e, t) { var s, r; if (this._isCurrentlySettingsSourceAttribute || e === this._previousSrc) return; if (!e || !e.length) { console.error("Needle Engine: No source specified", e); return } if (!this._context) { console.error("Needle Engine: Context not initialized"); return } this._previousSrc = e, this._isCurrentlySettingsSourceAttribute = !0, this.setAttribute("src", e?.toString()), this._isCurrentlySettingsSourceAttribute = !1; const n = this.getAttribute("alias"); this.classList.add("loading"), Xn && console.log("Needle Engine: Begin loading", n ?? ""); const o = !0, a = this.dispatchEvent(new CustomEvent("loadstart", { detail: { context: this._context, alias: n }, cancelable: o })); !this._loadingView && a && (this._loadingView = new yC(this)), a && ((s = this._loadingView) == null || s.onLoadingBegin("begin load")), this.onBeforeBeginLoading(), Xn && console.log(e); let l; Array.isArray(e) ? l = e : e.startsWith("[") && e.endsWith("]") ? l = JSON.parse(e) : e.includes(",") ? l = e.split(",") : l = [e]; let c = null; if (l?.length > 0 && (c = async d => { let p = 0; d.hash && (p = Number.parseInt(d.hash) ?? 0); const f = fo(); for (let g = 0; g < l.length; g++) { const m = l[g]; if (!m.includes(".glb") && !m.includes(".gltf")) { const w = `Needle Engine: found suspicious src "${m}"`; console.warn(w), dr() && ao(w) } const v = kne(m), A = { name: v, progress: null, index: g, count: l.length }, b = { detail: { context: d, name: v, progress: A.progress, index: g, count: l.length, totalProgress01: this._loadingProgress01 } }, y = await f.loadSync(d, m, m, p, w => { var E; A.progress = w, this._loadingProgress01 = vC(A), a && ((E = this._loadingView) == null || E.onLoadingUpdate(A)), b.detail.progress = w, b.detail.totalProgress01 = this._loadingProgress01, this.dispatchEvent(new CustomEvent("progress", b)) }), _ = y?.scene; _ && $.add(_, d.scene, d) } t || pg(d) }), !c) { console.error("Needle Engine: No files to load", e); return } const h = this.getAttribute("hash"); h != null && (this._context.hash = h), this._context.alias = n, this._context.isCreated ? await c(this._context) : await this._context.onCreate(c), this._loadingProgress01 = 1, a && ((r = this._loadingView) == null || r.onLoadingUpdate(1, "creating scene")), this.classList.remove("loading"), this.classList.add("loading-finished"), Xn && console.log("Needle Engine: finished loading", n ?? ""), this.dispatchEvent(new CustomEvent("loadfinished", { detail: { context: this._context, src: n ?? e } })) } registerEventFromAttribute(e, t) { if (typeof t == "string" && t.length > 0) { const s = (0, eval)(t); typeof s == "function" && this.addEventListener(e, r => s?.call(globalThis, this._context, r)) } } getAROverlayContainer() { return this._overlay_ar.findOrCreateARContainer(this) } getVROverlayContainer() { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; if (t.classList.contains("vr")) return t } return null } onEnterAR(e, t) { var s; this.onSetupAR(), this._overlay_ar.onBegin(this._context, t, e), this.dispatchEvent(new CustomEvent("enter-ar", { detail: { session: e, context: this._context, htmlContainer: (s = this._overlay_ar) == null ? void 0 : s.ARContainer } })) } onExitAR(e) { var t; this._overlay_ar.onEnd(this._context), this.onSetupDesktop(), this.dispatchEvent(new CustomEvent("exit-ar", { detail: { session: e, context: this._context, htmlContainer: (t = this._overlay_ar) == null ? void 0 : t.ARContainer } })) } onEnterVR(e) { this.onSetupVR(), this.dispatchEvent(new CustomEvent("enter-vr", { detail: { session: e, context: this._context } })) } onExitVR(e) { this.onSetupDesktop(), this.dispatchEvent(new CustomEvent("exit-vr", { detail: { session: e, context: this._context } })) } onSetupAR() { this.classList.add(hv), this.classList.remove(uv); const e = this.getAROverlayContainer(); e && (e.classList.add(hv), e.classList.remove(uv)), this.foreachHtmlElement(t => this.setupElementsForMode(t, Lh)) } onSetupVR() { this.classList.remove(hv), this.classList.remove(uv), this.foreachHtmlElement(e => this.setupElementsForMode(e, xN)) } onSetupDesktop() { this.classList.remove(hv), this.classList.add(uv); const e = this.getAROverlayContainer(); e && (e.classList.remove(hv), e.classList.add(uv)), this.foreachHtmlElement(t => this.setupElementsForMode(t, wN)) } setupElementsForMode(e, t, s = null) { var r; if (!(e === ((r = this._context) == null ? void 0 : r.renderer.domElement) || e.id === "VRButton" || e.id === "ARButton")) if (e.style.position = "absolute", e.classList.contains(t)) e.style.visibility = "visible", e.style.display === "none" && (e.style.display = "block"); else for (const n of Bne) e.classList.contains(n) && (e.style.visibility = "hidden", e.style.display = "none") } foreachHtmlElement(e) { for (let t = 0; t < this.children.length; t++) { const s = this.children[t]; s.style && e(s) } } onBeforeBeginLoading() { const e = this.getAttribute("dracoDecoderPath"); e && (Xn && console.log("using custom draco decoder path", e), jD(e)); const t = this.getAttribute("dracoDecoderType"); t && (Xn && console.log("using custom draco decoder type", t), QD(t)); const s = this.getAttribute("ktx2DecoderPath"); s && (Xn && console.log("using custom ktx2 decoder path", s), GD(s)) } } window.customElements.get(_N) || window.customElements.define(_N, pI); function kne(i) { const e = i.split("/"); let t = e[e.length - 1], s = t.indexOf("?"); return s > 0 && (t = t.substring(0, s)), decodeURIComponent(t) } const Dne = Object.freeze(Object.defineProperty({ __proto__: null, NeedleEngineHTMLElement: pI }, Symbol.toStringTag, { value: "Module" })); Zi.registerCallback(Jr.MissingCamera, i => { const e = i.context.scene, t = "unknown", s = new Me; e.add(s); const r = new Si, n = tc(s, r, !0); return n.sourceId = t, n.clearFlags = 2, n.backgroundColor = new mi(.5, .5, .5, 1), s.position.x = -2, s.position.y = 2, s.position.z = 2, n }), Zi.registerCallback(Jr.ContextCreated, i => { if (!i.context.mainCamera) return; const e = i.context.domElement; if (e?.cameraControls === !0) { const t = iee(i.context.mainCamera); if (t?.isCameraController === !0) return; const s = i.context.mainCameraComponent, r = s?.gameObject; if (r) { const n = tc(r, new Pc, !1); n.sourceId = "unknown" } else console.warn("Missing camera object, can not add orbit controls") } }); const fI = oe("debughotreload"); let dv = !1; const pv = new Map; function One() { return dv } function Lne(i) { var e; if (dv) return; const t = i.constructor.name; pv.has(t) ? (e = pv.get(t)) == null || e.push(i) : pv.set(t, [i]) } function Fne(i) { if (dv) return; const e = i.constructor.name, t = pv.get(e); if (!t) return; const s = t.indexOf(i); s !== -1 && t.splice(s, 1) } let CN = !1; function Une() { if (fI || CN) return; CN = !0; const i = console.error; console.error = (...e) => { if (e.length) { const t = e[0]; if (typeof t == "string" && t.includes("[hmr] Failed to reload ")) { console.log("[Needle Engine] Hot reloading failed"), window.location.reload(); return } } i.apply(console, e) } } function Nne(i) { fI && console.log("Hot Reload - apply changes"), Une(); for (const e of Object.keys(i)) try { dv = !0; const t = Q.get(e); if (!t) continue; const s = i[e], r = pv.get(s.name); let n = "[Needle Engine] Updating type: " + e, o = r?.length ?? -1; o > 0 ? n += " x" + o : n += " - no instances", console.log(n); const a = Object.getOwnPropertyNames(t.prototype), l = Object.getOwnPropertyDescriptors(s.prototype); for (const c in l) l[c].writable && (t.prototype[c] = i[e].prototype[c]); for (const c of a) l[c] || delete t.prototype[c]; if (r) { const c = new s, h = Object.getOwnPropertyDescriptors(c); for (const d of r) { const p = d, f = p.isComponent === !0, g = f ? p.activeAndEnabled : !0, m = f ? p.context : void 0; try { if (f && qa(p, m), f && g && (p.enabled = !1), d.onBeforeHotReloadFields && d.onBeforeHotReloadFields() === !1) continue; for (const v in h) if (h[v].writable) { if (d[v] === void 0) d[v] = c[v]; else if (typeof d[v] == "function" && !d[v].prototype) { const A = d[v], b = A.name, y = "bound "; if (b === y) continue; const _ = A.name.substring(y.length), w = s.prototype[_]; w && (d[v] = w.bind(d)) } } d.onAfterHotReloadFields && d.onAfterHotReloadFields() } finally { f && X1(p, m), f && g && (p.enabled = !0) } } } } catch (t) { if (fI) console.error(t); else return !1 } finally { dv = !1, Ea(Ro.Log, "Script changes applied (HMR)") } return !0 } const zne = Symbol("object"), SN = new To(() => new S, 20); class EN { constructor(e, t, s, r, n) { u(this, "_point"), u(this, "_normal"), u(this, "distance"), u(this, "impulse"), u(this, "friction"), this._point = e, this.distance = t, this._normal = s, this.impulse = r, this.friction = n } get point() { return SN.get().set(this._point.x, this._point.y, this._point.z) } get normal() { return SN.get().set(this._normal.x, this._normal.y, this._normal.z) } } class MN { constructor(e, t, s) { u(this, "contacts"), u(this, "me"), u(this, "_collider"), u(this, "_gameObject"), this.me = e, this._collider = t, this._gameObject = t.gameObject, this.contacts = s } get collider() { return this._collider } get gameObject() { return this._gameObject } get rigidBody() { var e; return (e = this.collider) == null ? void 0 : e.attachedRigidbody } } class IN { constructor(e, t) { u(this, "object"), u(this, "collider"), this.object = e, this.collider = t } } let Le; const fv = new Array(32).fill(void 0); fv.push(void 0, null, !0, !1); let TN; fv.length; function RN() { return TN.byteLength, TN } const jne = new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }); function mt(i, e) { if (!(i instanceof e)) throw new Error(`expected instance of ${e.name}`); return i.ptr } jne.decode(); let PN, BN, gv = 32; function kN(i) { if (gv == 1) throw new Error("out of js stack"); return fv[--gv] = i, gv } function Qne() { return PN.byteLength, PN } function Gne() { return BN.byteLength, BN } let mn = 0; function _u(i, e) { const t = e(4 * i.length); return Qne().set(i, t / 4), mn = i.length, t } function T_(i, e) { const t = e(4 * i.length); return Gne().set(i, t / 4), mn = i.length, t } class F_ { static __wrap(e) { const t = Object.create(F_.prototype); return t.ptr = e, t } __destroy_into_raw() { const e = this.ptr; return this.ptr = 0, e } free() { const e = this.__destroy_into_raw(); Le.__wbg_raweventqueue_free(e) } constructor(e) { const t = Le.raweventqueue_new(e); return F_.__wrap(t) } drainCollisionEvents(e) { try { Le.raweventqueue_drainCollisionEvents(this.ptr, kN(e)) } finally { fv[gv++] = void 0 } } drainContactForceEvents(e) { try { Le.raweventqueue_drainContactForceEvents(this.ptr, kN(e)) } finally { fv[gv++] = void 0 } } clear() { Le.raweventqueue_clear(this.ptr) } } class wa { static __wrap(e) { const t = Object.create(wa.prototype); return t.ptr = e, t } __destroy_into_raw() { const e = this.ptr; return this.ptr = 0, e } free() { const e = this.__destroy_into_raw(); Le.__wbg_rawgenericjoint_free(e) } static spherical(e, t) { mt(e, at), mt(t, at); const s = Le.rawgenericjoint_spherical(e.ptr, t.ptr); return wa.__wrap(s) } static prismatic(e, t, s, r, n, o) { mt(e, at), mt(t, at), mt(s, at); const a = Le.rawgenericjoint_prismatic(e.ptr, t.ptr, s.ptr, r, n, o); return a === 0 ? void 0 : wa.__wrap(a) } static fixed(e, t, s, r) { mt(e, at), mt(t, Ds), mt(s, at), mt(r, Ds); const n = Le.rawgenericjoint_fixed(e.ptr, t.ptr, s.ptr, r.ptr); return wa.__wrap(n) } static revolute(e, t, s) { mt(e, at), mt(t, at), mt(s, at); const r = Le.rawgenericjoint_revolute(e.ptr, t.ptr, s.ptr); return r === 0 ? void 0 : wa.__wrap(r) } } class SI { static __wrap(e) { const t = Object.create(SI.prototype); return t.ptr = e, t } __destroy_into_raw() { const e = this.ptr; return this.ptr = 0, e } free() { const e = this.__destroy_into_raw(); Le.__wbg_rawpointprojection_free(e) } point() { const e = Le.rawpointprojection_point(this.ptr); return at.__wrap(e) } isInside() { return Le.rawpointprojection_isInside(this.ptr) !== 0 } } class EI { static __wrap(e) { const t = Object.create(EI.prototype); return t.ptr = e, t } __destroy_into_raw() { const e = this.ptr; return this.ptr = 0, e } free() { const e = this.__destroy_into_raw(); Le.__wbg_rawrayintersection_free(e) } normal() { const e = Le.rawrayintersection_normal(this.ptr); return at.__wrap(e) } toi() { return Le.rawintegrationparameters_dt(this.ptr) } featureType() { return Le.rawrayintersection_featureType(this.ptr) >>> 0 } featureId() { try { const s = Le.__wbindgen_add_to_stack_pointer(-16); Le.rawrayintersection_featureId(s, this.ptr); var e = RN()[s / 4 + 0], t = RN()[s / 4 + 1]; return e === 0 ? void 0 : t >>> 0 } finally { Le.__wbindgen_add_to_stack_pointer(16) } } } class Ds { static __wrap(e) { const t = Object.create(Ds.prototype); return t.ptr = e, t } __destroy_into_raw() { const e = this.ptr; return this.ptr = 0, e } free() { const e = this.__destroy_into_raw(); Le.__wbg_rawrotation_free(e) } constructor(e, t, s, r) { const n = Le.rawrotation_new(e, t, s, r); return Ds.__wrap(n) } static identity() { const e = Le.rawrotation_identity(); return Ds.__wrap(e) } get x() { return Le.rawintegrationparameters_dt(this.ptr) } get y() { return Le.rawrotation_y(this.ptr) } get z() { return Le.rawintegrationparameters_erp(this.ptr) } get w() { return Le.rawrotation_w(this.ptr) } } class Ot { static __wrap(e) { const t = Object.create(Ot.prototype); return t.ptr = e, t } __destroy_into_raw() { const e = this.ptr; return this.ptr = 0, e } free() { const e = this.__destroy_into_raw(); Le.__wbg_rawshape_free(e) } static cuboid(e, t, s) { const r = Le.rawshape_cuboid(e, t, s); return Ot.__wrap(r) } static roundCuboid(e, t, s, r) { const n = Le.rawshape_roundCuboid(e, t, s, r); return Ot.__wrap(n) } static ball(e) { const t = Le.rawshape_ball(e); return Ot.__wrap(t) } static capsule(e, t) { const s = Le.rawshape_capsule(e, t); return Ot.__wrap(s) } static cylinder(e, t) { const s = Le.rawshape_cylinder(e, t); return Ot.__wrap(s) } static roundCylinder(e, t, s) { const r = Le.rawshape_roundCylinder(e, t, s); return Ot.__wrap(r) } static cone(e, t) { const s = Le.rawshape_cone(e, t); return Ot.__wrap(s) } static roundCone(e, t, s) { const r = Le.rawshape_roundCone(e, t, s); return Ot.__wrap(r) } static polyline(e, t) { const s = _u(e, Le.__wbindgen_malloc), r = mn, n = T_(t, Le.__wbindgen_malloc), o = mn, a = Le.rawshape_polyline(s, r, n, o); return Ot.__wrap(a) } static trimesh(e, t) { const s = _u(e, Le.__wbindgen_malloc), r = mn, n = T_(t, Le.__wbindgen_malloc), o = mn, a = Le.rawshape_trimesh(s, r, n, o); return Ot.__wrap(a) } static heightfield(e, t, s, r) { const n = _u(s, Le.__wbindgen_malloc), o = mn; mt(r, at); const a = Le.rawshape_heightfield(e, t, n, o, r.ptr); return Ot.__wrap(a) } static segment(e, t) { mt(e, at), mt(t, at); const s = Le.rawshape_segment(e.ptr, t.ptr); return Ot.__wrap(s) } static triangle(e, t, s) { mt(e, at), mt(t, at), mt(s, at); const r = Le.rawshape_triangle(e.ptr, t.ptr, s.ptr); return Ot.__wrap(r) } static roundTriangle(e, t, s, r) { mt(e, at), mt(t, at), mt(s, at); const n = Le.rawshape_roundTriangle(e.ptr, t.ptr, s.ptr, r); return Ot.__wrap(n) } static convexHull(e) { const t = _u(e, Le.__wbindgen_malloc), s = mn, r = Le.rawshape_convexHull(t, s); return r === 0 ? void 0 : Ot.__wrap(r) } static roundConvexHull(e, t) { const s = _u(e, Le.__wbindgen_malloc), r = mn, n = Le.rawshape_roundConvexHull(s, r, t); return n === 0 ? void 0 : Ot.__wrap(n) } static convexMesh(e, t) { const s = _u(e, Le.__wbindgen_malloc), r = mn, n = T_(t, Le.__wbindgen_malloc), o = mn, a = Le.rawshape_convexMesh(s, r, n, o); return a === 0 ? void 0 : Ot.__wrap(a) } static roundConvexMesh(e, t, s) { const r = _u(e, Le.__wbindgen_malloc), n = mn, o = T_(t, Le.__wbindgen_malloc), a = mn, l = Le.rawshape_roundConvexMesh(r, n, o, a, s); return l === 0 ? void 0 : Ot.__wrap(l) } castShape(e, t, s, r, n, o, a, l) { mt(e, at), mt(t, Ds), mt(s, at), mt(r, Ot), mt(n, at), mt(o, Ds), mt(a, at); const c = Le.rawshape_castShape(this.ptr, e.ptr, t.ptr, s.ptr, r.ptr, n.ptr, o.ptr, a.ptr, l); return c === 0 ? void 0 : II.__wrap(c) } intersectsShape(e, t, s, r, n) { return mt(e, at), mt(t, Ds), mt(s, Ot), mt(r, at), mt(n, Ds), Le.rawshape_intersectsShape(this.ptr, e.ptr, t.ptr, s.ptr, r.ptr, n.ptr) !== 0 } contactShape(e, t, s, r, n, o) { mt(e, at), mt(t, Ds), mt(s, Ot), mt(r, at), mt(n, Ds); const a = Le.rawshape_contactShape(this.ptr, e.ptr, t.ptr, s.ptr, r.ptr, n.ptr, o); return a === 0 ? void 0 : MI.__wrap(a) } containsPoint(e, t, s) { return mt(e, at), mt(t, Ds), mt(s, at), Le.rawshape_containsPoint(this.ptr, e.ptr, t.ptr, s.ptr) !== 0 } projectPoint(e, t, s, r) { mt(e, at), mt(t, Ds), mt(s, at); const n = Le.rawshape_projectPoint(this.ptr, e.ptr, t.ptr, s.ptr, r); return SI.__wrap(n) } intersectsRay(e, t, s, r, n) { return mt(e, at), mt(t, Ds), mt(s, at), mt(r, at), Le.rawshape_intersectsRay(this.ptr, e.ptr, t.ptr, s.ptr, r.ptr, n) !== 0 } castRay(e, t, s, r, n, o) { return mt(e, at), mt(t, Ds), mt(s, at), mt(r, at), Le.rawshape_castRay(this.ptr, e.ptr, t.ptr, s.ptr, r.ptr, n, o) } castRayAndGetNormal(e, t, s, r, n, o) { mt(e, at), mt(t, Ds), mt(s, at), mt(r, at); const a = Le.rawshape_castRayAndGetNormal(this.ptr, e.ptr, t.ptr, s.ptr, r.ptr, n, o); return a === 0 ? void 0 : EI.__wrap(a) } } class MI { static __wrap(e) { const t = Object.create(MI.prototype); return t.ptr = e, t } __destroy_into_raw() { const e = this.ptr; return this.ptr = 0, e } free() { const e = this.__destroy_into_raw(); Le.__wbg_rawshapecontact_free(e) } distance() { return Le.rawshapecontact_distance(this.ptr) } point1() { const e = Le.rawpointprojection_point(this.ptr); return at.__wrap(e) } point2() { const e = Le.rawshapecontact_point2(this.ptr); return at.__wrap(e) } normal1() { const e = Le.rawshapecontact_normal1(this.ptr); return at.__wrap(e) } normal2() { const e = Le.rawshapecontact_normal2(this.ptr); return at.__wrap(e) } } class II { static __wrap(e) { const t = Object.create(II.prototype); return t.ptr = e, t } __destroy_into_raw() { const e = this.ptr; return this.ptr = 0, e } free() { const e = this.__destroy_into_raw(); Le.__wbg_rawshapetoi_free(e) } toi() { return Le.rawintegrationparameters_dt(this.ptr) } witness1() { const e = Le.rawrayintersection_normal(this.ptr); return at.__wrap(e) } witness2() { const e = Le.rawshapetoi_witness2(this.ptr); return at.__wrap(e) } normal1() { const e = Le.rawshapetoi_normal1(this.ptr); return at.__wrap(e) } normal2() { const e = Le.rawshapetoi_normal2(this.ptr); return at.__wrap(e) } } class at { static __wrap(e) { const t = Object.create(at.prototype); return t.ptr = e, t } __destroy_into_raw() { const e = this.ptr; return this.ptr = 0, e } free() { const e = this.__destroy_into_raw(); Le.__wbg_rawvector_free(e) } static zero() { const e = Le.rawvector_zero(); return at.__wrap(e) } constructor(e, t, s) { const r = Le.rawvector_new(e, t, s); return at.__wrap(r) } get x() { return Le.rawintegrationparameters_dt(this.ptr) } set x(e) { Le.rawintegrationparameters_set_dt(this.ptr, e) } get y() { return Le.rawrotation_y(this.ptr) } set y(e) { Le.rawvector_set_y(this.ptr, e) } get z() { return Le.rawintegrationparameters_erp(this.ptr) } set z(e) { Le.rawintegrationparameters_set_erp(this.ptr, e) } xyz() { const e = Le.rawvector_xyz(this.ptr); return at.__wrap(e) } yxz() { const e = Le.rawvector_yxz(this.ptr); return at.__wrap(e) } zxy() { const e = Le.rawvector_zxy(this.ptr); return at.__wrap(e) } xzy() { const e = Le.rawvector_xzy(this.ptr); return at.__wrap(e) } yzx() { const e = Le.rawvector_yzx(this.ptr); return at.__wrap(e) } zyx() { const e = Le.rawvector_zyx(this.ptr); return at.__wrap(e) } } class Hne { constructor(e, t, s) { this.x = e, this.y = t, this.z = s } } class Ne { static new(e, t, s) { return new Hne(e, t, s) } static intoRaw(e) { return new at(e.x, e.y, e.z) } static zeros() { return Ne.new(0, 0, 0) } static fromRaw(e) { if (!e) return null; let t = Ne.new(e.x, e.y, e.z); return e.free(), t } static copy(e, t) { e.x = t.x, e.y = t.y, e.z = t.z } } class DN { constructor(e, t, s, r) { this.x = e, this.y = t, this.z = s, this.w = r } } class zi { static identity() { return new DN(0, 0, 0, 1) } static fromRaw(e) { if (!e) return null; let t = new DN(e.x, e.y, e.z, e.w); return e.free(), t } static intoRaw(e) { return new Ds(e.x, e.y, e.z, e.w) } static copy(e, t) { e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w } } var mv, fa, ON, Yn, gI, $t, R_, Gp, mI, vI, LN, FN; (function (i) { i[i.Dynamic = 0] = "Dynamic", i[i.Fixed = 1] = "Fixed", i[i.KinematicPositionBased = 2] = "KinematicPositionBased", i[i.KinematicVelocityBased = 3] = "KinematicVelocityBased" })(mv || (mv = {})), function (i) { i[i.Revolute = 0] = "Revolute", i[i.Fixed = 1] = "Fixed", i[i.Prismatic = 2] = "Prismatic", i[i.Spherical = 3] = "Spherical" }(fa || (fa = {})), function (i) { i[i.AccelerationBased = 0] = "AccelerationBased", i[i.ForceBased = 1] = "ForceBased" }(ON || (ON = {})); class $p { constructor() { } static fixed(e, t, s, r) { let n = new $p; return n.anchor1 = e, n.anchor2 = s, n.frame1 = t, n.frame2 = r, n.jointType = fa.Fixed, n } static spherical(e, t) { let s = new $p; return s.anchor1 = e, s.anchor2 = t, s.jointType = fa.Spherical, s } static prismatic(e, t, s) { let r = new $p; return r.anchor1 = e, r.anchor2 = t, r.axis = s, r.jointType = fa.Prismatic, r } static revolute(e, t, s) { let r = new $p; return r.anchor1 = e, r.anchor2 = t, r.axis = s, r.jointType = fa.Revolute, r } intoRaw() { let e, t, s = Ne.intoRaw(this.anchor1), r = Ne.intoRaw(this.anchor2), n = !1, o = 0, a = 0; switch (this.jointType) { case fa.Fixed: let l = zi.intoRaw(this.frame1), c = zi.intoRaw(this.frame2); t = wa.fixed(s, l, r, c), l.free(), c.free(); break; case fa.Prismatic: e = Ne.intoRaw(this.axis), this.limitsEnabled && (n = !0, o = this.limits[0], a = this.limits[1]), t = wa.prismatic(s, r, e, n, o, a), e.free(); break; case fa.Spherical: t = wa.spherical(s, r); break; case fa.Revolute: e = Ne.intoRaw(this.axis), t = wa.revolute(s, r, e), e.free() }return s.free(), r.free(), t } } (function (i) { i[i.Average = 0] = "Average", i[i.Min = 1] = "Min", i[i.Multiply = 2] = "Multiply", i[i.Max = 3] = "Max" })(Yn || (Yn = {})); class Iv { constructor(e, t, s, r, n) { this.distance = e, this.point1 = t, this.point2 = s, this.normal1 = r, this.normal2 = n } static fromRaw(e) { if (!e) return null; const t = new Iv(e.distance(), Ne.fromRaw(e.point1()), Ne.fromRaw(e.point2()), Ne.fromRaw(e.normal1()), Ne.fromRaw(e.normal2())); return e.free(), t } } (function (i) { i[i.Vertex = 0] = "Vertex", i[i.Edge = 1] = "Edge", i[i.Face = 2] = "Face", i[i.Unknown = 3] = "Unknown" })(gI || (gI = {})); class U_ { constructor(e, t) { this.point = e, this.isInside = t } static fromRaw(e) { if (!e) return null; const t = new U_(Ne.fromRaw(e.point()), e.isInside()); return e.free(), t } } class Vne { constructor(e, t) { this.origin = e, this.dir = t } pointAt(e) { return { x: this.origin.x + this.dir.x * e, y: this.origin.y + this.dir.y * e, z: this.origin.z + this.dir.z * e } } } class N_ { constructor(e, t, s, r) { this.featureType = gI.Unknown, this.featureId = void 0, this.toi = e, this.normal = t, r !== void 0 && (this.featureId = r), s !== void 0 && (this.featureType = s) } static fromRaw(e) { if (!e) return null; const t = new N_(e.toi(), Ne.fromRaw(e.normal()), e.featureType(), e.featureId()); return e.free(), t } } class Tv { constructor(e, t, s, r, n) { this.toi = e, this.witness1 = t, this.witness2 = s, this.normal1 = r, this.normal2 = n } static fromRaw(e, t) { if (!t) return null; const s = new Tv(t.toi(), Ne.fromRaw(t.witness1()), Ne.fromRaw(t.witness2()), Ne.fromRaw(t.normal1()), Ne.fromRaw(t.normal2())); return t.free(), s } } class TI extends Tv { constructor(e, t, s, r, n, o) { super(t, s, r, n, o), this.collider = e } static fromRaw(e, t) { if (!t) return null; const s = new TI(e.get(t.colliderHandle()), t.toi(), Ne.fromRaw(t.witness1()), Ne.fromRaw(t.witness2()), Ne.fromRaw(t.normal1()), Ne.fromRaw(t.normal2())); return t.free(), s } } class Js { static fromRaw(e, t) { const s = e.coShapeType(t); let r, n, o, a, l, c; switch (s) { case $t.Ball: return new AI(e.coRadius(t)); case $t.Cuboid: return r = e.coHalfExtents(t), new UN(r.x, r.y, r.z); case $t.RoundCuboid: return r = e.coHalfExtents(t), n = e.coRoundRadius(t), new NN(r.x, r.y, r.z, n); case $t.Capsule: return l = e.coHalfHeight(t), c = e.coRadius(t), new zN(l, c); case $t.Segment: return o = e.coVertices(t), new jN(Ne.new(o[0], o[1], o[2]), Ne.new(o[3], o[4], o[5])); case $t.Polyline: return o = e.coVertices(t), a = e.coIndices(t), new HN(o, a); case $t.Triangle: return o = e.coVertices(t), new QN(Ne.new(o[0], o[1], o[2]), Ne.new(o[3], o[4], o[5]), Ne.new(o[6], o[7], o[8])); case $t.RoundTriangle: return o = e.coVertices(t), n = e.coRoundRadius(t), new GN(Ne.new(o[0], o[1], o[2]), Ne.new(o[3], o[4], o[5]), Ne.new(o[6], o[7], o[8]), n); case $t.TriMesh: return o = e.coVertices(t), a = e.coIndices(t), new VN(o, a); case $t.HeightField: const h = e.coHeightfieldScale(t), d = e.coHeightfieldHeights(t), p = e.coHeightfieldNRows(t), f = e.coHeightfieldNCols(t); return new WN(p, f, d, h); case $t.ConvexPolyhedron: return o = e.coVertices(t), a = e.coIndices(t), new yI(o, a); case $t.RoundConvexPolyhedron: return o = e.coVertices(t), a = e.coIndices(t), n = e.coRoundRadius(t), new bI(o, a, n); case $t.Cylinder: return l = e.coHalfHeight(t), c = e.coRadius(t), new qN(l, c); case $t.RoundCylinder: return l = e.coHalfHeight(t), c = e.coRadius(t), n = e.coRoundRadius(t), new XN(l, c, n); case $t.Cone: return l = e.coHalfHeight(t), c = e.coRadius(t), new YN(l, c); case $t.RoundCone: return l = e.coHalfHeight(t), c = e.coRadius(t), n = e.coRoundRadius(t), new JN(l, c, n); default: throw new Error("unknown shape type: " + s) } } castShape(e, t, s, r, n, o, a, l) { let c = Ne.intoRaw(e), h = zi.intoRaw(t), d = Ne.intoRaw(s), p = Ne.intoRaw(n), f = zi.intoRaw(o), g = Ne.intoRaw(a), m = this.intoRaw(), v = r.intoRaw(), A = Tv.fromRaw(null, m.castShape(c, h, d, v, p, f, g, l)); return c.free(), h.free(), d.free(), p.free(), f.free(), g.free(), m.free(), v.free(), A } intersectsShape(e, t, s, r, n) { let o = Ne.intoRaw(e), a = zi.intoRaw(t), l = Ne.intoRaw(r), c = zi.intoRaw(n), h = this.intoRaw(), d = s.intoRaw(), p = h.intersectsShape(o, a, d, l, c); return o.free(), a.free(), l.free(), c.free(), h.free(), d.free(), p } contactShape(e, t, s, r, n, o) { let a = Ne.intoRaw(e), l = zi.intoRaw(t), c = Ne.intoRaw(r), h = zi.intoRaw(n), d = this.intoRaw(), p = s.intoRaw(), f = Iv.fromRaw(d.contactShape(a, l, p, c, h, o)); return a.free(), l.free(), c.free(), h.free(), d.free(), p.free(), f } containsPoint(e, t, s) { let r = Ne.intoRaw(e), n = zi.intoRaw(t), o = Ne.intoRaw(s), a = this.intoRaw(), l = a.containsPoint(r, n, o); return r.free(), n.free(), o.free(), a.free(), l } projectPoint(e, t, s, r) { let n = Ne.intoRaw(e), o = zi.intoRaw(t), a = Ne.intoRaw(s), l = this.intoRaw(), c = U_.fromRaw(l.projectPoint(n, o, a, r)); return n.free(), o.free(), a.free(), l.free(), c } intersectsRay(e, t, s, r) { let n = Ne.intoRaw(t), o = zi.intoRaw(s), a = Ne.intoRaw(e.origin), l = Ne.intoRaw(e.dir), c = this.intoRaw(), h = c.intersectsRay(n, o, a, l, r); return n.free(), o.free(), a.free(), l.free(), c.free(), h } castRay(e, t, s, r, n) { let o = Ne.intoRaw(t), a = zi.intoRaw(s), l = Ne.intoRaw(e.origin), c = Ne.intoRaw(e.dir), h = this.intoRaw(), d = h.castRay(o, a, l, c, r, n); return o.free(), a.free(), l.free(), c.free(), h.free(), d } castRayAndGetNormal(e, t, s, r, n) { let o = Ne.intoRaw(t), a = zi.intoRaw(s), l = Ne.intoRaw(e.origin), c = Ne.intoRaw(e.dir), h = this.intoRaw(), d = N_.fromRaw(h.castRayAndGetNormal(o, a, l, c, r, n)); return o.free(), a.free(), l.free(), c.free(), h.free(), d } } (function (i) { i[i.Ball = 0] = "Ball", i[i.Cuboid = 1] = "Cuboid", i[i.Capsule = 2] = "Capsule", i[i.Segment = 3] = "Segment", i[i.Polyline = 4] = "Polyline", i[i.Triangle = 5] = "Triangle", i[i.TriMesh = 6] = "TriMesh", i[i.HeightField = 7] = "HeightField", i[i.ConvexPolyhedron = 9] = "ConvexPolyhedron", i[i.Cylinder = 10] = "Cylinder", i[i.Cone = 11] = "Cone", i[i.RoundCuboid = 12] = "RoundCuboid", i[i.RoundTriangle = 13] = "RoundTriangle", i[i.RoundCylinder = 14] = "RoundCylinder", i[i.RoundCone = 15] = "RoundCone", i[i.RoundConvexPolyhedron = 16] = "RoundConvexPolyhedron" })($t || ($t = {})); class AI extends Js { constructor(e) { super(), this.type = $t.Ball, this.radius = e } intoRaw() { return Ot.ball(this.radius) } } class UN extends Js { constructor(e, t, s) { super(), this.type = $t.Cuboid, this.halfExtents = Ne.new(e, t, s) } intoRaw() { return Ot.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z) } } class NN extends Js { constructor(e, t, s, r) { super(), this.type = $t.RoundCuboid, this.halfExtents = Ne.new(e, t, s), this.borderRadius = r } intoRaw() { return Ot.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius) } } class zN extends Js { constructor(e, t) { super(), this.type = $t.Capsule, this.halfHeight = e, this.radius = t } intoRaw() { return Ot.capsule(this.halfHeight, this.radius) } } class jN extends Js { constructor(e, t) { super(), this.type = $t.Segment, this.a = e, this.b = t } intoRaw() { let e = Ne.intoRaw(this.a), t = Ne.intoRaw(this.b), s = Ot.segment(e, t); return e.free(), t.free(), s } } class QN extends Js { constructor(e, t, s) { super(), this.type = $t.Triangle, this.a = e, this.b = t, this.c = s } intoRaw() { let e = Ne.intoRaw(this.a), t = Ne.intoRaw(this.b), s = Ne.intoRaw(this.c), r = Ot.triangle(e, t, s); return e.free(), t.free(), s.free(), r } } class GN extends Js { constructor(e, t, s, r) { super(), this.type = $t.RoundTriangle, this.a = e, this.b = t, this.c = s, this.borderRadius = r } intoRaw() { let e = Ne.intoRaw(this.a), t = Ne.intoRaw(this.b), s = Ne.intoRaw(this.c), r = Ot.roundTriangle(e, t, s, this.borderRadius); return e.free(), t.free(), s.free(), r } } class HN extends Js { constructor(e, t) { super(), this.type = $t.Polyline, this.vertices = e, this.indices = t ?? new Uint32Array(0) } intoRaw() { return Ot.polyline(this.vertices, this.indices) } } class VN extends Js { constructor(e, t) { super(), this.type = $t.TriMesh, this.vertices = e, this.indices = t } intoRaw() { return Ot.trimesh(this.vertices, this.indices) } } class yI extends Js { constructor(e, t) { super(), this.type = $t.ConvexPolyhedron, this.vertices = e, this.indices = t } intoRaw() { return this.indices ? Ot.convexMesh(this.vertices, this.indices) : Ot.convexHull(this.vertices) } } class bI extends Js { constructor(e, t, s) { super(), this.type = $t.RoundConvexPolyhedron, this.vertices = e, this.indices = t, this.borderRadius = s } intoRaw() { return this.indices ? Ot.roundConvexMesh(this.vertices, this.indices, this.borderRadius) : Ot.roundConvexHull(this.vertices, this.borderRadius) } } class WN extends Js { constructor(e, t, s, r) { super(), this.type = $t.HeightField, this.nrows = e, this.ncols = t, this.heights = s, this.scale = r } intoRaw() { let e = Ne.intoRaw(this.scale), t = Ot.heightfield(this.nrows, this.ncols, this.heights, e); return e.free(), t } } class qN extends Js { constructor(e, t) { super(), this.type = $t.Cylinder, this.halfHeight = e, this.radius = t } intoRaw() { return Ot.cylinder(this.halfHeight, this.radius) } } class XN extends Js { constructor(e, t, s) { super(), this.type = $t.RoundCylinder, this.borderRadius = s, this.halfHeight = e, this.radius = t } intoRaw() { return Ot.roundCylinder(this.halfHeight, this.radius, this.borderRadius) } } class YN extends Js { constructor(e, t) { super(), this.type = $t.Cone, this.halfHeight = e, this.radius = t } intoRaw() { return Ot.cone(this.halfHeight, this.radius) } } class JN extends Js { constructor(e, t, s) { super(), this.type = $t.RoundCone, this.halfHeight = e, this.radius = t, this.borderRadius = s } intoRaw() { return Ot.roundCone(this.halfHeight, this.radius, this.borderRadius) } } (function (i) { i[i.DYNAMIC_DYNAMIC = 1] = "DYNAMIC_DYNAMIC", i[i.DYNAMIC_KINEMATIC = 12] = "DYNAMIC_KINEMATIC", i[i.DYNAMIC_FIXED = 2] = "DYNAMIC_FIXED", i[i.KINEMATIC_KINEMATIC = 52224] = "KINEMATIC_KINEMATIC", i[i.KINEMATIC_FIXED = 8704] = "KINEMATIC_FIXED", i[i.FIXED_FIXED = 32] = "FIXED_FIXED", i[i.DEFAULT = 15] = "DEFAULT", i[i.ALL = 60943] = "ALL" })(R_ || (R_ = {})); class Wne { constructor(e, t, s, r) { this.colliderSet = e, this.handle = t, this._parent = s, this._shape = r } finalizeDeserialization(e) { this.handle != null && (this._parent = e.get(this.colliderSet.raw.coParent(this.handle))) } ensureShapeIsCached() { this._shape || (this._shape = Js.fromRaw(this.colliderSet.raw, this.handle)) } get shape() { return this.ensureShapeIsCached(), this._shape } isValid() { return this.colliderSet.raw.contains(this.handle) } translation() { return Ne.fromRaw(this.colliderSet.raw.coTranslation(this.handle)) } rotation() { return zi.fromRaw(this.colliderSet.raw.coRotation(this.handle)) } isSensor() { return this.colliderSet.raw.coIsSensor(this.handle) } setSensor(e) { this.colliderSet.raw.coSetSensor(this.handle, e) } setShape(e) { let t = e.intoRaw(); this.colliderSet.raw.coSetShape(this.handle, t), t.free(), this._shape = e } setRestitution(e) { this.colliderSet.raw.coSetRestitution(this.handle, e) } setFriction(e) { this.colliderSet.raw.coSetFriction(this.handle, e) } frictionCombineRule() { return this.colliderSet.raw.coFrictionCombineRule(this.handle) } setFrictionCombineRule(e) { this.colliderSet.raw.coSetFrictionCombineRule(this.handle, e) } restitutionCombineRule() { return this.colliderSet.raw.coRestitutionCombineRule(this.handle) } setRestitutionCombineRule(e) { this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, e) } setCollisionGroups(e) { this.colliderSet.raw.coSetCollisionGroups(this.handle, e) } setSolverGroups(e) { this.colliderSet.raw.coSetSolverGroups(this.handle, e) } activeHooks() { return this.colliderSet.raw.coActiveHooks(this.handle) } setActiveHooks(e) { this.colliderSet.raw.coSetActiveHooks(this.handle, e) } activeEvents() { return this.colliderSet.raw.coActiveEvents(this.handle) } setActiveEvents(e) { this.colliderSet.raw.coSetActiveEvents(this.handle, e) } activeCollisionTypes() { return this.colliderSet.raw.coActiveCollisionTypes(this.handle) } setContactForceEventThreshold(e) { return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, e) } contactForceEventThreshold() { return this.colliderSet.raw.coContactForceEventThreshold(this.handle) } setActiveCollisionTypes(e) { this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, e) } setDensity(e) { this.colliderSet.raw.coSetDensity(this.handle, e) } setMass(e) { this.colliderSet.raw.coSetMass(this.handle, e) } setMassProperties(e, t, s, r) { let n = Ne.intoRaw(t), o = Ne.intoRaw(s), a = zi.intoRaw(r); this.colliderSet.raw.coSetMassProperties(this.handle, e, n, o, a), n.free(), o.free(), a.free() } setTranslation(e) { this.colliderSet.raw.coSetTranslation(this.handle, e.x, e.y, e.z) } setTranslationWrtParent(e) { this.colliderSet.raw.coSetTranslationWrtParent(this.handle, e.x, e.y, e.z) } setRotation(e) { this.colliderSet.raw.coSetRotation(this.handle, e.x, e.y, e.z, e.w) } setRotationWrtParent(e) { this.colliderSet.raw.coSetRotationWrtParent(this.handle, e.x, e.y, e.z, e.w) } shapeType() { return this.colliderSet.raw.coShapeType(this.handle) } halfExtents() { return Ne.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle)) } radius() { return this.colliderSet.raw.coRadius(this.handle) } roundRadius() { return this.colliderSet.raw.coRoundRadius(this.handle) } halfHeight() { return this.colliderSet.raw.coHalfHeight(this.handle) } vertices() { return this.colliderSet.raw.coVertices(this.handle) } indices() { return this.colliderSet.raw.coIndices(this.handle) } heightfieldHeights() { return this.colliderSet.raw.coHeightfieldHeights(this.handle) } heightfieldScale() { let e = this.colliderSet.raw.coHeightfieldScale(this.handle); return Ne.fromRaw(e) } heightfieldNRows() { return this.colliderSet.raw.coHeightfieldNRows(this.handle) } heightfieldNCols() { return this.colliderSet.raw.coHeightfieldNCols(this.handle) } parent() { return this._parent } friction() { return this.colliderSet.raw.coFriction(this.handle) } restitution() { return this.colliderSet.raw.coRestitution(this.handle) } density() { return this.colliderSet.raw.coDensity(this.handle) } mass() { return this.colliderSet.raw.coMass(this.handle) } volume() { return this.colliderSet.raw.coVolume(this.handle) } collisionGroups() { return this.colliderSet.raw.coCollisionGroups(this.handle) } solverGroups() { return this.colliderSet.raw.coSolverGroups(this.handle) } containsPoint(e) { let t = Ne.intoRaw(e), s = this.colliderSet.raw.coContainsPoint(this.handle, t); return t.free(), s } projectPoint(e, t) { let s = Ne.intoRaw(e), r = U_.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, s, t)); return s.free(), r } intersectsRay(e, t) { let s = Ne.intoRaw(e.origin), r = Ne.intoRaw(e.dir), n = this.colliderSet.raw.coIntersectsRay(this.handle, s, r, t); return s.free(), r.free(), n } castShape(e, t, s, r, n, o) { let a = Ne.intoRaw(e), l = Ne.intoRaw(s), c = zi.intoRaw(r), h = Ne.intoRaw(n), d = t.intoRaw(), p = Tv.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, a, d, l, c, h, o)); return a.free(), l.free(), c.free(), h.free(), d.free(), p } castCollider(e, t, s, r) { let n = Ne.intoRaw(e), o = Ne.intoRaw(s), a = TI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, n, t.handle, o, r)); return n.free(), o.free(), a } intersectsShape(e, t, s) { let r = Ne.intoRaw(t), n = zi.intoRaw(s), o = e.intoRaw(), a = this.colliderSet.raw.coIntersectsShape(this.handle, o, r, n); return r.free(), n.free(), o.free(), a } contactShape(e, t, s, r) { let n = Ne.intoRaw(t), o = zi.intoRaw(s), a = e.intoRaw(), l = Iv.fromRaw(this.colliderSet.raw.coContactShape(this.handle, a, n, o, r)); return n.free(), o.free(), a.free(), l } contactCollider(e, t) { return Iv.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, e.handle, t)) } castRay(e, t, s) { let r = Ne.intoRaw(e.origin), n = Ne.intoRaw(e.dir), o = this.colliderSet.raw.coCastRay(this.handle, r, n, t, s); return r.free(), n.free(), o } castRayAndGetNormal(e, t, s) { let r = Ne.intoRaw(e.origin), n = Ne.intoRaw(e.dir), o = N_.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, r, n, t, s)); return r.free(), n.free(), o } } (function (i) { i[i.Density = 0] = "Density", i[i.Mass = 1] = "Mass", i[i.MassProps = 2] = "MassProps" })(Gp || (Gp = {})); class Ti { constructor(e) { this.shape = e, this.massPropsMode = Gp.Density, this.density = 1, this.friction = .5, this.restitution = 0, this.rotation = zi.identity(), this.translation = Ne.zeros(), this.isSensor = !1, this.collisionGroups = 4294967295, this.solverGroups = 4294967295, this.frictionCombineRule = Yn.Average, this.restitutionCombineRule = Yn.Average, this.activeCollisionTypes = R_.DEFAULT, this.activeEvents = 0, this.activeHooks = 0, this.mass = 0, this.centerOfMass = Ne.zeros(), this.contactForceEventThreshold = 0, this.principalAngularInertia = Ne.zeros(), this.angularInertiaLocalFrame = zi.identity() } static ball(e) { const t = new AI(e); return new Ti(t) } static capsule(e, t) { const s = new zN(e, t); return new Ti(s) } static segment(e, t) { const s = new jN(e, t); return new Ti(s) } static triangle(e, t, s) { const r = new QN(e, t, s); return new Ti(r) } static roundTriangle(e, t, s, r) { const n = new GN(e, t, s, r); return new Ti(n) } static polyline(e, t) { const s = new HN(e, t); return new Ti(s) } static trimesh(e, t) { const s = new VN(e, t); return new Ti(s) } static cuboid(e, t, s) { const r = new UN(e, t, s); return new Ti(r) } static roundCuboid(e, t, s, r) { const n = new NN(e, t, s, r); return new Ti(n) } static heightfield(e, t, s, r) { const n = new WN(e, t, s, r); return new Ti(n) } static cylinder(e, t) { const s = new qN(e, t); return new Ti(s) } static roundCylinder(e, t, s) { const r = new XN(e, t, s); return new Ti(r) } static cone(e, t) { const s = new YN(e, t); return new Ti(s) } static roundCone(e, t, s) { const r = new JN(e, t, s); return new Ti(r) } static convexHull(e) { const t = new yI(e, null); return new Ti(t) } static convexMesh(e, t) { const s = new yI(e, t); return new Ti(s) } static roundConvexHull(e, t) { const s = new bI(e, null, t); return new Ti(s) } static roundConvexMesh(e, t, s) { const r = new bI(e, t, s); return new Ti(r) } setTranslation(e, t, s) { if (typeof e != "number" || typeof t != "number" || typeof s != "number") throw TypeError("The translation components must be numbers."); return this.translation = { x: e, y: t, z: s }, this } setRotation(e) { return zi.copy(this.rotation, e), this } setSensor(e) { return this.isSensor = e, this } setDensity(e) { return this.massPropsMode = Gp.Density, this.density = e, this } setMass(e) { return this.massPropsMode = Gp.Mass, this.mass = e, this } setMassProperties(e, t, s, r) { return this.massPropsMode = Gp.MassProps, this.mass = e, Ne.copy(this.centerOfMass, t), Ne.copy(this.principalAngularInertia, s), zi.copy(this.angularInertiaLocalFrame, r), this } setRestitution(e) { return this.restitution = e, this } setFriction(e) { return this.friction = e, this } setFrictionCombineRule(e) { return this.frictionCombineRule = e, this } setRestitutionCombineRule(e) { return this.restitutionCombineRule = e, this } setCollisionGroups(e) { return this.collisionGroups = e, this } setSolverGroups(e) { return this.solverGroups = e, this } setActiveHooks(e) { return this.activeHooks = e, this } setActiveEvents(e) { return this.activeEvents = e, this } setActiveCollisionTypes(e) { return this.activeCollisionTypes = e, this } setContactForceEventThreshold(e) { return this.contactForceEventThreshold = e, this } } (function (i) { i[i.EXCLUDE_FIXED = 1] = "EXCLUDE_FIXED", i[i.EXCLUDE_KINEMATIC = 2] = "EXCLUDE_KINEMATIC", i[i.EXCLUDE_DYNAMIC = 4] = "EXCLUDE_DYNAMIC", i[i.EXCLUDE_SENSORS = 8] = "EXCLUDE_SENSORS", i[i.EXCLUDE_SOLIDS = 16] = "EXCLUDE_SOLIDS", i[i.ONLY_DYNAMIC = 3] = "ONLY_DYNAMIC", i[i.ONLY_KINEMATIC = 5] = "ONLY_KINEMATIC", i[i.ONLY_FIXED = 6] = "ONLY_FIXED" })(mI || (mI = {})), function (i) { i[i.COLLISION_EVENTS = 1] = "COLLISION_EVENTS", i[i.CONTACT_FORCE_EVENTS = 2] = "CONTACT_FORCE_EVENTS" }(vI || (vI = {})); class qne { free() { this.raw.free(), this.raw = void 0 } collider1() { return this.raw.collider1() } collider2() { return this.raw.collider2() } totalForce() { return Ne.fromRaw(this.raw.total_force()) } totalForceMagnitude() { return this.raw.total_force_magnitude() } maxForceDirection() { return Ne.fromRaw(this.raw.max_force_direction()) } maxForceMagnitude() { return this.raw.max_force_magnitude() } } class Xne { constructor(e, t) { this.raw = t || new F_(e) } free() { this.raw.free(), this.raw = void 0 } drainCollisionEvents(e) { this.raw.drainCollisionEvents(e) } drainContactForceEvents(e) { let t = new qne; this.raw.drainContactForceEvents(s => { t.raw = s, e(t), t.free() }) } clear() { this.raw.clear() } } (function (i) { i[i.FILTER_CONTACT_PAIRS = 1] = "FILTER_CONTACT_PAIRS", i[i.FILTER_INTERSECTION_PAIRS = 2] = "FILTER_INTERSECTION_PAIRS" })(LN || (LN = {})), function (i) { i[i.EMPTY = 0] = "EMPTY", i[i.COMPUTE_IMPULSE = 1] = "COMPUTE_IMPULSE" }(FN || (FN = {})); for (var ioe = { byteLength: function (i) { var e = KN(i), t = e[0], s = e[1]; return 3 * (t + s) / 4 - s }, toByteArray: function (i) { var e, t, s = KN(i), r = s[0], n = s[1], o = new Yne(function (c, h, d) { return 3 * (h + d) / 4 - d }(0, r, n)), a = 0, l = n > 0 ? r - 4 : r; for (t = 0; t < l; t += 4)e = Jn[i.charCodeAt(t)] << 18 | Jn[i.charCodeAt(t + 1)] << 12 | Jn[i.charCodeAt(t + 2)] << 6 | Jn[i.charCodeAt(t + 3)], o[a++] = e >> 16 & 255, o[a++] = e >> 8 & 255, o[a++] = 255 & e; return n === 2 && (e = Jn[i.charCodeAt(t)] << 2 | Jn[i.charCodeAt(t + 1)] >> 4, o[a++] = 255 & e), n === 1 && (e = Jn[i.charCodeAt(t)] << 10 | Jn[i.charCodeAt(t + 1)] << 4 | Jn[i.charCodeAt(t + 2)] >> 2, o[a++] = e >> 8 & 255, o[a++] = 255 & e), o }, fromByteArray: function (i) { for (var e, t = i.length, s = t % 3, r = [], n = 16383, o = 0, a = t - s; o < a; o += n)r.push(Kne(i, o, o + n > a ? a : o + n)); return s === 1 ? (e = i[t - 1], r.push(ga[e >> 2] + ga[e << 4 & 63] + "==")) : s === 2 && (e = (i[t - 2] << 8) + i[t - 1], r.push(ga[e >> 10] + ga[e >> 4 & 63] + ga[e << 2 & 63] + "=")), r.join("") } }, ga = [], Jn = [], Yne = typeof Uint8Array < "u" ? Uint8Array : Array, _I = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Hp = 0, Jne = _I.length; Hp < Jne; ++Hp)ga[Hp] = _I[Hp], Jn[_I.charCodeAt(Hp)] = Hp; function KN(i) { var e = i.length; if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var t = i.indexOf("="); return t === -1 && (t = e), [t, t === e ? 0 : 4 - t % 4] } function Kne(i, e, t) { for (var s, r, n = [], o = e; o < t; o += 3)s = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (255 & i[o + 2]), n.push(ga[(r = s) >> 18 & 63] + ga[r >> 12 & 63] + ga[r >> 6 & 63] + ga[63 & r]); return n.join("") } Jn["-".charCodeAt(0)] = 62, Jn["_".charCodeAt(0)] = 63; const ma = oe("debugphysics"), xI = oe("debugphysicscolliders"), wI = oe("debugcollisions"), Zne = oe("showcolliders"), Mo = Symbol("needle component"), Kn = Symbol("physics body"), $ne = Symbol("rigidbody"); let Vp; const P_ = class { constructor() { u(this, "context"), u(this, "_initializePromise"), u(this, "_isInitialized", !1), u(this, "rapierRay", new Vne({ x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 1 })), u(this, "raycastVectorsBuffer", new To(() => new S, 10)), u(this, "rapierSphere", null), u(this, "rapierColliderArray", []), u(this, "rapierIdentityRotation", { x: 0, y: 0, z: 0, w: 1 }), u(this, "rapierForwardVector", { x: 0, y: 0, z: 1 }), u(this, "enabled", !1), u(this, "_tempPosition", new S), u(this, "_tempQuaternion", new we), u(this, "_tempScale", new S), u(this, "_tempMatrix", new He), u(this, "_isUpdatingPhysicsWorld", !1), u(this, "world"), u(this, "_hasCreatedWorld", !1), u(this, "eventQueue"), u(this, "collisionHandler"), u(this, "objects", []), u(this, "bodies", []), u(this, "_meshCache", new Map), u(this, "_gravity", { x: 0, y: -9.81, z: 0 }), u(this, "lines") } removeBody(i) { var e, t; this.validate(); const s = i[Kn]; if (i[Kn] = null, s && this.world) { const r = this.objects.findIndex(n => n === i); if (r >= 0) { const n = this.bodies[r]; if (this.bodies.splice(r, 1), this.objects.splice(r, 1), n instanceof Wne) { const o = n; (e = this.world) == null || e.removeCollider(o, !0); const a = o.parent(); a && a.numColliders() <= 0 && ((t = this.world) == null || t.removeRigidBody(a)) } } } } updateBody(i, e, t) { if (this.validate(), !!this.enabled && !(i.destroyed || !i.gameObject) && !(!e && !t)) if (i.isCollider === !0) console.warn("TODO: implement updating collider position"); else { const s = i, r = s[Kn]; r && this.syncPhysicsBody(s.gameObject, r, e, t) } } updateProperties(i) { this.validate(); const e = i[Kn]; e && this.internalUpdateProperties(i, e) } addForce(i, e, t) { this.validate(); const s = this.internal_getRigidbody(i); s?.addForce(e, t) } addImpulse(i, e, t) { this.validate(); const s = this.internal_getRigidbody(i); s?.applyImpulse(e, t) } getLinearVelocity(i) { this.validate(); const e = this.internal_getRigidbody(i); return e ? e.linvel() : null } getAngularVelocity(i) { this.validate(); const e = this.internal_getRigidbody(i); return e ? e.angvel() : null } resetForces(i, e) { this.validate(); const t = this.internal_getRigidbody(i); t?.resetForces(e) } resetTorques(i, e) { this.validate(); const t = this.internal_getRigidbody(i); t?.resetTorques(e) } applyImpulse(i, e, t) { this.validate(); const s = this.internal_getRigidbody(i); s?.applyImpulse(e, t) } wakeup(i) { this.validate(); const e = this.internal_getRigidbody(i); e?.wakeUp() } setAngularVelocity(i, e, t) { this.validate(); const s = this.internal_getRigidbody(i); s?.setAngvel(e, t) } setLinearVelocity(i, e, t) { this.validate(); const s = this.internal_getRigidbody(i); s?.setLinvel(e, t) } async initialize(i) { return this.context = i, this._initializePromise || (this._initializePromise = this.internalInitialization()), this._initializePromise } async internalInitialization() { return "env" in import.meta && {}.VITE_NEEDLE_USE_RAPIER, !1 } validate() { this._isInitialized || ma && console.warn("Physics engine is not initialized") } raycast(i, e = void 0, t = 1 / 0, s = !0) { var r; const n = this.getPhysicsRay(this.rapierRay, i, e); if (!n) return null; const o = (r = this.world) == null ? void 0 : r.castRay(n, t, s, void 0, void 0, void 0, void 0, a => { var l; return !((l = a[Mo]) != null && l.gameObject.layers.isEnabled(2)) }); if (o) { const a = n.pointAt(o.toi), l = this.raycastVectorsBuffer.get(); return l.set(a.x, a.y, a.z), { point: l, collider: o.collider[Mo] } } return null } raycastAndGetNormal(i, e = void 0, t = 1 / 0, s = !0) { var r; const n = this.getPhysicsRay(this.rapierRay, i, e); if (!n) return null; const o = (r = this.world) == null ? void 0 : r.castRayAndGetNormal(n, t, s, void 0, void 0, void 0, void 0, a => { var l; return !((l = a[Mo]) != null && l.gameObject.layers.isEnabled(2)) }); if (o) { const a = n.pointAt(o.toi), l = o.normal, c = this.raycastVectorsBuffer.get(), h = this.raycastVectorsBuffer.get(); return c.set(a.x, a.y, a.z), h.set(l.x, l.y, l.z), { point: c, normal: h, collider: o.collider[Mo] } } return null } getPhysicsRay(i, e, t = void 0) { var s, r; const n = (s = this.context) == null ? void 0 : s.mainCamera; if (e.z === void 0) { if (!n) return console.error("Can not perform raycast from 2d point - no main camera found"), null; const l = this.raycastVectorsBuffer.get(); l.x = e.x, l.y = e.y, l.z = 0, (l.x > 1 || l.y > 1 || l.y < -1 || l.x < -1) && ((r = this.context) == null || r.input.convertScreenspaceToRaycastSpace(l)), l.unproject(n), e = l } const o = e; i.origin.x = o.x, i.origin.y = o.y, i.origin.z = o.z; const a = this.raycastVectorsBuffer.get(); if (t) a.set(t.x, t.y, t.z); else { if (!n) return console.error("Can not perform raycast - no camera found"), null; a.set(i.origin.x, i.origin.y, i.origin.z); const l = xt(n); a.sub(l) } return a.normalize(), i.dir.x = a.x, i.dir.y = a.y, i.dir.z = a.z, i } sphereOverlap(i, e) { return this.rapierColliderArray.length = 0, this.world ? (this.rapierSphere || (this.rapierSphere = new AI(e)), this.rapierSphere.radius = e, this.world.intersectionsWithShape(i, this.rapierIdentityRotation, this.rapierSphere, t => { const s = t[Mo], r = new IN(s.gameObject, s); return this.rapierColliderArray.push(r), !0 }, mI.EXCLUDE_SENSORS, void 0, void 0, void 0, t => t[Mo].gameObject.layers.isEnabled(2) == !1), this.rapierColliderArray) : this.rapierColliderArray } get isUpdating() { return this._isUpdatingPhysicsWorld } get gravity() { var i; return ((i = this.world) == null ? void 0 : i.gravity) ?? this._gravity } set gravity(i) { this.world ? this.world.gravity = i : this._gravity = i } clearCaches() { this._meshCache.clear() } async addBoxCollider(i, e, t) { if (this._isInitialized || await this.initialize(i.context), !i.activeAndEnabled) return; if (!this.enabled) { ma && console.warn("Physics are disabled"); return } const s = i.gameObject, r = Fs(s, this._tempPosition).multiply(t); r.multiplyScalar(.5), r.x < 0 && (r.x = Math.abs(r.x)), r.y < 0 && (r.y = Math.abs(r.y)), r.z < 0 && (r.z = Math.abs(r.z)), r.x == 0 && (r.x = 1e-7), r.y == 0 && (r.y = 1e-7), r.z == 0 && (r.z = 1e-7); const n = Ti.cuboid(r.x, r.y, r.z); this.createCollider(i, n, e) } async addSphereCollider(i, e, t) { if (this._isInitialized || await this.initialize(i.context), !i.activeAndEnabled) return; if (!this.enabled) { ma && console.warn("Physics are disabled"); return } const s = i.gameObject, r = Fs(s, this._tempPosition).multiplyScalar(t); r.x = Math.abs(r.x); const n = Ti.ball(r.x); this.createCollider(i, n, e) } async addCapsuleCollider(i, e, t, s) { if (this._isInitialized || await this.initialize(i.context), !i.activeAndEnabled) return; if (!this.enabled) { ma && console.warn("Physics are disabled"); return } const r = i.gameObject, n = Fs(r, this._tempPosition); n.x = Math.abs(n.x), n.y = Math.abs(n.y); const o = Ti.capsule(t * .5 * n.y - s, s * n.x); this.createCollider(i, o, e) } async addMeshCollider(i, e, t, s) { var r; if (this._isInitialized || await this.initialize(i.context), !i.activeAndEnabled) return; if (!this.enabled) { ma && console.warn("Physics are disabled"); return } const n = e.geometry; if (!n) { ma && console.warn("Missing mesh geometry", e.name); return } let o = n.getAttribute("position").array; const a = (r = n.index) == null ? void 0 : r.array; if (Math.abs(s.x - 1) > 1e-4 || Math.abs(s.y - 1) > 1e-4 || Math.abs(s.z - 1) > 1e-4) { const c = n.uuid + "_" + s.x + "_" + s.y + "_" + s.z + "_" + t; if (this._meshCache.has(c)) o = this._meshCache.get(c); else { console.warn("Your model is using scaled mesh colliders which is not optimal for performance", e.name, Object.assign({}, s), e); const h = new Float32Array(o.length); for (let d = 0; d < o.length; d += 3)h[d] = o[d] * s.x, h[d + 1] = o[d + 1] * s.y, h[d + 2] = o[d + 2] * s.z; o = h, this._meshCache.set(c, h) } } const l = t ? Ti.convexMesh(o) : Ti.trimesh(o, a); l && this.createCollider(i, l).setMassProperties(1, { x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 0, w: 1 }) } createCollider(i, e, t) { if (!this.world) throw new Error("Physics world not initialized"); const s = this._tempMatrix, { rigidBody: r, useExplicitMassProperties: n } = this.getRigidbody(i, this._tempMatrix); s.decompose(this._tempPosition, this._tempQuaternion, this._tempScale), Fs(i.gameObject, this._tempScale), t && (t.multiply(this._tempScale), this._tempPosition.x -= t.x, this._tempPosition.y += t.y, this._tempPosition.z += t.z), e.setTranslation(this._tempPosition.x, this._tempPosition.y, this._tempPosition.z), e.setRotation(this._tempQuaternion), e.setSensor(i.isTrigger); const o = i.sharedMaterial; if (o) { switch (e.setRestitution(o.bounciness), o.bounceCombine) { case Jo.Average: e.setRestitutionCombineRule(Yn.Average); break; case Jo.Maximum: e.setRestitutionCombineRule(Yn.Max); break; case Jo.Minimum: e.setRestitutionCombineRule(Yn.Min); break; case Jo.Multiply: e.setRestitutionCombineRule(Yn.Multiply); break }switch (e.setFriction(o.dynamicFriction), o.frictionCombine) { case Jo.Average: e.setFrictionCombineRule(Yn.Average); break; case Jo.Maximum: e.setFrictionCombineRule(Yn.Max); break; case Jo.Minimum: e.setFrictionCombineRule(Yn.Min); break; case Jo.Multiply: e.setFrictionCombineRule(Yn.Multiply); break } } const a = this.world.createCollider(e, r); return a[Mo] = i, i[Kn] = a, a.setActiveEvents(vI.COLLISION_EVENTS), a.setActiveCollisionTypes(R_.ALL), this.objects.push(i), this.bodies.push(a), a } getRigidbody(i, e) { if (!this.world) throw new Error("Physics world not initialized"); let t = null, s = !1; if (i.attachedRigidbody) { const r = i.attachedRigidbody; if (t = r[Kn], s = !0, !t) { const n = r.isKinematic && !xI; ma && console.log("Create rigidbody", n); const o = n ? Vp.RigidBodyDesc.kinematicPositionBased() : Vp.RigidBodyDesc.dynamic(), a = xt(i.attachedRigidbody.gameObject); o.setTranslation(a.x, a.y, a.z), o.setRotation(_s(i.attachedRigidbody.gameObject)), t = this.world.createRigidBody(o), this.bodies.push(t), this.objects.push(r) } t[Mo] = r, r[Kn] = t, this.internalUpdateProperties(r, t), this.getRigidbodyRelativeMatrix(i.gameObject, r.gameObject, e) } else { const r = Vp.RigidBodyDesc.kinematicPositionBased(), n = xt(i.gameObject); r.setTranslation(n.x, n.y, n.z), r.setRotation(_s(i.gameObject)), t = this.world.createRigidBody(r), e.identity(), t[Mo] = null } return i[$ne] = t, { rigidBody: t, useExplicitMassProperties: s } } internal_getRigidbody(i) { return i[Kn] } internalUpdateProperties(i, e) { e.enableCcd(i.collisionDetectionMode !== Vy.Discrete), e.setLinearDamping(i.drag), e.setAngularDamping(i.angularDrag), e.setGravityScale(i.useGravity ? i.gravityScale : 0, !0), e.setEnabledRotations(!i.lockRotationX, !i.lockRotationY, !i.lockRotationZ, !0), e.setEnabledTranslations(!i.lockPositionX, !i.lockPositionY, !i.lockPositionZ, !0), i.isKinematic ? e.setBodyType(Vp.RigidBodyType.KinematicPositionBased) : e.setBodyType(Vp.RigidBodyType.Dynamic) } step(i) { this.world && this.enabled && (this._isUpdatingPhysicsWorld = !0, this.eventQueue || (this.eventQueue = new Xne(!1)), i && (this.world.timestep = Ke.lerp(this.world.timestep, i, .8)), this.world.step(this.eventQueue), this._isUpdatingPhysicsWorld = !1, this.updateDebugRendering(this.world)) } updateDebugRendering(i) { var e; if (ma || xI || Zne) { if (!this.lines) { const s = new Hi({ color: 2258688 }), r = new yt; this.lines = new sn(r, s), (e = this.context) == null || e.scene.add(this.lines) } const t = i.debugRender(); this.lines.geometry.setAttribute("position", new nt(t.vertices, 3)), this.lines.geometry.setAttribute("color", new nt(t.colors, 4)) } } postStep() { this.world && this.enabled && (this._isUpdatingPhysicsWorld = !0, this.syncObjects(), this._isUpdatingPhysicsWorld = !1, this.eventQueue && !this.collisionHandler && (this.collisionHandler = new eoe(this.world, this.eventQueue)), this.collisionHandler && (this.collisionHandler.handleCollisionEvents(), this.collisionHandler.update())) } syncObjects() { if (!xI) for (let i = 0; i < this.bodies.length; i++) { const e = this.objects[i], t = this.bodies[i], s = e; if (s?.isCollider === !0 && !s.attachedRigidbody) { const a = t.parent(); a && this.syncPhysicsBody(e.gameObject, a, !0, !0); continue } const r = t.translation(), n = t.rotation(), o = e.center; if (o && o.isVector3) { this._tempQuaternion.set(n.x, n.y, n.z, n.w); const a = this._tempPosition.copy(o).applyQuaternion(this._tempQuaternion), l = Fs(e.gameObject); a.multiply(l), r.x -= a.x, r.y -= a.y, r.z -= a.z } dd(e.gameObject, r.x, r.y, r.z), fB(e.gameObject, n.x, n.y, n.z, n.w) } } syncPhysicsBody(i, e, t, s) { const r = xt(i, this._tempPosition), n = _s(i, this._tempQuaternion); switch (e.bodyType()) { case mv.Fixed: case mv.KinematicPositionBased: case mv.KinematicVelocityBased: t && e.setNextKinematicTranslation(r), s && e.setNextKinematicRotation(n); break; default: t && e.setTranslation(r, !1), s && e.setRotation(n, !1); break }e.wakeUp() } getRigidbodyRelativeMatrix(i, e, t, s) { if (s === void 0 && (s = P_._matricesBuffer, s.length = 0), i === e) { const r = Fs(i, this._tempPosition); t.makeScale(r.x, r.y, r.z); for (let n = s.length - 1; n >= 0; n--)t.multiply(s[n]); return t } return s.push(i.matrix), i.parent && this.getRigidbodyRelativeMatrix(i.parent, e, t, s), t } addFixedJoint(i, e) { if (!this.world) { console.error("Physics world not initialized"); return } const t = i[Kn], s = e[Kn]; this.calculateJointRelativeMatrices(i.gameObject, e.gameObject, this._tempMatrix), this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale); const r = $p.fixed(P_.centerConnectionPos, P_.centerConnectionRot, this._tempPosition, this._tempQuaternion), n = this.world.createImpulseJoint(r, t, s, !0); ma && console.log("ADD FIXED JOINT", n) } addHingeJoint(i, e, t, s) { if (!this.world) { console.error("Physics world not initialized"); return } const r = i[Kn], n = e[Kn]; this.calculateJointRelativeMatrices(i.gameObject, e.gameObject, this._tempMatrix), this._tempMatrix.decompose(this._tempPosition, this._tempQuaternion, this._tempScale); let o = Vp.JointData.revolute(t, this._tempPosition, s), a = this.world.createImpulseJoint(o, r, n, !0); ma && console.log("ADD HINGE JOINT", a) } calculateJointRelativeMatrices(i, e, t) { i.updateWorldMatrix(!0, !1), e.updateWorldMatrix(!0, !1); const s = i.matrixWorld, r = e.matrixWorld; s.elements[0] = 1, s.elements[5] = 1, s.elements[10] = 1, r.elements[0] = 1, r.elements[5] = 1, r.elements[10] = 1, t.copy(r).premultiply(s.invert()).invert() } }; let vv = P_; u(vv, "_didLoadPhysicsEngine", !1), u(vv, "_matricesBuffer", []), u(vv, "centerConnectionPos", { x: 0, y: 0, z: 0 }), u(vv, "centerConnectionRot", { x: 0, y: 0, z: 0, w: 1 }); class eoe { constructor(e, t) { u(this, "world"), u(this, "eventQueue"), u(this, "activeCollisions", []), u(this, "activeCollisionsStay", []), u(this, "activeTriggers", []), this.world = e, this.eventQueue = t } handleCollisionEvents() { this.eventQueue && this.world && this.eventQueue.drainCollisionEvents((e, t, s) => { const r = this.world.getCollider(e), n = this.world.getCollider(t), o = r[Mo], a = n[Mo]; wI && console.log("EVT", o.name, a.name, s, r, n), o && a && (s ? (this.onCollisionStarted(o, r, a, n), this.onCollisionStarted(a, n, o, r)) : (this.onCollisionEnded(o, a), this.onCollisionEnded(a, o))) }) } update() { this.onHandleCollisionStay() } onCollisionStarted(e, t, s, r) { let n = null; if (e.isTrigger || s.isTrigger) Dh(e.gameObject, o => { o.onTriggerEnter && !o.destroyed && o.onTriggerEnter(s), this.activeTriggers.push({ collider: e, component: o, otherCollider: s }) }); else { const o = e.gameObject; this.world.contactPair(t, r, (a, l) => { Dh(o, c => { var h; if (c.destroyed) return; const d = c.onCollisionEnter || c.onCollisionStay || c.onCollisionExit; if (d || wI) { if (!n) { const p = [], f = a.normal(); for (let g = 0; g < a.numSolverContacts(); g++) { const m = a.solverContactPoint(g), v = a.contactImpulse(g); if (m) { const A = a.contactDist(g), b = a.solverContactFriction(g), y = new EN(m, A, f, v, b); p.push(y), wI && Wo.DrawDirection(m, f, 16711680, 3, !0) } } n = new MN(o, s, p) } if (d) { const p = { collider: e, component: c, collision: n }; this.activeCollisions.push(p), c.onCollisionStay && this.activeCollisionsStay.push(p), (h = c.onCollisionEnter) == null || h.call(c, n) } } }) }) } } onHandleCollisionStay() { for (const e of this.activeCollisionsStay) { const t = e.component; if (!t.destroyed && t.activeAndEnabled && t.onCollisionStay) { const s = e.collision; t.onCollisionStay(s) } } for (const e of this.activeTriggers) { const t = e.component; if (!t.destroyed && t.activeAndEnabled && t.onTriggerStay) { const s = e.otherCollider; t.onTriggerStay(s) } } } onCollisionEnded(e, t) { if (!(e.destroyed || t.destroyed)) { for (let s = 0; s < this.activeCollisions.length; s++) { const r = this.activeCollisions[s], n = r.collider; if (n.destroyed) { this.activeCollisions.splice(s, 1), s--; continue } if (n === e && r.collision.collider === t) { const o = r.component; if (this.activeCollisions.splice(s, 1), s--, o.activeAndEnabled && o.onCollisionExit) { const a = r.collision; o.onCollisionExit(a) } } } for (let s = 0; s < this.activeCollisionsStay.length; s++) { const r = this.activeCollisionsStay[s], n = r.collider; if (n.destroyed) { this.activeCollisionsStay.splice(s, 1), s--; continue } if (n === e && r.collision.collider === t) { const o = r.component; if (this.activeCollisionsStay.splice(s, 1), s--, o.activeAndEnabled && o.onCollisionExit) { const a = r.collision; o.onCollisionExit(a) } } } for (let s = 0; s < this.activeTriggers.length; s++) { const r = this.activeTriggers[s], n = r.collider; if (n.destroyed) { this.activeTriggers.splice(s, 1), s--; continue } if (n === e && r.otherCollider === t) { const o = r.component; if (this.activeTriggers.splice(s, 1), s--, o.activeAndEnabled && o.onTriggerExit) { const a = r.otherCollider; o.onTriggerExit(a) } } } } } } Object.defineProperty(Xt.prototype, "fov", { get: function () { return this._fov }, set: function (i) { const e = i !== this._fov; this._fov = i, e && this.view !== void 0 && this.updateProjectionMatrix() } }), Object.defineProperty(Xt.prototype, "near", { get: function () { return this._near }, set: function (i) { const e = i !== this._near; this._near = i, e && this.view !== void 0 && this.updateProjectionMatrix() } }), Object.defineProperty(Xt.prototype, "far", { get: function () { return this._far }, set: function (i) { const e = i !== this._far; this._far = i, e && this.view !== void 0 && this.updateProjectionMatrix() } }); function toe(i, e, t, s = "image/webp", r) { if (!r && (r = i.mainCamera, !r)) return console.error("No camera found"), null; const n = i.renderer.domElement.width, o = i.renderer.domElement.height; try { const a = i.renderer.domElement; return i.renderer.setSize(e, t), r instanceof Xt && i.updateAspect(r, e, t), i.renderNow(), a.toDataURL(s) } finally { i.renderer.setSize(n, o), i.updateSize() } return null } mz(); const B_ = { Context: _t }; globalThis.Needle !== void 0 && console.warn("Needle Engine is already imported"), globalThis.Needle = B_; function ZN(i) { for (const e in i) B_[e] = i[e] } ZN(Tq), ZN(Ane), B_.$meta = { version: $_, generator: qI }; for (const i of Object.getOwnPropertyNames($)) switch (i) { case "prototype": case "constructor": case "length": case "name": continue; default: B_[i] = $[i]; break }globalThis.THREE ? console.warn("Threejs is already imported") : globalThis.THREE = WV; export { zne as $physicsKey, ni as ActionBuilder, ES as ActionCollection, yo as ActionModel, fD as Addressables, Ug as AlignmentConstraint, xd as AmbientMode, mo as Animation, Gh as AnimationCurve, Uy as AnimationExtension, bb as AnimationTrackHandler, Fr as Animator, hc as AnimatorConditionMode, xu as AnimatorController, kC as AnimatorControllerParameterType, cy as AnimatorStateInfo, vm as Antialiasing, AD as Application, ay as ApplicationEvents, v2 as AssetDatabase, or as AssetReference, ea as AttachedObject, db as AttachedObjectEvents, xb as AudioExtension, cp as AudioListener, ss as AudioSource, fm as AudioTrackHandler, Kh as AvatarBlink_Simple, dp as AvatarEyeLook_Rotation, Gy as AvatarLoader, lr as AvatarMarker, Qy as AvatarModel, Gg as Avatar_Brain_LookAt, Am as Avatar_MouthShapes, BE as Avatar_MustacheShake, Er as Avatar_POI, Kd as Axes, pp as AxesHelper, ba as BaseUIComponent, LE as BasicIKConstraint, Cb as BehaviorExtension, Cr as BehaviorModel, Ee as Behaviour, Zh as Bloom, bm as BoxCollider, qh as BoxGizmo, qo as BoxHelperComponent, Al as Button, jh as CallInfo, Si as Camera, cr as Canvas, Ap as CanvasGroup, kc as CapsuleCollider, Cm as ChangeMaterialOnClick, tu as ChangeTransformOnClick, iu as CharacterController, bl as CharacterControllerInput, Mm as ChromaticAberration, To as CircularBuffer, BF as ClearFlags, Bc as ClipExtrapolation, ia as Collider, MN as Collision, Vy as CollisionDetectionMode, Uc as ColorAdjustments, su as ColorBySpeedModule, Tm as ColorOverLifetimeModule, ac as Component, ig as ComponentEvents, sg as ComponentLifecycleEvents, qk as ConnectionEvents, EN as ContactPoint, _t as Context, Eq as ContextArgs, Jr as ContextEvent, Zi as ContextRegistry, _b as ControlTrackHandler, pl as ControllerEvents, rp as ControllerType, Qc as CustomBranding, vo as CustomShader, oy as DefaultReflectionMode, eM as Deletable, Nb as DeleteBox, Eo as DepthOfField, zb as DeviceFlag, tM as DocumentExtension, Sp as DragControls, Pm as DropListener, ou as Duplicatable, Sy as EXTENSION_NAME, na as EmissionModule, _p as EmphasizeOnClick, yC as EngineLoadingView, Nr as EventList, My as EventListEvent, jn as EventSystem, Gb as EventTrigger, vS as FieldWithDefault, YF as FileSpawnModel, XF as File_Event, uM as FixedJoint, dM as FlyControls, Mp as Fog, on as FrameEvent, $ as GameObject, Wo as Gizmos, Rl as GltfExport, yM as GltfExportBox, bu as GltfLoadEvent, gN as GltfLoadEventType, Nc as Gradient, Dc as Graphic, SE as GraphicRaycaster, lo as Graphics, Tp as GridHelper, qE as GridLayoutGroup, au as GroundProjectedEnv, bc as GroupActionModel, x2 as HideFlags, KE as HideOnStart, Bm as HingeJoint, WE as HorizontalLayoutGroup, D8 as HostData, mp as Image, ny as ImageReference, gD as ImageReferenceSerializer, jc as InheritVelocityModule, dB as Input, Lo as InputEvents, cu as InputField, Xr as InstancingUtil, Zk as InstantiateEvent, Br as InstantiateIdProvider, No as InstantiateOptions, Yd as Interactable, b8 as JoinedRoomResponse, f0 as KeyEventArgs, Lm as LODGroup, hu as LODModel, _8 as LeftRoomResponse, Wr as Light, vD as LightData, ls as LimitVelocityOverLifetimeModule, Uq as LoadingElementOptions, CM as LogStats, Ro as LogType, uu as LookAt, zg as LookAtConstraint, Hs as MainModule, TE as MarkerType, wm as MaskableGraphic, Ke as Mathf, _m as MeshCollider, Ry as MeshRenderer, it as MinMaxCurve, Hr as MinMaxGradient, qI as NEEDLE_ENGINE_GENERATOR, $_ as NEEDLE_ENGINE_VERSION, il as NEEDLE_progressive, pI as NeedleEngineHTMLElement, uI as NeedleGltfLoader, q0 as NeedlePatchesKey, Xb as NestedGltf, Yk as NetworkConnection, nu as Networking, hi as NoiseModule, Yh as ObjectRaycaster, du as OffsetConstraint, Bp as OpenURL, Pc as OrbitControls, gp as Outline, Xk as OwnershipEvent, z0 as OwnershipModel, Oc as Padding, Im as ParticleBurst, s_ as ParticleSubEmitter, us as ParticleSystem, xl as ParticleSystemRenderer, SB as Physics, Jo as PhysicsMaterialCombine, Gm as PixelationEffect, Fc as PlayAnimationOnClick, xp as PlayAudioOnClick, um as PlayableDirector, wu as PlayerColor, jp as PlayerState, pN as PlayerStateEvent, aI as PlayerSync, _D as PlayerView, xD as PlayerViewManager, Xh as PointerEventData, uB as PointerType, Ir as PostProcessingEffect, n_ as PostProcessingHandler, Cp as PreliminaryAction, Sm as PreliminaryTrigger, JO as ProgressiveLoadingInfo, mi as RGBAColor, vv as RapierPhysics, Rb as RawImage, co as RaycastOptions, lp as Raycaster, QE as Rect, Tr as RectTransform, Qd as ReflectionProbe, Ly as RegisteredAnimationInfo, pu as RemoteSkybox, jd as RenderTexture, tL as RenderTextureSerializer, Ui as Renderer, mD as RendererData, Lg as RendererLightmap, ki as Rigidbody, Yi as RigidbodyConstraints, Li as RoomEvents, un as RotationBySpeedModule, Gn as RotationOverLifetimeModule, Cy as SceneLightSettings, pn as SceneSwitcher, qm as ScreenCapture, wl as ScreenSpaceAmbientOcclusion, Lr as SendQueue, bp as SetActiveOnClick, Jm as ShadowCatcher, Ji as ShapeModule, cm as SignalAsset, up as SignalReceiver, hp as SignalReceiverEvent, gm as SignalTrackHandler, jE as Size, Rr as SizeBySpeedModule, zc as SizeOverLifetimeModule, AS as SkinnedMeshRenderer, Wc as SmoothFollow, QM as SpatialHtml, $m as SpatialTrigger, ua as SpatialTriggerReceiver, u_ as SpectatorCamera, ym as SphereCollider, CB as SphereIntersection, IN as SphereOverlapResult, Cl as Sprite, Up as SpriteData, fu as SpriteRenderer, ev as SpriteSheet, Zq as StateMachineBehaviour, Qm as SubEmitterSystem, p_ as SyncedCamera, qc as SyncedRoom, Ic as SyncedTransform, $E as TapGestureTrigger, ub as TeleportTarget, KM as TestRunner, ZM as TestSimulateUserData, Vr as Text, g_ as TextBuilder, $M as TextExtension, Vs as TextureSheetAnimationModule, da as TiltShiftEffect, MB as Time, iv as ToneMapping, dm as TrackHandler, ln as TrackType, Mi as TrailModule, Fy as TransformData, vu as TransformGizmo, zr as TriggerBuilder, Hd as TriggerModel, Q as TypeStore, sp as UIRaycastUtils, em as UIRootComponent, Vn as USDZExporter, Xc as USDZText, lC as Upload_Result, iL as UriSerializer, Jd as UsageMarker, x8 as UserJoinedOrLeftRoomModel, fl as VRUserState, SS as VariantAction, Di as VelocityOverLifetimeModule, VE as VerticalLayoutGroup, Xs as VideoPlayer, jo as ViewDevice, Au as Vignette, Em as VisibilityAction, Il as Voip, __ as Volume, Dt as VolumeParameter, mm as VolumeProfile, Ose as WaitForFrames, VU as WaitForSeconds, qp as Watch, nm as WebAR, w_ as WebARCameraBackground, Cc as WebARSessionRoot, wt as WebXR, Ec as WebXRAvatar, os as WebXRController, bi as WebXREvent, S_ as WebXRImageTracking, Sl as WebXRImageTrackingModel, E_ as WebXRPlaneTracking, sm as WebXRSync, yu as WebXRTrackedImage, Sr as XRFlag, M_ as XRGrabModel, nI as XRGrabRendering, pb as XRRig, yg as XRSessionMode, Xo as XRState, rs as XRStateFlag, oI as __Ignore, b2 as __internalNotifyObjectDestroyed, Ma as activeInHierarchyFieldName, hX as addCustomExtension, sM as addFile, JF as addFileFromUrl, Ine as addGltfLoadEventListener, tc as addNewComponent, H8 as addPatch, V0 as apply, Nne as applyChanges, t2 as beginListenDestroy, KF as beginListenFileSpawn, i2 as beginListenInstantiate, Sq as build_scene_functions, eh as builtinComponentKeyName, vC as calculateProgress01, gX as colorSerializer, Iy as componentSerializer, xB as copyTexture, dI as createGLTFLoader, HD as createMotion, Ar as debugNet, tg as debugOwner, Ov as deepClone, nf as delay, p0 as deserializeObject, ic as destroy, c2 as destroyComponentInstance, TF as detectARSupport, RF as detectVRSupport, uo as disposeObjectResources, uD as download, hC as download_file, af as editorGuidKeyName, LM as effectsOrder, bX as eventListSerializer, yN as findAnimations, Rne as findAnimationsLate, ug as findByGuid, d2 as findObjectOfType, p2 as findObjectsOfType, V1 as findUsers, Dh as foreachComponent, q1 as foreachComponentEnumerator, _6 as forward, G0 as generateSeed, md as getComponent, vd as getComponentInChildren, og as getComponentInParent, rg as getComponents, ng as getComponentsInChildren, H0 as getComponentsInParent, pz as getIp, fz as getIpAndLocation, dz as getIpCloudflare, fo as getLoader, G1 as getOrAddComponent, oe as getParam, az as getPath, sf as getUrlParams, K8 as getUserCount, w6 as getWorldDirection, yB as getWorldEuler, xt as getWorldPosition, _s as getWorldQuaternion, y1 as getWorldRotation, Fs as getWorldScale, lc as hasProLicense, cC as hash, dg as instantiate, w2 as isActiveInHierarchy, Ad as isActiveSelf, _B as isAnimationAction, rz as isDebugMode, W1 as isDestroyed, Mn as isDevEnvironment, zI as isHostedOnGlitch, One as isHotReloading, dr as isLocalNetwork, Su as isMobileDevice, X_ as isMozillaXR, hz as isQuest, Sa as isSafari, y2 as isUsageTrackingEnabled, J0 as isUsingInstancing, of as isiOS, AN as loadSync, v0 as logHierarchy, v6 as lookAtInverse, oz as makeId, FI as makeIdFromRandomWords, C2 as markAsInstancedRendered, H1 as moveComponentInstance, sz as nameof, Dv as nameofFactory, eL as objectSerializer, vN as parseSync, GY as prefix, kI as pushState, DI as randomNumber, Lne as register, ly as registerComponent, gS as registerComponentExtension, ZO as registerExtensions, uC as registerLoader, r2 as registerPrefabProvider, NI as relativePathPrefix, Q1 as removeComponent, uX as removeCustomExtension, Tne as removeGltfLoadEventListener, V8 as removePatch, Pl as resolveUrl, UI as sanitizeString, toe as screenshot, e2 as sendDestroyed, x as serializable, lB as serializeObject, Cd as serializeable, hg as setActive, E2 as setDestroyed, rf as setOrAddParamsToUrl, nz as setParam, BI as setParamWithoutReload, q_ as setState, Y8 as setUsageTrackingEnabled, bB as setWorldEuler, ts as setWorldPosition, dd as setWorldPositionXYZ, Dr as setWorldQuaternion, fB as setWorldQuaternionXYZW, S6 as setWorldRotation, m0 as setWorldRotationXYZ, A1 as setWorldScale, Ls as showBalloonMessage, ao as showBalloonWarning, c1 as showDebugConsole, pB as slerp, Q0 as syncDestroy, NM as syncField, z1 as syncInstantiate, E6 as textureToCanvas, Cu as tryFindObject, bN as tryFindObjectByName, Pne as tryFindScript, Fne as unregister, hD as upload_file, Ko as validate };

